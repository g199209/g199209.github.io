<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态库全局符号覆盖的大坑</title>
      <link href="/2020/06/03/shared_library_global_symbol_override/"/>
      <url>/2020/06/03/shared_library_global_symbol_override/</url>
      
        <content type="html"><![CDATA[<p>今天在调试时发现了一个奇怪的core：<code>double free or corruption (fasttop)</code>，从堆栈看是由于 <code>_dl_fini</code> 函数多次重复释放了某些 STL 容器导致的，此时就算在 <code>main</code> 函数中只保留个简单 <code>return 0</code> 也会出错，因此猜想肯定和某些全局变量有关。后面经过各种修改尝试，终于发现这是由于引用的 <code>.so</code> 动态库和主程序中定义了同名的全局 STL 容器导致的，此时的行为简直就是一个神坑，很有必要记录一下……</p><a id="more"></a><p>先说最终结论吧：</p><ul><li>多个动态库或者是动态库与主程序间可以有同名全局符号，包括全局变量和函数等，此时链接过程是不会出错的。</li><li>这些同名全局符号的地址是<strong>相同的</strong>！</li><li>链接过程中会从前往后依次查找符号，对于 <code>.so</code> 及 <code>.a</code> 来说，如果遇到相同的全局变量是不会报错的，此时 GCC 会默默的选择第一个，这种情况连 Warning 都不会有。这与多个 <code>.o</code> 是不同的，在多个 <code>.o</code> 中定义相同的全局变量无法正常链接。</li><li>以上行为的问题在于，绝大部分情况下各模块期望的行为都是调用自己的全局变量及函数，而不是调用其他模块的，因此大概率会造成运行时的各种异常。</li><li>尤有甚者，若全局变量并不是基本类型而是 <code>class</code>，那虽然此变量只有一个内存地址，然而<strong>其构造与析构函数会被调用多次</strong>，若其中有动态分配的内存，多次 <code>delete</code> 就会导致 <code>double free</code> 异常。</li><li>以上构造与析构行为是通过编译时向 <code>_init()</code> 及 <code>_fini()</code> 中添加 hook 函数实现的，构造顺序是链接顺序，析构顺序是其逆序。前文提到的 <code>_dl_fini()</code> 函数应该是 <code>_fini()</code> 的动态库版本。</li></ul><p>上面这些行为看上去已经很坑了吧，然而这并不是全部……以上行为仅适用于编译时直接指定需要链接库的情况，若是在程序运行过程中使用 <code>dlopen</code> 动态加载 <code>.so</code> 时行为不太一样；若通过 <code>LD_PRELOAD</code> 指定动态库那行为又不一样了……</p><p>使用 <code>dlopen</code> 加载时的行为可以简要归纳如下：</p><ul><li>主程序中的全局符号是<strong>永远都不会</strong>被加载进来的动态库给覆盖的，无论是变量还是函数。这与很多文章中说的不太一样，然而实际使用 GCC 9.3 测试的结果就是如此，估计是较新的 GCC 版本做了什么修改导致的。</li><li>多次调用 <code>dlopen</code> 加载多个动态库，若这些动态库间存在相同的全局符号，则它们之间是<strong>有可能</strong>相互覆盖的，这取决于 <code>dlopen</code> 的 <code>flag</code>。若使用 <code>RTLD_GLOBAL</code>，则后面加载进来的动态库会使用已有的全局符号；若使用 <code>RTLD_LOCAL</code>，则每个动态库间的符号是独立的。</li><li>上述行为中，对应全局变量的构造及析构每次都会进行，也就是后面加载进来的动态库会在之前内存的基础上再来构造一次，退出的时候也会析构多次。</li></ul><p>以上很多行为显然应该都不是预期行为的，那如何解决这些问题呢，大概有这些方法：</p><ul><li>创建 <code>.so</code> 时加上编译选项 <code>-Wl,-Bsymbolic</code>，这会强制采用本地的全局变量定义。</li><li>可以通过 <code>__attribute__ ((visibility(&quot;xxx&quot;)))</code> 来控制符号可见性，并通过编译选项 <code>-fvisibility=xxx</code> 来控制默认符号可见性。</li><li>将不需要导出的全局变量声明为 <code>static</code> 的。</li><li>最根本的做法，<strong>通过 namespace 等手段从根本上避免同名变量及函数的存在</strong>！</li></ul><hr><p>最后给出几个简单测试程序，可以对照着理解上面的各种行为。</p><p><code>my_calss.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   MyClass(<span class="keyword">int</span> a) : a_(a) &#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Construct! "</span> &lt;&lt; a_ &lt;&lt; <span class="string">" @ "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">     g_fun();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ~MyClass() &#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Destruct! "</span> &lt;&lt; a_ &lt;&lt; <span class="string">" @ "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> a_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>my_lib1.cc</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_class.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">g_var</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>my_lib2.cc</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_class.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">g_var</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>app1.cc</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_class.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">g_var</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  g_fun();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>app2.cc</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_class.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">g_var</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dlopen(<span class="string">"./libmylib1.so"</span>, RTLD_NOW);</span><br><span class="line">  dlopen(<span class="string">"./libmylib2.so"</span>, RTLD_NOW);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  g_fun();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>app3.cc</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_class.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">g_var</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dlopen(<span class="string">"./libmylib1.so"</span>, RTLD_NOW | RTLD_GLOBAL);</span><br><span class="line">  dlopen(<span class="string">"./libmylib2.so"</span>, RTLD_NOW | RTLD_GLOBAL);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  g_fun();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Makefile</code>:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mylib1: my_class.h my_lib1.cc</span></span><br><span class="line">    g++ -fPIC -shared -o libmylib1.so my_lib1.cc</span><br><span class="line"></span><br><span class="line"><span class="section">mylib2: my_class.h my_lib2.cc</span></span><br><span class="line">    g++ -fPIC -shared -o libmylib2.so my_lib2.cc</span><br><span class="line"></span><br><span class="line"><span class="section">app1: app1.cc my_class.h mylib1 mylib2</span></span><br><span class="line">    g++ -L./ -lmylib1 -lmylib2 -o app1 app1.cc</span><br><span class="line"></span><br><span class="line"><span class="section">app2: app2.cc my_class.h</span></span><br><span class="line">    g++ -ldl -o app2 app2.cc</span><br><span class="line"></span><br><span class="line"><span class="section">app3: app3.cc my_class.h</span></span><br><span class="line">    g++ -ldl -o app3 app3.cc</span><br><span class="line"></span><br><span class="line"><span class="section">all: app1 app2 app3</span></span><br></pre></td></tr></table></figure><hr><p>测试程序运行结果为：</p><p><code>app1</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./app1</span></span><br><span class="line">Construct! 2 @ 0x404194</span><br><span class="line">app1.cc:6</span><br><span class="line">Construct! 1 @ 0x404194</span><br><span class="line">app1.cc:6</span><br><span class="line">Construct! 10 @ 0x404194</span><br><span class="line">app1.cc:6</span><br><span class="line">----------</span><br><span class="line">app1.cc:6</span><br><span class="line">----------</span><br><span class="line">Destruct! 10 @ 0x404194</span><br><span class="line">Destruct! 10 @ 0x404194</span><br><span class="line">Destruct! 10 @ 0x404194</span><br></pre></td></tr></table></figure><p><code>app2</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./app2</span></span><br><span class="line">Construct! 12 @ 0x404194</span><br><span class="line">app2.cc:9</span><br><span class="line">Construct! 1 @ 0x7fd81b9f106c</span><br><span class="line">my_lib1.cc:7</span><br><span class="line">Construct! 2 @ 0x7fd81b9ec06c</span><br><span class="line">my_lib2.cc:7</span><br><span class="line">----------</span><br><span class="line">app2.cc:9</span><br><span class="line">----------</span><br><span class="line">Destruct! 2 @ 0x7fd81b9ec06c</span><br><span class="line">Destruct! 1 @ 0x7fd81b9f106c</span><br><span class="line">Destruct! 12 @ 0x404194</span><br></pre></td></tr></table></figure><p><code>app3</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./app3</span></span><br><span class="line">Construct! 12 @ 0x404194</span><br><span class="line">app3.cc:9</span><br><span class="line">Construct! 1 @ 0x7efd3799d06c</span><br><span class="line">my_lib1.cc:7</span><br><span class="line">Construct! 2 @ 0x7efd3799d06c</span><br><span class="line">my_lib1.cc:7</span><br><span class="line">----------</span><br><span class="line">app3.cc:9</span><br><span class="line">----------</span><br><span class="line">Destruct! 2 @ 0x7efd3799d06c</span><br><span class="line">Destruct! 2 @ 0x7efd3799d06c</span><br><span class="line">Destruct! 12 @ 0x404194</span><br></pre></td></tr></table></figure><hr><p>本文只是一个简单的总结，关于此问题的更多深入讨论可以参考以下文章：</p><blockquote><p><a href="https://www.ibm.com/developerworks/cn/aix/library/au-aix-symbol-visibility/index.html" target="_blank" rel="noopener">控制共享库的符号可见性  第 1 部分 - 符号可见性简介</a><br><a href="http://kouucocu.lofter.com/post/1cdb8c4b_50f6306" target="_blank" rel="noopener">浅谈动态库符号的私有化与全局化</a><br><a href="http://codemacro.com/2014/11/04/linux-dynamic-library/" target="_blank" rel="noopener">linux动态库的种种要点</a><br><a href="https://zhuanlan.zhihu.com/p/36529418" target="_blank" rel="noopener">Linux动态链接库so版本兼容</a><br><a href="http://codemacro.com/2014/09/15/inside-static-library/" target="_blank" rel="noopener">浅析静态库链接原理</a><br><a href="https://www.jianshu.com/p/383f9cd4c67e" target="_blank" rel="noopener">全局符号</a><br><a href="https://www.cnblogs.com/suncoolcat/p/3398170.html" target="_blank" rel="noopener">Linux下全局符号覆盖问题</a><br><a href="https://www.technovelty.org/c/what-exactly-does-bsymblic-do.html" target="_blank" rel="noopener">What exactly does -Bsymblic do?</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> C++ </tag>
            
            <tag> Linux </tag>
            
            <tag> Compiler </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何从 coredump 文件中获取被优化掉的局部变量真实值</title>
      <link href="/2019/12/24/coredump_optimized_value/"/>
      <url>/2019/12/24/coredump_optimized_value/</url>
      
        <content type="html"><![CDATA[<p>在 GCC  <code>-O3</code> 优化级别下，很多局部变量是会被优化掉的，此时只能通过人工分析反汇编代码来获取所需信息，而这么做的前提是保存下来的寄存器中的值是准确的。绝大部分情况下 coredump 是由于 segment fault 或 assert 触发的，segment fault 情况下 Kernel 保存下来的 registers 信息是准确的，GDB 中直接用 <code>info registers</code> 就可以看到。然而若是由 assert 触发，由于 assert 会进行多层函数调用后最终执行 <code>raise()</code>，错误现场的寄存器信息是不准确的，这时候就需要一些其他手段来解决此问题。下面用一个具体例子来说明此问题。</p><a id="more"></a><p>测试程序代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> final = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b = a + <span class="number">100</span>;</span><br><span class="line">  final = b;</span><br><span class="line">  <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    assert(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fun(rand()) == <span class="number">1</span>) &#123;</span><br><span class="line">      n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">100000</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此程序肯定会发生 assert failed，我们用 gdb 来看下调用栈：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Program terminated with signal SIGABRT, Aborted.</span><br><span class="line"><span class="meta">#</span><span class="bash">0  0x00007fac9f2f31f7 <span class="keyword">in</span> raise () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">gef&gt;</span><span class="bash"> bt</span></span><br><span class="line"><span class="meta">#</span><span class="bash">0  0x00007fac9f2f31f7 <span class="keyword">in</span> raise () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1  0x00007fac9f2f48e8 <span class="keyword">in</span> abort () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2  0x00007fac9f2ec266 <span class="keyword">in</span> __assert_fail_base () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">3  0x00007fac9f2ec312 <span class="keyword">in</span> __assert_fail () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">4  0x0000000000400d5e <span class="keyword">in</span> fun (a=&lt;optimized out&gt;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">5  main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;)</span></span><br></pre></td></tr></table></figure><p>切换到 <code>fun()</code> 的栈帧：</p><figure class="highlight sh"><figcaption><span>e</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; f 4</span><br><span class="line"><span class="comment">#4  0x0000000000400de0 in fun (a=&lt;optimized out&gt;)</span></span><br><span class="line">245    assert(<span class="literal">false</span>);</span><br><span class="line">gef&gt; p a</span><br><span class="line"><span class="variable">$1</span> = &lt;optimized out&gt;</span><br><span class="line">gef&gt; p b</span><br><span class="line"><span class="variable">$2</span> = &lt;optimized out&gt;</span><br></pre></td></tr></table></figure><p>可以看到 <code>a</code> 与 <code>b</code> 都被优化掉了，到底是哪个值触发了 assert 就不能直接确定了。当然并不是就彻底没办法知道了，来看下 <code>fun()</code> 函数的反汇编：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; disassemble</span><br><span class="line">Dump of assembler code for function main(<span class="keyword">int</span>, char**):</span><br><span class="line">   <span class="number">0x0000000000400d10</span> &lt;+<span class="number">0</span>&gt;:<span class="keyword">push</span>   <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000400d11</span> &lt;+<span class="number">1</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="number">0x186a1</span></span><br><span class="line">   <span class="number">0x0000000000400d16</span> &lt;+<span class="number">6</span>&gt;:<span class="keyword">nop</span>    <span class="built_in">WORD</span> <span class="built_in">PTR</span> <span class="built_in">cs</span>:[<span class="built_in">rax</span>+<span class="built_in">rax</span>*<span class="number">1</span>+<span class="number">0x0</span>]</span><br><span class="line">   <span class="number">0x0000000000400d20</span> &lt;+<span class="number">16</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400c70</span> &lt;rand@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000400d25</span> &lt;+<span class="number">21</span>&gt;:<span class="keyword">lea</span>    <span class="built_in">esi</span>,[<span class="built_in">rax</span>+<span class="number">0x64</span>]</span><br><span class="line">   <span class="number">0x0000000000400d28</span> &lt;+<span class="number">24</span>&gt;:<span class="keyword">test</span>   <span class="built_in">esi</span>,<span class="built_in">esi</span></span><br><span class="line">   <span class="number">0x0000000000400d2a</span> &lt;+<span class="number">26</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rip</span>+<span class="number">0x201570</span>],<span class="built_in">esi</span>        # <span class="number">0x6022a0</span> &lt;final&gt;</span><br><span class="line">   <span class="number">0x0000000000400d30</span> &lt;+<span class="number">32</span>&gt;:<span class="keyword">jg</span>     <span class="number">0x400d45</span> &lt;main(<span class="keyword">int</span>, char**)+<span class="number">53</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000400d32</span> &lt;+<span class="number">34</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edi</span>,<span class="number">0x602080</span></span><br><span class="line">   <span class="number">0x0000000000400d37</span> &lt;+<span class="number">39</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400cd0</span> &lt;_ZNSolsEi@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000400d3c</span> &lt;+<span class="number">44</span>&gt;:<span class="keyword">sub</span>    <span class="built_in">ebx</span>,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x0000000000400d3f</span> &lt;+<span class="number">47</span>&gt;:<span class="keyword">jne</span>    <span class="number">0x400d20</span> &lt;main(<span class="keyword">int</span>, char**)+<span class="number">16</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000400d41</span> &lt;+<span class="number">49</span>&gt;:<span class="keyword">xor</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="number">0x0000000000400d43</span> &lt;+<span class="number">51</span>&gt;:<span class="keyword">pop</span>    <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000400d44</span> &lt;+<span class="number">52</span>&gt;:<span class="keyword">ret</span></span><br><span class="line">   <span class="number">0x0000000000400d45</span> &lt;+<span class="number">53</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="number">0x400fc6</span></span><br><span class="line">   <span class="number">0x0000000000400d4a</span> &lt;+<span class="number">58</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0xf5</span></span><br><span class="line">   <span class="number">0x0000000000400d4f</span> &lt;+<span class="number">63</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">esi</span>,<span class="number">0x400f70</span></span><br><span class="line">   <span class="number">0x0000000000400d54</span> &lt;+<span class="number">68</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edi</span>,<span class="number">0x400fc0</span></span><br><span class="line">   <span class="number">0x0000000000400d59</span> &lt;+<span class="number">73</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400c80</span> &lt;__assert_fail@plt&gt;</span><br></pre></td></tr></table></figure><p>在 <code>-O3</code> 优化下 <code>fun()</code> 直接被内联到 <code>main()</code> 里面了，不过这不影响基本分析，重点关注 <code>&lt;+16&gt;</code> ~ <code>&lt;+32&gt;</code> 这几行，这就对应 <code>fun()</code> 的前几行逻辑，<code>if (b &gt; 0)</code> 是通过 <code>test</code> + <code>jg</code> 来实现的，<code>b</code> 的值此时就是 <code>%esi</code> 寄存器中的值。看下 gdb 分析出来的当前栈帧的寄存器值：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; info registers</span><br><span class="line"><span class="built_in">rax</span>            <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">rbx</span>            <span class="number">0x186a1</span>             <span class="number">0x186a1</span></span><br><span class="line"><span class="built_in">rcx</span>            <span class="number">0x7fac9f2f31f7</span>      <span class="number">0x7fac9f2f31f7</span></span><br><span class="line"><span class="built_in">rdx</span>            <span class="number">0x6</span>                 <span class="number">0x6</span></span><br><span class="line"><span class="built_in">rsi</span>            <span class="number">0x4cc5</span>              <span class="number">0x4cc5</span></span><br><span class="line"><span class="built_in">rdi</span>            <span class="number">0x4cc5</span>              <span class="number">0x4cc5</span></span><br><span class="line"><span class="built_in">rbp</span>            <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">rsp</span>            <span class="number">0x7fff091e0410</span>      <span class="number">0x7fff091e0410</span></span><br><span class="line"><span class="built_in">r8</span>             <span class="number">0x1</span>                 <span class="number">0x1</span></span><br><span class="line"><span class="built_in">r9</span>             <span class="number">0xfeff092d63646b68</span>  <span class="number">0xfeff092d63646b68</span></span><br><span class="line"><span class="built_in">r10</span>            <span class="number">0x8</span>                 <span class="number">0x8</span></span><br><span class="line"><span class="built_in">r11</span>            <span class="number">0x206</span>               <span class="number">0x206</span></span><br><span class="line"><span class="built_in">r12</span>            <span class="number">0x400daf</span>            <span class="number">0x400daf</span></span><br><span class="line"><span class="built_in">r13</span>            <span class="number">0x7fff091e04f0</span>      <span class="number">0x7fff091e04f0</span></span><br><span class="line"><span class="built_in">r14</span>            <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">r15</span>            <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">rip</span>            <span class="number">0x400d5e</span>            <span class="number">0x400d5e</span></span><br><span class="line">eflags         <span class="number">0x206</span>               [ PF IF ]</span><br><span class="line"><span class="built_in">cs</span>             <span class="number">0x33</span>                <span class="number">0x33</span></span><br><span class="line"><span class="built_in">ss</span>             <span class="number">0x2b</span>                <span class="number">0x2b</span></span><br><span class="line"><span class="built_in">ds</span>             <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">es</span>             <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">fs</span>             <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">gs</span>             <span class="number">0x0</span>                 <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>是不是其中 <code>%rsi</code> 的值就是我们需要的 <code>b</code> 了呢？非也！注意到 <code>&lt;+68&gt;</code> 行，在调用 <code>__assert_fail()</code> 前 <code>%esi</code> 又被重新赋值用于传递参数了，且由于 <code>%esi</code> 属于 caller save 的寄存器，在 <code>__assert_fail()</code> 内有可能会被再次改写。因此 <strong>使用 GDB 分析 coredump 文件不同栈帧的 register 信息时，只有为数不多的几个 callee save 寄存器的值是可靠的，其他的都是不可靠的。</strong> 那如何才能得到可靠的寄存器值呢？一般来说只有靠我们自己保存了，一个简单思路是只要在调用 <code>__assert_fail()</code> 前把所有寄存器的值保存到一个全局数组中就可以了。</p><p>在 <code>assert()</code> 前添加如下一段内联汇编代码即可实现此目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(<span class="string">"movq $0, %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rax, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rbx, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rcx, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rdx, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rsi, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rdi, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rbp, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rsp, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r8, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r9, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r10, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r11, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r12, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r13, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r14, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r15, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                        :</span><br><span class="line">                        : <span class="string">"r"</span> (registers_data)</span><br><span class="line">                        : <span class="string">"%r15"</span>);</span><br></pre></td></tr></table></figure><p>再来看下此时的反汇编代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; disassemble</span><br><span class="line">Dump of assembler code for function main(<span class="keyword">int</span>, char**):</span><br><span class="line">   <span class="number">0x0000000000400d10</span> &lt;+<span class="number">0</span>&gt;:<span class="keyword">push</span>   <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d12</span> &lt;+<span class="number">2</span>&gt;:<span class="keyword">push</span>   <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000400d13</span> &lt;+<span class="number">3</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="number">0x186a1</span></span><br><span class="line">   <span class="number">0x0000000000400d18</span> &lt;+<span class="number">8</span>&gt;:<span class="keyword">sub</span>    <span class="built_in">rsp</span>,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x0000000000400d1c</span> &lt;+<span class="number">12</span>&gt;:<span class="keyword">nop</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="number">0x0</span>]</span><br><span class="line">   <span class="number">0x0000000000400d20</span> &lt;+<span class="number">16</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400c70</span> &lt;rand@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000400d25</span> &lt;+<span class="number">21</span>&gt;:<span class="keyword">lea</span>    <span class="built_in">esi</span>,[<span class="built_in">rax</span>+<span class="number">0x64</span>]</span><br><span class="line">   <span class="number">0x0000000000400d28</span> &lt;+<span class="number">24</span>&gt;:<span class="keyword">test</span>   <span class="built_in">esi</span>,<span class="built_in">esi</span></span><br><span class="line">   <span class="number">0x0000000000400d2a</span> &lt;+<span class="number">26</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rip</span>+<span class="number">0x201570</span>],<span class="built_in">esi</span>        # <span class="number">0x6022a0</span> &lt;final&gt;</span><br><span class="line">   <span class="number">0x0000000000400d30</span> &lt;+<span class="number">32</span>&gt;:<span class="keyword">jg</span>     <span class="number">0x400d4b</span> &lt;main(<span class="keyword">int</span>, char**)+<span class="number">59</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000400d32</span> &lt;+<span class="number">34</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edi</span>,<span class="number">0x602080</span></span><br><span class="line">   <span class="number">0x0000000000400d37</span> &lt;+<span class="number">39</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400cd0</span> &lt;_ZNSolsEi@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000400d3c</span> &lt;+<span class="number">44</span>&gt;:<span class="keyword">sub</span>    <span class="built_in">ebx</span>,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x0000000000400d3f</span> &lt;+<span class="number">47</span>&gt;:<span class="keyword">jne</span>    <span class="number">0x400d20</span> &lt;main(<span class="keyword">int</span>, char**)+<span class="number">16</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000400d41</span> &lt;+<span class="number">49</span>&gt;:<span class="keyword">add</span>    <span class="built_in">rsp</span>,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x0000000000400d45</span> &lt;+<span class="number">53</span>&gt;:<span class="keyword">xor</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="number">0x0000000000400d47</span> &lt;+<span class="number">55</span>&gt;:<span class="keyword">pop</span>    <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000400d48</span> &lt;+<span class="number">56</span>&gt;:<span class="keyword">pop</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d4a</span> &lt;+<span class="number">58</span>&gt;:<span class="keyword">ret</span></span><br><span class="line">   <span class="number">0x0000000000400d4b</span> &lt;+<span class="number">59</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x6021a0</span></span><br><span class="line">   <span class="number">0x0000000000400d50</span> &lt;+<span class="number">64</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">r15</span>,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000000000400d57</span> &lt;+<span class="number">71</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x0000000000400d5b</span> &lt;+<span class="number">75</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d5e</span> &lt;+<span class="number">78</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000400d62</span> &lt;+<span class="number">82</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d65</span> &lt;+<span class="number">85</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rcx</span></span><br><span class="line">   <span class="number">0x0000000000400d69</span> &lt;+<span class="number">89</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d6c</span> &lt;+<span class="number">92</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rdx</span></span><br><span class="line">   <span class="number">0x0000000000400d70</span> &lt;+<span class="number">96</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d73</span> &lt;+<span class="number">99</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rsi</span></span><br><span class="line">   <span class="number">0x0000000000400d77</span> &lt;+<span class="number">103</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d7a</span> &lt;+<span class="number">106</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rdi</span></span><br><span class="line">   <span class="number">0x0000000000400d7e</span> &lt;+<span class="number">110</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d81</span> &lt;+<span class="number">113</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rbp</span></span><br><span class="line">   <span class="number">0x0000000000400d85</span> &lt;+<span class="number">117</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d88</span> &lt;+<span class="number">120</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rsp</span></span><br><span class="line">   <span class="number">0x0000000000400d8c</span> &lt;+<span class="number">124</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d8f</span> &lt;+<span class="number">127</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r8</span></span><br><span class="line">   <span class="number">0x0000000000400d93</span> &lt;+<span class="number">131</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d96</span> &lt;+<span class="number">134</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r9</span></span><br><span class="line">   <span class="number">0x0000000000400d9a</span> &lt;+<span class="number">138</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d9d</span> &lt;+<span class="number">141</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r10</span></span><br><span class="line">   <span class="number">0x0000000000400da1</span> &lt;+<span class="number">145</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400da4</span> &lt;+<span class="number">148</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r11</span></span><br><span class="line">   <span class="number">0x0000000000400da8</span> &lt;+<span class="number">152</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400dab</span> &lt;+<span class="number">155</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r12</span></span><br><span class="line">   <span class="number">0x0000000000400daf</span> &lt;+<span class="number">159</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400db2</span> &lt;+<span class="number">162</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r13</span></span><br><span class="line">   <span class="number">0x0000000000400db6</span> &lt;+<span class="number">166</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400db9</span> &lt;+<span class="number">169</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r14</span></span><br><span class="line">   <span class="number">0x0000000000400dbd</span> &lt;+<span class="number">173</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400dc0</span> &lt;+<span class="number">176</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400dc4</span> &lt;+<span class="number">180</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400dc7</span> &lt;+<span class="number">183</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="number">0x4010c6</span></span><br><span class="line">   <span class="number">0x0000000000400dcc</span> &lt;+<span class="number">188</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0xf5</span></span><br><span class="line">   <span class="number">0x0000000000400dd1</span> &lt;+<span class="number">193</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">esi</span>,<span class="number">0x401070</span></span><br><span class="line">   <span class="number">0x0000000000400dd6</span> &lt;+<span class="number">198</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edi</span>,<span class="number">0x4010c0</span></span><br><span class="line">   <span class="number">0x0000000000400ddb</span> &lt;+<span class="number">203</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400c80</span> &lt;__assert_fail@plt&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;+59&gt;</code> ~ <code>&lt;+180&gt;</code> 行就是我们新加的逻辑，可以看到这段代码紧接在 <code>&lt;+32&gt;</code> 行之后，理论上分析的确是可以保存准确的寄存器信息。来看下实际效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gef&gt;</span><span class="bash"> p registers_data</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 = &#123;0x6021a0, 0x186a1, 0x7f872ad260d4, 0x7f872ad260c8, 0x6b8b45cb, 0x7f872ad266e0, 0x0, 0x7ffd6d53a660, 0x7f872ad260c8, 0x7f872ad26140, 0x7ffd6d53a370, 0x7f872a9a38b0, 0x400e2f, 0x7ffd6d53a750, 0x0, 0xf, 0x0 &lt;repeats 16 <span class="built_in">times</span>&gt;&#125;</span></span><br><span class="line"><span class="meta">gef&gt;</span><span class="bash"> p final</span></span><br><span class="line"><span class="meta">$</span><span class="bash">2 = 0x6b8b45cb</span></span><br></pre></td></tr></table></figure><p><code>registers_data[4]</code> 与 <code>final</code> 的值完全相同，而从源代码和反汇编 <code>&lt;+26&gt;</code> 行可以看到，<code>final</code> 中保存的就是 <code>b</code> 的真实值。</p><hr><blockquote><p>参考资料：<br><a href="https://undo.io/resources/value-optimized-out-reverse-debugging-rescue/" target="_blank" rel="noopener">Value optimized out. Reverse debugging to the rescue!</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Linux </tag>
            
            <tag> Debug </tag>
            
            <tag> x86 </tag>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 perf 进行性能分析时如何获取准确的调用栈</title>
      <link href="/2019/10/30/perf_stack_traceback/"/>
      <url>/2019/10/30/perf_stack_traceback/</url>
      
        <content type="html"><![CDATA[<p><code>perf</code> 是 Linux 下重要的性能分析工具，<code>perf</code> 可以通过采样获取很多性能指标，其中最常用的是获取 CPU Cycles，即程序各部分代码运行所需的时间，进而确定性能瓶颈在哪。不过在实际使用过程中发现，简单的使用<code>perf record -g</code> 获取到的调用栈是有问题的，存在大量 <code>[Unknown]</code> 函数，从 <code>perf report</code> 的结果来看这些部分对应地址大部分都是非法地址，且生成的火焰图中存在很多明显与代码矛盾的调用关系。</p><a id="more"></a><p>最初怀疑是优化级别的问题，然而尝试使用 <code>Og</code> 或 <code>O0</code> 优化依然存在此问题，仔细阅读 <code>perf record</code> 的手册后发现，<code>perf</code> 同时支持 3 种栈回溯方式：<code>fp</code>, <code>dwarf</code>, <code>lbr</code>，可以通过 <code>--call-graph</code> 参数指定，而 <code>-g</code> 就相当于 <code>--call-graph fp</code>.</p><h3 id="栈回溯方式"><a href="#栈回溯方式" class="headerlink" title="栈回溯方式"></a>栈回溯方式</h3><p> <code>fp</code> 就是 Frame Pointer，即 x86 中的 <code>EBP</code> 寄存器，<code>fp</code> 指向当前栈帧栈底地址，此地址保存着上一栈帧的 <code>EBP</code> 值，具体可参考<a href="https://www.cs.rutgers.edu/~pxk/419/notes/frames.html" target="_blank" rel="noopener">此文章</a>的介绍，根据 <code>fp</code> 就可以逐级回溯调用栈。然而这一特性是会被优化掉的，而且这还是 GCC 的默认行为，在不手动指定 <code>-fno-omit-frame-pointer</code> 时默认都会进行此优化，此时 <code>EBP</code> 被当作一般的通用寄存器使用，以此为依据进行栈回溯显然是错误的。不过尝试指定 <code>-fno-omit-frame-pointer</code> 后依然没法获取到正确的调用栈，根据 GCC 手册的<a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html" target="_blank" rel="noopener">说明</a>，指定了此选项后也并不保证所有函数调用都会使用 <code>fp</code>…… 看来只有放弃使用 <code>fp</code> 进行回溯了。</p><p><code>dwarf</code> 是一种调试文件格式，GCC 编译时附加的 <code>-g</code> 参数生成的就是 <code>dwarf</code> 格式的调试信息，其中包括了栈回溯所需的全部信息，使用 <code>libunwind</code> 即可展开这些信息。<code>dwarf</code> 的进一步介绍可参考 <a href="http://cwndmiao.github.io/programming%20tools/2013/11/26/Dwarf/" target="_blank" rel="noopener">“关于DWARF”</a>，值得一提的是，GDB 进行栈回溯时使用的正是 <code>dwarf</code> 调试信息。实际测试表明使用 <code>dwarf</code> 可以很好的获取到准确的调用栈。</p><p>最后 <code>perf</code> 还支持通过 <code>lbr</code> 获取调用栈，<code>lbr</code> 即 Last Branch Records，是较新的 Intel CPU 中提供的一组硬件寄存器，其作用是记录之前若干次分支跳转的地址，主要目的就是用来支持 <code>perf</code> 这类性能分析工具，其详细说明可参考 <a href="https://lwn.net/Articles/680985/" target="_blank" rel="noopener">“An introduction to last branch records”</a> &amp; <a href="https://lwn.net/Articles/680996/" target="_blank" rel="noopener">“Advanced usage of last branch records”</a>。此方法是性能与准确性最高的手段，然而它存在一个很大的局限性，由于硬件 Ring Buffer 寄存器的大小是有限的，<code>lbr</code> 能记录的栈深度也是有限的，具体值取决于特定 CPU 实现，一般就是 32 层，若超过此限制会得到错误的调用栈。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>实际测试下以上 3 种栈回溯方式得到的结果，测试程序是一个调用深度为 50 的简单程序，从 <code>f0()</code> 依次调用至 <code>f50()</code>。</p><p><strong><code>--call-graph fp</code></strong>：</p><p><img src="https://pic.gaomf.store/perf_test_fp.svg" alt=""></p><p><strong><code>--call-graph lbr</code></strong>：</p><p><img src="https://pic.gaomf.store/perf_test_lbr.svg" alt=""></p><p><strong><code>--call-graph dwarf</code></strong>：</p><p><img src="https://pic.gaomf.store/perf_test_dwarf.svg" alt=""></p><p>可以看到，的确只有 <code>dwarf</code> 获取到了正确的调用栈。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><code>fp</code></td><td>None</td><td>1. 默认 <code>fp</code> 被优化掉了根本不可用。</td></tr><tr><td><code>lbr</code></td><td>1. 高效准确</td><td>1. 需要较新的 Intel CPU 才有此功能；2. 能记录的调用栈深度有限。</td></tr><tr><td><code>dwarf</code></td><td>1. 准确</td><td>1. 开销相对较大；2. 需要编译时附加了调试信息。</td></tr></tbody></table><hr><blockquote><p>参考资料：</p><p><a href="http://www.brendangregg.com/perf.html" target="_blank" rel="noopener">perf Examples</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Debug </tag>
            
            <tag> x86 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PVE上部署OpenWRT发生网络中断的解决方法</title>
      <link href="/2019/07/28/PVE_OpenWRT_Network_Broken/"/>
      <url>/2019/07/28/PVE_OpenWRT_Network_Broken/</url>
      
        <content type="html"><![CDATA[<p>在旧笔记本上使用Proxmox搭建了一个OpenWRT软路由，正常使用都很稳定，然而当PC使用百度网盘，迅雷等工具进行全速率下载时偶尔会出现网络中断问题，此时Proxmox宿主机的网络会全部断掉，即PVE自己的Web管理界面也无法登录。查看终端，此时会不断打印<code>Detected Hardware Unit Hang</code>的错误提示。</p><a id="more"></a><p>Google一下这个错误提示，还是有不少类似问题的：</p><blockquote><p><a href="https://jhartman.pl/2018/08/06/proxmox-enp0s31f6-detected-hardware-unit-hang/" target="_blank" rel="noopener">Proxmox: enp0s31f6: Detected Hardware Unit Hang</a></p><p><a href="https://ovear.info/post/356" target="_blank" rel="noopener">解决FreeNAS under KVM使用Virtio网卡导致宿主机网卡Hang的问题</a></p><p><a href="https://serverfault.com/questions/616485/e1000e-reset-adapter-unexpectedly-detected-hardware-unit-hang" target="_blank" rel="noopener">e1000e Reset adapter unexpectedly / Detected Hardware Unit Hang</a></p><p><a href="https://superuser.com/questions/1270723/how-to-fix-eth0-detected-hardware-unit-hang-in-debian-9" target="_blank" rel="noopener">How to fix “eth0: Detected Hardware Unit Hang” in Debian 9?</a></p><p><a href="https://forum.proxmox.com/threads/proxmox-node-freezes.44618/" target="_blank" rel="noopener">Proxmox Node freezes</a></p></blockquote><p>基本所有文章都提到此问题与<code>TCP checksum offload</code>特性有关，解决方案就是关掉<code>checksum offload</code>。具体方法是使用<code>ethtool</code>工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -K enp0s25 tx off rx off</span><br></pre></td></tr></table></figure><p>如果要重启后永久生效的话将此命令写入<code>/etc/network/if-up.d/ethtool2</code>文件中并为此文件加上<code>x</code>权限即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">ethtool -K enp0s25 tx off rx off</span><br></pre></td></tr></table></figure><hr><p>除此之外上述第2篇文章的情况和我遇到的很像，里面提到这与<code>Virtio</code>虚拟化有很大关系，而我使用的也正是<code>Vritio</code>，根据作者的说法，更应该在OpenWRT而不是Proxmox中关闭<code>checksum offload</code>。然而实际试了下却发现一个蛋疼的问题，OpenWRT中是无法把<code>tx checksum offload</code>给关掉的……</p><p>此外作者还提到，将网卡的虚拟化方式从<code>Virtio</code>改为<code>E1000</code>也可以解决此问题，不过会有CPU占用率上升的副作用。</p><hr><p>综合以上几种方法，我最后采用的解决办法是：禁用Proxmox宿主机上的<code>TCP checksum offload</code>，并将OpenWRT使用的网卡虚拟化方式改为<code>E1000</code>。实际测试下来没有再发生网卡hang的问题，满速率下载（250Mbps左右）时CPU占用率50%左右，比之前使用<code>Virtio</code>时CPU占用率要高10%左右，还是可以接受的。</p><hr><p>问题算是解决了，最后顺带去进一步学习了下相关的知识，首先是<code>TCP checksum offload</code>，此技术的作用是将计算TCP  checksum的工作由CPU软件实现改为由NIC设备（即网卡等）硬件实现，以此达到节约CPU资源的目的。</p><blockquote><p><a href="https://www2.cs.duke.edu/ari/trapeze/freenix/node7.html" target="_blank" rel="noopener">Checksum Offloading</a></p><p><a href="https://www.ibm.com/support/knowledgecenter/en/ssw_aix_71/performance/tcp_checksum_offload.html" target="_blank" rel="noopener">TCP checksum offload</a></p><p><a href="https://blog.csdn.net/sinat_20184565/article/details/82979778" target="_blank" rel="noopener">UDP的checksum计算与硬件Offload</a></p></blockquote><p>另外就是<code>Virtio</code>与<code>E1000</code>，这是两种不同的网络虚拟化技术，<code>Virtio</code>是半虚拟化而<code>E1000</code>是全虚拟化。对于全虚拟化方案来说，虚拟机是完全感知不到自己是运行在一个虚拟环境中的；而半虚拟化则是虚拟机知道自己就是运行在一个虚拟环境中，此时IO驱动就可以做一些针对性的修改优化，以此降低虚拟化层进行转换带来的开销及性能损失。显而易见，半虚拟化技术的隔离度是没有全虚拟化好的，而且要是虚拟机驱动有问题会导致宿主机也出问题。这就是为什么在使用<code>Virtio</code>时，OpenWRT网络出现问题会导致整个Proxmox的网络都不能用了的原因。除了这两种虚拟化方式外，还有些更为先进的虚拟化技术，如<code>SR-IVO</code>等，有兴趣的话可以看看下面这篇文章的总结：</p><blockquote><p><a href="https://blog.51cto.com/xiaoli110/1558984" target="_blank" rel="noopener">KVM虚拟化网络优化技术总结</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Virtualization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用于嵌入式车载安全预警的交通标志检测若干关键技术研究与验证</title>
      <link href="/2019/02/24/Thesis_of_Master/"/>
      <url>/2019/02/24/Thesis_of_Master/</url>
      
        <content type="html"><![CDATA[<p>转眼间毕业已经要一年了，今天在整理电脑文件的时候翻出了当初写的硕士毕业论文，在知网上搜搜也<a href="http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201802&filename=1018186759.nh" target="_blank" rel="noopener">找得到了</a>。想想硕士期间做过的东西也太杂了，电机控制、Android 开发、嵌入式。。。最后确定了这个毕业论文的题目后只有1年不到的时间可以做了，这期间还要复习准备找工作，不过最后做出来的东西还算是自己基本满意的，这估计也是我在学术上的顶峰了……</p><a id="more"></a><p>为纪念下我离Academy最近的时刻，这里把我这篇论文的摘要及pdf版本的全文贴一下吧。</p><p>全文下载链接：<a href="https://pic.gaomf.store/%E7%94%A8%E4%BA%8E%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%A6%E8%BD%BD%E5%AE%89%E5%85%A8%E9%A2%84%E8%AD%A6%E7%9A%84%E4%BA%A4%E9%80%9A%E6%A0%87%E5%BF%97%E6%A3%80%E6%B5%8B%E8%8B%A5%E5%B9%B2%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E4%B8%8E%E9%AA%8C%E8%AF%81_%E9%AB%98%E6%98%8E%E9%A3%9E.pdf" target="_blank" rel="noopener">用于嵌入式车载安全预警的交通标志检测若干关键技术研究与验证</a></p><p>论文摘要：</p><p>车载安全预警系统可及时为驾驶员提供必要的行车安全预警信息以提高驾驶安全性,其包含若干子系统,如交通标志识别、超速预警等,而交通标志检测则是支撑诸多子系统的重要基础技术之一;本文就针对交通标志检测中基于颜色分割的定位算法及多线程任务调度策略这两项关键技术进行了研究,提出了适用于性能有限嵌入式系统的混合颜色分割策略及混合切换任务调度策略,并通过搭建嵌入式原型样机在实际道路环境中验证了方法的有效性。此外为更好的验证及评估交通标志检测算法的效果,本文建立了中国道路交通标志视频数据集,并将此数据集公开发布以供其他研究人员使用,这也是此领域目前唯一的中国公开数据集。目前主流成熟的交通标志检测定位方法基本均是基于颜色及几何形状局部特征的,本文在此框架下对用于车载安全预警的交通标志检测中最为重要的红色及黄色分割方法展开了深入研究,针对已有主流颜色分割方法的不足提出了混合颜色分割策略,此策略通过若干线性分类器的组合实现了对红色及黄色准确高效的分割,分割效果优于目前常用的各方法且其算法执行速度与最简单的RGB阈值法相似,可保证安全预警算法在性能有限的小型嵌入式车载设备上依然有较好的实时性;在颜色分割基础上本文采用经典的Hough变换实现了对红色圆形交通标志的检测定位并在数据集上评估了算法的效果。本文通过对交通标志检测识别问题进行建模分析提出可用采样间隔时间作为定量衡量此类系统实时性的指标,进而针对目前广泛使用的多核CPU提出了理论最优的理想多线程任务调度算法,此算法可显著降低采样间隔时间以提高系统实时性;不过理想任务调度算法实际无法实现,因此本文进一步提出了实际可实现的混合切换任务调度策略及动态更新参数估计策略;通过控制系统模型数值仿真及实际嵌入式原型样机上的测试验证均表明本文提出的方法可有效优化采样间隔时间分布以此提高系统实时性。本文同时开发了基于Qt的算法验证平台软件及基于Intel Joule模块的嵌入式原型样机,并在其上验证了上述各方法的有效性,最后在校园环境及城市道路上分别进行了静态及动态系统集成测试;测试结果表明本文提出的方法可在小型嵌入式设备上满足系统实时性要求,在天气光照条件较好时检出率也相对较高,不过算法鲁棒性依然需要加强。</p>]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrent </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入分析Docker hello-world镜像</title>
      <link href="/2019/02/15/Deep_Into_Dokcer_Helloworld/"/>
      <url>/2019/02/15/Deep_Into_Dokcer_Helloworld/</url>
      
        <content type="html"><![CDATA[<p>学习Docker时一般刚开始接触的第一个docker image就是<code>hello-world</code>，这个image运行起来的效果也很简单直接，仅仅是在屏幕上输出一段Docker的使用说明就结束了。这个镜像虽然简单，然而仔细分析下还是涉及不少底层机制的。</p><a id="more"></a><p>我之所以会对这个镜像感兴趣，是发现它的大小仅仅只有1.84kB，这实在是太小了，写一个<code>printf(&quot;Hello Wolrd\n&quot;);</code>的程序编译出来大小就远超1.84kB了，所以很好奇这个镜像是如何构建出来的。</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Docker的镜像构建过程是由其镜像描述文件Dockerfile决定的，所以就先找到其Dockerfile来看看。<code>hello-world</code>用于<code>AMD64</code>架构的Dockerfile可以在<a href="https://github.com/docker-library/hello-world/blob/b715c35271f1d18832480bde75fe17b93db26414/amd64/hello-world/Dockerfile" target="_blank" rel="noopener">Github上</a>找到，只有简单的3行：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hello /</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/hello"</span>]</span></span><br></pre></td></tr></table></figure><p>第1行导入了一个名为<code>scratch</code>的东西，这并不是一个真正的image，可以把它视为是所有image的最底层虚拟镜像，类似于一个基本抽象类，Docker官方对其的说明<a href="https://hub.docker.com/_/scratch" target="_blank" rel="noopener">如下</a>：</p><blockquote><p>This image is most useful in the context of building base images (such as <a href="https://registry.hub.docker.com/_/debian/" target="_blank" rel="noopener"><code>debian</code></a> and <a href="https://registry.hub.docker.com/_/busybox/" target="_blank" rel="noopener"><code>busybox</code></a>) or super minimal images (that contain only a single binary and whatever it requires, such as <a href="https://registry.hub.docker.com/_/hello-world/" target="_blank" rel="noopener"><code>hello-world</code></a>).</p><p>As of Docker 1.5.0 (specifically, <a href="https://github.com/docker/docker/pull/8827" target="_blank" rel="noopener"><code>docker/docker#8827</code></a>), <code>FROM scratch</code> is a no-op in the <code>Dockerfile</code>, and will not create an extra layer in your image (so a previously 2-layer image will be a 1-layer image instead).</p><p>……</p><p>You can use Docker’s reserved, minimal image, <code>scratch</code>, as a starting point for building containers. Using the <code>scratch</code> “image” signals to the build process that you want the next command in the <code>Dockerfile</code> to be the first filesystem layer in your image.</p></blockquote><p>后面两行的含义也很直接，把一个名为hello的程序copy到根目录下，在运行image的时候运行此程序。下面就来看下这个如此小的hello world程序是如何实现的。</p><h2 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h2><p>hello.c文件的源码也在同一个<a href="https://github.com/docker-library/hello-world/blob/master/hello.c" target="_blank" rel="noopener">Github仓库中</a>，省略掉过长的字符串常量后很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> message[] =</span><br><span class="line">    <span class="string">"Hello World!"</span></span><br><span class="line">    <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _start() &#123;</span><br><span class="line">    syscall(SYS_write, <span class="number">1</span>, message, <span class="keyword">sizeof</span>(message) - <span class="number">1</span>);</span><br><span class="line">    syscall(SYS_exit, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个最简版本的Hello World和C语言教科书中第一个Hello World是有不小差别的。首先是程序入口点上，众所周知正常C/C++程序的入口点是<code>main()</code>，然而这里使用的是<code>_start()</code>。</p><p>我们的程序是运行在Linux系统上的，程序的加载与运行必然是由OS发起的，<strong>对于Linux来说，OS层面的程序入口点就是<code>_start()</code>而不是<code>main()</code></strong>，一个程序要能正常运行在<code>main()</code>之前是有一些准备工作要做的，比如建立程序运行环境（初始化.bss全局变量等）；在<code>main()</code>返回之后也有些收尾工作要处理，比如调用<code>exit()</code>通知系统等。这些工作正常情况下是由语言标准库来完成的，也就是所谓的Runtime运行环境，对于C语言来说就是<code>crt0.o</code>。大部分程序的<code>_start()</code>就位于其中，在建立好运行环境后<code>_start()</code>会调用<code>main()</code>跳转到用户定义的入口点处。当<code>main()</code>返回后程序又将回到<code>ctr0.o</code>中，最终调用<code>exit()</code>通知OS回收进程资源。</p><p>这里为了缩小程序体积和简单起见，没有使用标准的<code>ctr0.o</code> Runtime，事实上这一个简单的程序也不需要什么Runtime。程序最后直接通过<code>syscall</code>函数调用了<code>SYS_exit</code>系统调用结束了自身的运行。</p><p>将字符串输出到屏幕上也没有使用标准库中的<code>printf()</code>，同样是直接调用了<code>SYS_write</code>这个系统调用，其第一个参数显式的写为了1，其实就是<code>STDOUT_FILENO</code>，Linux系统在<code>unistd.h</code>中定义了<code>stdin</code>, <code>stdout</code>, <code>stderr</code>这几个标准文件描述符。</p><p>可以看到，这样一个程序是可以不依赖于任何其他的库在Linux上独立运行的，为了实现不链接C标准库的目的，需要使用一些特殊的编译选项。从编译这个<code>hello-world</code>程序使用的<a href="https://github.com/docker-library/hello-world/blob/master/Makefile" target="_blank" rel="noopener">Makefile</a>中可以找到使用的编译选项为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS := -static -Os -nostartfiles -fno-asynchronous-unwind-tables</span><br></pre></td></tr></table></figure><ul><li><code>-static</code>表示静态链接，虽然对这个程序来说无所谓动态链接还是静态链接……</li><li><code>-Os</code>表示为空间进行<code>-O2</code>级别的优化，专门用于减少目标文件大小；</li><li><code>-nostartfiles</code>是关键编译选项，此选项表示不使用标准C语言运行库（即<code>crt0.o</code>），也不链接C标准库；</li><li><code>-fno-asynchronous-unwind-tables</code>选项也是用于减少代码空间的，其大概含义是不产生C++异常处理机制中使用的<code>.eh_frame</code>段，关于什么是<code>unwind-tables</code>和<code>.eh_frame</code>是个比这篇文章复杂多了的问题，文末有几篇参考资料，之后有空可以深入学习下C++的底层机制……</li></ul><p>进行了以上诸多特殊优化处理后，终于可以得到一个只有1k多的可以正常运行于Linux上的Hello World程序了。</p><hr><blockquote><p>参考资料：</p><p><a href="https://stackoverflow.com/questions/29694564/what-is-the-use-of-start-in-c" target="_blank" rel="noopener">What is the use of _start() in C?</a></p><p><a href="https://stackoverflow.com/questions/43050089/when-is-the-gcc-flag-nostartfiles-used" target="_blank" rel="noopener">When is the gcc flag -nostartfiles used?</a></p><p><a href="https://software.intel.com/en-us/blogs/2013/01/17/x86-gcc-code-size-optimizations" target="_blank" rel="noopener">GCC x86 code size optimizations</a></p><p><a href="https://www.cnblogs.com/catch/p/3619379.html" target="_blank" rel="noopener">c++ 异常处理（2）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Runtime </tag>
            
            <tag> Linux </tag>
            
            <tag> Compiler </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sudo不需要输入密码的方法</title>
      <link href="/2018/11/17/Sudo_No_Passwd/"/>
      <url>/2018/11/17/Sudo_No_Passwd/</url>
      
        <content type="html"><![CDATA[<p>正常情况下，使用<code>sudo</code>命令是需要输入密码的，连续输入多条<code>sudo</code>只用输一次密码就行，不过若干分钟后又需要输入密码了。对于自己使用的本地桌面环境来说，其实是可以配置成<code>sudo</code>免输入密码的，这样可以减少一些麻烦。</p><a id="more"></a><p>以<code>Ubuntu 18.04</code>为例说明设置方法，其他发行版可能会有区别。<code>Ubuntu Desktop</code>默认已经将安装系统时配置的用户加入了<code>admin</code>用户组，且<code>admin</code>用户组中的用户都是有<code>sudo</code>权限的，因此无需修改<code>sudo</code>用户组。若需要将某用户添加到<code>sudo</code>用户组中，可参考文末链接。</p><p>输入<code>su -</code>命令切换到<code>root</code>下，修改<code>/etc/sudoers</code>文件，找到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Allow members of group sudo to execute any command</span></span><br><span class="line">%sudoALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Allow members of group sudo to execute any command</span></span><br><span class="line">%sudoALL=(ALL:ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure><p>即可。</p><p>这样就可以允许<code>sudo</code>用户组中的用户免密码执行<code>sudo</code>命令了。</p><hr><blockquote><p>参考资料：</p><p><a href="https://www.jianshu.com/p/5d02428f313d" target="_blank" rel="noopener">免密码使用sudo和su</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为Hexo博客Yelee主题添加Gitment评论系统</title>
      <link href="/2018/11/04/Hexo_Yelee_Gitment/"/>
      <url>/2018/11/04/Hexo_Yelee_Gitment/</url>
      
        <content type="html"><![CDATA[<p>本来博客使用的是多说作为评论系统，前两年多说停止服务了换成了友言，用了没多久友言又要求备案不能用了……后面由于工作繁忙也就没管这个了。前段时间发现Gitment这个基于Github Issue的评论系统不错，这两天终于有空把它给加上了。</p><a id="more"></a><p>我使用的主题是基于<a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">Yelee</a>做了些修改得到的，Yelee又是基于<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">Yilia</a>的，添加Gitment的过程可以参考这篇文章：</p><blockquote><p><a href="https://sogrey.github.io/article/Hexo-%E6%B7%BB%E5%8A%A0-Gitment-%E8%AF%84%E8%AE%BA/" target="_blank" rel="noopener">Hexo 添加 Gitment 评论</a></p></blockquote><p>Yiila主题也添加了Gitment支持，其<a href="https://github.com/litten/hexo-theme-yilia/commit/af58957e14a00b3da03e4026c56d34cdf7eda9b4" target="_blank" rel="noopener">Commit</a>也是很有参考价值的。</p><p>与以上教程有区别的是，无需安装Gitment npm插件，添加修改的代码我也改了下，有兴趣的话可以看这个<a href="https://github.com/g199209/BlogTheme/commit/bc591586bd737f0f24a08c54f36f6e10372050c6" target="_blank" rel="noopener">Commit</a>。</p><p>其中Gitment的CSS &amp; JS文件改为了本地压缩后的版本，评论框的显示效果也调整了下。</p><p>终于评论系统又可以用啦，之后就该静心学学技术提高下自己的水平了……</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sizeof 获取 extern 数组长度</title>
      <link href="/2018/06/30/sizeof_extern_array/"/>
      <url>/2018/06/30/sizeof_extern_array/</url>
      
        <content type="html"><![CDATA[<p>sizeof是获取数组元素个数的常用运算符，然而前几天使用时发现，对于extern类型的数组，sizeof的使用上是有些需要考虑的问题的。</p><a id="more"></a><p>假设系统中有3个文件：</p><p><code>file1.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p><code>header1.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="built_in">array</span>[];</span><br></pre></td></tr></table></figure><p><code>main.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This is WRONG!</span></span><br><span class="line">    <span class="keyword">size_t</span> elements_in_array = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>main.c</code>中期望通过<code>sizeof</code>运算符获取<code>array</code>中元素个数，然而这么做是错误的，编译时无法通过，错误提示类似<code>incomplete type not allowed</code>这类。</p><p>造成这一问题的原因在于，<strong><code>sizeof</code>是在编译时计算的，而C/C++的编译是以文件为基本单位的</strong>。在编译<code>main.c</code>文件时，编译器是不可能知道定义在<code>file1.c</code>文件中<code>array</code>数组具体信息的，只根据<code>header1.h</code>文件中的声明是无法确定<code>array</code>的具体大小的，因此，就算某些编译器编译时不报错，得到的结果也是不正确的。</p><p>分析清楚原因后来看下解决方案，基本解决方法有4种：</p><ol><li>避免使用匿名长度的数组声明，使用宏定义预先确定数组大小；</li><li>定义一个辅助变量用于保存数组大小信息，将其定义赋值放在定义<code>array</code>数组的同一个文件中；</li><li>使用特殊元素表示数组结束，就像字符串结尾的<code>&#39;\0&#39;</code>一样，这样就可以在运行阶段动态确定数组大小；</li><li>将数组的定义放到使用它的源文件中。</li></ol><p>这几种方法都有其缺点：</p><ol><li>使用<code>sizeof</code>就是不想固定数组长度，因为使用宏定义固定数组长度不够灵活，要是想添加数组元素也要同时修改宏定义，否则尽管编译不会报错，然而运行时新添加的元素其实是无效的，这会导致将来维护时一些潜在Bug发生的可能性增加；</li><li>需要一个额外的存储空间，且由于这是一个变量，每次使用数组长度时都需要访问内存，编译器也无法对数组长度作出任何假设，进而影响编译优化，理论上说这可能会导致运行时一些微小的效率损失；</li><li>需要修改上层逻辑，缺乏通用性；</li><li>大部分情况下，使用非<code>static</code>全局变量的原因就是多个源文件需要使用这个变量，这时显然无法做到这一点，多次重复定义链接时会出错的。</li></ol><p>实际使用中，需要根据具体问题具体分析采用哪种方法最恰当，一般而言不经常变化的数组就使用宏定义确定其大小，会经常变化的第2种方法最常用，此时还可以用一些宏定义简化编程，以上代码可修改为：</p><p><code>file1.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">ELEMENTS_IN_DEF(<span class="built_in">array</span>)</span><br></pre></td></tr></table></figure><p><code>header1.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ELEMENTS_IN(array)            __elements_in_##array</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ELEMENTS_IN_DEF(array)        size_t __elements_in_##array = sizeof(array) / sizeof(array[0]);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ELEMENTS_IN_DECLARE(array)    extern size_t __elements_in_##array;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="built_in">array</span>[];</span><br><span class="line">ELEMENTS_IN_DECLARE(<span class="built_in">array</span>)</span><br></pre></td></tr></table></figure><p><code>main.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> elements_in_array = ELEMENTS_IN(<span class="built_in">array</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考资料：</p><p><a href="http://c-faq.com/decl/extarraysize.html" target="_blank" rel="noopener">comp.lang.c FAQ list · Question 1.24</a></p><p><a href="https://stackoverflow.com/questions/23230114/c-how-to-determine-sizeofarray-sizeofstruct-for-external-array" target="_blank" rel="noopener">C: How to determine sizeof(array) / sizeof(struct) for external array?</a></p><p><a href="https://blog.csdn.net/ranhui_xia/article/details/39502665" target="_blank" rel="noopener">sizeof extern数组</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多歧路，今安在？</title>
      <link href="/2018/06/03/The_Road/"/>
      <url>/2018/06/03/The_Road/</url>
      
        <content type="html"><![CDATA[<p>好久没写博客了，翻看自己的博客，上次更新已是半年多前了，这大半年来忙于找工作，毕业设计，毕业答辩、入职……入职前两个月也是各种忙碌，现在对手头的工作也熟悉一些了，于是乎在低头做事的空暇时也需要抬起头来看看路了。</p><a id="more"></a><p>自从找工作拿到几个Offer可以选择时就开始各种纠结与困惑了，大疆、阿里、Intel、华为、拼多多、乐鑫、网易……有幸能拿到这么些优秀公司的Offer，然而每一家公司都同时有吸引我和令我踌躇的地方，鱼和熊掌终不可兼得，选择也变得十分困难。虽然最终选择了大疆，然而这一选择并不是那么顺理成章，当时在犹豫，本以为选了之后就不会困惑了，现在才发觉，困惑的东西并不会随着时间推移而自然而然的变得清晰起来。</p><p>人生有很多选择，选择和努力哪个更重要呢？这个问题的标准答案在准备面试时都背得滚瓜烂熟了，选择与努力互为因果，选择是为了决定之后努力的方向，努力是为了将来能有更多选择。然而，记住了所谓的标准答案并无济于事，该困惑的时候还是一样困惑。</p><p>其实想想，所有困惑的根源都来自于两点：不知道自己真正想要的是什么；不知道未来会是怎样。</p><p>与其说是不知道自己想要什么，不如说是不知道自己愿意放弃什么，选择之所以困难，是因为选择与放弃总是如影相随的，选择了此就注定要放弃彼。人总是什么都想要的，但事实是我们注定要放弃大多数东西的，人生在不断的做出选择，同时也是在不断放弃。然而，我究竟愿意放弃什么呢？愿意选择什么呢？这并不是那么确定的啊……什么都不想放弃，也就注定什么都无法得到。</p><p>上面那点也许还能随着年岁与阅历的增长思考得越来越清楚，那对未来不可知的迷茫更是让人觉得无能为力。生命的精彩源于不可知，生命的痛苦也源于不可知。时代的洪流滚滚前进，顺之者昌逆之者亡，然而时代的车轮碾向何方又有谁知？</p><p>可供选的路总是越来越少的，我们都终有一日会无路可选，到那时，认命也罢，不认也罢，是非成败转头空，唯余夕阳照青山。在我们还有得可选的时候，还是多想想吧，就算是一条咸鱼也还是要挣扎下看看的。虽然路最终总是越走越窄的，还是要努力下让它窄得不要那么快吧，毕竟啊，谁又能说自己走的一定是那条自己想要同时又不会被时代湮没的道路呢？</p><p>瞎扯了这么多似乎还是多想清楚了那么一丝东西吧，脚踏实地亦要仰望星空，不要让天天加班和生活琐事的忙碌成为一种错觉蒙蔽了双眼。自己的未来何在，尽管想不清还是要去找的吧，在坚信自己找到之前，努力让未来的路宽广一些，努力让自己不要失去有选择的能力，虽然选择是困难和纠结的，然而没选择的走投无路是更大的悲哀。</p><p>然而，要维持像学校里那样站在四通八达的十字路口近乎是不可能完成的事，两条路经常是越来越远的，刚开始时尚有可能跳过去，越到后面越难跳过去了吧。所以啊，还是要尽快想清楚自己想去哪条路上才行啊，然而，谁知道哪时候能想清楚呢……不过在想清楚自己要跳去哪条路上之前，还是要多练练自己跳跃的能力，培养些通用的技能，让自己还是有路可跳有路可选吧。</p>]]></content>
      
      
      <categories>
          
          <category> 人生之思 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH反向穿透访问内网主机</title>
      <link href="/2017/11/04/SSH_Forwarding/"/>
      <url>/2017/11/04/SSH_Forwarding/</url>
      
        <content type="html"><![CDATA[<p>学校的网络位于无数重NAT内网中，而且还有各种VPN，所以想要从外网访问十分困难，之前试过各种方法都没成功。今天偶然看到了SSH反向穿透的方法，因为我访问内网服务器主要也是需要SSH连接功能，故此方法可以很好的满足我的需求。此处记录下配置方法。</p><a id="more"></a><p>SSH反向穿透需要有一台有公网IP的服务器作为桥梁，此处将位于多重NAT网络中需要访问的主机称为Target，而将有固定IP的中转服务器称为Server。SSH反向穿透的原理是，Target主动建立与Server间的SSH连接，利用SSH的端口转发功能，将访问Server某端口的数据包转发到Target SSH端口（22端口）上，以此实现间接登陆Target的目的。</p><p>假设Server上的转发端口为<code>6766</code>，使用如下命令在Target上建立与Server间的反向隧道：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 22 -fN -R 6766:localhost:22 userServer@Server</span><br></pre></td></tr></table></figure><p><code>-R</code>用于定义反向隧道，<code>-fN</code>用于在建立SSH连接后SSH进入后台运行。</p><p>之后需要在Server上打开<code>sshd</code>的<code>GatewayPorts</code>功能，这样才能实现只登录一次即可连接上Target。修改<code>/etc/ssh/sshd_config</code>文件，添加下面这行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GatewayPorts clientspecified</span><br></pre></td></tr></table></figure><p>重启<code>sshd</code>服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ssh restart</span><br></pre></td></tr></table></figure><p>此时就可以在任意一个终端上使用<code>ssh -p 6766 userTarget@Server</code>登录到Target上了，需要注意的是，此时使用的用户名、密码、秘钥都应该是Target而不是Server的，只有IP地址或者是域名是Server的。</p><p>最后一个问题是，如何保持这个SSH反向隧道的稳定存在，并且实现若Target意外重启后能自动再次建立此反向隧道。解决方法是使用<code>autossh</code>，并且把它作为一个服务自动启动。</p><p>先安装<code>autossh</code>，之后在<code>/etc/init.d</code>下建立一个名为<code>autossh</code>的文件：（以下操作以Ubuntu为例，其他发行版可能会有区别）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">/usr/bin/autossh -p 22 -M 6777 -fN -R *:6766:localhost:22 userServer@Server -i id_rsa</span><br></pre></td></tr></table></figure><p><code>-M</code>参数指定了一个监控端口，和端口转发无关，使用一个无用的端口即可；<code>-i</code>指定了一个密钥，此处用RSA密钥的方式登陆Server。</p><p>保存此文件，并添加执行权限：<code>chmod +x autossh</code>；注册服务：<code>update-rc.d autossh enable</code>；最后启动服务：<code>service autossh start</code>。</p><p>可使用<code>sysv-rc-conf</code>工具查看<code>autossh</code>服务的开机自启动情况。这样将其作为服务配置好后，就可以实现稳定的SSH反向穿透了，终于可以实现从任何地方自由访问内网主机的目的了~~</p><p>最后顺便提一下，SSH转发其实可以承载其他更多的网络服务，这个之后有空再来研究~</p><hr><blockquote><p>参考资料：<br><a href="http://network.51cto.com/art/201505/477144.htm" target="_blank" rel="noopener">如何通过SSH反向隧道，访问NAT后面的Linux服务器?</a><br><a href="http://arondight.me/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" target="_blank" rel="noopener">使用SSH反向隧道进行内网穿透</a><br><a href="https://marshal.ohtly.com/2017/01/26/Reverse-SSH-Tunneling-with-Autossh/" target="_blank" rel="noopener">使用autossh实现反向SSH隧道</a><br><a href="http://blog.csdn.net/yuanchao99/article/details/9111269" target="_blank" rel="noopener">ubuntu service的添加和删除</a><br><a href="https://stackoverflow.com/questions/37438630/how-to-use-systemctl-in-ubuntu-14-04" target="_blank" rel="noopener">How to use systemctl in Ubuntu 14.04</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言关键词restrict的应用</title>
      <link href="/2017/10/25/C_restrict/"/>
      <url>/2017/10/25/C_restrict/</url>
      
        <content type="html"><![CDATA[<p><code>restrict</code>是C99标准中新增的关键词，只能用于修饰指针（函数指针除外），其含义为：<strong>此指针是访问其指向对象的唯一初始方法</strong>。使用此关键词的意义在于：<strong>有助于编译器进行代码优化</strong>。</p><a id="more"></a><p><code>restrict</code>是一个类型限定词，在C99标准(ISO/IEC 9899:1999)的”6.7.3.1 Formal definition of restrict”中给出其定义，基本语法为<code>xxx * restrict var</code>，其中<code>xxx</code>是指针指向的变量类型。需要注意的是，只有指向所谓”object types”的指针才能用<code>restrict</code>修饰，而”object types”的定义应该是除了函数指针外所有类型的指针。另外，对于函数参数来说，由于数组和指针的等价性，函数参数为数组时也可以用<code>restrict</code>修饰，此时<code>restrict</code>放在<code>[]</code>中，如：<code>void fun(int par[restrict])</code>。</p><p>上面也说到，使用<code>restrict</code>的意义在于便于编译器优化，此处使用<code>restrict</code>最常用的一个例子进行说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> * a, <span class="keyword">int</span> * b)</span> </span>&#123;</span><br><span class="line">    *a = <span class="number">5</span>;</span><br><span class="line">    *b = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> *a + *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfoo</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">restrict</span> a, <span class="keyword">int</span> * <span class="keyword">restrict</span> b)</span> </span>&#123;</span><br><span class="line">    *a = <span class="number">5</span>;</span><br><span class="line">    *b = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> *a + *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!---workaround highlight bugs*---><p>对于<code>foo</code>函数，编译器是不能假设<code>a</code>和<code>b</code>指向的区域是不同的，它们有可能指向同一内存区域，故此时编译得到的汇编代码为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movl<span class="number">4</span>(%esp), %eax</span><br><span class="line">movl<span class="number">8</span>(%esp), %edx</span><br><span class="line">movl<span class="number">$5</span>, (%eax)</span><br><span class="line">movl<span class="number">$6</span>, (%edx)</span><br><span class="line">movl(%eax), %eax</span><br><span class="line">addl<span class="number">$6</span>, %eax</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>可以看到，在进行最后一步加法运算前，需要再读一遍<code>*a</code>的值，以保证结果的正确性，因为若<code>a==b</code>的话，此时<code>*a == 6</code>而不是<code>*a == 5</code>；此时这段程序返回的是12而不是11。</p><p>然而，我们如果能确保<code>a != b</code>，那以上代码是可以进一步优化的，<code>restrict</code>关键词就用于把这一信息提供给编译器，此时的<code>rfoo</code>函数编译结果如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movl<span class="number">4</span>(%esp), %eax</span><br><span class="line">movl<span class="number">$5</span>, (%eax)</span><br><span class="line">movl<span class="number">8</span>(%esp), %eax</span><br><span class="line">movl<span class="number">$6</span>, (%eax)</span><br><span class="line">movl<span class="number">$11</span>, %eax</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>这段代码中直接返回了编译器预先计算出来的结果11，与<code>foo</code>相比减少了一次加法运算，且不需要进行<code>movl    (%eax), %eax</code>这一步骤。（虽然由于Cache的存在，这一指令也不一定会进行内存访问）</p><blockquote><p>以上汇编代码使用GCC 4.9.3编译得到，编译参数为：<code>-O3 -S -std=gnu11</code>，结果和参考资料中给出的汇编代码稍有区别，不知为何参数传递使用的是栈而不是寄存器……</p></blockquote><p>从以上例子中可以看到，若一个指针是访问某内存区域的唯一方法，那可以为其加上<code>restrict</code>限定符，这有利于编译器进行代码优化生成效率更高的程序。</p><hr><blockquote><p>参考资料：<br><a href="http://en.cppreference.com/w/c/language/restrict" target="_blank" rel="noopener">restrict type qualifier</a><br><a href="https://www.zhihu.com/question/41653775?sort=created" target="_blank" rel="noopener">如何理解C语言关键字restrict？</a><br><a href="http://blog.csdn.net/lovekatherine/article/details/1891806pub" target="_blank" rel="noopener">C99中的restrict关键字</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux kernel中的min和max宏</title>
      <link href="/2017/10/08/Kernel_min_max_macro/"/>
      <url>/2017/10/08/Kernel_min_max_macro/</url>
      
        <content type="html"><![CDATA[<p><code>min</code>和<code>max</code>是两个很常用的操作，一般都是用宏实现的，不过想要写出一个很完善的宏定义还是要考虑很多问题的，本文就来分析下Linux Kernel中的实现方法。文中仅考虑<code>min</code>，<code>max</code>的结构与其完全相同，只要修改下大于小于号即可。</p><a id="more"></a><p>宏定义中要将整体和变量都加上括号的意义此处就不多说了，据此我们可以写出一个最基本的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure><p>然而这种写法是有副作用的，考虑<code>min(a++, b)</code>这样的用法，其展开后的形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((a++) &lt; (b) ? (a++) : (b++))</span><br></pre></td></tr></table></figure><p>当<code>a&lt;b</code>时，<code>a++</code>会被执行两次，这显然不是我们所希望的，为了解决这一问题，我们可以使用下面这个稍显复杂的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) (&#123; \</span></span><br><span class="line">    typeof(a) __min1__ = (a);  \</span><br><span class="line">    typeof(b) __min2__ = (b);  \</span><br><span class="line">    (<span class="keyword">void</span>)(&amp;__min1__ == &amp;__min2__);  \</span><br><span class="line">    __min1__ &lt; __min2__ ? __min1__ : __min2__;&#125;)</span><br></pre></td></tr></table></figure><p>这里用到了GCC的一个扩展特性，形如<code>({ ... })</code>这样的代码块会被视为一条语句，其计算结果是<code>{ ... }</code>中最后一条语句的计算结果。故上述宏定义展开后的结果就是第5行返回的结果。注意，这个扩展特性不是所有编译器都有的，如果用VS编译上述代码，是无法通过编译的。<br>这个宏定义中，先根据<code>a</code>, <code>b</code>的类型生成了两个局部变量<code>__min1__</code>和<code>__min2__</code>，之后比较其大小，返回较小的一个，这样就保证了宏参数只会被执行一次，避免了上述副作用。另外，第4行代码其实是没有实际作用的，其意义在于，若<code>__min1__</code>和<code>__min2__</code>的类型不同，比较其地址时编译器会给出一个Warning，这样可以避免一些潜在的错误发生。</p><p>以上宏定义就是网上普遍流传的Linux Kernel中的实现方法，然而，我实际阅读了当前<code>4.12.7</code>版本的Kernel源代码，发现实际的实现方法要更复杂一些。在引入实际的实现方法前，我们先思考一下以上宏定义还存在什么漏洞。</p><p>考虑以下代码段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __min1__ = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> __min2__ = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> min_val = min(__min1__--, __min2__++);</span><br></pre></td></tr></table></figure><p>期望得到的结果应该是<code>__min1__ = 9</code>, <code>__min2__ = 21</code>, <code>min_val = 10</code>。然而实际情况是，<code>__min1__ = 10</code>, <code>__min2__ = 20</code>，<code>min_val</code>的值则是不确定的。造成这一结果的原因在于输入参数和宏定义内部使用的局部变量重名了，这样就会导致在宏定义的语句块内，外层同名变量的作用域被内层局部变量的作用域所屏蔽，展开后的代码就成了这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main_val = (&#123;typeof(__min1__--) __min1__ = (__min1__--); <span class="comment">/* 省略 */</span> &#125;)</span><br></pre></td></tr></table></figure><p>这就类似于<code>int a = a</code>这样的语句，执行完后<code>a</code>的值是不确定的，且因为展开后<code>__min1__</code>成了宏体内的局部变量，<code>__min1__--</code>的自减操作对于外层变量来说也是无效的。</p><p>知道问题的原因后解决方法就很清晰了，只要避免重名就可以了，其实上述宏定义中使用<code>__min1__</code>这样的名字也是为了避免重名，然而，靠起特殊的名字这种方法不是那么的优雅，故实际新版的Linux Kernel中使用了编译器产生的唯一名称来解决这一问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Indirect macros required for expanded argument pasting, eg. __LINE__. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___PASTE(a,b) a##b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PASTE(a,b) ___PASTE(a,b)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * min()/max()/clamp() macros that also do</span></span><br><span class="line"><span class="comment"> * strict type-checking.. See the</span></span><br><span class="line"><span class="comment"> * "unnecessary" pointer comparison.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __min(t1, t2, min1, min2, x, y) (&#123;\</span></span><br><span class="line">    t1 min1 = (x);\</span><br><span class="line">    t2 min2 = (y);\</span><br><span class="line">    (<span class="keyword">void</span>) (&amp;min1 == &amp;min2);\</span><br><span class="line">    min1 &lt; min2 ? min1 : min2; &#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(x, y)\</span></span><br><span class="line">    __min(typeof(x), typeof(y),\</span><br><span class="line">          __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),\</span><br><span class="line">          x, y)</span><br></pre></td></tr></table></figure><p>可以看到这是一个多重的宏嵌套结构，主要区别就在于<code>__UNIQUE_ID(min1_)</code>上，<code>__UNIQUE_ID</code>可以生成一个唯一的名字。唯一性是由编译器提供的<code>__COUNTER__</code>宏保证的，这也是GCC的一个扩展，<a href="https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html" target="_blank" rel="noopener">GCC文档中</a>对其的说明如下：</p><blockquote><p>This macro expands to sequential integral values starting from 0. In conjunction with the ## operator, this provides a convenient means to generate unique identifiers.</p></blockquote><p>简而言之，<code>__COUNTER__</code>会被展开为一个从0开始的整数，且每次调用后其值都会加一，这也就保证了其唯一性。</p><p>至于<code>__PASTE</code>宏这是用来实现两个token连接的，之所以要两重宏定义和宏的嵌套展开规则有关，可以参考我之前写的<a href="/2017/10/06/C_Macro/">总结文章</a>。调用<code>__UNIQUE_ID(min1_)</code>后产生的就是形如<code>__UNIQUE_ID_min1_0</code>这样的变量名，这就确保了此名称不会和传入变量的名称重复了。当然，我们还是可以通过刻意构造这样一个特殊名称来实现冲突的，只是程序是程序员自己写的，相信也没有程序员这么无聊……故我们只需要保证正常情况下不会发生冲突即可。</p>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言中typeof的使用</title>
      <link href="/2017/10/07/C_typeof/"/>
      <url>/2017/10/07/C_typeof/</url>
      
        <content type="html"><![CDATA[<p><code>typeof</code>不是C语言本身的关键词或运算符（<code>sizeof</code>是C标准定义的运算符），它是GCC的一个扩展，作用正如其字面意思，<strong>用某种已有东西（变量、函数等）的类型去定义新的变量类型</strong>。</p><a id="more"></a><p><code>typeof</code>通常用于宏定义中，一些示例用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typeof(var)</span><br><span class="line">typeof(a[<span class="number">0</span>])</span><br><span class="line">typeof(<span class="keyword">int</span> *)</span><br><span class="line">typeof(fun())</span><br></pre></td></tr></table></figure><p>可以看到，<code>typeof()</code>中可以是任何有类型的东西，变量就是其本身的类型，函数是它返回值的类型。<code>typeof</code>一般用于声明变量，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof(a) var;</span><br></pre></td></tr></table></figure><p>不过，这也不是绝对的，从语法上来说，所有可以出现基本类型关键词的地方都可以使用<code>typeof</code>，比如<code>sizeof(typeof(a))</code>这样的用法，虽然这里的<code>typeof</code>是多余的，不过它是符合语法的。</p><p>再来看一些高级用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">typeof(fun) * fptr;    <span class="comment">// int (*fptr)(int);</span></span><br><span class="line"></span><br><span class="line">typeof(<span class="keyword">int</span> *)a, b;     <span class="comment">// int * a, * b;</span></span><br><span class="line">typeof(<span class="keyword">int</span>) * a, b;    <span class="comment">// int * a, b;</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>typeof</code>还可以用来定义函数指针等，且<code>typeof(int *)a, b</code>是定义了两个指针变量。</p><p>最后指出一些需要注意的问题。<code>typeof()</code>是在编译时处理的，故<strong>其中的表达式在运行时是不会被执行的</strong>，比如<code>typeof(fun())</code>，<code>fun()</code>函数是不会被执行的，<code>typeof</code>只是在编译时分析得到了<code>fun()</code>的返回值而已。<code>typeof</code>还有一些局限性，其中的变量是不能包含存储类说明符的，如<code>static</code>、<code>extern</code>这类都是不行的。</p><hr><blockquote><p>参考资料：<br><a href="https://gcc.gnu.org/onlinedocs/gcc/Typeof.html" target="_blank" rel="noopener">6.6 Referring to a Type with typeof</a><br><a href="http://cstriker1407.info/blog/the-gcc-study-notes-typeof/" target="_blank" rel="noopener">GCC扩展关键字typeof学习笔记</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解C语言中宏定义</title>
      <link href="/2017/10/06/C_Macro/"/>
      <url>/2017/10/06/C_Macro/</url>
      
        <content type="html"><![CDATA[<p>从本质上看，C语言中的宏定义实现的是一个文本替换的功能，似乎很简单的样子，然而这几天去看了下Linux Kernel源码中的各种宏定义，才发现一个宏定义竟然也可以有如此多的奇技淫巧……于是花了一天时间仔细研究了下宏的相关知识，此处整理总结下。</p><a id="more"></a><p>关于宏，网上有一组写得极好的文章，基本上看完这几篇文章就可以对宏有一个深入的理解了：</p><blockquote><p><a href="http://feng.zone/2017/05/17/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-1/" target="_blank" rel="noopener">宏定义黑魔法-从入门到奇技淫巧 (1) —— 基本概念</a><br><a href="http://feng.zone/2017/05/18/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-2/" target="_blank" rel="noopener">宏定义黑魔法-从入门到奇技淫巧 (2) —— object-like宏的展开</a><br><a href="http://feng.zone/2017/05/20/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-3/" target="_blank" rel="noopener">宏定义黑魔法-从入门到奇技淫巧 (3) —— function-like宏的展开</a><br><a href="http://feng.zone/2017/05/21/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-4/" target="_blank" rel="noopener">宏定义黑魔法-从入门到奇技淫巧 (4) —— 一些宏的高级用法</a><br><a href="http://feng.zone/2017/05/21/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-5/" target="_blank" rel="noopener">宏定义黑魔法-从入门到奇技淫巧 (5) —— 图灵完备</a><br><a href="http://feng.zone/2017/05/28/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-6/" target="_blank" rel="noopener">宏定义黑魔法-从入门到奇技淫巧 (6) —— 宏的一些坑</a></p></blockquote><p>作者的知乎上也有一份<a href="https://www.zhihu.com/people/feng-yu-yao/posts" target="_blank" rel="noopener">相同的备份</a>。</p><p>相同的内容此处就不再重复了，此处列出一些要点。</p><ul><li>带参数的宏中可以使用两个特殊运算符，<code>#</code>(Stringification Operator)和<code>##</code>(Token Pasting Operator)，作用分别是把宏参数变为字符串字面量和连接两个token。且遇到这两个运算符时，宏参数不会展开。</li><li>宏的嵌套展开过程中，已展开过的宏不会重复展开。</li><li>宏展开后，会进一步检查是否构成了新的宏，若构成了会进一步展开。</li><li>宏定义中也可以使用<code>...</code>代表可变参数，用<code>__VA_ARGS__</code>获取可变参数列表。</li><li>宏参数会先展开，之后再进行替换，这也被称为”prescan”.</li><li>宏基本上是图灵完备的，所以可以只靠宏实现各种东西……</li></ul><p>宏的展开过程遵循以下流程图：</p><p><img src="https://pic.gaomf.store/Macro_Expand3.svg" alt=""></p><p>这个流程图是我根据自己的理解和实验画出来的，并不确定完全正确……图中的“已展开宏记录”就是文章中说的“蓝色列表”。</p><p>使用gcc编译时，可以通过附加<code>-E</code>参数，让gcc只进行预处理，这样就可以看到各种宏实际展开出来的结果是什么了，如<code>gcc -E -o test.i test.c</code>命令对<code>test.c</code>文件进行预处理，生成<code>test.i</code>文件。</p><p>关于宏的展开流程，有一些不太明确的地方，此处用例子说明下，结果都经过gcc预处理验证过。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M K(P)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K(a) a a ## a a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PP 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO(a) #a a</span></span><br><span class="line"></span><br><span class="line">FOO(M)--&gt;  FOO(K(P))</span><br><span class="line">        --&gt;  FOO(<span class="number">2</span> PP <span class="number">2</span>)</span><br><span class="line">        --&gt;  FOO(<span class="number">2</span> <span class="number">11</span> <span class="number">2</span>)</span><br><span class="line">        --&gt;  <span class="string">"M"</span> <span class="number">2</span> <span class="number">11</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>遇到<code>#</code>或<code>##</code>时，其相连的宏参数不会展开，然而这不意味着这个宏参数本身不会展开，其他部分用到这个宏参数的地方还是会展开的。</p><p>另外，<code>#</code>运算符后必须是一个宏参数，不能是其他东西，不过<code>##</code>两端则无这一要求，来看个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(a)  #a a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PP(a) #a a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAT(a) P ## P(P##a(a))</span></span><br><span class="line"></span><br><span class="line">CAT(P)--&gt;  PP(PP(P))</span><br><span class="line">        --&gt;  PP(<span class="string">"P"</span> P)</span><br><span class="line">        --&gt;  <span class="string">"PP(P)"</span> <span class="string">"P"</span> P</span><br><span class="line"></span><br><span class="line">CAT(A)--&gt;  PP(PA(A))</span><br><span class="line">        --&gt;  <span class="string">"PA(A)"</span> PA(A)</span><br></pre></td></tr></table></figure><p>可以看到，<code>##</code>两端可以是任意token，其作用就是把这两个token合成一个。另外，还可以看到，<code>##</code>是在最开始就进行处理的，所以<code>P(a)</code>这个宏是没有用到的。另外，由<code>##</code>操作符组合产生的新宏是会继续展开的，并不像某些文章说的那样会停止展开。</p><hr><p>关于多次扫描展开的问题，有些文章中说的是展开完成后会重新扫描一遍当前字符串，若有可以继续展开的则继续展开，然而实际测试下来并不是这样的。还是来看个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BRACKET ()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATE(a, b)  a ## b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO() 123</span></span><br><span class="line"></span><br><span class="line">CREATE(F, OO) BRACKET   --&gt;  FOO BRACKET</span><br><span class="line">                        --&gt;  FOO ()</span><br><span class="line"></span><br><span class="line">CREATE(F, OO) ()        --&gt;  FOO ()</span><br><span class="line">                        --&gt;  <span class="number">123</span></span><br><span class="line"></span><br><span class="line">FOO BRACKET             --&gt;  FOO ()</span><br></pre></td></tr></table></figure><p>可以看到，第1、3个例子中，展开到<code>FOO ()</code> 之后就没有继续展开下去了，这说明并没有重新扫描字符串这一步，<strong>已经处理过的部分不会再次处理的</strong>。而第2个例子则说明的确是会再展开合并出新的宏来的，故上面的流程图中使用了”向后扫描一个token，形成一个新的字符串”这样的说法。考虑到token是以空白为界划分的，<strong>后面组合出来的新宏只可能是function-like的宏</strong>，所以这样的展开方式是不存在歧义的，不会出现原来的宏被组合成其他宏的情况。</p><p>如果要继续展开上面未能展开的那两个宏，可以再封装一层：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BRACKET ()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATE(a, b)  a ## b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO() 123</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPAND(...) __VA_ARGS__</span></span><br><span class="line"></span><br><span class="line">EXPAND(CREATE(F, OO) BRACKET)--&gt;  EXPAND(FOO())</span><br><span class="line">                                --&gt;  EXPAND(<span class="number">123</span>)</span><br><span class="line">                                --&gt;  <span class="number">123</span></span><br></pre></td></tr></table></figure><p>这里利用的原理是：宏参数会先尽可能展开后再进行替换。</p><hr><p>将宏定义的各种奇技淫巧应用得巅峰造极、神鬼莫测之作就是<a href="http://www.boost.org/doc/libs/1_65_1/libs/preprocessor/doc/index.html" target="_blank" rel="noopener">The Boost Preprocessing library</a>，这是Boost库的一部分，不过和其他部分完全独立，这部分包含了各种数据结构和算法等，而且只有头文件，全部都是宏定义……简直可谓是丧心病狂……Github上有人将这部分独立的代码提取出来了，有兴趣的读者可以去进一步揣摩瞻仰：<a href="https://github.com/imoldman/boost-preprocessor" target="_blank" rel="noopener">boost-preprocessor</a></p><hr><blockquote><p>参考资料：<br><a href="http://www.cppblog.com/kevinlynx/archive/2008/03/19/44828.html" target="_blank" rel="noopener">代码自动生成-宏带来的奇技淫巧</a><br><a href="http://blog.csdn.net/jy_95/article/details/45260775" target="_blank" rel="noopener">《C标准库》—之&lt;assert.h&gt;实现</a><br><a href="https://en.wikipedia.org/wiki/C_preprocessor" target="_blank" rel="noopener">C preprocessor</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言中的字符串字面量连接</title>
      <link href="/2017/10/05/string_literal_concatenate/"/>
      <url>/2017/10/05/string_literal_concatenate/</url>
      
        <content type="html"><![CDATA[<p>字符串字面量(string literal)就是程序代码中出现的<code>&quot;</code>包围的字符串，比如<code>&quot;hello&quot;</code>, <code>&quot;I Love C Language!&quot;</code>这类的。在C语言中，有一个奇技淫巧：<strong>两个相邻的字符串字面量会自动被合并连接为一个</strong>。这里的相邻可以是直接连在一起，也可以是间隔着若干个空白字符。需要指出的是，这个特性是C语言标准所要求的，并不是某个编译器的扩展功能。</p><p>一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello"</span> <span class="string">" World"</span><span class="string">"!"</span>    <span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure><p>以上代码完全等同于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考资料：<br><a href="https://stackoverflow.com/questions/12120944/how-does-concatenation-of-two-string-literals-work" target="_blank" rel="noopener">How does concatenation of two string literals work?</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用代码判断栈的增长方向</title>
      <link href="/2017/09/28/Detect_Stack_Direction/"/>
      <url>/2017/09/28/Detect_Stack_Direction/</url>
      
        <content type="html"><![CDATA[<p>对于大部分CPU架构和编译器来说，程序的栈空间增长方向都是向下递减的，然而这也不是一定的。我们可以用一小段简单的C语言代码来判断下栈的增长方向。</p><a id="more"></a><p>栈基本都是用于保存局部变量和传递参数，故要判断栈的增长方向就要从这两个方面入手。<a href="http://www.cnblogs.com/youxin/p/3313288.html" target="_blank" rel="noopener">第一篇参考资料</a>中给出了各种思路及其可行性分析，很值得看看，此处直接给出结论：</p><ul><li>一个函数中的局部变量在栈中的顺序是不定的，或者说是由编译器决定的，故不能通过直接比较两个局部变量的地址来判断栈的增长方向；</li><li>函数参数压栈的顺序也是不确定的，虽然一般编译器都是从后向前压栈，然而从前向后也不是绝对不可能；</li><li>连续嵌套调用两个函数时，第一个函数的相关数据会先入栈，之后才是它调用的第二个函数，这一点应该是一个通用成立的结论。</li></ul><p>综上，要判断栈的增长方向，可以通过函数的嵌套调用来进行判断，更优雅一点的方案是使用递归，得到的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;Upward, Downward&#125; Stack_Dir_t;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack_Dir_t <span class="title">detect_stack_dir</span><span class="params">(<span class="keyword">char</span> * p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> local = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;local &gt; p ? Upward : Downward;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> detect_stack_dir(&amp;local);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (detect_stack_dir(<span class="literal">NULL</span>) == Upward)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Stack Growth Upward!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Stack Growth Downward!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在绝大多数平台上，我们得到的结果应该都是<code>Stack Growth Downward!</code>。</p><hr><blockquote><p>参考资料：<br><a href="http://www.cnblogs.com/youxin/p/3313288.html" target="_blank" rel="noopener">判断栈和堆的生长方向</a><br><a href="http://www.cnblogs.com/xkfz007/archive/2012/06/22/2558935.html" target="_blank" rel="noopener">栈增长方向与大端/小端问题</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>printf格式化字符串漏洞攻击</title>
      <link href="/2017/09/20/printf_format_string_attack/"/>
      <url>/2017/09/20/printf_format_string_attack/</url>
      
        <content type="html"><![CDATA[<p>前几天去Intel面试时，遇到了一个问题：<code>printf(&quot;%s&quot;, s)</code>与<code>printf(s)</code>有何区别？面试官还提示我从安全的角度回答这个问题，然而当时并没有想出答案来……:( 回来后仔细研究了下这个问题，才发现<code>pritnf(s)</code>这种写法是存在严重安全漏洞的，这被称为printf格式化字符串漏洞攻击。</p><a id="more"></a><p><code>printf</code>函数支持不定参数的原理在此不多说，可参考<code>stdarg.h</code>头文件的相关介绍。核心就是，函数使用栈传递参数，且根据cdecl函数调用约定，压栈顺序是从最后一个参数开始逆序进行的，而<code>printf</code>函数的第一个参数是确定的字符串，故可以从这个字符串中判断出栈中还有多少个数据，每个数据的类型是什么，进而依次取出各个数据。</p><p>正常情况下，格式化字符串中格式化字符<code>%</code>是和之后的参数一一对应的，然而我们可以考虑一种情况，若格式化字符<code>%</code>比参数多会怎么样呢，答案是，会取到栈中其他的数据。这就是<code>printf(s)</code>这种写法有问题的原因了，这里使用<code>s</code>而不是一个字符串字面常量，而<code>s</code>传入什么内容其实是不可控的，若传入字符中存在<code>%</code>，就会输出栈中其他一些内容。要是<code>s</code>还是可以由外部输入的，那就可以通过巧妙的构造<code>s</code>的形式来实现<strong>访问栈中本来没有权限访问的内容</strong>，这就是所谓的格式化字符串漏洞攻击。</p><p>下面来看一个实际的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> security;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;security);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序中由用户输入一个整数，存放在<code>security</code>这个变量中，之后再输入一个字符串<code>str</code>，并使用<code>printf(str)</code>这样的形式将其打印出来。针对这个例子，我们可以构造一个特定的输入字符串将<code>security</code>的内容给打印出来。</p><p>使用GCC 4.9.3编译以上程序，优化等级<code>-O2</code>，得到的程序用<code>objdump</code>反汇编一下，可以找出对应的汇编代码为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00408350</span> &lt;_main&gt;:</span><br><span class="line">  <span class="number">408350</span>:<span class="number">55</span>                   <span class="keyword">push</span>   %ebp</span><br><span class="line">  <span class="number">408351</span>:<span class="number">89</span> e5                <span class="keyword">mov</span>    %esp,%ebp</span><br><span class="line">  <span class="number">408353</span>:<span class="number">53</span>                   <span class="keyword">push</span>   %ebx</span><br><span class="line">  <span class="number">408354</span>:<span class="number">83</span> e4 f0             <span class="keyword">and</span>    <span class="number">$0</span>xfffffff0,%esp</span><br><span class="line">  <span class="number">408357</span>:<span class="number">83</span> c4 <span class="number">80</span>             <span class="keyword">add</span>    <span class="number">$0</span>xffffff80,%esp</span><br><span class="line">  40835a:e8 <span class="number">31</span> <span class="number">95</span> ff ff       <span class="keyword">call</span>   <span class="number">401890</span> &lt;___main&gt;</span><br><span class="line">  40835f:<span class="number">8d</span> <span class="number">44</span> <span class="number">24</span> <span class="number">18</span>          <span class="keyword">lea</span>    <span class="number">0x18</span>(%esp),%eax</span><br><span class="line">  <span class="number">408363</span>:<span class="number">8d</span> 5c <span class="number">24</span> 1c          <span class="keyword">lea</span>    <span class="number">0x1c</span>(%esp),%ebx</span><br><span class="line">  <span class="number">408367</span>:c7 <span class="number">04</span> <span class="number">24</span> c0 a0 <span class="number">40</span> <span class="number">00</span> movl   <span class="number">$0</span>x40a0c0,(%esp)</span><br><span class="line">  40836e:<span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">04</span>          <span class="keyword">mov</span>    %eax,<span class="number">0x4</span>(%esp)</span><br><span class="line">  <span class="number">408372</span>:e8 f1 fb ff ff       <span class="keyword">call</span>   407f68 &lt;_scanf&gt;</span><br><span class="line">  <span class="number">408377</span>:<span class="number">89</span> 5c <span class="number">24</span> <span class="number">04</span>          <span class="keyword">mov</span>    %ebx,<span class="number">0x4</span>(%esp)</span><br><span class="line">  40837b:c7 <span class="number">04</span> <span class="number">24</span> c3 a0 <span class="number">40</span> <span class="number">00</span> movl   <span class="number">$0</span>x40a0c3,(%esp)</span><br><span class="line">  <span class="number">408382</span>:e8 e1 fb ff ff       <span class="keyword">call</span>   407f68 &lt;_scanf&gt;</span><br><span class="line">  <span class="number">408387</span>:<span class="number">89</span> 1c <span class="number">24</span>             <span class="keyword">mov</span>    %ebx,(%esp)</span><br><span class="line">  40838a:e8 e9 fb ff ff       <span class="keyword">call</span>   407f78 &lt;_printf&gt;</span><br><span class="line">  40838f:<span class="number">31</span> c0                <span class="keyword">xor</span>    %eax,%eax</span><br><span class="line">  <span class="number">408391</span>:8b <span class="number">5d</span> fc             <span class="keyword">mov</span>    -<span class="number">0x4</span>(%ebp),%ebx</span><br><span class="line">  <span class="number">408394</span>:c9                   <span class="keyword">leave</span>  </span><br><span class="line">  <span class="number">408395</span>:c3                   <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p><code>408350</code><del><code>40835a</code>部分为GCC自动生成的<code>main</code>函数入口处代码，此处不用管它；<code>40835f</code></del><code>408372</code>为第一个<code>scanf</code>函数，读入<code>security</code>；<code>408377</code><del><code>408382</code>为第二个<code>scanf</code>函数，读入<code>str</code>；<code>408387</code></del><code>40838a</code>调用<code>printf</code>输出<code>str</code>。根据反汇编结果，我们可以画出<code>408372</code>行时栈的结构：</p><p><img src="https://pic.gaomf.store/scanf_stack.svg" alt=""></p><p><code>scanf</code>函数反向压栈，故<code>%esp</code>指针指向的元素<code>$0x40a0c0</code>应该就是字符串字面量<code>&quot;%d&quot;</code>的首地址，而<code>%esp+0x04</code>就是栈中的下一个元素，这就是<code>security</code>变量的地址，从汇编代码中可以看到，这个地址是一个<code>%esp</code>的偏移量，<code>%esp+0x18</code>。由此，我们可以分析出<code>security</code>在栈中的位置，而之后<code>%esp</code>指针没有改变，故我们可以构造以下这个特殊的字符串：<code>%d%d%d%d%d_____security_is:%d</code>，这个字符串会连续取出栈中的前6个<code>int</code>，第6个<code>int</code>的地址就是<code>%esp+0x18</code>，这正是<code>security</code>变量的地址。</p><p>实际运行程序测试一下：</p><p><img src="https://pic.gaomf.store/20170920214800.png" alt=""></p><p>可以看到，我们成功读到了<code>security</code>的内容。</p><p>为了预防这个问题，我们需要确保在使用<code>printf</code>函数时第一个参数必须是一个字符串字面量。其实，以上写法编译器也会产生warning：format string is not a string literal (potentially insecure).</p><p>最后，其实配合一个比较少用的<code>printf</code>参数<code>%n</code>还可以利用此漏洞实现对栈中内容的修改，在此就不展开了，可参考第三篇参考资料。</p><hr><blockquote><p>参考资料：<br><a href="https://stackoverflow.com/questions/13692044/printfstring-vs-printfs-string" target="_blank" rel="noopener">printf(string) vs. printf(“%s”, string)</a><br><a href="https://stackoverflow.com/questions/39415536/what-is-the-underlying-difference-between-printfs-and-printfs-s" target="_blank" rel="noopener">What is the underlying difference between printf(s) and printf(“%s”, s)?</a><br><a href="https://paper.seebug.org/papers/Archive/drops2/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B.html" target="_blank" rel="noopener">格式化字符串漏洞简介</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> C </tag>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atom编辑器配置</title>
      <link href="/2017/09/16/Atom_Configure/"/>
      <url>/2017/09/16/Atom_Configure/</url>
      
        <content type="html"><![CDATA[<p>之前使用过各种文本编辑器，<a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a>、<a href="https://www.sublimetext.com" target="_blank" rel="noopener">Sublime Text</a>、<a href="http://www.vim.org/" target="_blank" rel="noopener">VIM</a>等，使用下来觉得各有千秋，都有些不太满意的地方。前段时间体验了下<a href="https://atom.io/" target="_blank" rel="noopener">Atom</a>，感觉很不错~作为一个所谓的”A hackable text editor for the 21st Century”，还是有很多可以折腾配置的东西，此处总结整理下。</p><a id="more"></a><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>Atom是Github社区推出的开源编辑器，即可以开箱即用无需配置，也可以充分的去定制折腾：</p><blockquote><p>Atom is a text editor that’s modern, approachable, yet hackable to the core—a tool you can customize to do anything but also use productively without ever touching a config file.</p></blockquote><p>Atom官方的使用手册见文末第一个参考资料链接。</p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>一般从其<a href="https://atom.io/" target="_blank" rel="noopener">主页</a>上下载编译好的二进制程序文件即可，Windows下一般使用<code>exe</code>安装包。安装过程完全不需要用户参与，也无法参与……安装包会将Atom自动安装到C盘的某个位置，且这是无法更改的。</p><h3 id="命令面板（Command-Palette）"><a href="#命令面板（Command-Palette）" class="headerlink" title="命令面板（Command Palette）"></a>命令面板（Command Palette）</h3><p>Windows下，使用<code>ctrl-shift-p</code>键即可打开命令面板，在这个命令面板中可以使用模糊搜索快速查找所需的命令，而无需像传统方式那样在层层菜单中寻找。如设置界面，可从菜单中的<code>File</code>-&gt;<code>Setting</code>打开，更快的方式是在命令面板中搜索<code>setting</code>，即可看到所需命令及其快捷键：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170827162506.png" alt=""></p><h3 id="主题与字体"><a href="#主题与字体" class="headerlink" title="主题与字体"></a>主题与字体</h3><p>在设置界面中，<code>Themes</code>一项用于设置界面及语法高亮主题，尝试下来<code>One</code>这个主题最好看，还提供了<code>One Light</code>及<code>One Dark</code>两套亮色及暗色主题。如果对自带的几个主题配色不满意的话，可以去官方的<a href="https://atom.io/themes" target="_blank" rel="noopener">几千个主题</a>中挑选自己喜欢的，或者干脆自己自定义一个~不过自带的这两个主题已经可以完全满足我的需求了，就不再去折腾了……</p><p>至于编辑器界面的字体与字号，可在<code>Editor</code>选项卡中配置，一般选择等宽字体，如我选择的<code>YaHei Consolas Hybrid</code>。</p><h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><p>Atom中，通过文件夹的方式来组织管理项目，界面左侧就是<code>Project</code>面板。若要查找项目中的文件，可使用<code>ctrl-p</code>快捷键；使用<code>ctrl-b</code>查找已打开的文件。</p><h3 id="编辑-amp-移动"><a href="#编辑-amp-移动" class="headerlink" title="编辑&amp;移动"></a>编辑&amp;移动</h3><p>Atom中本身就有一些光标移动的快捷键，不过更方便的是使用下文将要提到的Vim扩展插件，此处仅列举一些比Vim更好用的功能：</p><ul><li>跳转到某行：<code>ctrl-g</code>，之后输入行号</li><li>跳转到标签：<code>ctrl-r</code>，如要在工程内搜索，使用<code>ctrl-shift-r</code></li><li>将当前行（或选中的几行）上下移动：<code>ctrl-↑/↓</code>，此功能在调整代码时会很有用</li></ul><p>Atom中还有个很强大的多光标功能，按住<code>ctrl</code>键的同时用鼠标在多个位置点击或选取，即可启用多光标编辑模式。也可以选中一个词后，按<code>ctrl-d</code>键即可选择下一个相同的词。</p><p>另外，Atom中的括号等不仅会自动配对，而且选中某一个部分后输入单边括号，编辑器会自动用此括号把选中内容包围起来。</p><h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><p>使用<code>alt-ctrl-F2</code>键来添加或删除书签，使用<code>F2</code>键可以调到下一个书签，<code>ctrl-F2</code>打开书签列表。</p><h3 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h3><p>与大部分软件一样，<code>ctrl-f</code>打开搜索替换面板，<code>ctrl-shift-f</code>在整个工程中执行搜索替换。也可以使用正则表达式，在替换时若需反向引用，使用<code>$1</code>, <code>$2</code>…</p><h2 id="各种高级功能"><a href="#各种高级功能" class="headerlink" title="各种高级功能"></a>各种高级功能</h2><p>Atom内置了很多高级编辑功能，此处列出一些常用的，详见<a href="http://flight-manual.atom.io/" target="_blank" rel="noopener">Atom Flight Manual</a>中的帮助说明。</p><h3 id="Snippets"><a href="#Snippets" class="headerlink" title="Snippets"></a>Snippets</h3><p>常用代码片段，输入响应关键词后，会自动弹出提示，此时按<code>Tab</code>键即可自动输入。不同文件类型有不同的默认代码片段，各种package也会添加自己的snippets扩展，可在命令面板中输入<code>Snippets:Available</code>查看当前可用的snippets。如果要自定义snippets，可参考官方文档的说明：<a href="http://flight-manual.atom.io/using-atom/sections/snippets/#creating-your-own-snippets" target="_blank" rel="noopener">Creating Your Own Snippets</a></p><h3 id="Git集成"><a href="#Git集成" class="headerlink" title="Git集成"></a>Git集成</h3><p>Atom是Github发布的编辑器，自然内置了很好的Git支持，界面右下角即可看到当前状态，点击后即可打开Git面板。不过和大部分IDE中集成的Git一样，此处的Git只适合日常工作时commit新代码，若要查看之前的提交记录或进行一些更复杂的操作，还是使用专门的软件更好，比如<a href="https://www.gitkraken.com/" target="_blank" rel="noopener">GitKraken</a>。</p><p>值得一提的是，编辑器左侧使用不同颜色直接标出了此文件的修改情况，十分的直观~使用快捷键<code>alt-g-↑/↓</code>可以快速切换到下一个修改过的地方。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Atom本身是一个很轻量级的编辑器框架，它的各种功能都是由不同插件实现的，称为Packages，这也就是配置Atom中最好玩的部分了~插件的安装有几种不同的方法，最简单的方法是，在<code>Settings</code>-&gt;<code>Install</code>中直接搜索安装即可。此处记录下我安装的插件。</p><h3 id="配置备份"><a href="#配置备份" class="headerlink" title="配置备份"></a>配置备份</h3><p>Atom的所有配置文件其实都位于<code>.atom</code>文件夹下，理论上可通过自行备份这个文件夹来实现配置备份，不过此处我们有一个更优雅的解决方案：<code>Sync-setttings</code>插件。此插件基于Github gist进行备份，所以还需要进行一些额外的配置，详见下面两篇文章：</p><blockquote><p><a href="http://wiki.jikexueyuan.com/project/atom/sync-settings.html" target="_blank" rel="noopener">Sync-setttings(插件-备份神器)</a><br><a href="http://elickzhao.github.io/2016/10/Atom%20%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AEsync-setting/" target="_blank" rel="noopener">Atom 编辑器配置sync-setting</a></p></blockquote><h3 id="Vim扩展"><a href="#Vim扩展" class="headerlink" title="Vim扩展"></a>Vim扩展</h3><p>Vim最好用的地方应该是其移动方式，在Atom中也可以通过安装<code>vim-mode-plus</code>这个插件实现基础的Vim功能，这个插件是对官方Vim插件的升级加强，功能还是很完善的。这个插件还有一个<a href="https://github.com/t9md/atom-vim-mode-plus/wiki" target="_blank" rel="noopener">Wiki页面</a>，里面有各种帮助文档，其中<a href="https://github.com/t9md/atom-vim-mode-plus/wiki/AdvancedTopicTutorial" target="_blank" rel="noopener">Advanced Topic Tutorial</a>部分介绍了各种高级编辑技巧，很值得一读。</p><p><code>vim-mode-plus</code>插件默认绑定了很多快捷键，如果需要自定义的话，可以修改<code>keymap.cson</code>文件。比如我就根据自己的需求加入了以下一些配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&apos;atom-text-editor.vim-mode-plus&apos;:</span><br><span class="line">  # 保证通用的复制粘贴快捷键可用</span><br><span class="line">  &apos;ctrl-c&apos;: &apos;core:copy&apos;</span><br><span class="line">  &apos;ctrl-v&apos;: &apos;core:paste&apos;</span><br><span class="line"></span><br><span class="line">&apos;atom-text-editor.vim-mode-plus:not(.insert-mode)&apos;:</span><br><span class="line">  &apos;H&apos;: &apos;vim-mode-plus:move-to-first-character-of-line&apos;</span><br><span class="line">  &apos;L&apos;: &apos;vim-mode-plus:move-to-last-character-of-line&apos;</span><br><span class="line">  &apos;ctrl-/&apos;: &apos;vim-mode-plus:toggle-line-comments&apos;</span><br><span class="line">  &apos;space space&apos;: &apos;vim-mode-plus:toggle-fold&apos;</span><br></pre></td></tr></table></figure><p>Vim中还有个很好用的插件叫EasyMotion，可以实现快速移动定位，同样在Atom中，也可以通过安装<code>Jumpy</code>这个插件来实现这一目的。此插件默认绑定的快捷键是<code>shift-Enter</code>，可以将<code>vim-mode-plus</code>中的<code>f</code>键替换为这个插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;atom-text-editor:not(.mini).vim-mode-plus:not(.insert-mode):not(.jumpy-jump-mode)&apos;:</span><br><span class="line">  &apos;f&apos;: &apos;jumpy:toggle&apos;</span><br></pre></td></tr></table></figure><h3 id="Markdown扩展"><a href="#Markdown扩展" class="headerlink" title="Markdown扩展"></a>Markdown扩展</h3><p>Atom本身就支持Markdown语法高亮的，再配合一些插件就可以很完美的作为一个Markdown编辑器使用了：</p><ul><li><code>markdown-preview-enhanced</code> : Markdown预览增强版，提供了各种高级功能，详见其<a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/" target="_blank" rel="noopener">文档</a>。安装好后可以把Atom自带的<code>markdown-preview</code>给禁用掉</li><li><code>Markdown-Writer</code> : 各种辅助增强功能，功能介绍见其<a href="https://github.com/zhuochun/md-writer/wiki/Features" target="_blank" rel="noopener">文档</a></li></ul><p><code>Markdown-Writer</code>有一个很方便的功能就是自动生成草稿文件(draft)和发布(publish)完成的草稿文件，这需要先在其设置中配置一下，相应的<code>config.cson</code>文件如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"markdown-writer"</span>:</span><br><span class="line"><span class="symbol">  fileExtension:</span> <span class="string">".md"</span></span><br><span class="line"><span class="symbol">  frontMatter:</span> <span class="string">'''</span></span><br><span class="line"><span class="symbol">    title:</span> <span class="params">&lt;title&gt;</span></span><br><span class="line"><span class="symbol">    permalink:</span></span><br><span class="line"><span class="symbol">    toc:</span> false</span><br><span class="line"><span class="symbol">    mathjax:</span> false</span><br><span class="line"><span class="symbol">    fancybox:</span> false</span><br><span class="line"><span class="symbol">    tags:</span></span><br><span class="line"><span class="symbol">    categories:</span></span><br><span class="line"><span class="symbol">    date:</span> <span class="params">&lt;date&gt;</span></span><br><span class="line"></span><br><span class="line">    ---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="params">&lt;!--more--&gt;</span></span><br><span class="line"></span><br><span class="line">    ----------</span><br><span class="line"></span><br><span class="line">    &gt; 参考资料：</span><br><span class="line">    &gt; []()</span><br><span class="line">  <span class="string">'''</span></span><br><span class="line"><span class="symbol">  siteDraftsDir:</span> <span class="string">"draft"</span></span><br><span class="line"><span class="symbol">  siteEngine:</span> <span class="string">"hexo"</span></span><br><span class="line"><span class="symbol">  siteLocalDir:</span> <span class="string">"D:\\Github\\Hexo"</span></span><br><span class="line"><span class="symbol">  sitePostsDir:</span> <span class="string">"source\\_posts"</span></span><br><span class="line"><span class="symbol">  urlForCategories:</span> <span class="string">"http://gaomf.cn/categories.json"</span></span><br><span class="line"><span class="symbol">  urlForPosts:</span> <span class="string">"http://gaomf.cn/posts.json"</span></span><br><span class="line"><span class="symbol">  urlForTags:</span> <span class="string">"http://gaomf.cn/tags.json"</span></span><br></pre></td></tr></table></figure><p>最后三个选项是为了实现自动管理标签和分类用的，这需要另一个Hexo插件<a href="https://github.com/timnew/hexo-generator-atom-markdown-writer-meta" target="_blank" rel="noopener">hexo-generator-atom-markdown-writer-meta</a>配合，这个插件有些小Bug，在Hexo 3上无法正常使用，不过有人给出了解决方案，打上<a href="https://github.com/timnew/hexo-generator-atom-markdown-writer-meta/pull/5/files" target="_blank" rel="noopener">这个补丁</a>即可。</p><p>这样配置好后，再配合内置Terminal，就可以实现在Atom内完成博客写作的全过程了~</p><h3 id="minimap"><a href="#minimap" class="headerlink" title="minimap"></a>minimap</h3><p>Sublime Text中有一个很好用的文档缩略图功能，在滚动时屏幕右侧会显示此文档的缩略图。在Atom中也可以通过插件实现这一功能，这就是<code>minimap</code>插件，除了这个基础插件外，还有几个扩展插件用于增强其功能：</p><ul><li><code>minimap-autohider</code> : 在不滚动鼠标时自动隐藏minimap缩略图；</li><li><code>minimap-bookmarks</code> : 在缩略图中高亮显示书签；</li><li><code>minimap-find-and-replace</code> : 在缩略图中高亮显示搜索结果；</li><li><code>minimap-git-diff</code> : 在缩略图中高亮显示当前文档修改情况；</li><li><code>minimap-highlight-selected</code> : 在缩略图中高亮显示选中的单词；</li><li><code>minimap-split-diff</code> : 在缩略图中显示<code>split-diff</code>插件的比较结果；</li></ul><h3 id="Terminal集成"><a href="#Terminal集成" class="headerlink" title="Terminal集成"></a>Terminal集成</h3><p>Atom中的terminal插件有很多，使用下来最好用的是<code>platformio-ide-terminal</code>，在Windows下默认调用的是<code>powershell</code>。安装好此插件后，点击界面左下角的加号即可新建一个terminal，其显示风格也可以自定义，用起来极为方便。</p><h3 id="编程辅助"><a href="#编程辅助" class="headerlink" title="编程辅助"></a>编程辅助</h3><p>最常用的两个功能就是自动补全和代码检查，通过插件<code>autocomplete-plus</code>和<code>linter</code>实现，这两个插件都只是一个框架，针对不同语言有不同语言的扩展。针对C/C++，可安装<code>autocomplete-clang</code>和<code>linter-clang</code>，这两个插件都依赖于<code>clang</code>，所以要先装好<code>clang</code>。<code>clang</code>是LLVM的一部分，下载链接在<a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener">这里</a>，在Windows下就是一个exe安装包，直接安装即可，不过需要注意的是，<strong>安装时一定要选择添加到环境变量，否则无法正常使用</strong>。安装好后，在命令行中输入<code>clang -v</code>，若有输出说明安装正确。</p><p>关于这两个插件的详细使用和配置可参考其文档。另外，<code>linter</code>的显示似乎还需要一个名为<code>Linter-UI-Default</code>的插件支持，也要一起安装上。</p><p>其他一些推荐插件还有：</p><ul><li><code>atom-ctags</code> : 为当前工程生成tag索引，以便实现跳转，默认跳转快捷键为<code>F12</code>，<code>shift-F12</code>返回；</li><li><code>symbols-tree-view</code> : 与<code>atom-ctags</code>配合使用，以列表的形式列出tag；</li></ul><p>最后一个待解决的问题就是调试器，要是能把GDB等集成到Atom里面就完美了，这个之后再来折腾……</p><blockquote><p>Update 2017-10-05:<br>对于Python来说，可以安装<code>autocomplete-python</code>和<code>linter-pylama</code>，Python的语法补全和错误检查比C语言用起来感觉更好~<br>关于调试器，可以使用<code>dbg-gdb</code>插件</p></blockquote><h3 id="其它插件"><a href="#其它插件" class="headerlink" title="其它插件"></a>其它插件</h3><ul><li><code>highlight-selected</code> : 高亮当前选中的单词</li><li><code>file-icons</code> : 添加一些文件类型的图标，更为美观</li><li><code>split-diff</code> : 可以对比两个文件的差异</li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>使用过程中也遇到了一些零散的问题，此处记录一下。</p><p>Q: 无法通过拖拽打开文件，即将文件拖入一个已经打开的Atom窗口界面时，显示红色的禁止标志。<br>A: 不要使用管理员身份运行Atom即可。</p><p>Q: 界面字体发虚。<br>A: <a href="/2017/08/30/Win10_Software_Font_Blur/">Win10下软件界面显示模糊问题解决办法</a><br>   <a href="/2017/09/06/Atom_Disable_GPU/">Atom禁用GPU启动的方法</a></p><p>Q: 安装Package时网络连接错误。<br>A: 这是由于GFW把相关网站墙掉了的缘故……开VPN或者是系统代理即可，使用代理的话，在<code>Settings</code>-&gt;<code>Core</code>中找到<code>Use Proxy Settings When Calling APM</code>，勾选上此选项即可。</p><hr><p>最后，使用了一段时间后觉得，Atom有各种好，不过它也有个最大的缺点，就是慢，真的好慢啊…………</p><hr><blockquote><p>参考资料：<br><a href="http://flight-manual.atom.io/" target="_blank" rel="noopener">Atom Flight Manual</a><br><a href="http://blog.csdn.net/u010494080/article/details/50372857" target="_blank" rel="noopener">Atom编辑器入门到精通(一) 安装及使用基础</a><br><a href="https://www.urlteam.org/2017/07/atom%E5%9C%A8vim%E6%A8%A1%E5%BC%8F%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%BF%AB%E6%8D%B7%E5%A4%8D%E5%88%B6%E6%8C%89%E9%94%AE/" target="_blank" rel="noopener">atom在vim模式下设置快捷复制按键</a><br><a href="https://draapho.github.io/2016/10/12/1610-WinSoft-atompack/" target="_blank" rel="noopener">Windows 软件系列-atom插件</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atom禁用GPU启动的方法</title>
      <link href="/2017/09/06/Atom_Disable_GPU/"/>
      <url>/2017/09/06/Atom_Disable_GPU/</url>
      
        <content type="html"><![CDATA[<p>正如在<a href="/2017/08/30/Win10_Software_Font_Blur/">之前的文章</a>中提到，Atom在Win10下若不禁用GPU加速的话，界面字体会模糊，启动时可以通过附加<code>--disable-gpu</code>选项来禁用GPU，然而在打开关联文件等时候，是无法直接设置命令行参数的，此时就需要做些配置来实现这一目的。</p><a id="more"></a><h3 id="修改快捷方式"><a href="#修改快捷方式" class="headerlink" title="修改快捷方式"></a>修改快捷方式</h3><p>若要直接打开一个程序，较常用的方法就是通过桌面或开始菜单中的快捷方式，此时可以在快捷方式属性中指定命令行参数即可，如图所示：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170906160347.png" alt=""></p><h3 id="修改右键菜单"><a href="#修改右键菜单" class="headerlink" title="修改右键菜单"></a>修改右键菜单</h3><p>默认情况下，Atom会自动新建一个<code>Open with Atom</code>的右键菜单项，这个功能还是很实用的，要实现此处打开的Atom也能附加命令行参数，需要通过修改注册表实现。在<code>regedit</code>中，找到<code>\HKEY_CLASSES_ROOT\*\shell\Atom</code>项，这就对应右键菜单中那个命令，其默认项为菜单项的名称，<code>Icon</code>项指向一个<code>exe</code>文件，对应缩略图图标，不要去修改它。继续展开其<code>command</code>子目录，其默认项就是调用的命令，在最后添加一个<code>--disable-gpu</code>即可，例如：<code>&quot;C:\Users\g1992\AppData\Local\atom\atom.exe&quot; &quot;%1&quot; --disable-gpu</code>。最先为Atom的目录，之后的<code>&quot;%1&quot;</code>应该就是系统传入的待打开的文件，最后为我们加上的附加参数。注意，<code>disable-gpu</code>必须加在<code>&quot;%1&quot;</code>之后，加在前面Atom无法正常打开文件。</p><h3 id="修改文件关联"><a href="#修改文件关联" class="headerlink" title="修改文件关联"></a>修改文件关联</h3><p>要修改文件关联调用的程序，也要通过修改注册表实现。系统的打开方式中列出的程序其实是由注册表中<code>\HKEY_CLASSES_ROOT\Applications\</code>目录决定的，每一个子项对应一个程序。找到<code>\HKEY_CLASSES_ROOT\Applications\atom.exe</code>项，这就对应打开方式中Atom项。<code>\HKEY_CLASSES_ROOT\Applications\atom.exe\shell\open</code>目录下的<code>FriendlyAppName</code>项就是打开方式中程序的名称，而其下的<code>command</code>目录的默认项就对应调用的命令行。同理在最后添加一个<code>--disable-gpu</code>即可。</p><hr><p>通过以上配置，基本可以实现无论通过哪种方式打开Atom均可以完全禁用GPU加速的效果了~</p><hr><blockquote><p>参考资料：<br><a href="http://www.360doc.com/content/13/0518/07/4299739_286250789.shtml" target="_blank" rel="noopener">修改注册表实现文件默认打开方式</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10下软件界面显示模糊问题解决办法</title>
      <link href="/2017/08/30/Win10_Software_Font_Blur/"/>
      <url>/2017/08/30/Win10_Software_Font_Blur/</url>
      
        <content type="html"><![CDATA[<p>某些软件在使用过程中会出现显示显示模糊的问题，鼠标动一下或者点一下菜单显示又清晰起来。使用的系统是Win 10，笔记本显卡为GT 730M，开启了系统DPI缩放。遇到此问题的软件有：</p><ul><li>Visual Studio 2015</li><li>Atom</li><li>MarkdownPad</li></ul><a id="more"></a><p>我遇到的问题与这两个问题基本完全一样：</p><blockquote><p><a href="https://www.zhihu.com/question/57583720" target="_blank" rel="noopener">atom，vs2017、vscode 在 win10 下界面显示模糊怎么办？</a><br><a href="http://jingyan.baidu.com/article/6181c3e0ba537f152ef1532d.html" target="_blank" rel="noopener">Visual Studio 2015字体发虚、模糊解决方案</a></p></blockquote><p>解决方法正如其中所说，关掉GPU硬件加速即可。不过对于Atom来说，使用配置<code>useHardwareAcceleration: false</code>是<strong>无效的</strong>，必须在启动时附加命令行参数<code>--disable-gpu</code>才行。</p><p>此问题显然应该是某个Bug造成的，但具体是什么原因导致的并没有查到……</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memcpy中的内存读写优化问题</title>
      <link href="/2017/08/15/Memcpy_Optimization/"/>
      <url>/2017/08/15/Memcpy_Optimization/</url>
      
        <content type="html"><![CDATA[<p><code>memcpy</code>作为一个很简单的库函数，实现了内存的拷贝。不过这个函数功能虽然简单，要实现一个高效的<code>memcpy</code>函数还是很有难度的，这里对其优化问题做一简单讨论。</p><a id="more"></a><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>最简单的<code>memcpy</code>函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memcpy1</span><span class="params">(<span class="keyword">void</span> * dest, <span class="keyword">const</span> <span class="keyword">void</span> * src, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * psrc, * pdest;</span><br><span class="line">    psrc = (<span class="keyword">char</span> *)src; pdest = (<span class="keyword">char</span> *)dest; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        *pdest = *psrc;</span><br><span class="line">        pdest++; psrc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>memcpy1</code>函数对应的汇编代码如下：（使用gcc 4.8.4 -O1优化级别得到，-O2优化级别得到的代码差不多，-O3优化级别得到的代码会复杂很多，极为难以理解……）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">memcpy1:</span></span><br><span class="line">    <span class="keyword">movq</span>%rdi, %rax</span><br><span class="line">    testq%rdx, %rdx</span><br><span class="line">    <span class="keyword">je</span>.L2</span><br><span class="line">    movl<span class="number">$0</span>, %ecx</span><br><span class="line"><span class="symbol">.L3:</span></span><br><span class="line">    movzbl(%rsi, %rcx), %r8d</span><br><span class="line">    movb%r8b, (%rax, %rcx)</span><br><span class="line">    addq<span class="number">$1</span>, %rcx</span><br><span class="line">    cmpq%rdx, %rcx</span><br><span class="line">    <span class="keyword">jne</span>.L3</span><br><span class="line"><span class="symbol">.L2:</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>从中可以看到，在<code>.L3</code>主循环中，每次使用零扩展传送（<code>MOVZ</code>）从源地址读取一个字节的内容，然后将其写入目的地址。</p><h3 id="内存读写优化"><a href="#内存读写优化" class="headerlink" title="内存读写优化"></a>内存读写优化</h3><p><code>memcpy1</code>实现的功能是完全正确的，然而，这段代码效率也是很低效的，其中一个重要原因就是没考虑到实际内存读写过程。目前大部分主流CPU架构中，数据总线的位宽是确定的（大部分是32位或64位），在进行数据传输时，只能以此为基本单位进行传输，且每次读写数据的地址也最好是按照总线位宽对齐的（可能会有其他更严格的对其要求，如x86平台上SSE寄存器要求128位对齐），如果需要的数据不满足此要求时，读写效率会降低，如会进行多次读写等。</p><p>根据以上分析，我们可以每次都以数据总线位宽为单位进行读写，以此优化上述代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memcpy2</span><span class="params">(<span class="keyword">void</span> * dest, <span class="keyword">const</span> <span class="keyword">void</span> * src, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> * psrc, * pdest;</span><br><span class="line">    psrc = (<span class="keyword">long</span> <span class="keyword">long</span> *)src; pdest = (<span class="keyword">long</span> <span class="keyword">long</span> *)dest;</span><br><span class="line">    n /= <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        *pdest = *psrc;</span><br><span class="line">        pdest++; psrc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，以上代码假设<code>n</code>是8的整数倍。对应的汇编代码如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">memcpy2:</span></span><br><span class="line">    <span class="keyword">movq</span>%rdi, %rax</span><br><span class="line">    testq%rdx, %rdx</span><br><span class="line">    <span class="keyword">je</span>.L2</span><br><span class="line">    movl<span class="number">$0</span>, %ecx</span><br><span class="line"><span class="symbol">.L3:</span></span><br><span class="line">    <span class="keyword">movq</span>(%rsi, %rcx, <span class="number">8</span>), %r8</span><br><span class="line">    <span class="keyword">movq</span>%r8, (%rax, %rcx, <span class="number">8</span>)</span><br><span class="line">    addq<span class="number">$1</span>, %rcx</span><br><span class="line">    cmpq%rdx, %rcx</span><br><span class="line">    <span class="keyword">jne</span>.L3</span><br><span class="line"><span class="symbol">.L2:</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>对比两段反汇编代码可以看到，理论上说后一段代码的执行速度会是前一段的8倍，实际测试表明后一段的确快很多，数据长度不同时加速比不一样，不过没有达到8倍，其原因应该和Cache有关，现代主流CPU中均有Cache，所以第一段代码也不是每次都会去读取内存的，之前读到的数据会存在于Cache中，后续访问的速度会比读取内存快很多。</p><p><code>memcpy2</code>为了说明主要问题，假设<code>n</code>是8的整数倍，然而对于实际使用的函数而言，显然不能做这个假设，此时的处理方法是最后来复制<code>n % 8</code>个字节，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memcpy3</span><span class="params">(<span class="keyword">void</span> * dest, <span class="keyword">const</span> <span class="keyword">void</span> * src, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> * psrc, *pdest;</span><br><span class="line">    psrc = (<span class="keyword">long</span> <span class="keyword">long</span> *)src; pdest = (<span class="keyword">long</span> <span class="keyword">long</span> *)dest;</span><br><span class="line">    n /= <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">size_t</span> m = n % <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        *pdest = *psrc;</span><br><span class="line">        pdest++; psrc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> * psrc2, *pdest2;</span><br><span class="line">    psrc2 = (<span class="keyword">char</span> *)psrc; pdest2 = (<span class="keyword">char</span> *)pdest;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        *pdest = *psrc;</span><br><span class="line">        pdest++; psrc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的汇编代码类似<code>memcpy1</code>与<code>memcpy2</code>的混合体，此处从略。</p><p>另一个问题是，之前也提到，内存的读写最好以对齐的方式进行，不过我实际测试了下对于<code>memcpy3</code>来说，<code>src</code>与<code>dest</code>是不是对齐的影响并不大，特别是数据量比较大的时候。这个应该也与Cache机制有关。当然，这是对于x86架构来说的，对于ARM架构而言，地址是强制要求对齐的，好像不对齐的话会出现错误。</p><h3 id="更多优化"><a href="#更多优化" class="headerlink" title="更多优化"></a>更多优化</h3><p>实际的标准库<code>memcpy</code>函数的实现要复杂的多，主要还要考虑以下一些问题：</p><ul><li>使用SIMD指令集，如SSE2，SSSE3，AVX2等；</li><li>考虑缓存预取问题（Cache Prefetch）；</li><li>考虑地址对齐问题；</li></ul><p>相关讨论可以参考这个知乎帖子：</p><blockquote><p><a href="https://www.zhihu.com/question/35172305" target="_blank" rel="noopener">怎样写出一个更快的 memset/memcpy？</a></p></blockquote><p>关于预取（Prefetch）技术的优化技巧，可参考ARM公司的这篇文章：</p><blockquote><p><a href="http://files.rsdn.ru/23380/AMD_block_prefetch_paper.pdf" target="_blank" rel="noopener">Using Block Prefetch for Optimized Memory Performance</a></p></blockquote><p>最后，实际最新版的Glibc 2.26中<code>memcpy</code>的代码是用汇编写的，对于x86_64架构使用了SSSE3指令集优化，代码长达3000余行……列在最后以表达下对技术大佬的膜拜……</p><blockquote><p><a href="https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=sysdeps/x86_64/multiarch/memcpy-ssse3.S;h=f3ea52a46cc808abca920621120a3eff69250137;hb=refs/heads/release/2.26/master" target="_blank" rel="noopener">memcpy-ssse3.S</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找数组中出现次数超过一半的元素</title>
      <link href="/2017/07/31/Array_Find_Half/"/>
      <url>/2017/07/31/Array_Find_Half/</url>
      
        <content type="html"><![CDATA[<p>一个数组中，有某个元素的出现次数超过数组中元素个数的一半，找出这个元素。</p><a id="more"></a><p>这题有一些较容易想到的常规做法：</p><ol><li>先排序，中间元素即为所需元素。时间复杂度O(lonN)。</li><li>利用散列，统计每个元素出现的次数，超过一半即输出。此算法需要额外空间，约为O(n)。</li></ol><p>不过这两种方法都未能在时间和空间上同时达到最优，在牛客网上做到这题时，评论区中有个给出了一个来源于《编程之美》中的巧妙算法，可以做到只循环一遍，且不需要额外空间。</p><p>算法基本思路是：<strong>在数组中任选两个不同元素消去，最终剩下的元素一定是出现次数超过一半的元素</strong>（在保证此元素存在的情况下）。</p><p>具体编程时，可以重头开始扫描，记录当前元素出现次数<code>times</code>，遇到不同的元素则<code>times--</code>，若<code>times==0</code>，换一个元素继续。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMode</span><span class="params">(<span class="keyword">int</span> Nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> remain, times = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (times == <span class="number">0</span>) &#123;</span><br><span class="line">            remain = Nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (remain == Nums[i]) &#123;</span><br><span class="line">            times++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            times--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> remain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此算法需要预先保证输入元素中肯定存在解时返回结果才正确，若不确定是否有元素出现次数大于一半，需要在最后再循环检查一遍：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">times = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (Nums[i] == remain)</span><br><span class="line">        times++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (times &gt; n / <span class="number">2</span> ? remain : <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++中std::string的COW及SSO实现</title>
      <link href="/2017/07/26/Cpp_string_COW_SSO/"/>
      <url>/2017/07/26/Cpp_string_COW_SSO/</url>
      
        <content type="html"><![CDATA[<p>在牛客网上看到一题字符串拷贝相关的题目，深入挖掘了下才发现原来C++中string的实现还是有好几种优化方法的，这里简单记录一下。</p><a id="more"></a><p>原始题目是这样的：</p><blockquote><p>关于代码输出正确的结果是()（Linux g++ 环境下编译运行）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a=<span class="string">"hello world"</span>;</span><br><span class="line">    <span class="built_in">string</span> b=a;</span><br><span class="line">    <span class="keyword">if</span> (a.c_str()==b.c_str())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"true"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">string</span> c=b;</span><br><span class="line">    c=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.c_str()==b.c_str())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"true"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    a=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.c_str()==b.c_str())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"true"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"false"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这段程序的输出结果和编译器有关，在老版本(5.x之前)的GCC上，输出是<code>true true false</code>，而在VS上输出是<code>false false false</code>。这是由于不同STL标准库对<code>string</code>的实现方法不同导致的。</p><p>简而言之，目前各种STL实现中，对<code>string</code>的实现有两种不同的优化策略，即COW(Copy On Write)和SSO(Small String Optimization)。<code>string</code>也是一个类，类的拷贝操作有两种策略——深拷贝及浅拷贝。我们自己写的类默认情况下都是浅拷贝的，可以理解为指针的复制，要实现深拷贝需要重载赋值操作符或拷贝构造函数。不过对于<code>string</code>来说，大部分情况下我们用赋值操作是想实现深拷贝的，故所有实现中<code>string</code>的拷贝均为深拷贝。</p><p>最简单的深拷贝就是直接new一个对象，然后把数据复制一遍，不过这样做效率很低，STL中对此进行了优化，基本策略就是上面提到的COW和SSO。</p><h3 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h3><p>所谓COW就是指，复制的时候不立即申请新的空间，而是把这一过程延迟到写操作的时候，因为在这之前，二者的数据是完全相同的，无需复制。这其实是一种广泛采用的通用优化策略，它的核心思想是懒惰处理多个实体的资源请求，在多个实体之间共享某些资源，直到有实体需要对资源进行修改时，才真正为该实体分配私有的资源。</p><p>COW的实现依赖于引用计数（reference count, <code>rc</code>），初始时<code>rc=1</code>，每次赋值复制时<code>rc++</code>，当修改时，如果<code>rc&gt;1</code>，需要申请新的空间并复制一份原来的数据，并且<code>rc--</code>，当<code>rc==0</code>时，释放原内存。</p><p>不过，实际的<code>string</code>COW实现中，对于什么是”写操作”的认定和我们的直觉是不同的，考虑以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">string</span> b = a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>以上代码显然没有修改<code>string b</code>的内容，此时似乎<code>a</code>和<code>b</code>是可以共享一块内存的，然而由于<code>string</code>的<code>operator[]</code>和<code>at()</code>会返回某个字符的引用，此时无法准确的判断程序是否修改了<code>string</code>的内容，为了保证COW实现的正确性，<code>string</code>只得统统认定<code>operator[]</code>和<code>at()</code>具有修改的“语义”。</p><p>这就导致<code>string</code>的COW实现存在诸多弊端（除了上述原因外，还有线程安全的问题，可进一步阅读文末参考资料），因此只有老版本的GCC编译器和少数一些其他编译器使用了此方式，VS、Clang++、GCC 5.x等编译器均放弃了COW策略，转为使用SSO策略。</p><h3 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h3><p>SSO策略中，拷贝均使用立即复制内存的方法，也就是深拷贝的基本定义，其优化在于，当字符串较短时，直接将其数据存在栈中，而不去堆中动态申请空间，这就避免了申请堆空间所需的开销。</p><p>使用以下代码来验证一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a = <span class="string">"aaaa"</span>;</span><br><span class="line">    <span class="built_in">string</span> b = <span class="string">"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p ------- %p\n"</span>, &amp;a, a.c_str());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p ------- %p\n"</span>, &amp;b, b.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>某次运行的输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0136F7D0 ------- 0136F7D4</span><br><span class="line">0136F7AC ------- 016F67F0</span><br></pre></td></tr></table></figure><p>可以看到，<code>a.c_str()</code>的地址与<code>a</code>、<code>b</code>本身的地址较为接近，他们都位于函数的栈空间中，而<code>b.c_str()</code>则离得较远，其位于堆中。</p><p>SSO是目前大部分主流STL库的实现方式，其优点就在于，对程序中经常用到的短字符串来说，运行效率较高。</p><hr><blockquote><p>参考资料：<br><a href="http://www.cnblogs.com/promise6522/archive/2012/03/22/2412686.html" target="_blank" rel="noopener">std::string的Copy-on-Write：不如想象中美好</a><br><a href="http://www.cnblogs.com/Solstice/archive/2012/03/17/2403335.html" target="_blank" rel="noopener">C++ 工程实践(10)：再探std::string</a><br><a href="https://stackoverflow.com/questions/31228579/why-is-cow-stdstring-optimization-still-enabled-in-gcc-5-1" target="_blank" rel="noopener">Why is COW std::string optimization still enabled in GCC 5.1?</a><br><a href="http://blog.csdn.net/kemaWCZ/article/details/52709747" target="_blank" rel="noopener"> C++ string的COW和SSO</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> C++ </tag>
            
            <tag> Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LDO应用总结</title>
      <link href="/2017/06/12/LDO/"/>
      <url>/2017/06/12/LDO/</url>
      
        <content type="html"><![CDATA[<p>LOD(Low Dropout Regulator, 低压差线性稳压器)是目前最常用的线性稳压元件，本文对其特性进行一总结。</p><a id="more"></a><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>LDO的本质可以视为一个带反馈的可变电阻，其降压的基本原理就是电阻分压。其基本原理框图如下：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170612164119.png" alt=""></p><p>其中虚线框内的调整元件(Pass Element)可以有很多实现方式，比如NPN、PNP、NMOS、PMOS、达灵顿管等。目前比较先进的LDO使用的都是MOS，这是由于MOS管可以获得比三极管更低的导通电阻，进而获得更低的压差(Drop Voltage)。</p><blockquote><p>最常用的1117 LDO使用的调整元件就是NPN三极管：<br><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170612165733.png" alt=""></p><p>而TI的TPS737xx(130mV @ 1A)使用的则是NMOS：<br><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170612165956.png" alt=""></p></blockquote><p>误差比较器也是LDO的一个核心器件，它将输出反馈电压分压与<code>REFERENCE</code>基准源提供的基准电压进行比较，之后通过改变调整元件的栅极电压（或基极电流），进而改变其电阻，以实现将输出电压稳定在某一个特定值处的目的。</p><p><code>REFERENCE</code>基准源一般都是使用带隙基准电路(<a href="https://en.wikipedia.org/wiki/Bandgap_voltage_reference" target="_blank" rel="noopener">Bandgap voltage reference</a>)来实现的，所以其电压一般为1.25V左右。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>LDO在稳态工作时的特性与一个电阻<strong>完全相同</strong>，也就是说，可以直接用一个电阻来替代<strong>稳态工作时的LDO</strong>。LDO名称中的Low Dropout低压差是与传统三端串联稳压元件（如78xx系列）相比来说的，这类串联稳压元件之所以有一个最小压差，本质原因就是<strong>其调整元件的电阻不能降为0</strong>，这也就是上面的原理框图中将调整元件电阻拆分为两部分——$R_{DS(on)}$及一个可变电阻的原因。下面就来具体分析下此问题，需要注意的是，<strong>下面的分析仅在调整元件为MOS时成立，对于1117这类调整元件为三极管的LDO是不适用的</strong>。</p><p>首先来看一下LDO的工作区域：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170612192337.png" alt=""></p><p>图中<code>Saturation Line</code>饱和线右下方的区域即为LDO可能的工作区域，这张图其实就是MOS管的输出特性曲线，正常情况下LDO是工作在MOS的恒流区的，图中A、B、C三点即是三个可能的工作点。当输出电流发生改变时，误差放大器就会通过调节$V_{GS}$保证$V_{DS}$不变，就像A-&gt;B点的变化过程。任意一点与原点连线斜率的倒数就是这一工作点下LDO的等效电阻，可以看到，由于MOS管的$I_{DS}$会饱和，<strong>LDO的工作区域中存在最小的导通电阻，即饱和线上对应的电阻</strong>，而饱和线近似为一条直线，故这个最小电阻近似为一固定值，即$R_{DS(on)}$。</p><p>一般数据手册中给出的最小压降是LDO在最大工作电流时对应的最小压降，即上图饱和线左上角那一点。从图中可以很容易看出：<strong>当工作电流降低时，对应的最小压降成比例的降低，也就是说LDO的最小导通电阻基本为一常量，最小压降与工作电流存在线性关系</strong>。</p><blockquote><p>几个实际LDO芯片的最小压降特性：</p><p>TPS737xx:<br><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170612194425.png" alt=""><br>ISL80510:<br><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170612194600.png" alt=""><br>ADM7172:<br><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170612195024.png" alt=""></p></blockquote><p>不过需要注意的是，以上特性仅在导通元件为MOS的情况下存在，对于导通元件为三极管时，以上特性不成立。比如对于BL1117来说，其最小压降为：1.3V@1A; <a href="mailto:1.23V@0.1A" target="_blank" rel="noopener">1.23V@0.1A</a>。输出电流的减小并没有让最小压降显著减小。</p><p><strong>当LDO工作于饱和区时（即实际压差小于最小压差时），LDO特性相当于一个固定电阻，失去了稳压调节能力。</strong></p><h2 id="核心参数指标"><a href="#核心参数指标" class="headerlink" title="核心参数指标"></a>核心参数指标</h2><h3 id="极限参数"><a href="#极限参数" class="headerlink" title="极限参数"></a>极限参数</h3><p>各种极限参数，比较重要的是最高输入电压，也就是器件的最高耐压；除此之外还有器件的极限温度，需要保证晶元温度不能超过此值。</p><h3 id="输出电压"><a href="#输出电压" class="headerlink" title="输出电压"></a>输出电压</h3><p>LDO有固定输出和可变输出两种，固定输出反馈回路集成在器件内部，其电压是厂家出厂前调整过的，精度较高，数据手册中一般会给出典型输出电压及其最大最小范围。输出电压的精度与很多因素有关，如温度、噪声等，详细分析可以参考文末第二篇参考资料。</p><h3 id="最大输出电流"><a href="#最大输出电流" class="headerlink" title="最大输出电流"></a>最大输出电流</h3><p>需要注意的是，设计过程中不仅要考虑最大输出电流，而且要考虑散热，就算电流小于最大输出电流，然而散热不能保证，导致器件温度超过其极限温度时，LDO一样会损坏的。</p><h3 id="最小压差-Dropout-Voltage"><a href="#最小压差-Dropout-Voltage" class="headerlink" title="最小压差(Dropout Voltage)"></a>最小压差(Dropout Voltage)</h3><p>本文前面一节分析过这一问题，最小压差与输出电流有关，除此之外，最小压差还可能会与输入电压有关，如：</p><blockquote><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170612203009.png" alt=""></p></blockquote><p>需要指出的是，当器件工作于最小压差的临界状态时，数据手册中的很多指标都无法保证，比如PSRR会下降等。</p><h3 id="线性调整率-Line-Regulation"><a href="#线性调整率-Line-Regulation" class="headerlink" title="线性调整率(Line Regulation)"></a>线性调整率(Line Regulation)</h3><p>其定义为，在某个固定负载电流条件下，当输入电压变化时，对应输出电压的变化量，即：</p><p>$$Line\ Regulation=\frac{\Delta V_{out}}{\Delta V_{in}}$$</p><p>最小输入电压是指满足最小压差情况下的最小输入电压。线性调整率是一个DC直流参数，反映了直流情况下输入电压对输出电压的影响，其值越小越好。</p><h3 id="负载调整率-Load-Regulation"><a href="#负载调整率-Load-Regulation" class="headerlink" title="负载调整率(Load Regulation)"></a>负载调整率(Load Regulation)</h3><p>与线性调整率类似，其定义为，在某个固定输入电压条件下，当输出电流变化时，对应输出电压的变化量，即：</p><p>$$Load\ Regulation=\frac{\Delta V_{out}}{\Delta I_{out}}$$</p><p>这也是一个DC直流参数，反映了直流情况下输出电流对输入电压的影响，其值也是越小越好。</p><h3 id="电源抑制比-Power-Supply-Rejection-Ratio-PSRR"><a href="#电源抑制比-Power-Supply-Rejection-Ratio-PSRR" class="headerlink" title="电源抑制比(Power Supply Rejection Ratio, PSRR)"></a>电源抑制比(Power Supply Rejection Ratio, PSRR)</h3><p>表征LDO性能好坏的核心参数，其定义也是输入电压对输出电压的影响，与线性调整率类似，一般用分贝表示：</p><p>$$PSRR=20\log(\frac{ v_{in} } { v_{out} } )$$</p><p>与线性调整率不同的是，<strong>PSRR是一个频域交流参数，其表征的是，LDO对于输入电压不同频率噪声（纹波）的动态抑制能力。</strong></p><blockquote><p>TPS737xx的PSRR和频率的关系：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170612211608.png" alt=""></p></blockquote><p>其值越大代表对输入纹波的抑制效果越好，故PSRR又称Ripple Rejection Ratio。<strong>LDO在10k~1M这个范围内的PSRR尤为重要，这是因为LDO一般是接在开关电源后的，而开关电源的开关频率一般是上述范围，这也导致开关电源的输出纹波频率集中在上述范围内。</strong></p><p>PSRR与频率的大致关系如下：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170612213257.png" alt=""></p><p>图中区域1的PSRR主要与带隙基准滤波器有关，不深入分析；区域2的PSRR主要取决于<strong>误差放大器的闭环增益特性</strong>，这个区域曲线的形状与运放的频率响应特性基本相同，极小值点就是放大器增益降低为单位增益时的频率；达到区域3后，误差放大器对于抑制PSRR帮助已经不大了，此时的PSRR主要取决于<strong>输出滤波电容</strong>，也就是说高频部分（100k以上）的电源纹波抑制只有靠电容来完成了，LDO的响应速度是没有这么快的，这与电源完整性中的结论异曲同工~。</p><p>除了频率外，LDO的PSRR还与很多因素有关，如输出电流、压差、负载电容等，在此不详细分析了，可以参考文末第二篇参考资料。</p><h3 id="瞬态响应"><a href="#瞬态响应" class="headerlink" title="瞬态响应"></a>瞬态响应</h3><p>包括负载电流与输入电压突变时的瞬态响应，一般数据手册中会给出实际实验测试得到的波形图。<strong>瞬态响应与PSRR有密切关系，因为通过傅里叶变换，阶跃信号也可以分解成很多正弦信号的叠加</strong>。</p><blockquote><p>TPS73733瞬态响应：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170612220138.png" alt=""></p></blockquote><h3 id="接地电流-Ground-Current"><a href="#接地电流-Ground-Current" class="headerlink" title="接地电流(Ground Current)"></a>接地电流(Ground Current)</h3><p>即GND脚上流出的电流，如果只给出一个值的话，一般是输出电流为0时的接地电流。接地电流与输出电流关系最大，如：</p><blockquote><p>TPS737xx的接地电流与输出电流的关系：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170612215751.png" alt=""></p></blockquote><h3 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h3><p>LDO的噪声主要来自带隙基准电路及误差放大器，手册中一般会给出其噪声电压频谱密度，如：</p><blockquote><p>TPS737xx系列：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170612220514.png" alt=""></p></blockquote><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>LDO内部有误差放大器，自然就存在稳定性问题，其稳定性主要取决于<strong>外部负载电容及其ESR</strong>，数据手册中一般会对负载电容的容值范围进行说明，也可能会给出确保系统稳定性要求的ESR。对此问题的详细分析可参考以下技术资料：</p><blockquote><p><a href="http://www.ti.com/lit/an/slva115/slva115.pdf" target="_blank" rel="noopener">ESR, Stability, and the LDO Regulator</a><br><a href="http://www.ti.com/lit/an/snva167a/snva167a.pdf" target="_blank" rel="noopener">LDO Regulator Stability Using Ceramic Output Capacitors</a><br><a href="http://www.ti.com/lit/an/slyt187/slyt187.pdf" target="_blank" rel="noopener">Understanding the stable range of equivalent series resistance of an LDO regulator</a><br><a href="http://lens.unifi.it/ew/dwl.php?dwl=bm90ZXMvTERPX1N0YWJpbGl0eV9hbmFseXNpcy5wZGY=&mtyp=application/pdf." target="_blank" rel="noopener">Stability analysis of low-dropout linear regulators with a PMOS pass element</a></p></blockquote><h2 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h2><p>PSRR是LDO的重要参数，为了提高PSRR，研究人员设计出了各种新型电路结构，比如在以下文章中，作者将输入端电压也加入控制回路中，这相当于引入了前馈，作者将其称为“Feed‐Forward Ripple Cancellation Technique”：</p><blockquote><p><a href="http://sites.ieee.org/scv-sscs/files/2010/02/LDO-IEEE_SSCS_Chapter.pdf" target="_blank" rel="noopener">Low Drop-Out (LDO) Linear Regulators: Design Considerations and Trends for High Power Supply Rejection (PSR)</a></p></blockquote><hr><blockquote><p>参考资料：<br><a href="http://www.ti.com/lit/ml/slup239/slup239.pdf" target="_blank" rel="noopener">Understanding Low Drop Out (LDO) Regulators</a><br><a href="http://www.analog.com/media/en/analog-dialogue/volume-48/number-4/articles/understand-ldo-concepts.pdf" target="_blank" rel="noopener">Understand Low-Dropout Regulator (LDO) Concepts to Achieve Optimal Designs</a><br><a href="http://www.intersil.com/content/dam/Intersil/whitepapers/linear-regulator/understanding-ldos.pdf" target="_blank" rel="noopener">Understanding Linear Regulators and Their Key Performance Parameters</a><br><a href="http://www.ti.com/lit/an/slyt202/slyt202.pdf" target="_blank" rel="noopener">Understanding power supply ripple rejection in linear regulators</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HW Component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TL431自激振荡消除方法</title>
      <link href="/2017/06/09/TL431_Self_OScillation/"/>
      <url>/2017/06/09/TL431_Self_OScillation/</url>
      
        <content type="html"><![CDATA[<p>项目中使用TL431作为电流采样放大电路的基准源，然而之后调试过程中发现，采样电流有很大噪声，会影响控制效果。进一步分析表明，这是因为TL431输出的基准电压不稳造成的，输出纹波有几百毫伏，初步猜测是发生了自激振荡。下面对此问题进行下总结。</p><a id="more"></a><p>TL431部分电路原理图如下：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170609165635.png" alt=""></p><p>TL431作为基准源使用，输出2.5V基准电压，<code>RL</code>为后级等效负载，<code>CL</code>则是一个负载电容，设计电路时增加此电容是为了起到滤波作用，期望使得基准电压更平稳。</p><p>系统供电是反激开关电源产生的<code>+5V</code>，实际使用示波器测试过，<code>+5V</code>的纹波和毛刺都很小，50mV不到，所以可以排除是电源导致的输出振荡。再来看一下TL431的内部原理框图：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170609152547.png" alt=""></p><p>TL431内部有一个误差比较器，用于比较<code>REF</code>管脚的电压与内部2.5V<code>Vref</code>间的差异，进而控制后级晶体管的基极电流，这个三极管应该是工作在放大区的，通过调整其基极电流，可以控制<code>ICE</code>，对于后级负载来说，这就相当于一个分流器，进而实现了对<code>Cathode</code>阴极输出电压的控制。这只是对其基本工作原理的一个定性理解，若对其内部电路实现有兴趣，可以进一步参考此分析文章：</p><blockquote><p><a href="https://wenku.baidu.com/view/e3e3e71b227916888486d738.html" target="_blank" rel="noopener">TL431内部结构</a></p></blockquote><p>TL431应用电路极为广泛，不同的外电路接法可以实现不同的功能，就像数据手册中说的这样：</p><blockquote><p>This standard device has proven ubiquity and versatility across a wide range of applications, ranging from power to signal path. This is due to it’s key components containing an accurate voltage reference &amp; opamp, which are very fundamental analog building blocks. TL43xx is used in conjunction with it’s key components to behave as a single voltage reference, error amplifier, voltage clamp or comparator with integrated reference.</p></blockquote><p>当用作电压基准源时，从上面的工作原理分析中很容易想到，此时该引入负反馈闭环使得阴极输出电压稳定，这就是最经典的所谓的“Shunt Regulator”电路：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170609154537.png" alt=""></p><p>输出电压可以由电阻分压很简单的求出来，在我们的应用电路中，省去了反馈的两个分压电阻，直接将阴极输出与反馈端连接了起来，这样输出电压期望就是2.5V。<code>RSup</code>电阻用于提供直流偏置，保证整个系统在开环时就工作于合适的线性放大区，这个偏置电流在数据手册中用<code>IKA</code>表示，其范围很宽，1mA~100mA均可保证TL431正常工作，典型值是10mA。不过较大的驱动电流可以获得更好的响应特性及稳定性，所以在我们的电路中，<code>IKA</code>设置为了100mA。</p><p>分析了电路的内部原理就会发现，这其实就是一个运放负反馈电路，自然就存在系统稳定性问题，关于这个问题，TL431的数据手册中是这样说的：</p><blockquote><p>Unlike many linear regulators, TL43xx is internally compensated to be stable without an output capacitor between the cathode and anode. However, if it is desired to use an output capacitor Figure 24 can be used as a guide to assist in choosing the correct capacitor to maintain stability.</p></blockquote><p>Figure 24是TL431内部晶体管的详细原理图，我的水平并不能从中分析出稳定区域来……不过仔细阅读数据手册后发现，其中给了这么一张稳定性区域图：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170609161554.png" alt=""></p><p>仔细看这张图，当<code>IKA</code>为100mA时，A曲线的<strong>不稳定区域</strong>对应的负载电容在0.3uF~4uF之间，而我们选择的2.2uF正好在这个区域中，所以此时整个闭环系统是处于不稳定区域的，发生自激振荡也就很正常了。这张图是通过实际实验测试得到的，考虑到元器件参数的离散性，特别是电容公差较大，我们选择的2.2uF离临界值相差不远，所以其实可以理解成，这个设计其实是处于临界稳定状态的。这也就进一步解释了，实际调试时，为何大部分板子都会振荡，但是也有几块板子不振荡。</p><p>TI文档<code>SLVA482A</code>对此问题做了进一步的分析：</p><blockquote><p><a href="http://www.ti.com/lit/an/slva482a/slva482a.pdf" target="_blank" rel="noopener">Understanding stability boundary conditions charts in TL431, TL432 Data sheet</a></p></blockquote><p>其中指出，<strong>负载电容的加入相当于为系统引入了一个极点，当此极点位于S平面右半边时，系统即会发生振荡。数据手册中给出的稳定性区域图是临界条件，也就是相位裕度为0的情况，实际设计时还要预留30度以上的相位裕度，以保证系统的可靠性。粗略来看，可以使用左右两侧临界区域1/10或10倍的值作为设计参考。</strong>文档中还给出了一张30度相位裕度参考图：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170609163714.png" alt=""></p><p>至此问题已经明确了，将板子上的2.2uF的电容改为1nF的，自激振荡即消失，电机控制效果好了很多。</p><hr><p>最后还要补充一点，除了调整负载电容容量外，TI文档中还给出了另一种解决方法，在电容上人为串联一个电阻，相当于增加电容的ESR。此方法的原理是为系统增加一个零点，用这个零点来抵消相位延迟：</p><blockquote><p>The output capacitor pole greatly limits the capacitors that can be used. However, any capacitor could be used if a series resistor was added that created an output zero at a low enough frequency. The zero can cancel most of phase lag of the output pole at the unity gain bandwidth frequency of the loop.</p></blockquote><p>不过我没有能很好的理解此方法的内在原理，最后列在这里，之后可以再思考一下。</p><hr><blockquote><p>参考资料：<br><a href="http://www.ti.com/lit/ds/symlink/tl431b.pdf" target="_blank" rel="noopener">TL431 Datasheet</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> HW Component </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数独求解程序</title>
      <link href="/2017/06/07/Sudoku/"/>
      <url>/2017/06/07/Sudoku/</url>
      
        <content type="html"><![CDATA[<p>今晚上帮同学写了个求解数独的小程序，发出来记录下。</p><a id="more"></a><p>标准数独是9*9的，规则是行、列、每个小九宫都填入不重复的1<del>9，我们可以把这个经典游戏扩展到N阶，行和列的规则不变，可以加入对角线限制，即对角线也需要唯一的填入1</del>N。对于N为完全平方的情况，可以加入分块，即类似经典数独那样，每一个小块也要唯一的填入1~N。</p><p>程序逻辑很简单，就是基本的回溯算法，和<a href="/2016/11/22/N_Queen_Problem/">N皇后问题</a>基本完全一样，下面给出求解程序的核心框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!FindNextBlank(i, j))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Number[i][j]++;</span><br><span class="line">        <span class="comment">// Recall</span></span><br><span class="line">        <span class="keyword">if</span> (Number[i][j] &gt; order) &#123;</span><br><span class="line">            <span class="comment">// Clear this positon first</span></span><br><span class="line">            Number[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!FindPreviousBlank(i, j)) &#123;</span><br><span class="line">                <span class="comment">// Stop</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!CheckValid(i, j))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Valid!!</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Found a solution</span></span><br><span class="line">        <span class="keyword">if</span> (!FindNextBlank(i, j)) &#123;</span><br><span class="line">            NofSolutions++;</span><br><span class="line">            <span class="keyword">if</span> (printSolution) &#123;</span><br><span class="line">                PrintSudoku();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Find next solution</span></span><br><span class="line">            i = order - <span class="number">1</span>, j = order;</span><br><span class="line">            FindPreviousBlank(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else find next blank positon</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CheckValid()</code>是与规则有关的判断填入数字合法性的函数，<code>FindNextBlank()</code>和<code>FindPreviousBlank()</code>两个函数用于寻找下一个及上一个空位置，参数使用引用的方式传递，返回结果直接修改了传入值。</p><p>程序中先从第一个空位置开始，依次尝试所有取值，找到一个合法值后，开始填下一个空位置；若达到最后一个空位置，则说明找到了一个解，输出后继续循环；若当前位置尝试完所有取值后，依然没有合法值，说明之前填的有误，需要回溯，清除当前位置的值后会退到上一个空位置继续循环即可。</p><p>完整的程序代码见<a href="https://github.com/g199209/Sudoku" target="_blank" rel="noopener">GitHub</a>。</p><hr><blockquote><p>参考资料：<br><a href="http://cn.sudokupuzzle.org/" target="_blank" rel="noopener">SudokuPuzzle</a><br><a href="http://philoscience.iteye.com/blog/1525673" target="_blank" rel="noopener">总共有多少个数独？</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV与GTK+结合使用</title>
      <link href="/2017/06/01/OpenCV_and_GTK/"/>
      <url>/2017/06/01/OpenCV_and_GTK/</url>
      
        <content type="html"><![CDATA[<p>之前研究过<a href="/2016/12/10/OpenCV_and_Qt/">OpenCV与Qt结合使用</a>，毕设要用的Intel Joule开发板上安装Qt较为困难，不过它自带了GTK+3.0 GUI框架，于是研究了下是否可以在GTK+中显示OpenCV的图片，折腾了一下发现是可行的，记录一下方法。</p><a id="more"></a><p>OpenCV默认的<code>imshow</code>似乎使用的就是GTK+框架，在GTK中显示图片的方法参考以下这篇教程：</p><blockquote><p><a href="http://blog.csdn.net/tennysonsky/article/details/43057081" target="_blank" rel="noopener">GTK常用控件之图片控件(GtkImage)</a></p></blockquote><p>可以看到，GTK中的图片是使用<code>GdkPixbuf</code>结构体来保存的，而OpenCV 3.x中使用<code>Mat</code>类来保存图片，所以只要实现<code>Mat</code>到<code>GdkPixbuf</code>的转换即可在GTK中显示图片了，实现代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Mat Image;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mat(BGR) -&gt; IplImage(RGB)</span></span><br><span class="line">cvtColor(image, image, COLOR_BGR2RGB);</span><br><span class="line">IplImage ipltmp = image;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IplImage -&gt; GdkPixbuf</span></span><br><span class="line">GdkPixbuf * src = gdk_pixbuf_new_from_data(</span><br><span class="line">    (<span class="keyword">const</span> guchar *)ipltmp.imageData, </span><br><span class="line">    GDK_COLORSPACE_RGB, </span><br><span class="line">    <span class="number">0</span>, </span><br><span class="line">    ipltmp.depth, </span><br><span class="line">    ipltmp.width, </span><br><span class="line">    ipltmp.height, </span><br><span class="line">    ipltmp.widthStep, </span><br><span class="line">    <span class="literal">NULL</span>, </span><br><span class="line">    <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>关于<code>gdk_pixbuf_new_from_data()</code>及<code>GdkPixbuf</code>的详细说明参见：</p><blockquote><p><a href="http://openbooks.sourceforge.net/books/wga/graphics-gdk-pixbuf.html" target="_blank" rel="noopener">Gdk-pixbuf</a></p></blockquote><hr><blockquote><p>参考资料：<br><a href="https://stackoverflow.com/questions/1188665/how-can-i-display-an-opencv-iplimage-in-gtk-gtkmm/1230761#1230761" target="_blank" rel="noopener">How can I display an OpenCV IplImage in Gtk+/Gtkmm?</a><br><a href="https://stackoverflow.com/questions/4664187/converting-cvmat-to-iplimage" target="_blank" rel="noopener">Converting cv::Mat to IplImage*</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cadence Allegro 调整界面字体字号</title>
      <link href="/2017/05/14/Allegro_Font/"/>
      <url>/2017/05/14/Allegro_Font/</url>
      
        <content type="html"><![CDATA[<p>在使用高分屏时，会发现系统设置的dpi缩放对Allegro无效，这就导致对话框中的文本会显得很小，极不方便使用。不过研究发现，Allegro中是有设置可以调整字体和字号的。</p><a id="more"></a><p>打开<code>Setup</code>-&gt;<code>User Preference...</code>，在左侧<code>Categories</code>中展开<code>Ui</code>-&gt;<code>Fonts</code>。右侧的设置中，<code>fontsize</code>代表字号，这是个负数，值越小字号越大，默认值是<code>-12</code>；<code>fontface</code>是字体；<code>fontweight</code>是用来控制加粗的，<code>500</code>代表粗体，<code>300</code>是不加粗字体，默认的<code>400</code>介于二者之间。</p><p><img src="https://pic.gaomf.store/20170514103643.png" alt=""></p><p>确定保存后重启程序即可生效。</p><p>最后附上官方帮助文档中的说明以供参考：</p><blockquote><p>Changing Fonts</p><p>The layout editor lets you customize the look of the graphical user interface by changing the size and type of the fonts in the console, status, and Options windows, and in the Find window pane. This can be convenient if you find it difficult to read information presented in the default size and type.</p><p>To change fonts in the user interface:</p><ol><li><p>Exit the layout editor, if you have it running.</p></li><li><p>Set the font variables in your environment file.<br>These variables can also be set in the System dialog box in the Control Panel.<br><code>fontSize</code> = -12<br>where -12 represents the default font size. A larger negative number (for example -20) makes the font larger. Do not use positive numbers in this value.<br><code>fontFace</code> = helvetica<br>where helvetica represents the default font type. Fonts available to you depend on your platform and any user-installed fonts. The value is always a font name.<br><code>fontWeight</code> = 500<br>where 500 represents bolded type. Change the value to 300 to produce unbolded type.</p></li><li><p>Restart the tool.</p></li><li><p>Resize the window, if necessary, to display all information in the larger font size.</p></li></ol><p>You can also change font variables in the User Preferences Editor dialog box by running the enved command. Note that you must restart the tool to see the change.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带软启动的分立负载开关电路</title>
      <link href="/2017/05/05/Discrete_Load_Switch/"/>
      <url>/2017/05/05/Discrete_Load_Switch/</url>
      
        <content type="html"><![CDATA[<p>负载开关用于控制后级电路的供电，可以采用分立元件，也可用专用的芯片，此处总结一下最常用的分立元件方案。</p><a id="more"></a><p>电路原理图：</p><p><img src="https://pic.gaomf.store/20170505203851.png" alt=""></p><p>图中C1及R5代表后级负载电路。U5断开时，Q1截止，进而U4也为截止状态；U5导通时，Q1也导通，此时V1、C2、R2、Q1构成RC充电回路，U4 Vgs逐渐上升，当Vgs上升超过其阈值后，U4导通，不过刚开始导通时其导通电阻较大，故尽管负载电容很大，此时的电流并不会很大，这也就是所谓的软启动功能。随着Vgs进一步上升，U4导通电阻降低，系统正常为后级负载供电。</p><p>PSpice仿真结果如下：</p><p><img src="https://pic.gaomf.store/20170505210411.png" alt=""></p><p>若去掉C2，此时就没有软启动了，PSpice仿真结果为：</p><p><img src="https://pic.gaomf.store/20170505210633.png" alt=""></p><p>可以看到，在导通的瞬间有一个很大的脉冲浪涌电流，这很有可能导致MOS管的损坏。不过也要看到，软启动功能也带来了一些弊端，比如电路延时变长。</p><p>更为可靠的方法是使用集成式负载开关，可参考之前写的这篇文章：</p><blockquote><p><a href="/2016/01/24/%E9%9B%86%E6%88%90%E5%BC%8F%E8%B4%9F%E8%BD%BD%E5%BC%80%E5%85%B3/">集成式负载开关</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PSpice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PSpice教程及帮助文档</title>
      <link href="/2017/05/05/PSpice_Tutorial_Help/"/>
      <url>/2017/05/05/PSpice_Tutorial_Help/</url>
      
        <content type="html"><![CDATA[<p>PSpice的教程在网上随便一搜就有一大堆，不过其实还是Cadence自带的帮助文档最好，这里就来总结下有哪些比较有用的PSpice帮助文档。</p><a id="more"></a><h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><p>打开OrCAD Capture CIS，选择<code>Help</code>-&gt;<code>Learning PSpice</code>即可打开一个交互式的Tutorial，这个比各种教程好多了，从最简单的元器件基础内容到各种高级分析方法都介绍到了：</p><blockquote><p>Cadence OrCAD Solution’s “Learning PSpice” is made available to all, for learning various concepts related to Electrical and Electronics engineering. This complete material covers several diverse topics, ranging from basic theorems to very advanced topics in the field of Electrical &amp; Electronics Engineering and electronic design automation etc. </p></blockquote><h2 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h2><p>打开Cadence帮助（按F1），在左侧导航栏中可以找到PSpice文件夹，这些就是PSpice相关帮助文档，可以在当前帮助浏览器中直接查看，也可通过菜单栏上的pdf按钮打开对应的pdf文件查看：</p><p><img src="https://pic.gaomf.store/20170505165654.png" alt=""></p><p>下面列举几份比较有用的文档。</p><h3 id="SPICE帮助"><a href="#SPICE帮助" class="headerlink" title="SPICE帮助"></a>SPICE帮助</h3><blockquote><p>PSpice A/D Reference Guide</p></blockquote><p>在导航菜单中的名字叫做<code>PSpice Reference Guide</code>，这份文档其实是对SPICE本身的介绍，包括各种基本元件、分析方法、基本函数、SPICE语法等。实际上使用SPICE分析模拟电路的情况更多一些，故在需要时可以通过其中<code>Analog devices</code>部分查阅各种基础元件的模型：</p><p><img src="https://pic.gaomf.store/20170505170850.png" alt=""></p><blockquote><p>Detailed descriptions of the simulation controls and analysis specifications, start-up option definitions, and a list of device types in the analog and digital model libraries. User interface commands are provided to instruct you on each of the screen commands.</p></blockquote><h3 id="PSpice基础文档"><a href="#PSpice基础文档" class="headerlink" title="PSpice基础文档"></a>PSpice基础文档</h3><blockquote><p>PSpice User Guide<br>PSpice Help</p></blockquote><p>PSpice软件相关的文档，Guide相当于一份十分详尽的软件教程，而Help则是用于查阅的帮助文档。在<code>PSpice Help</code>中有一部分叫做<code>Index of PSpice symbol and part properties</code>，其中包含了所有仿真模型和仿真参数的说明，可以在这里查到每个参数的意思，还有这个元件是包含在那个库文件中的。</p><h3 id="PSpice高级文档"><a href="#PSpice高级文档" class="headerlink" title="PSpice高级文档"></a>PSpice高级文档</h3><blockquote><p>PSpice Advanced Analysis User Guide<br>PSpice Advanced Analysis Help</p></blockquote><p>与上面的<code>PSpice基础文档</code>类似，只是介绍的是PSpice中的各种高级功能，比如蒙特卡洛分析、灵敏度分析、优化器等等。</p>]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PSpice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PSpice中的延时开关</title>
      <link href="/2017/05/05/PSpice_Swt/"/>
      <url>/2017/05/05/PSpice_Swt/</url>
      
        <content type="html"><![CDATA[<p>延时开关用于仿真某一时刻闭合或断开的元件特性，这不是SPICE的基本元件，PSpice中使用了两个子电路模块来实现这一功能：初始时刻闭合，某一时刻断开的<code>Sw_tOpen</code>；初始时刻断开，某一时刻闭合的<code>Sw_tClose</code>。</p><a id="more"></a><p>这两个元件原理图符号位于<code>eval.olb</code>库中，SPICE实现位于<code>anl_misc.lib</code>库中，下面对其参数及实现做一总结。</p><h3 id="Sw-tOpen"><a href="#Sw-tOpen" class="headerlink" title="Sw_tOpen"></a>Sw_tOpen</h3><p><img src="https://pic.gaomf.store/sw_topen.png" alt=""></p><p>SPICE实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* For DC and AC analyses, the switch will be Closed.</span><br><span class="line">.SUBCKT  Sw_tOpen   1  2  PARAMS: </span><br><span class="line">+ tOpen=0      ; time at which switch begins to open</span><br><span class="line">+ ttran=1u     ; time required to switch states (must be realistic, not 0)</span><br><span class="line">+ Rclosed=0.01 ; Closed state resistance</span><br><span class="line">+ Ropen=1Meg   ; Open state resistance (Ropen/Rclosed &lt; 1E10)</span><br><span class="line">V1 3 0 pulse(1 0 &#123;tOpen&#125; &#123;ttran&#125; 1 10k 11k)</span><br><span class="line">S1 1 2 3 0 Smod</span><br><span class="line">.model Smod Vswitch(Ron=&#123;Rclosed&#125; Roff=&#123;Ropen&#125;)</span><br><span class="line">.ends</span><br></pre></td></tr></table></figure><p>可以看到，<code>Sw_tOpen</code>是由一个压控开关和一个脉冲电压源组成的，<code>tOpen</code>前电阻为<code>Rclosed</code>，之后<code>ttran</code>时间内电阻以指数形式变化至<code>Ropen</code>，并保持<code>10k</code>秒。</p><table><thead><tr><th>参数</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>TOPEN</td><td>断开切换时间</td><td>0</td></tr><tr><td>TTRAN</td><td>过渡时间</td><td>1u</td></tr><tr><td>RCLOSED</td><td>导通电阻</td><td>0.01</td></tr><tr><td>ROPEN</td><td>开路电阻</td><td>1Meg</td></tr></tbody></table><h3 id="Sw-tClose"><a href="#Sw-tClose" class="headerlink" title="Sw_tClose"></a>Sw_tClose</h3><p><img src="https://pic.gaomf.store/sw_tclose.png" alt=""></p><p>SPICE实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* For DC and AC analyses, the switch will be Open.</span><br><span class="line">.SUBCKT  Sw_tClose  1  2  PARAMS: </span><br><span class="line">+ tClose=0     ; time at which switch begins to close</span><br><span class="line">+ ttran=1u     ; time required to switch states (must be realistic, not 0)</span><br><span class="line">+ Rclosed=0.01 ; Closed state resistance</span><br><span class="line">+ Ropen=1Meg   ; Open state resistance (Ropen/Rclosed &lt; 1E10)</span><br><span class="line">V1 3 0 pulse(0 1 &#123;tClose&#125; &#123;ttran&#125; 1 10k 11k)</span><br><span class="line">S1 1 2 3 0 Smod</span><br><span class="line">.model Smod Vswitch(Ron=&#123;Rclosed&#125; Roff=&#123;Ropen&#125;)</span><br><span class="line">.ends</span><br></pre></td></tr></table></figure><p>与<code>Sw_tOpen</code>基本完全相同，只是开始时是断开的，<code>tClose</code>后导通。</p><table><thead><tr><th>参数</th><th>含义</th><th>默认值</th></tr></thead><tbody><tr><td>TCLOSE</td><td>导通切换时间</td><td>0</td></tr><tr><td>TTRAN</td><td>过渡时间</td><td>1u</td></tr><tr><td>RCLOSED</td><td>导通电阻</td><td>0.01</td></tr><tr><td>ROPEN</td><td>开路电阻</td><td>1Meg</td></tr></tbody></table><hr><p>需要注意的是，默认的<code>RCLOSED</code>和<code>ROPEN</code>的值不一定合适，需要根据实际电路进行修改，而且根据注释说明，这两个值之间的差距还不能太大，也就是说其实这两个元件是无法很好的模拟仿真理想开关的性质的。</p>]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PSpice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux软路由——基础配置</title>
      <link href="/2017/04/25/Linux_SoftRouter_Basic/"/>
      <url>/2017/04/25/Linux_SoftRouter_Basic/</url>
      
        <content type="html"><![CDATA[<p>之前买了台二手服务器，总觉得应该让它发挥点什么作用，正好针对学校蛋疼的网络，先试试能不能把它当做一台超级智能路由器吧~:)</p><a id="more"></a><p>系统：Ubuntu Server 14.04 64bit</p><h2 id="设置无线AP"><a href="#设置无线AP" class="headerlink" title="设置无线AP"></a>设置无线AP</h2><p>使用的设备是TP-Link TL-WDN4800，配合<code>hostapd</code>实现软AP功能，实现方法参考以下几篇文章：</p><blockquote><p><a href="http://www.361way.com/hostapd-soft-ap/2933.html" target="_blank" rel="noopener">linux软AP－－hostapd+dhcpd</a><br><a href="https://blog.kylemanna.com/linux/wifi-hostapd/" target="_blank" rel="noopener">My Wi-Fi access point revisited</a><br><a href="http://rustyrazorblade.com/2013/09/setting-up-a-wireless-access-point-with-ubuntu-raring-ringtail/" target="_blank" rel="noopener">Setting up a Wireless Access Point with Ubuntu Raring Ringtail</a></p></blockquote><p>我使用的<code>hostapd</code>的配置文件如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface=wlan0</span><br><span class="line">driver=nl80211</span><br><span class="line">ssid=TLWDN4800</span><br><span class="line">macaddr_acl=0</span><br><span class="line">ignore_broadcast_ssid=0</span><br><span class="line"></span><br><span class="line">auth_algs=1</span><br><span class="line">wpa=3</span><br><span class="line">wpa_passphrase=xxxxxxxxxx</span><br><span class="line">wpa_key_mgmt=WPA-PSK</span><br><span class="line">wpa_pairwise=TKIP</span><br><span class="line">rsn_pairwise=CCMP</span><br><span class="line"></span><br><span class="line">ieee80211n=1</span><br><span class="line">wme_enabled=1</span><br><span class="line">wmm_enabled=1</span><br><span class="line">ht_capab=[HT40-][SHORT-GI-40][TX-STBC][RX-STBC1][DSSS_CCK-40][LDPC]</span><br><span class="line">hw_mode=g</span><br><span class="line">channel=13</span><br></pre></td></tr></table></figure><p>完整的<code>hostapd</code>配置文件说明可以参考：</p><blockquote><p><a href="https://w1.fi/cgit/hostap/plain/hostapd/hostapd.conf" target="_blank" rel="noopener">hostapd configuration file</a></p></blockquote><p>配置好后使用<code>service hostapd restart</code>启动服务即可。</p><p>不过以上配置应该并不是最优配置，TL-WDN4800最高传输速率450Mbps，然而之后实际测试得到的速率只有30Mbps左右。</p><h2 id="配置DHCP服务器"><a href="#配置DHCP服务器" class="headerlink" title="配置DHCP服务器"></a>配置DHCP服务器</h2><p>为无线AP添加DHCP服务。</p><h3 id="安装DHCP服务"><a href="#安装DHCP服务" class="headerlink" title="安装DHCP服务"></a>安装DHCP服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install isc-dhcp-server</span><br></pre></td></tr></table></figure><h3 id="配置DHCP网卡"><a href="#配置DHCP网卡" class="headerlink" title="配置DHCP网卡"></a>配置DHCP网卡</h3><p>修改<code>/etc/default/isc-dhcp-server</code>文件，根据注释说明添加对应网卡即可，可以添加不止一个，此处以<code>wlan0</code>为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INTERFACES=<span class="string">"wlan0"</span></span><br></pre></td></tr></table></figure><h3 id="修改DHCP配置文件"><a href="#修改DHCP配置文件" class="headerlink" title="修改DHCP配置文件"></a>修改DHCP配置文件</h3><p>修改<code>/etc/dhcp/dhcpd.conf</code>文件，根据注释修改即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ddns-update-style none;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处填写分配的DNS服务器地址，一般所有客户机都是一样的，故可以使用全局配置</span></span><br><span class="line">option domain-name-servers 223.5.5.5;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可适当增加地址租期</span></span><br><span class="line">default-lease-time 6000;</span><br><span class="line">max-lease-time 36000;</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>-facility local7;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最基本的子网配置方法</span></span><br><span class="line">subnet 192.168.137.0 netmask 255.255.255.0 &#123;</span><br><span class="line">    <span class="comment"># 起止IP地址范围</span></span><br><span class="line">    range 192.168.137.10 192.168.137.70;</span><br><span class="line">    <span class="comment"># 子网掩码</span></span><br><span class="line">    option subnet-mask 255.255.255.0;</span><br><span class="line">    <span class="comment"># 默认网关</span></span><br><span class="line">    option routers 192.168.137.77</span><br><span class="line">    <span class="comment"># 广播地址</span></span><br><span class="line">    option broadcast-address 192.168.137.255;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是最基本的配置方法，各种高级配置可参考注释说明。</p><h3 id="配置本机IP"><a href="#配置本机IP" class="headerlink" title="配置本机IP"></a>配置本机IP</h3><p>DHCP服务器本身显然是不能再配置为动态获取IP的，需要配置为静态IP的形式。修改<code>/etc/network/interfaces</code>文件，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iface wlan0 inet static</span><br><span class="line">address 192.168.137.77</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.137.77</span><br><span class="line">dns-nameservers 223.5.5.5 223.6.6.6</span><br></pre></td></tr></table></figure><h3 id="重启DHCP服务"><a href="#重启DHCP服务" class="headerlink" title="重启DHCP服务"></a>重启DHCP服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service isc-dhcp-server restart</span><br></pre></td></tr></table></figure><p>此时客户端配置为自动获取IP即可。</p><h2 id="通过VPN拨号连接校园网"><a href="#通过VPN拨号连接校园网" class="headerlink" title="通过VPN拨号连接校园网"></a>通过VPN拨号连接校园网</h2><p>根据学校网络中心的<a href="https://pic.gaomf.store/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%AD%A6L2TP%20Linux%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE%E6%89%8B%E5%86%8C.doc" target="_blank" rel="noopener">说明文件</a>配置即可。</p><h3 id="配置静态IP"><a href="#配置静态IP" class="headerlink" title="配置静态IP"></a>配置静态IP</h3><p>修改<code>/etc/network/interfaces</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iface eth0 inet static</span><br><span class="line">address 10.12.218.231</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 10.12.218.1</span><br><span class="line">dns-nameservers 223.5.5.5 223.6.6.6</span><br></pre></td></tr></table></figure><h3 id="安装xl2tpd"><a href="#安装xl2tpd" class="headerlink" title="安装xl2tpd"></a>安装<code>xl2tpd</code></h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install xl2tpd</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>配置<code>/etc/xl2tpd/xl2tpd.conf</code>文件，在最后加入以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[lac ZJU_VPN]</span><br><span class="line">lns = 10.5.1.7</span><br><span class="line">redial = yes</span><br><span class="line">redial timeout = 15</span><br><span class="line">max redials = 5</span><br><span class="line">require pap = no</span><br><span class="line">require chap = yes</span><br><span class="line">name = g199209@a</span><br><span class="line">ppp debug = no</span><br><span class="line">pppoptfile = /etc/ppp/options.xl2tpd.zju</span><br></pre></td></tr></table></figure><p>创建<code>/etc/ppp/options.xl2tpd.zju</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">noauth</span><br><span class="line">proxyarp</span><br><span class="line">defaultroute</span><br></pre></td></tr></table></figure><p>保存用户名与密码，修改<code>/etc/ppp/chap-secrets</code>文件，在最后添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g199209@a * 00000000 *</span><br></pre></td></tr></table></figure><p>其中<code>00000000</code>替换为真实的密码。</p><h3 id="启动服务与停止服务"><a href="#启动服务与停止服务" class="headerlink" title="启动服务与停止服务"></a>启动服务与停止服务</h3><p>连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service xl2tpd start</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'c ZJU_VPN'</span> &gt; /var/run/xl2tpd/l2tp-control</span><br></pre></td></tr></table></figure><p>连接成功后，使用<code>ifconfig</code>命令可以看到<code>ppp0</code>接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ppp0      Link encap:Point-to-Point Protocol</span><br><span class="line">          inet addr:222.205.109.222  P-t-P:10.5.1.7  Mask:255.255.255.255</span><br><span class="line">          UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1442  Metric:1</span><br><span class="line">          RX packets:262777 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:348384 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:3</span><br><span class="line">          RX bytes:123894650 (123.8 MB)  TX bytes:332214801 (332.2 MB)</span><br></pre></td></tr></table></figure><p>其中的<code>inet addr</code>就是虚拟局域网IP地址。</p><p>断开连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'d ZJU_VPN'</span> &gt; /var/run/xl2tpd/l2tp-control</span><br><span class="line">service xl2tpd stop</span><br></pre></td></tr></table></figure><h3 id="修改路由表"><a href="#修改路由表" class="headerlink" title="修改路由表"></a>修改路由表</h3><p>添加两条记录即可，首先将发往VPN服务器的流量通过本地网关发送：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add -host 10.5.1.7 gw 10.12.218.1 dev eth0</span><br></pre></td></tr></table></figure><p>默认流量都通过<code>ppp0</code>发送：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add default gw 222.205.109.222 dev ppp0</span><br></pre></td></tr></table></figure><p>此处的网关就是之前看到的<code>ppp0</code>的IP地址。</p><p>需要将矛盾的路由记录删除掉，比如只要保留一条默认记录就可以了。</p><h2 id="使用手机USB共享提供4G网络连接"><a href="#使用手机USB共享提供4G网络连接" class="headerlink" title="使用手机USB共享提供4G网络连接"></a>使用手机USB共享提供4G网络连接</h2><p>本来想买个4G USB网卡的，然而价格都太贵……之前一直用一个闲置的Nexus手机做无线AP的，其实可以使用USB网络共享（USB Tethering）功能，把手机当成一个4G网卡用的。将手机与电脑连起来，在手机上开启USB网络共享功能，使用<code>lsusb</code>命令可以查看手机是否正常连接上了，若成功连接的话，会有显示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bus 001 Device 009: ID 18d1:4ee4 Google Inc. Nexus 4 (debug + tether)</span><br></pre></td></tr></table></figure><p>显示<code>tether</code>的话就说明共享成功了，使用<code>ifconfig -a</code>命令可以看到一个名为<code>usb0</code>的网络设备：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usb0      Link encap:Ethernet  HWaddr aa:e3:b2:da:e7:27</span><br><span class="line">          BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure><p>不过可以看到，此时还没有正确分配IP地址，使用<code>dhcpcd usb0</code>命令从手机DHCP服务器上获取一下IP地址即可，再使用<code>ifconfig</code>命令即可看到<code>usb0</code>已经获得正确的IP地址了。使用<code>route -n</code>命令可以看到此时也自动添加了路由表。</p><h2 id="添加路由转发"><a href="#添加路由转发" class="headerlink" title="添加路由转发"></a>添加路由转发</h2><p>路由器最重要的功能就是路由转发啦，Linux内核本身就支持这一功能，这在之前写的<a href="http://gaomf.cn/2016/11/01/Ubuntu_NAT_Raspberry/">Ubuntu虚拟机中设置NAT使树莓派开发板可以联网</a>一文中介绍了实现方法，大概就是在<code>/etc/sysctl.conf</code>文件中开启IP转发功能，之后在<code>iptables</code>中添加一条<code>MASQUERADE</code>规则即可，文末参考资料中鸟哥的文章里对此有详细介绍。</p><p>如果要使用有线网上网：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 192.168.137.0/24 -o ppp0 -j MASQUERADE</span><br></pre></td></tr></table></figure><p>如果要使用4G网络上网：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 192.168.137.0/24 -o usb0 -j MASQUERADE</span><br></pre></td></tr></table></figure><h2 id="自动连接脚本"><a href="#自动连接脚本" class="headerlink" title="自动连接脚本"></a>自动连接脚本</h2><p>以上操作可以写成一个脚本文件，方便在校园网和4G网络间切换。</p><h3 id="连接至校园网"><a href="#连接至校园网" class="headerlink" title="连接至校园网"></a>连接至校园网</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">service xl2tpd start</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'c ZJU_VPN'</span> &gt; /var/run/xl2tpd/l2tp-control</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Create L2TP connection..."</span></span><br><span class="line">sleep 5</span><br><span class="line">VPNIP=$(ifconfig | grep P-t-P | awk <span class="string">'&#123;print $2&#125;'</span> | awk <span class="string">'BEGIN &#123;FS=":"&#125; &#123;print $2&#125;'</span>)</span><br><span class="line"><span class="keyword">if</span> [ ! -n <span class="string">"<span class="variable">$VPNIP</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"VPNIP Empty!"</span></span><br><span class="line">        <span class="built_in">exit</span> -1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Update Route &amp; Iptables"</span></span><br><span class="line">route del -host 10.5.1.7</span><br><span class="line">route add -host 10.5.1.7 gw 10.12.218.1 dev eth0</span><br><span class="line">route del default</span><br><span class="line">route add default gw <span class="variable">$VPNIP</span> dev ppp0</span><br><span class="line">iptables -t nat -F</span><br><span class="line">iptables -t nat -A POSTROUTING -s 192.168.137.0/24 -o ppp0 -j MASQUERADE</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"nameserver 223.5.5.5"</span> &gt; /etc/resolv.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"nameserver 223.6.6.6"</span> &gt;&gt; /etc/resolv.conf</span><br></pre></td></tr></table></figure><h3 id="连接至4G网络"><a href="#连接至4G网络" class="headerlink" title="连接至4G网络"></a>连接至4G网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'d ZJU_VPN'</span> &gt; /var/run/xl2tpd/l2tp-control</span><br><span class="line">service xl2tpd stop</span><br><span class="line">dhcpcd usb0</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Update Route &amp; Iptables"</span></span><br><span class="line">route del default</span><br><span class="line">route add default gw 192.168.42.129 dev usb0</span><br><span class="line">iptables -t nat -F</span><br><span class="line">iptables -t nat -A POSTROUTING -s 192.168.137.0/24 -o usb0 -j MASQUERADE</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"nameserver 223.5.5.5"</span> &gt; /etc/resolv.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"nameserver 223.6.6.6"</span> &gt;&gt; /etc/resolv.conf</span><br></pre></td></tr></table></figure><hr><p>使用以上方法配置好后，笔记本通过无线连接，电脑即可正常上网了，此时服务器就相当于一台路由器，只是目前4G和校园网还是独立的，要更改连接需要自己手动输入命令，之后进一步研究下如何实现更高级的策略路由。</p><hr><blockquote><p>参考资料：<br><a href="http://blog.csdn.net/zuifeng503/article/details/8203849" target="_blank" rel="noopener">Ubuntu下DHCP服务器的配置</a><br><a href="http://cn.linux.vbird.org/linux_server/0250simple_firewall_3.php" target="_blank" rel="noopener">Linux 的封包过滤软件： iptables</a><br><a href="http://cn.linux.vbird.org/linux_server/0230router.php" target="_blank" rel="noopener">第八章、路由观念与路由器设定</a><br><a href="http://blog.csdn.net/moreorless/article/details/5397427" target="_blank" rel="noopener">linux 添加静态路由</a><br><a href="http://blog.sina.com.cn/s/blog_bce68edc0101de0x.html" target="_blank" rel="noopener">在多种系统下通过USB连接android手机上网</a><br><a href="https://bbs.linuxdistrocommunity.com/discussion/779/usb-tethering-on-linux" target="_blank" rel="noopener">USB Tethering on Linux</a><br><a href="http://blog.csdn.net/vevenlcf/article/details/48026965" target="_blank" rel="noopener">linux 路由表设置 之 route 指令详解</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>松弛振荡器原理</title>
      <link href="/2017/04/04/Relaxation_Oscillator/"/>
      <url>/2017/04/04/Relaxation_Oscillator/</url>
      
        <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Relaxation_oscillator" target="_blank" rel="noopener">松弛振荡器</a> (Relaxation Oscillator, RO)是一种无稳态多谐振荡器，一般使用比较器或者施密特触发器构成，在电容检测中，很多情况下就是使用此电路检测电容大小。</p><a id="more"></a><p>松弛振荡器的基本电路如下：</p><p><img src="https://pic.gaomf.store/312px-OpAmpHystereticOscillator.svg.png" alt=""></p><p>当然，这是针对比较器是使用双电源供电的情况下才能使用的，输出波形及电容电压如下：</p><p><img src="https://pic.gaomf.store/644px-Opamprelaxationoscillator.svg.png-height300" alt=""></p><p>若运放使用单电源供电，是不能使用此电路的。单电源供电时，简单分析即可知道，此电路有一个稳态，即所有点电压均为0的状态，故此系统无法稳定的振荡起来。单电源情况下，要引入一个直流偏置：</p><p><img src="https://pic.gaomf.store/20170404173330.png-height300" alt=""></p><p>简单的计算即可知道，此时 $V_{+}$ 的两个阈值为$\frac{2}{3}V_{cc}$及$\frac{1}{3}V_{cc}$，电容就在这两个阈值之间来回充放电，进而产生振荡。粗略的仿真波形如下：</p><p><img src="https://pic.gaomf.store/20170404174119.png-height300" alt=""></p><p>图中红线为$V_{out}$，绿线为$V_{+}$，蓝线为$V_{-}$。</p><p>上图这种松弛振荡器输出波形占空比基本是50%，震荡周期为$2\ln2 R_{c}C$，这就是一个简单的电容充放电过程，根据“<a href="/2017/04/04/Capacity_Charge/">对电容充放电过程的理解</a>”一文中的方法可以很快计算出振荡周期来。</p><p>其实，上面那个电路就是一个反相施密特触发器加上一个电容和电阻，故也可以直接使用施密特触发器来构造松弛振荡器：</p><p><img src="https://pic.gaomf.store/20170404175130.png-width600" alt=""></p><p>这两个电路原理基本完全一样，其实所有的多谐振荡器原理都差不多，比如经典的555振荡电路，都是利用比较器的滞回特性，配合电容的周期性充放电实现振荡的。</p><hr><blockquote><p>参考资料：<br><a href="https://en.wikipedia.org/wiki/Relaxation_oscillator" target="_blank" rel="noopener">Relaxation oscillator</a><br><a href="https://courses.engr.illinois.edu/ece110/content/labs/Modules/TheRelaxationOscillator_v2.pdf" target="_blank" rel="noopener">The Relaxation Oscillator</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对电容充放电过程的理解</title>
      <link href="/2017/04/04/Capacity_Charge/"/>
      <url>/2017/04/04/Capacity_Charge/</url>
      
        <content type="html"><![CDATA[<p>很多年前就学过电容的性质了，之后也知道了如何快速写出时域上电容充放电过程的表达式，不过好长时间不用又忘了……今天又捡起来回忆了一下，在此总结记录一下。</p><a id="more"></a><p>理想电容的基本性质很简单：</p><p>$$i=C\frac{\mathrm{d} u}{\mathrm{dt}}$$</p><p>从线性系统的角度来看，这就是一个一阶微分系统，所以对电容的分析其实可以直接用于其他类似系统的，比如电感等。</p><p>一个基本的<a href="https://zh.wikipedia.org/wiki/RC%E9%9B%BB%E8%B7%AF" target="_blank" rel="noopener">RC电路</a>，如果在时域列微分方程，大概是这样的：</p><p>$$C\frac{\mathrm{d} u}{\mathrm{dt}}+\frac{u}{R}=0$$</p><p>最早学电路的时候，都是叫我们直接求解这个微分方程的，然后就结束了，这其实并没有理解到问题的实质，我们不可能也不需要在分析每个电路的时候都去解微分方程的。之后学到了信号与系统，还有线性系统理论，从s域的角度对此问题有了更好的理解，其实在s域中，可以把电容电感当成和电阻一样的东西进行分析的，串联并联都很简单，就比如RC电路的传递函数是这样的：</p><p>$$\frac{1}{RCs+1}$$</p><p>不过这依然不能直接得出时域性质，求解反拉普拉斯变换也很麻烦的，而且复杂点的还不一定求得出来……</p><p>MIT的<a href="http://open.163.com/special/opencourse/circuits.html" target="_blank" rel="noopener">电路与电子学</a>真的堪称基本电路课程中最好的，虽然从所谓的“深度”上看，远远不如国内的很多教材和课程，不过其中蕴含的思想极为深刻而实用，多少年前看完至今仍然受益匪浅啊……</p><p>回到RC电路上来，在MIT的公开课中，Agarwal教授给出了一种很快捷的方法可以直接写出各种一阶系统的时域响应。我们知道，无论是通过求解微分方程还是进行反拉普拉斯变换，任何一阶系统在时域的表达式都是<code>exp()</code>形式的，即都有这么一项：</p><p>$$\mathrm{e}^{-\frac{t}{\tau}}$$</p><p>上式必然是负指数形式的，否则系统不收敛。$\tau$就是所谓的时间常数，从拉氏变换中可以很容易的找出这一项来。现在有意思的地方来了，任意一阶系统的时域响应其实都可以写成以下形式的：</p><p>$$u(t)=A+B\mathrm{e}^{-\frac{t}{\tau}}$$</p><p>其中$A$、$B$是两个待定系数，根据直觉，我们可以很容易的确定这两个系数，当$t\rightarrow+\infty$时，后一项趋于0，故$A$就是系统的稳态解，而当$t=0$时，指数项等于1，故$A+B$就是系统的初始状态。根据这两个状态就可以写出完整的表达式了<del>这对于电容有初始电压时进行充电的过程尤为方便</del></p><p>上面的做法也许不那么严谨，不过的确是行之有效的。我们也可以从另一个角度来严谨的看这一问题，在线性系统理论中我们知道，LTI系统的响应可以分解为两部分，零输入响应和零状态响应，系统的完整响应就是二者的叠加。对于一阶系统来说，零输入响应就类似电容的放电过程：</p><p>$$u(t)=V\mathrm{e}^{-\frac{t}{\tau}}$$</p><p>而零状态响应就对应电容的充电过程：</p><p>$$u(t)=V(1-\mathrm{e}^{-\frac{t}{\tau}})$$</p><p>二者的叠加，化简一下不就成上面那个简单的式子了么~</p><p>上面是以电容充放电为例分析了以下，然而这显然不局限于电容的充放电，所有的一阶LTI系统都可以用这种方法快速确定其时域响应<del>这就是Agarwal教授所谓的工程师的直觉</del></p>]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>纽扣电池型号总结</title>
      <link href="/2017/04/03/Button_Cell/"/>
      <url>/2017/04/03/Button_Cell/</url>
      
        <content type="html"><![CDATA[<p>纽扣电池型号很多，而且命名也不是特别规范，这里选择其中相对较有规律的一些总结一下。</p><a id="more"></a><p>纽扣电池的型号可以分解成几个部分，逐部分介绍一下。</p><h3 id="串联节数"><a href="#串联节数" class="headerlink" title="串联节数"></a>串联节数</h3><p>如果第一位是数字，代表若干节电池串联，如4LR44表示内部是4节LR44串联。</p><h3 id="电池类型"><a href="#电池类型" class="headerlink" title="电池类型"></a>电池类型</h3><p>第一位字母代表电池的化学组成，这是型号中最统一的部分，也经常是最有价值的部分。</p><table><thead><tr><th>代号</th><th>通用名</th><th>负极</th><th>电解液</th><th>正极</th><th>标称电压</th><th>截止电压</th></tr></thead><tbody><tr><td>C</td><td>锂锰电池</td><td>锂</td><td>非水系有机电解液</td><td>二氧化锰</td><td>3.0V</td><td>2.0V</td></tr><tr><td>B</td><td>锂氟化碳电池</td><td>锂</td><td>非水系有机电解液</td><td>氟化碳</td><td>3.0V</td><td>2.0V</td></tr><tr><td>G</td><td>锂氧化铜电池</td><td>锂</td><td>非水系有机电解液</td><td>氧化铜</td><td>1.5V</td><td>1.2V</td></tr><tr><td>L</td><td>碱性电池</td><td>锌</td><td>碱金属碳酸盐电解液</td><td>二氧化锰</td><td>1.5V</td><td>1.0V</td></tr><tr><td>S</td><td>氧化银电池</td><td>锌</td><td>碱金属碳酸盐电解液</td><td>氧化银</td><td>1.55V</td><td>1.2V</td></tr><tr><td>P</td><td>锌空气电池</td><td>锌</td><td>碱金属碳酸盐电解液</td><td>氧气</td><td>1.4V</td><td>1.2V</td></tr></tbody></table><p>以上是一些最常用的电池，当然也还有其他的电池，可查阅文末参考资料。</p><p>锂锰电池与锂氟化碳电池相比，锂锰电池的耐温性比较差，工作温度大概在-20℃<del>70℃，而锂氟化碳电池大概在-30℃</del>80℃，所以有时候又把锂氟化碳电池叫做所谓的高温电池。二者寿命和工作稳定性也不一样，一般认为锂锰电池的寿命和稳定性都要好一些，可以达到10年左右。</p><h3 id="电池形状"><a href="#电池形状" class="headerlink" title="电池形状"></a>电池形状</h3><p>第二位字母代表电池形状，一般纽扣电池都是圆的，用R表示。百度百科上也给出了个其他形状的代号，可供参考。</p><h3 id="电池尺寸"><a href="#电池尺寸" class="headerlink" title="电池尺寸"></a>电池尺寸</h3><p>最后几位数字表示尺寸，早期使用1~2位的流水号，如LR44，直径11.6mm，厚度5.4mm。新的编码方式是按照尺寸来编码，如CR2032表示直径20mm，厚度3.2mm。不过这只是粗略的大小，精确大小还需查阅具体标准。</p><hr><blockquote><p>参考资料：<br><a href="https://zh.wikipedia.org/wiki/%E9%88%95%E6%89%A3%E9%9B%BB%E6%B1%A0" target="_blank" rel="noopener">钮扣电池</a><br><a href="https://en.wikipedia.org/wiki/Button_cell" target="_blank" rel="noopener">Button cell</a><br><a href="http://baike.baidu.com/item/CR2032" target="_blank" rel="noopener">CR2032</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HW Component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVN常用命令</title>
      <link href="/2017/03/30/SVN/"/>
      <url>/2017/03/30/SVN/</url>
      
        <content type="html"><![CDATA[<p>本文总结一下常用的SVN命令，以便之后查阅。</p><a id="more"></a><h3 id="检出"><a href="#检出" class="headerlink" title="检出"></a>检出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn checkout [URL] --username [username]</span><br><span class="line">svn co [URL] --username [username]</span><br></pre></td></tr></table></figure><p>其中<code>[URL]</code>是服务器上的路径，如<code>svn://xxxx.com/repo</code>，此命令会把服务器上的内容在<strong>当前</strong>本地目录中检出，<code>co</code>是<code>checkout</code>的简写。使用<code>--username</code>参数附加用户名，之后会提示输入密码。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn update [PATH]</span><br><span class="line">svn up [PATH]</span><br></pre></td></tr></table></figure><p>使用远程版本库中的文件更新本地版本库及工作副本，可以使用<code>[PATH]</code>指定更新哪个路径，如不指定的话，递归的更新<strong>当前目录及其子目录</strong>。会输出更新条目的状态：</p><ul><li>A : 已将一个文件添加到工作副本中</li><li>U : 已更新工作副本中的一个文件</li><li>D : 已从工作副本中删除一个文件</li><li>R : 已替换工作副本中的一个文件</li><li>G : 已成功合并了一个文件</li><li>C : 一个文件已合并了,但必须手动解决冲突</li></ul><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn list [-v] [PATH]</span><br></pre></td></tr></table></figure><p>上述<code>svn update</code>命令会直接更新当前工作副本，若需要先确定一下哪些文件有更改了，可使用<code>svn list -v</code>命令，会列出远程版本库<code>[PATH]</code>下各文件的版本号，修改人，修改日期等信息，若没有<code>-v</code>参数则只有文件名。</p><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn status [-v] [PATH]</span><br><span class="line">svn st [-v] [PATH]</span><br></pre></td></tr></table></figure><p>查看工作副本的状态，如省略<code>[PATH]</code>的话，显示<strong>当前路径</strong>的状态。与版本库中相同则不显示，<code>?</code>代表不在版本库中，<code>D</code>代表删除，<code>M</code>代表有修改，<code>A</code>代表添加，<code>C</code>代表有冲突。如果附加上<code>[-v]</code>参数，会列出所有文件，第一列表示状态，第二列是版本号，第三和第四列是此文件最后一次修改的版本号及修改人。</p><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn info</span><br></pre></td></tr></table></figure><p>查看SVN仓库的相关信息，如URL、上次修改时间等。</p><h3 id="添加、删除及提交"><a href="#添加、删除及提交" class="headerlink" title="添加、删除及提交"></a>添加、删除及提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn add [PATH]</span><br></pre></td></tr></table></figure><p>第一次在工作目录中创建并编辑新文件后，需要使用此命令将此文件添加到版本库中，<code>[PATH]</code>可以是一个文件也可以是一个目录，可配合<code>*</code>通配符使用。</p><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn delete [PATH]</span><br><span class="line">svn rm [PATH]</span><br></pre></td></tr></table></figure><p>如果需要将版本库中的某个文件或目录删除，使用此命令，直接用<code>rm</code>删除那个文件是无效的，下次<code>update</code>的时候又会回来的。</p><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn commit -m <span class="string">""</span></span><br><span class="line">svn ci -m <span class="string">""</span></span><br></pre></td></tr></table></figure><p>修改、添加、删除文件后，仅仅是影响了本地副本，还没有将其提交到版本库中，使用此命令提交更改。注意，附加参数<code>-m</code>是这次提交的说明，这是必须的，可以为空<code>&quot;&quot;</code>，但不能没有。另外，SVN与Git不同，不能只更新本地版本库而不将其上传到远程版本库上。</p><h3 id="撤销更改"><a href="#撤销更改" class="headerlink" title="撤销更改"></a>撤销更改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn revert [-R] [filename]</span><br></pre></td></tr></table></figure><p>对本地副本进行了某些修改，但还没有使用<code>svn ci</code>提交之前，若想丢弃这些更改，可以使用此命令。<code>filename</code>可以是一个目录，此时需加上<code>-R</code>参数递归的进行处理。</p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn <span class="built_in">log</span> [-v] [-l [N]]</span><br></pre></td></tr></table></figure><p>列出提交日志，使用<code>-l [N]</code>参数指定只列出最近<code>N</code>次的提交记录，否则列出全部记录；<code>-v</code>参数会列出每次提交的具体条目细节。</p><h3 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn diff [-r m[:n]] [PATH]</span><br></pre></td></tr></table></figure><p>比较两个版本间的差异，使用<code>-r m:n</code>参数比较版本<code>m</code>和版本<code>n</code>之间的差异，使用<code>-r m</code>参数比较当前工作副本的文件和版本<code>m</code>之间的差异，不附加此参数比较当前工作副本文件和版本库中最新版本间的差异。</p><p>SVN默认的diff是没有颜色的，看起来很不方便，可以通过安装<code>colordiff</code>来解决这一问题：</p><blockquote><p><a href="http://www.cnblogs.com/pylemon/archive/2012/06/29/2569940.html" target="_blank" rel="noopener">在ubuntu下，给 svn diff 一点颜色</a></p></blockquote><h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn merge [-r [n]] [PATH]</span><br></pre></td></tr></table></figure><p>实际使用时，先用<code>svn log</code>命令找出需要回滚到的版本，必要时使用<code>svn diff</code>进行比较确认；之后使用<code>svn merge -r n</code>命令将版本<code>n</code>合并到当前副本，此处的<code>[PATH]</code>可以是文件也可以是目录，若省略依然代表当前目录；最后，如果要确认这次回滚，还要使用<code>svn commit</code>将其重新提交到版本库中。</p><h3 id="加锁、解锁"><a href="#加锁、解锁" class="headerlink" title="加锁、解锁"></a>加锁、解锁</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn lock -m <span class="string">""</span> [--force] [PATH]</span><br><span class="line">svn unlock [PATH]</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考资料：<br><a href="https://www.open.collab.net/scdocs/ddUsingSVN_command-line.html.zh-cn" target="_blank" rel="noopener">使用命令行 Subversion 访问项目源文件</a><br><a href="http://blog.csdn.net/ithomer/article/details/6187464" target="_blank" rel="noopener">SVN常用命令</a><br><a href="http://blog.csdn.net/rangf/article/details/7408230" target="_blank" rel="noopener">SVN：取消对代码的修改</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SVN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++生成随机数</title>
      <link href="/2017/03/22/C++_Random/"/>
      <url>/2017/03/22/C++_Random/</url>
      
        <content type="html"><![CDATA[<p>之前写过一篇<a href="/2015/11/16/C%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/">C语言生成随机数</a>，其中生成随机数的方法自然也可用于C++中，不过C++ 11扩展了生成随机数的方法，我们可以有更多更好的选择了。</p><a id="more"></a><p>随机数的相关类声明都位于<code>&lt;random&gt;</code>头文件中，完整说明可参考：<a href="http://www.cplusplus.com/reference/random/" target="_blank" rel="noopener">random</a>，此处选择一些常用的总结一下。文末参考文献中那两篇知乎讨论很有趣，介绍了各种关于随机数的知识，很值得一读。</p><h2 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="随机数生成器"></a>随机数生成器</h2><p>一共提供了3种算法的生成器：线性同余法（LCG）、梅森旋转法、Lagged Fibonacci generator（LFG），其中梅森旋转法据说是最好的伪随机数生成算法，在C++中的具体实现类为<code>std::mt19937</code>和<code>std::mt19937_64</code>，前者是32位的，后者是64位的。</p><h2 id="非确定性随机数生成设备"><a href="#非确定性随机数生成设备" class="headerlink" title="非确定性随机数生成设备"></a>非确定性随机数生成设备</h2><p>上面几个随机数生成器的本质都是从一个种子开始，使用某个递推方法生成伪随机数序列，其实还有种随机数生成策略就是利用物理世界中的各种噪声，以此产生所谓的真随机数。<code>std::random_device</code>就是这样一种机制，具体实现方法Linux和Windows不相同，以Linux为例就是读取<code>/dev/urandom</code>设备的输出得到的。这个设备中有一个容纳来自各种设备驱动噪声数据的熵池，具体可参考：</p><blockquote><p><a href="https://zh.wikipedia.org/wiki//dev/random" target="_blank" rel="noopener">/dev/random</a></p></blockquote><p><code>/dev/urandom</code>是<code>/dev/random</code>的非阻塞版本，会重复利用熵池，保证在熵池为空的时候也会有输出，这以降低随机数可靠性为代价提高了其生成速度。</p><h2 id="生成特定分布的随机数"><a href="#生成特定分布的随机数" class="headerlink" title="生成特定分布的随机数"></a>生成特定分布的随机数</h2><p>在C语言中，要生成特定分布的随机数并不容易，不过在C++中这就很简单了，C++中提供了各种常用分布的实现，直接调用就可以了。比如最常用的均匀分布的整数：<code>std::uniform_int_distribution</code>；均匀分布的小数：<code>std::uniform_real_distribution</code>；正态分布：<code>std::normal_distribution</code>等。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>最后举几个实际的例子来说明具体用法。</p><p>直接使用<code>random_device</code>的输出作为随机数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::random_device rd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rd() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法速度较慢，所以一般并不直接使用。</p><hr><p>以<code>random_device</code>的输出为初始种子，使用梅森旋转法生成[0,99]范围内的整数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::random_device rd;</span><br><span class="line">    <span class="built_in">std</span>::mt19937 mt(rd());</span><br><span class="line">    <span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; dist(<span class="number">0</span>, <span class="number">99</span>);</span><br><span class="line">    <span class="keyword">auto</span> dice = <span class="built_in">std</span>::bind(dist, mt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dice() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>std::bind()</code>是为了让之后调用起来更方便些。此方法就是生成某个区间内均匀分布的整数随机数最常用的方法了，注意区间两端都是闭区间。</p><hr><p>以<code>random_device</code>的输出为初始种子，使用梅森旋转法生成[0.0, 1.0)范围内的小数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::random_device rd;</span><br><span class="line">    <span class="built_in">std</span>::mt19937 mt(rd());</span><br><span class="line">    <span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; dist(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">auto</span> dice = <span class="built_in">std</span>::bind(dist, mt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dice() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成[0, 1)区间内任意小数最常用的方法，注意这里是左闭右开区间，不包含1.0的。</p><hr><blockquote><p>参考资料：<br><a href="http://www.cnblogs.com/egmkang/archive/2012/09/06/2673253.html" target="_blank" rel="noopener">C++11带来的随机数生成器</a><br><a href="https://www.zhihu.com/question/24297923" target="_blank" rel="noopener">C++ 如何生成大随机数？</a><br><a href="https://www.zhihu.com/question/20423025" target="_blank" rel="noopener">电脑取随机数是什么原理，是真正的随机数吗？</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Number Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH证书登录总结</title>
      <link href="/2017/03/01/SSH_Authentication/"/>
      <url>/2017/03/01/SSH_Authentication/</url>
      
        <content type="html"><![CDATA[<p>远程登录Linux服务器一般都是通过SSH方式，除此之外，像Git同步等其他一些操作也可通过SSH进行，默认情况下SSH是通过用户名和密码来进行用户身份验证的，这样密码太复杂自己输入不方便，太短了不安全，故更好的方式是通过证书进行身份验证和登录。</p><a id="more"></a><h2 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h2><p>使用<code>ssh-keygen</code>工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen</span><br><span class="line"></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/gmf/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /home/gmf/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/gmf/.ssh/id_rsa.pub.</span><br></pre></td></tr></table></figure><p>直接使用<code>ssh-keygen</code>而不附加任何参数相当于<code>ssh-keygen -t rsa -b 2048</code>，即RSA类型2048字节的公钥/私钥对。<code>ssh-keygen</code>还可以附加很多参数，可以参考文末参考资料。</p><p><code>Enter passphrase</code>处可以输入一个秘钥文件的密码，如果设置了密码的话之后每次访问都要输入密码。</p><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>一般是<code>/etc/ssh/sshd_config</code>文件，只需要设置以下几项启用秘钥登录就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure><blockquote><p>Update 2019-07-13:</p><p>在CentOS 7.4及以上版本中，没有<code>RSAAuthentication</code>这一项配置了，也不需要去配置这个，可参考：</p><p><a href="https://www.cnblogs.com/Leroscox/p/9627809.html" target="_blank" rel="noopener">CentOS7.4配置SSH登录密码与密钥身份验证踩坑</a></p></blockquote><p>在<strong>保证可以用证书正常登录后</strong>，可以禁用密码登录以提高安全性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure><p>以上几项设置默认情况下都是注释，把开头的注释符号去掉即可。其余还有一些和安全性有关的设置，此处就省略了，可以根据文件中的注释说明进行修改，也可参考文末资料。</p><h3 id="添加用户公钥"><a href="#添加用户公钥" class="headerlink" title="添加用户公钥"></a>添加用户公钥</h3><p>受信任的用户公钥记录在<code>~/.ssh/authorized_keys</code>文件中，服务器上每一个用户都有自己的<code>authorized_keys</code>文件，在使用SSH登录时，登录用户是哪一个就会去这个用户的用户目录中查找<code>~/.ssh/authorized_keys</code>文件，比如使用<code>ssh root@192.168.1.1</code>登录时，SSH服务器端就会使用<code>/root/.ssh/authorized_keys</code>文件中的公钥。</p><p>所以我们要将之前生成的公钥添加到需要登录的用户目录下，如允许使用多个用户身份登录，需要分别添加公钥。</p><p>添加方法有好几种，可以手动用vim打开此文件添加（如果不存在新建一个即可），也可先把之前生成的<code>id_rsa.pub</code>文件传到服务器上，使用以下命令添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>此外，似乎还可以直接使用<code>ssh-copy-id</code>工具上传：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id user@host</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>~/.ssh</code>目录及<code>~/.ssh/authorized_keys</code>文件<strong>必须是</strong>700及600权限的，如果不是的话要先修改一下，否则之后ssh客户端会出于安全因素拒绝使用此证书文件。</p><h3 id="重启sshd服务"><a href="#重启sshd服务" class="headerlink" title="重启sshd服务"></a>重启sshd服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><p>这时就可以在客户机上使用<code>ssh user@host</code>的方式登录了，默认会使用位于<strong>当前用户目录下的</strong><code>~/.ssh/id_rsa</code>文件作为私钥。不过还可以在客户端上进行下配置简化这一命令。</p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>修改<code>~/.ssh/config</code>文件（若不存在则新建），按以下格式添加Host配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host myserver</span><br><span class="line">User &lt;user_name&gt;</span><br><span class="line">Hostname &lt;server_name&gt;</span><br><span class="line">Port &lt;port&gt;</span><br><span class="line">IdentityFile &lt;private_key_path&gt;</span><br></pre></td></tr></table></figure><p><code>Port</code>可以省略，此时使用默认的22端口。</p><p>配置好后输入<code>ssh myserver</code>即等价于<code>ssh -i &lt;private_key_path&gt; &lt;user_name&gt;@&lt;server_name&gt; -p &lt;port&gt;</code>。这样用一条简单的命令就可以实现自动调用指定的私钥文件以特定的用户名和端口登录远程服务器的目的了，不同的服务器可以使用不同配置，十分方便灵活。</p><hr><blockquote><p>参考资料：<br><a href="http://skypegnu1.blog.51cto.com/8991766/1641064" target="_blank" rel="noopener">SSH 原理和基本使用：ssh 安全配置 以及ssh key 认证登录</a><br><a href="https://cnzhx.net/blog/linux-server-ssh-key-auth-configuration/" target="_blank" rel="noopener">配置 SSH 服务以使用证书登录 Linux 服务器</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu减小swap分区大小的方法</title>
      <link href="/2017/02/28/Ubuntu_Reduce_Swap/"/>
      <url>/2017/02/28/Ubuntu_Reduce_Swap/</url>
      
        <content type="html"><![CDATA[<p>这几天在新买的服务器上装上了Ubuntu Server 14.04，然而安装系统时没注意swap分区大小设置，导致swap分区占用了很大的磁盘空间，因为服务器本身的内存就很大，所以显然不需要分配这么多swap空间，在网上搜索一番找到了减小swap空间的方法，记录于此。</p><a id="more"></a><h2 id="定位swap分区"><a href="#定位swap分区" class="headerlink" title="定位swap分区"></a>定位swap分区</h2><p>首先要确定swap分区的位置才能进行之后的调整操作，可以简单的使用<code>free -h</code>命令查看当前内存及swap空间的使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># free -h</span><br><span class="line"></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           15G       1.5G        14G       1.0M       160M       1.0G</span><br><span class="line">-/+ buffers/cache:       282M        15G</span><br><span class="line">Swap:         1.0G         0B       1.0G</span><br></pre></td></tr></table></figure><p>可以看到swap空间有1G，不过这是收缩了一次后的结果，最初的swap空间是16G……</p><p><code>free</code>命令只显示了swap分区的大小，为了找到swap分区所在位置，需要具体查看一下分区情况。因为Ubuntu Server 14.04安装时默认使用了GPT分区形式，所以应该使用<code>parted -l</code>而不是<code>fdisk -l</code>来查看分区情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># parted -l</span><br><span class="line"></span><br><span class="line">Model: ATA EEKSATA60G1702 (scsi)</span><br><span class="line">Disk /dev/sda: 60.0GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name                  Flags</span><br><span class="line"> 1      1049kB  538MB   537MB   fat32        EFI System Partition  boot</span><br><span class="line"> 2      538MB   794MB   256MB   ext2</span><br><span class="line"> 3      794MB   60.0GB  59.2GB                                     lvm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Model: Linux device-mapper (linear) (dm)</span><br><span class="line">Disk /dev/mapper/Xeon--vg-root: 58.2GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: loop</span><br><span class="line"></span><br><span class="line">Number  Start  End     Size    File system  Flags</span><br><span class="line"> 1      0.00B  58.2GB  58.2GB  ext4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Model: Linux device-mapper (linear) (dm)</span><br><span class="line">Disk /dev/mapper/Xeon--vg-swap_1: 1065MB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: loop</span><br><span class="line"></span><br><span class="line">Number  Start  End     Size    File system     Flags</span><br><span class="line"> 1      0.00B  1065MB  1065MB  linux-swap(v1)</span><br></pre></td></tr></table></figure><p>从上面的输出结果中可以看到，硬盘上只有3个物理分区，前两个是系统启动引导时用的，可以忽略，主分区就只有一个，并没有单独为swap创建一个分区。Ubuntu系统在这里采用了LVM逻辑卷管理机制（Logical Volume Manager）进行磁盘空间管理，关于LVM可进一步阅读以下文章：</p><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/l-lpic1-v3-102-1/" target="_blank" rel="noopener">学习 Linux，101: 硬盘布局</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-lvm2/index.html" target="_blank" rel="noopener">逻辑卷管理</a><br><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Logical_Volume_Manager_Administration/lv_overview.html" target="_blank" rel="noopener">LVM Logical Volume</a></p></blockquote><p>使用<code>pvdisplay</code>命令列出所有物理卷（PVs）属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># pvdisplay</span><br><span class="line"></span><br><span class="line">  --- Physical volume ---</span><br><span class="line">  PV Name               /dev/sda3</span><br><span class="line">  VG Name               Xeon-vg</span><br><span class="line">  PV Size               55.16 GiB / not usable 4.00 MiB</span><br><span class="line">  Allocatable           yes (but full)</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              14120</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          14120</span><br><span class="line">  PV UUID               lHbbtD-GhR7-5Ie9-OQnQ-9IYE-Y0cV-HDdZtZ</span><br></pre></td></tr></table></figure><p>可以看到，只有一个物理卷<code>/dev/sda3</code>，再使用<code>vgdisplay</code>命令列出卷组（VGs）属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># vgdisplay</span><br><span class="line"></span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               Xeon-vg</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  6</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                2</span><br><span class="line">  Open LV               2</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               55.16 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              14120</span><br><span class="line">  Alloc PE / Size       14120 / 55.16 GiB</span><br><span class="line">  Free  PE / Size       0 / 0   </span><br><span class="line">  VG UUID               Wbc0FF-M7HR-Rzgf-4wf2-oNjB-J2KT-1Kwp0Z</span><br></pre></td></tr></table></figure><p>唯一一个卷组的名称叫做<code>Xeon-vg</code>（<code>Xeon</code>是主机名），最后用<code>lvdisplay</code>命令列出所有逻辑卷（LVs）属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># lvdisplay</span><br><span class="line"></span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/Xeon-vg/root</span><br><span class="line">  LV Name                root</span><br><span class="line">  VG Name                Xeon-vg</span><br><span class="line">  LV UUID                TO99bO-91qT-Zqeu-SsJ0-jFMo-30Kn-oVtGqd</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time Xeon, 2017-02-27 07:01:36 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 1</span><br><span class="line">  LV Size                54.16 GiB</span><br><span class="line">  Current LE             13866</span><br><span class="line">  Segments               2</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           252:0</span><br><span class="line">   </span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/Xeon-vg/swap_1</span><br><span class="line">  LV Name                swap_1</span><br><span class="line">  VG Name                Xeon-vg</span><br><span class="line">  LV UUID                Ig7xvr-scZ3-Opqe-d1Ww-Z0aT-I4B1-9h2sD4</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time Xeon, 2017-02-27 07:01:36 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 2</span><br><span class="line">  LV Size                1016.00 MiB</span><br><span class="line">  Current LE             254</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           252:1</span><br></pre></td></tr></table></figure><p>此处划分了两个逻辑卷，分别是<code>/dev/Xeon-vg/root</code>和<code>/dev/Xeon-vg/swap_1</code>，然而与<code>parted -l</code>的输出结果进行对比，会发现逻辑卷的名字并不相同，在<code>parted -l</code>的输出结果中使用的是<code>/dev/mapper/Xeon--vg-root</code>和<code>/dev/mapper/Xeon--vg-swap_1</code>，查看这几个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ll /dev/Xeon-vg/</span><br><span class="line"></span><br><span class="line">lrwxrwxrwx  1 root root    7  2月 27 21:09 root -&gt; ../dm-0</span><br><span class="line">lrwxrwxrwx  1 root root    7  2月 28 15:03 swap_1 -&gt; ../dm-1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ll /dev/mapper/</span><br><span class="line"></span><br><span class="line">lrwxrwxrwx  1 root root       7  2月 27 21:09 Xeon--vg-root -&gt; ../dm-0</span><br><span class="line">lrwxrwxrwx  1 root root       7  2月 28 15:03 Xeon--vg-swap_1 -&gt; ../dm-1</span><br></pre></td></tr></table></figure><p>它们都通过符号链接指向了同一个地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ll /dev | grep dm-</span><br><span class="line"></span><br><span class="line">brw-rw----  1 root disk    252,   0  2月 27 21:09 dm-0</span><br><span class="line">brw-rw----  1 root disk    252,   1  2月 28 15:03 dm-1</span><br></pre></td></tr></table></figure><p>事实上这里用到的是Linux内核中的Device Mapper机制，设备名称<code>dm</code>就是<code>Device Mapper</code>之意。Device Mapper机制是LVM依赖的基础技术，用于实现物理设备到逻辑设备的映射，详细说明可进一步阅读以下文章：</p><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/l-devmapper/index.html" target="_blank" rel="noopener">Linux 内核中的 Device Mapper 机制</a><br><a href="http://www.lxway.net/884499696.html" target="_blank" rel="noopener">flashcache中应用device mapper机制</a><br><a href="http://coolshell.cn/articles/17200.html" target="_blank" rel="noopener">DOCKER基础技术：DEVICEMAPPER</a></p></blockquote><p>另一个需要注意的问题是，尽管以上几个文件是通过符号链接联系起来的，不过它们并不等价，在使用<code>lvm</code>系列命令操作逻辑卷时，应该使用<code>/dev/{VG}/{LV}</code>这个路径，直接使用<code>/dev/dm-*</code>会出错。</p><p>通过以上操作，我们已经找到swap文件对应的逻辑卷位置了，下面就来减小其大小。</p><h2 id="减小Swap分区"><a href="#减小Swap分区" class="headerlink" title="减小Swap分区"></a>减小Swap分区</h2><p>先用<code>swapoff</code>命令关闭交换分区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># swapoff /dev/Xeon-vg/swap_1</span><br></pre></td></tr></table></figure><p>检查下是否关闭成功了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># free -h</span><br><span class="line"></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           15G       1.4G        14G       1.0M       176M       971M</span><br><span class="line">-/+ buffers/cache:     299212   16104504</span><br><span class="line">Swap:            0          0          0</span><br></pre></td></tr></table></figure><p>可以看到swap分区的容量已经是0了，这时就可以通过<code>lvreduce</code>命令来收缩<code>Swap_1</code>这个逻辑卷的大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># lvreduce -L 512M /dev/Xeon-vg/swap_1 </span><br><span class="line"></span><br><span class="line">  WARNING: Reducing active logical volume to 512.00 MiB</span><br><span class="line">  THIS MAY DESTROY YOUR DATA (filesystem etc.)</span><br><span class="line">Do you really want to reduce swap_1? [y/n]: y</span><br><span class="line">  Reducing logical volume swap_1 to 512.00 MiB</span><br><span class="line">  Logical volume swap_1 successfully resized</span><br></pre></td></tr></table></figure><p><code>-L 512M</code>代表收缩至512M，更多用法可用<code>man</code>查询。之后要把新的逻辑卷重新设置为swap分区并用<code>swapon</code>命令开启之：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># mkswap /dev/Xeon-vg/swap_1</span><br><span class="line"> </span><br><span class="line">mkswap: /dev/Xeon-vg/swap_1: warning: don&apos;t erase bootbits sectors</span><br><span class="line">        on whole disk. Use -f to force.</span><br><span class="line">Setting up swapspace version 1, size = 524284 KiB</span><br><span class="line">no label, UUID=142b1c26-9e3f-45c4-afff-b0cce3c9448e</span><br><span class="line"></span><br><span class="line"># swapon /dev/Xeon-vg/swap_1</span><br></pre></td></tr></table></figure><p>最后检查下swap分区是否真的变小了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># free -h</span><br><span class="line"></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           15G       1.4G        14G       1.0M       176M       971M</span><br><span class="line">-/+ buffers/cache:       294M        15G</span><br><span class="line">Swap:         511M         0B       511M</span><br></pre></td></tr></table></figure><p>不过此时回收的空间成为了闲置的自由空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># vgdisplay</span><br><span class="line"></span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               Xeon-vg</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  7</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                2</span><br><span class="line">  Open LV               2</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               55.16 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              14120</span><br><span class="line">  Alloc PE / Size       13994 / 54.66 GiB</span><br><span class="line">  Free  PE / Size       126 / 504.00 MiB</span><br><span class="line">  VG UUID               Wbc0FF-M7HR-Rzgf-4wf2-oNjB-J2KT-1Kwp0Z</span><br></pre></td></tr></table></figure><p>注意其中的<code>Free  PE / Size</code>，可以看到还有504M的未分配闲置空间，下一步就是要把这部分空间扩展到<code>root</code>逻辑卷中。</p><h2 id="扩展root分区"><a href="#扩展root分区" class="headerlink" title="扩展root分区"></a>扩展root分区</h2><p>对于Ext4文件系统，内核是支持在线扩容的，直接使用<code>lvextend</code>命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># lvextend -l +100%FREE /dev/Xeon-vg/root </span><br><span class="line"></span><br><span class="line">  Extending logical volume root to 54.66 GiB</span><br><span class="line">  Logical volume root successfully resized</span><br></pre></td></tr></table></figure><p><code>-l +100%FREE</code>表示扩展所有剩余空间，需要注意的是，<code>-l</code>与<code>-L</code>是不同的，<code>-l</code>的单位是所谓的<code>logical extents</code>，也就是上面<code>vgdisplay</code>命令显示出来的<code>PE Size</code>，这就是LVM中容量调整的一个基本单位；而<code>-L</code>的单位是传统的字节，<code>-L</code>选项不能搭配<code>%100</code>之类的形式使用。命令的详细用法还是参考<code>man</code>的说明。</p><p>逻辑卷的容量和文件系统的容量并没有直接关系，故最后还需要对文件系统进行在线扩容，对于Ext文件系统可使用<code>resize2fs</code>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># resize2fs /dev/Xeon-vg/root </span><br><span class="line"></span><br><span class="line">resize2fs 1.42.9 (4-Feb-2014)</span><br><span class="line">Filesystem at /dev/Xeon-vg/root is mounted on /; on-line resizing required</span><br><span class="line">old_desc_blocks = 4, new_desc_blocks = 4</span><br><span class="line">The filesystem on /dev/Xeon-vg/root is now 14327808 blocks long.</span><br></pre></td></tr></table></figure><h2 id="调整Swap分区交换策略"><a href="#调整Swap分区交换策略" class="headerlink" title="调整Swap分区交换策略"></a>调整Swap分区交换策略</h2><p>Linux系统并不是在内存全部使用完之后再使用swap空间的，内核会自动判断是否该使用swap空间，可以通过很多参数控制这一行为，可参考以下文章：</p><blockquote><p><a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/s-memory-tunables.html" target="_blank" rel="noopener">Tuning Virtual Memory</a></p></blockquote><p>其中最重要的一个参数叫做<code>swappiness</code>，取值在0~100之间，表示的是内核使用swap空间的频率策略，值越大内核越倾向于使用交换空间。目前内存很大而swap空间很小，故可以尽量不去使用swap空间。要实现这一目的，将<code>swapiness</code>设置为0即可，这代表内核仅在内存快要用完时使用swap空间，具体解释可参考：</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Swappiness" target="_blank" rel="noopener">Swappiness</a></p></blockquote><p>设置方法也很简单，使用<code>sysctl</code>命令可以临时修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sysctl -w vm.swappiness=0</span><br></pre></td></tr></table></figure><p>要永久修改的话，在<code>/etc/sysctl.conf</code>文件中添加<code>vm.swappiness=0</code>即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo vm.swappiness=0 &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>除了用<code>sysctl</code>命令外，还可用以下方法查看当前<code>swappiness</code>的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/sys/vm/swappiness</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考资料：<br><a href="https://segmentfault.com/a/1190000007813965" target="_blank" rel="noopener">linux基础命令介绍十二：磁盘与文件系统</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Linux </tag>
            
            <tag> File System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于未来的迷茫</title>
      <link href="/2017/02/27/Future_Hesitate/"/>
      <url>/2017/02/27/Future_Hesitate/</url>
      
        <content type="html"><![CDATA[<p>返乡半月有余，闲暇时反思过去一年半的研究生生活，不由感慨时光飞逝，如白驹过隙。昔时子于川上曰，逝者如斯，不舍昼夜，子诚不欺余。再想到半年后就要找工作了，而过去一年多似乎自己的水平并没有太大的提高，未免心中忐忑难安，唯恐所图甚大，所行甚小……古语有云，士为知己者死，这才有两表酬三顾，一对足千秋之美名；才有报君黄金台上意，提携玉龙为君死之意气。然古往今来更多的是怀才不遇，功名难就，冠盖满京华，斯人独憔悴的落寞……呜呼，不知未来在等待我的会是什么呢？月明星稀，乌鹊南飞，绕树三匝，何枝可依？</p>]]></content>
      
      
      <categories>
          
          <category> 人生之思 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树算法</title>
      <link href="/2017/02/22/Minimum_Spanning_Tree/"/>
      <url>/2017/02/22/Minimum_Spanning_Tree/</url>
      
        <content type="html"><![CDATA[<p>最小生成树是指在一个图中，由连接所有顶点的边构成的权值之和最小的树，求最小生成树的算法主要有Prim算法及Kruskal算法，此处介绍Prim算法的基本原理。</p><a id="more"></a><p>Prim算法是一种贪心算法，不过可以证明，此算法得到的必定是全局最优解。Prim算法的基本思路如下：</p><ol><li>将图中的所有顶点分为两个集合，<code>Known</code>及<code>Unknown</code>，初始时<strong>任意选择</strong>一个顶点放置在<code>Known</code>中，其余顶点位于<code>Unknown</code>中，算法的目标是将<code>Unknown</code>中的所有顶点移至<code>Known</code>中；</li><li>选择一条边，这条边连接的两个顶点一个位于<code>Known</code>中，另一个位于<code>Unknown</code>中，且这条边的权值是所有满足条件的边中最小的；</li><li>将这条边添加到最小生成树中，并将其连接的那个位于<code>Unknown</code>集合中的顶点移至<code>Known</code>中；</li><li>重复以上两步，直至<code>Unknown</code>集合为空；</li></ol><p>算法图示：</p><p><img src="https://pic.gaomf.store/Prim%E5%9B%BE%E7%A4%BA.png" alt=""></p><p>Prim算法的过程与<a href="http://gaomf.cn/2017/02/03/Shortest_Path/">Dijkstra算法</a>很相像，故二者的程序结构也很类似。</p><p>在使用邻接表及二叉堆实现时，Prim算法的时间复杂度是O(|E|log|V|)，需要注意的是，无论对于稀疏图还是稠密图，这都是一个最优的算法复杂度。Kruskal算法的复杂度是O(|E|log|E|)，对于所有连通图来说都有|E|&gt;=|V|-1，所以可以得出结论，<strong>Prim算法在时间复杂度上无论是对于稀疏图还是稠密图来说都是最优的，优于Kruskal算法</strong>。不过其最大缺点就是在<strong>使用二叉堆时空间复杂度会极大</strong>，对于超稠密图就很不合适了。具体定量比较可参考：</p><blockquote><p><a href="http://blog.csdn.net/gykimo/article/details/8538275" target="_blank" rel="noopener">Prim、Kruskal、Prim+Heap算法效率实测</a></p></blockquote><p>算法的实现代码有空再补上吧……</p><hr><blockquote><p>参考资料：<br><a href="http://mindlee.com/2011/11/16/minimum-spanning-trees/" target="_blank" rel="noopener">最小生成树(Minimum Spanning Trees)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大流算法</title>
      <link href="/2017/02/20/Maximum_Flow_Algorithm/"/>
      <url>/2017/02/20/Maximum_Flow_Algorithm/</url>
      
        <content type="html"><![CDATA[<p>最大流问题是指在一个有向图中，每条边的容量有限，求两点间能通过的最大流量。解决此问题常用Ford–Fulkerson方法，本文对此方法做一总结记录。</p><a id="more"></a><p>在最大流问题中，涉及到很多术语，如残留网络、增广路径等，本文不打算使用和介绍这些名词，想深入了解此问题的话可进一步阅读文末的参考资料，这里仅从编程使用的角度介绍算法实现方法。</p><p>Ford–Fulkerson方法的基本步骤很简单：</p><ol><li>在当前的图中寻找<strong>任意一条</strong>从源点到汇点的路径；</li><li>为这条路径添加一条反向路径；</li><li>重复以上两步，直至无法找到更多的路径为止。</li></ol><p>这个算法如此简单，很让人怀疑其正确性，不过，根据最大流与最小割定理，我们可以严格的证明：<strong>只要每一条边的容量都是有理数，Ford–Fulkerson方法肯定收敛于图的最大流，然而，若容量是无理数，算法不一定会收敛。</strong>证明步骤可以参考第二篇参考资料。</p><p>算法的执行过程可以参考这个<a href="http://rosulek.github.io/vamonos/demos/max-flow.html" target="_blank" rel="noopener">动画演示</a>。</p><p>此方法之所以称为Ford–Fulkerson方法而不是Ford–Fulkerson算法的原因在于，第一步寻找路径的过程可以使用很多不同的策略，这就可以衍生出各种不同的具体实现算法，其中最常用的一种是<strong>使用BFS广度优先搜索策略</strong>，这种算法称之为Edmonds-Karp算法。最后一篇参考资料中给出了一个实现代码，此处给出另一种封装更好一些的实现代码，实用邻接表实现。</p><hr><p>图的相关数据结构定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">path</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dst;</span><br><span class="line">    <span class="keyword">int</span> flow;</span><br><span class="line">&#125; path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">vertex</span> &#123;</span></span><br><span class="line">    <span class="built_in">list</span>&lt;path&gt; adjacency;<span class="comment">// 邻接表</span></span><br><span class="line">    <span class="keyword">bool</span> visited;<span class="comment">// BFS搜索记录</span></span><br><span class="line">    <span class="keyword">int</span> pre;<span class="comment">// 前一个节点</span></span><br><span class="line">    <span class="keyword">int</span> minflow;<span class="comment">// 当前路径流量</span></span><br><span class="line">&#125; vertex;</span><br></pre></td></tr></table></figure><p><code>FindPath()</code>函数使用BFS搜索<code>src</code>至<code>dst</code>之间的一条路径，并计算此条路径的流量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindPath</span><span class="params">(<span class="built_in">vector</span>&lt;vertex&gt; &amp; G, <span class="keyword">int</span> src, <span class="keyword">int</span> dst)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; buf;</span><br><span class="line">    buf.push_back(src);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!buf.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = buf.front();</span><br><span class="line">        buf.pop_front();</span><br><span class="line"></span><br><span class="line">        G[s].visited = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == dst)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新与G[s]节点相连的所有节点的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = G[s].adjacency.begin(); it != G[s].adjacency.end(); it++) &#123;</span><br><span class="line">            <span class="comment">// 未访问过且有剩余流量</span></span><br><span class="line">            <span class="keyword">if</span> (!G[it-&gt;dst].visited &amp;&amp; it-&gt;flow &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                G[it-&gt;dst].pre = s;</span><br><span class="line">                G[it-&gt;dst].minflow = it-&gt;flow &lt; G[s].minflow ? it-&gt;flow : G[s].minflow;</span><br><span class="line">                buf.push_back(it-&gt;dst);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AddFlow()</code>函数更新流量信息（减去正向流量并添加反向流量），返回值即为当前路径流量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AddFlow</span><span class="params">(<span class="built_in">vector</span>&lt;vertex&gt; &amp; G, <span class="keyword">int</span> src, <span class="keyword">int</span> dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = dst;</span><br><span class="line">    <span class="keyword">int</span> minflow = G[v].minflow;</span><br><span class="line">    <span class="keyword">while</span> (v != src) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = G[v].adjacency.begin(); it != G[v].adjacency.end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;dst == G[v].pre) &#123;</span><br><span class="line">                it-&gt;flow += minflow;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = G[G[v].pre].adjacency.begin(); it != G[G[v].pre].adjacency.end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;dst == v) &#123;</span><br><span class="line">                it-&gt;flow -= minflow;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v = G[v].pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minflow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GClear()</code>函数用于清除上一次BFS的中间数据，为下一次循环做好准备：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GClear</span><span class="params">(<span class="built_in">vector</span>&lt;vertex&gt; &amp; G)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = G.begin(); it != G.end(); it++) &#123;</span><br><span class="line">        it-&gt;visited = <span class="literal">false</span>;</span><br><span class="line">        it-&gt;minflow = INT_MAX;</span><br><span class="line">        it-&gt;pre = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是测试用的<code>main()</code>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V,E;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"V, E : "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; V &gt;&gt; E;</span><br><span class="line">    <span class="built_in">vector</span>&lt;vertex&gt; G = <span class="built_in">vector</span>&lt;vertex&gt;(V);</span><br><span class="line"></span><br><span class="line">    GClear(G);</span><br><span class="line">    <span class="keyword">while</span> (E--) &#123;</span><br><span class="line">        <span class="keyword">int</span> s, d, f;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; d &gt;&gt; f;</span><br><span class="line">        G[s].adjacency.push_back((path)&#123;d, f&#125;);</span><br><span class="line">        G[d].adjacency.push_back((path)&#123;s, <span class="number">0</span>&#125;);  <span class="comment">// 反向流量初始值为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> src, dst;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"src, dst: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; src &gt;&gt; dst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (FindPath(G,src,dst)) &#123;</span><br><span class="line">        flow += AddFlow(G, src, dst);</span><br><span class="line">        GClear(G);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"MaxFlow: "</span> &lt;&lt; flow &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考资料：<br>算法导论（Introduction to Algorithm）第26章  最大流<br><a href="http://course.study.cerbibo.com/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-854JFall-2005/1BE4D09F-597F-44C6-B72A-1B8B22B21C42/0/lec06_2003.pdf" target="_blank" rel="noopener">6.854 高级算法 —— 网络流 最大流</a><br><a href="http://blog.forec.cn/2015/12/25/Graph-Algorithms7-flow/" target="_blank" rel="noopener">最大流（一）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历算法</title>
      <link href="/2017/02/12/BinaryTree_Traversal/"/>
      <url>/2017/02/12/BinaryTree_Traversal/</url>
      
        <content type="html"><![CDATA[<p>二叉树的遍历有两个基本问题：给定一颗树，输出其特定形式的遍历结果；给定一个或几个遍历，重建这棵树。第一个问题比较简单，而第二个问题则相对较复杂。本文就对这两个问题进行一个总结。</p><a id="more"></a><p>二叉树的节点使用以下结构体定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node_s</span> * <span class="title">left</span>, * <span class="title">right</span>;</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><h2 id="输出遍历结果"><a href="#输出遍历结果" class="headerlink" title="输出遍历结果"></a>输出遍历结果</h2><h3 id="前序遍历（Preorder-Traversal）"><a href="#前序遍历（Preorder-Traversal）" class="headerlink" title="前序遍历（Preorder Traversal）"></a>前序遍历（Preorder Traversal）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversal</span><span class="params">(Node * T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, T-&gt;element);</span><br><span class="line">    PreorderTraversal(T-&gt;left);</span><br><span class="line">    PreorderTraversal(T-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历（Inorder-Traversal）"><a href="#中序遍历（Inorder-Traversal）" class="headerlink" title="中序遍历（Inorder Traversal）"></a>中序遍历（Inorder Traversal）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">(Node * T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    InorderTraversal(T-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, T-&gt;element);</span><br><span class="line">    InorderTraversal(T-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历（Postorder-Traversal）"><a href="#后序遍历（Postorder-Traversal）" class="headerlink" title="后序遍历（Postorder Traversal）"></a>后序遍历（Postorder Traversal）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTraversal</span><span class="params">(Node * T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    PostorderTraversal(T-&gt;left);</span><br><span class="line">    PostorderTraversal(T-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, T-&gt;element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历（Levelorder-Traversal）"><a href="#层序遍历（Levelorder-Traversal）" class="headerlink" title="层序遍历（Levelorder Traversal）"></a>层序遍历（Levelorder Traversal）</h3><p>与其它遍历方法不同，层序遍历是一种广度优先搜索（BFS），一般需要使用队列实现，此处使用了STL中的<code>&lt;deque&gt;</code>结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelorderTraversal</span><span class="params">(Node * T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;Node *&gt; buf;</span><br><span class="line">    buf.push_back(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!buf.empty()) &#123;</span><br><span class="line">        Node * currentNode = buf.front();</span><br><span class="line">        buf.pop_front();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; currentNode-&gt;element &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">if</span> (currentNode-&gt;left)</span><br><span class="line">            buf.push_back(currentNode-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (currentNode-&gt;right)</span><br><span class="line">            buf.push_back(currentNode-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据遍历结果重建树"><a href="#根据遍历结果重建树" class="headerlink" title="根据遍历结果重建树"></a>根据遍历结果重建树</h2><h3 id="一般二叉树"><a href="#一般二叉树" class="headerlink" title="一般二叉树"></a>一般二叉树</h3><p>对于一般二叉树来说，只给定任何一种遍历都无法唯一的确定树的结构，<strong>需要且仅需要给定中序遍历+另一种其他遍历才能唯一的确定树的结构</strong>，下面给出树的重建方法。</p><h4 id="中序-前序"><a href="#中序-前序" class="headerlink" title="中序 + 前序"></a>中序 + 前序</h4><p>通过前序遍历可以找出树的根节点，再根据中序遍历确定左右子树元素个数，之后就可以对遍历序列进行划分，迭代处理左右子树了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">InPreRebuild</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder)</span> </span>&#123;</span><br><span class="line">    Node * T = <span class="keyword">new</span> Node();</span><br><span class="line">    T-&gt;element = preorder[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator root = find(inorder.begin(), inorder.end(), T-&gt;element);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = root - inorder.begin();</span><br><span class="line">    <span class="keyword">int</span> right = inorder.end() - root - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        T-&gt;left = InPreRebuild(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(inorder.begin(), inorder.begin() + left), </span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(preorder.begin() + <span class="number">1</span>, preorder.begin() + left + <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        T-&gt;right = InPreRebuild(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(inorder.end() - right, inorder.end()), </span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(preorder.end() - right, preorder.end()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序-后序"><a href="#中序-后序" class="headerlink" title="中序 + 后序"></a>中序 + 后序</h4><p>与上一种情况算法基本相同，只是前序遍历根节点元素是第一个，后序遍历是最后一个，其余步骤完全相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">InPostRebuild</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder)</span> </span>&#123;</span><br><span class="line">    Node * T = <span class="keyword">new</span> Node();</span><br><span class="line">    T-&gt;element = *(postorder.end() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator root = find(inorder.begin(), inorder.end(), T-&gt;element);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = root - inorder.begin();</span><br><span class="line">    <span class="keyword">int</span> right = inorder.end() - root - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        T-&gt;left = InPostRebuild(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(inorder.begin(), inorder.begin() + left),</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(postorder.begin(), postorder.begin() + left));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        T-&gt;right = InPostRebuild(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(inorder.end() - right, inorder.end()),</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(postorder.end() - right - <span class="number">1</span>, postorder.end() - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序-层序"><a href="#中序-层序" class="headerlink" title="中序 + 层序"></a>中序 + 层序</h4><p>层序遍历无法划分为左右子树进行迭代，故这里使用了一种不同的思路。在中序遍历的所有元素中，出现在层序遍历中最前面那个必定是根节点，也就是可以通过搜索来确定根节点，之后对中序遍历进行划分迭代求解左右子树即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">InLevelRebuild</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelorder)</span> </span>&#123;</span><br><span class="line">    Node * T = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = levelorder.begin(); it != levelorder.end(); it++) &#123;</span><br><span class="line">        root = find(inorder.begin(), inorder.end(), *it);</span><br><span class="line">        <span class="keyword">if</span> (root != inorder.end()) &#123;</span><br><span class="line">            T-&gt;element = *root;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = root - inorder.begin();</span><br><span class="line">    <span class="keyword">int</span> right = inorder.end() - root - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        T-&gt;left = InLevelRebuild(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(inorder.begin(), inorder.begin() + left),</span><br><span class="line">                levelorder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        T-&gt;right = InLevelRebuild(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(inorder.end() - right, inorder.end()),</span><br><span class="line">                levelorder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p><strong>对于二叉查找树来说，因为它的元素是有序的，所以只需给定先序、层序及后序遍历中的任何一种即可唯一确定树的结构，不过只给定中序遍历是不能唯一确定的</strong>，下面给出树的重建方法。</p><h4 id="先序"><a href="#先序" class="headerlink" title="先序"></a>先序</h4><p>先序遍历中，根节点必定是第一个元素，又因为这是一棵二叉查找树，左子树所有元素必定小于根节点，右子树所有元素必定大于根节点，根据这一基本性质，可以很容易的将先序遍历序列划分为左子树和右子树部分，进而迭代求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">PreRebuild</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder)</span> </span>&#123;</span><br><span class="line">    Node * T = <span class="keyword">new</span> Node();</span><br><span class="line">    T-&gt;element = preorder[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator partition = preorder.begin() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; partition != preorder.end(); partition++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*partition &gt; T-&gt;element)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (partition - preorder.begin() - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        T-&gt;left = PreRebuild(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(preorder.begin() + <span class="number">1</span>, partition));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preorder.end() - partition &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        T-&gt;right = PreRebuild(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(partition, preorder.end()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h4><p>与先序遍历相同，只不过根节点对应元素是遍历结果中的最后一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">PostRebuild</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder)</span> </span>&#123;</span><br><span class="line">    Node * T = <span class="keyword">new</span> Node();</span><br><span class="line">    T-&gt;element = *(postorder.end() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator partition = postorder.begin();</span><br><span class="line">    <span class="keyword">for</span> (; partition != postorder.end() - <span class="number">1</span>; partition++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*partition &gt; T-&gt;element) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (partition - postorder.begin() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        T-&gt;left = PostRebuild(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(postorder.begin(), partition));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (postorder.end() - partition - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        T-&gt;right = PostRebuild(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(partition, postorder.end() - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序"><a href="#层序" class="headerlink" title="层序"></a>层序</h4><p>思路也是一样的，只是因为层序遍历中，左右子树的元素是混杂在一起的，直接划分并不方便，所以这里新建了两个<code>vector</code>，将对应的元素放入其中即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">LevelRebuild</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; levelorder)</span> </span>&#123;</span><br><span class="line">    Node * T = <span class="keyword">new</span> Node();</span><br><span class="line">    T-&gt;element = levelorder[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it  = levelorder.begin(); it != levelorder.end(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it &lt; T-&gt;element) &#123;</span><br><span class="line">            left.push_back(*it);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*it &gt; T-&gt;element) &#123;</span><br><span class="line">            right.push_back(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!left.empty()) &#123;</span><br><span class="line">        T-&gt;left = LevelRebuild(left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!right.empty()) &#123;</span><br><span class="line">        T-&gt;right = LevelRebuild(right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据遍历结果重建二叉树的算法虽然有很多变体，不过其核心思想都是一样的：<strong>先找出根节点，之后将遍历结果划分为左右子树对应的部分，最后递归求解</strong>。无法唯一确定二叉树的情况都是因为无法唯一确定根节点或无法划分左右子树。</p><hr><blockquote><p>参考资料：<br><a href="http://biaobiaoqi.github.io/blog/2013/04/27/pat1020-pat1043-rebuild-binary-tree/" target="_blank" rel="noopener">根据前中后序和层序重建二叉树</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Data Struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——AVL树</title>
      <link href="/2017/02/11/Data_Structure_AVLTree/"/>
      <url>/2017/02/11/Data_Structure_AVLTree/</url>
      
        <content type="html"><![CDATA[<p>AVL树是一种特殊的二叉查找树，其特征在于：对所有节点来说，其左子树和右子树间的高度差小于等于1。本文简要总结下AVL树的几种基本操作。</p><a id="more"></a><h2 id="节点结构体定义"><a href="#节点结构体定义" class="headerlink" title="节点结构体定义"></a>节点结构体定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node_s</span> * <span class="title">left</span>, * <span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>为了突出说明核心问题，节点数据类型使用最简单的<code>int</code>表示；<code>height</code>为树的高度，<strong>叶子节点高度为0，每向上一层加1，即每个节点的深度为其左右子树最大深度加1</strong>。可使用以下几个宏定义来计算及获取深度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Height(T) (T == NULL ? -1 : T-&gt;height)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) (a &gt; b ? a : b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CalHeight(T) (T-&gt;height = MAX(Height(T-&gt;left), Height(T-&gt;right)) + 1)</span></span><br></pre></td></tr></table></figure><h2 id="AVL树的旋转"><a href="#AVL树的旋转" class="headerlink" title="AVL树的旋转"></a>AVL树的旋转</h2><p>旋转操作是AVL树特有的操作，也是学习AVL树的核心,旋转的目的在于解决插入、删除等操作造成的AVL树不平衡问题。AVL树的不平衡一共只有4种情况（以插入为例说明）：</p><ul><li>LL：在左子树左节点进行插入</li><li>LR：在左子树右节点进行插入</li><li>RR：在右子树右节点进行插入</li><li>RL：在右子树左节点进行插入</li></ul><p>示意图：</p><p><img src="https://pic.gaomf.store/281624280475098.jpg" alt=""><br><img src="https://pic.gaomf.store/281625317193879.jpg" alt=""></p><p>关于旋转的详细分析可参考<a href="http://www.cnblogs.com/skywang12345/p/3576969.html" target="_blank" rel="noopener">第一篇参考资料</a>，此处仅给出实现代码及简要思路。</p><h3 id="LL及RR单旋转"><a href="#LL及RR单旋转" class="headerlink" title="LL及RR单旋转"></a>LL及RR单旋转</h3><p>二者是镜像操作，实现方法比较简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">RotateLL</span> <span class="params">(Node * T)</span> </span>&#123;</span><br><span class="line">    Node * t = T-&gt;left;</span><br><span class="line"></span><br><span class="line">    T-&gt;left = t-&gt;right;</span><br><span class="line">    t-&gt;right = T;</span><br><span class="line"></span><br><span class="line">    CalHeight(T);</span><br><span class="line">    CalHeight(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">RotateRR</span> <span class="params">(Node * T)</span> </span>&#123;</span><br><span class="line">    Node * t = T-&gt;right;</span><br><span class="line"></span><br><span class="line">    T-&gt;right = t-&gt;left;</span><br><span class="line">    t-&gt;left = T;</span><br><span class="line"></span><br><span class="line">    CalHeight(T);</span><br><span class="line">    CalHeight(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调整完节点关系后，需要重新计算一下节点的高度。</p><h3 id="LR及RL双旋转"><a href="#LR及RL双旋转" class="headerlink" title="LR及RL双旋转"></a>LR及RL双旋转</h3><p>二者也是镜像操作，可以视为两次单旋转的结合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">RotateLR</span><span class="params">(Node * T)</span> </span>&#123;</span><br><span class="line">    T-&gt;left = RotateRR(T-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> RotateLL(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">RotateRL</span><span class="params">(Node * T)</span> </span>&#123;</span><br><span class="line">    T-&gt;right = RotateLL(T-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> RotateRR(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为单旋转操作已经正确的调整了节点高度，双旋转中无需再调整节点高度。</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>一般使用递归形式，递归函数返回时，检查当前节点是否平衡，不平衡则执行旋转操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">Insert</span><span class="params">(Node * T, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 新插入的元素必定为叶子节点 */</span></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        T = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        T-&gt;element = val;</span><br><span class="line">        T-&gt;left = T-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* 在左子树插入 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; T-&gt;element) &#123;</span><br><span class="line">        T-&gt;left = Insert(T-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (Height(T-&gt;left) - Height(T-&gt;right) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; T-&gt;left-&gt;element)</span><br><span class="line">                T = RotateLL(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = RotateLR(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* 在右子树插入 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; T-&gt;element) &#123;</span><br><span class="line">        T-&gt;right = Insert(T-&gt;right, val);</span><br><span class="line">        <span class="keyword">if</span> (Height(T-&gt;right) - Height(T-&gt;left) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; T-&gt;right-&gt;element)</span><br><span class="line">                T = RotateRR(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = RotateRL(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 若元素已存在，不执行任何操作 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 递归函数返回前调整节点高度 */</span></span><br><span class="line">    <span class="comment">/* 这保证了每一层递归函数返回的节点高度都是正确的 */</span></span><br><span class="line">    <span class="comment">/* 进而保证了整棵树的节点高度正确 */</span></span><br><span class="line">    CalHeight(T);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>根据二叉查找树的基本性质，可以很容易的写出查找最大元素、最小元素、任意元素的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">FindMax</span><span class="params">(Node * T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        T = T-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">FindMin</span><span class="params">(Node * T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        T = T-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">Find</span><span class="params">(Node * T, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;element == val)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; T-&gt;element)</span><br><span class="line">            T = T-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            T = T-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除是最复杂的操作，如果删除操作不多的话，可以考虑使用懒惰删除的策略，即增加一个标志位，表明当前节点是否被删除了。如果需要真实的删除元素，使用以下方法进行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">Delete</span><span class="params">(Node * T, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 待删除元素在左子树中 */</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; T-&gt;element) &#123;</span><br><span class="line">        T-&gt;left = Delete(T-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (Height(T-&gt;right) - Height(T-&gt;left) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Height(T-&gt;right-&gt;left) &lt; Height(T-&gt;right-&gt;right))</span><br><span class="line">                T = RotateRR(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = RotateRL(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* 待删除元素在右子树中 */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; T-&gt;element) &#123;</span><br><span class="line">        T-&gt;right = Delete(T-&gt;right, val);</span><br><span class="line">        <span class="keyword">if</span> (Height(T-&gt;left) - Height(T-&gt;right) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Height(T-&gt;left-&gt;right) &lt; Height(T-&gt;left-&gt;left))</span><br><span class="line">                T = RotateLL(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = RotateLR(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* 删除当前节点 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 当前节点有两个儿子 */</span></span><br><span class="line">        <span class="comment">/* 选择高度较大那一边进行删除，以此避免AVL树不平衡 */</span></span><br><span class="line">        <span class="keyword">if</span> (T-&gt;left &amp;&amp; T-&gt;right) &#123;</span><br><span class="line">            <span class="comment">/* 选择左树的话，用左树中最大节点代替当前节点，并删除最大节点原位置 */</span></span><br><span class="line">            <span class="keyword">if</span> (Height(T-&gt;left) &gt; Height(T-&gt;right)) &#123;</span><br><span class="line">                Node * tmax = FindMax(T-&gt;left);</span><br><span class="line">                T-&gt;element = tmax-&gt;element;</span><br><span class="line">                T-&gt;left = Delete(T-&gt;left, tmax-&gt;element);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">/* 选择右树的话，用右树中最小节点代替当前节点，并删除最小节点原位置 */</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Node * tmin = FindMin(T-&gt;right);</span><br><span class="line">                T-&gt;element = tmin-&gt;element;</span><br><span class="line">                T-&gt;right = Delete(T-&gt;right, tmin-&gt;element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">/* 当前节点是叶子节点或只有一个儿子，直接删除 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node * tmp = T;</span><br><span class="line">            T = T-&gt;left ? T-&gt;left : T-&gt;right;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 递归返回非空节点时，需要重新计算其高度 */</span></span><br><span class="line">    <span class="keyword">if</span> (T) </span><br><span class="line">        CalHeight(T);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本策略和插入一样，依然是递归的进行删除，若待删除节点有两个儿子时，使用树的删除操作中的一般方法，即<strong>选择较高一侧子树中最大或最小元素代替当前元素，之后再删除那个最大或最小元素</strong>。最大或最小元素一定是叶子元素，这样之后的删除操作就会很简单，且这样的替代删除策略不会导致树的不平衡。</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>同样有前序、中序、后序及层序四种遍历策略，就是树的通用遍历策略，可参考<a href="http://gaomf.cn/2017/02/12/BinaryTree_Traversal/">二叉树的遍历算法</a>。</p><hr><blockquote><p>参考资料：<br><a href="http://www.cnblogs.com/skywang12345/p/3576969.html" target="_blank" rel="noopener">AVL树(一)之 图文解析 和 C语言的实现</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径算法</title>
      <link href="/2017/02/03/Shortest_Path/"/>
      <url>/2017/02/03/Shortest_Path/</url>
      
        <content type="html"><![CDATA[<p>图论中求解最短路径的算法主要有两种，Dijkstra算法及Floyd算法，其中Dijkstra算法用于求解单源最短路径问题，而Floyd算法则用于解决多源最短路径问题。本文对这两种算法做一总结。</p><a id="more"></a><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>Dijkstra算法是最经典的最短路径算法，这是一种典型的贪心算法，不过可以证明，<strong>这种贪心策略得到的就是全局最优解</strong>。Dijkstra算法的详细描述可以参考数据结构的基础书籍，以下文章也可供参考：</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">戴克斯特拉算法</a><br><a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html" target="_blank" rel="noopener">算法 7：Dijkstra 最短路算法</a></p></blockquote><p>Dijkstra算法的主要思想可以简要总结为：</p><ol><li>将所有顶点分为两类，即<code>Known</code>和<code>Unknown</code>两个集合，初始时所有顶点均位于<code>Unknown</code>集合中，<strong>算法的目标就是将<code>Unknown</code>集合中的所有顶点移至<code>Known</code>集合中；</strong></li><li>每一个顶点均有一个表示当前状态的属性表，其中一定要有一个变量记录<strong>此时距离源点的最短路径长度</strong>（不妨将其记为<code>dr</code>），除此之外根据需要还可以有一些附加信息，如<strong>最短路径来源顶点</strong>、经过的顶点数、所属的集合（<code>Known</code>还是<code>Unknown</code>）等；</li><li>初始时，<strong>源点的<code>dr</code>为0，其余所有顶点的<code>dr</code>均为无穷大</strong>，这里的无穷大只是数学上的说法，实际编程中会用一个合适的值替代；</li><li><strong>从<code>Unknown</code>集合中选出<code>dr</code>最小的一个顶点，将其移至<code>Known</code>集合中，并更新<code>Unknown</code>集合中剩余顶点的<code>dr</code></strong>；</li><li>重复第4步，直至<code>Unknown</code>为空。</li></ol><p>算法的核心就是上述步骤中的第4步，这里所谓的更新是指：<strong>遍历与选出的顶点邻接的所有顶点，若其位于<code>Unknown</code>集合中，比较当前<code>dr</code>与经由选出顶点至其的距离，若新的距离小于<code>dr</code>，则使用新的距离替代<code>dr</code></strong>。需要注意的是，<strong>这里只更新比较位于<code>Unknown</code>集合中的邻接顶点，不需要去更新<code>Known</code>集合中的顶点</strong>，否则这就不是贪心法了。</p><p>用一张图可以很好的说明以上步骤：</p><p><img src="https://pic.gaomf.store/Dijkstra_Animation.gif" alt=""></p><p>下面给出Dijkstra算法的核心伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!Unknown.empty()) &#123;</span><br><span class="line">    V = Unknown.FindMinDr();</span><br><span class="line">    Unknown.remove(V);</span><br><span class="line">    Known.add(V);</span><br><span class="line">    </span><br><span class="line">    foreach(W adjacent to V) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Known.contain(W))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (V.dr + D[v][w] &lt; W.dr) &#123;</span><br><span class="line">        W.dr = V.dr + D[v][w];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Dijkstra算法的结果一般使用一个一维表（即数组）来记录，每一项即是一个顶点对应的当前状态属性表。</strong>算法的复杂度取决于具体实现方式，一个较好的选择是使用斐波那契堆来实现，不过粗略的看，其复杂度大概是O(n^2)级别的。</p><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p>Floyd算法的实质是一种动态规划算法，<strong>最初不允许经由任何中间点，之后逐步添加允许的中间点，可以证明，最终允许的中间点为全部顶点时，算法得出的就是最优解</strong>。算法详细描述可见：</p><blockquote><p><a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/floyd.html" target="_blank" rel="noopener">算法 6：只有五行的 Floyd 最短路算法</a></p></blockquote><p>Floyd算法的核心伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N : 顶点数</span></span><br><span class="line"><span class="comment">// D[N][N] : 两点间最短距离记录</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; N; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (D[i][j] &gt; D[i][k] + D[k][j]) &#123;</span><br><span class="line">          D[i][j] = D[i][k] + D[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最外层的<code>for</code>循环逐渐添加允许途径的中间点，内层的两个循环遍历所有点之间的距离。Floyd算法的结果一般使用一个二维表（即二维数组）来记录，即上述代码中的<code>D[N][N]</code>，初始值即为当前图的邻接矩阵（Adjacency Matrix）表示。算法的复杂度是O(n^3)的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim配置及插件总结</title>
      <link href="/2017/02/02/Vim_Plugin/"/>
      <url>/2017/02/02/Vim_Plugin/</url>
      
        <content type="html"><![CDATA[<p>Vim之所以强大很大程度上是源于其灵活的配置及丰富的插件，本文就对我的配置文件及用到的插件做一总结记录，插件用法主要给出参考链接，不做过多重复说明。</p><a id="more"></a><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>如果不对Vim进行配置的话，其界面和功能都不是很好用，Vim的配置文件在Linux下是<code>~/.vimrc</code>文件，不过为了方便管理和使用Git进行备份同步，一般将其放在<code>~/.vim/.vimrc</code>处，并在<code>~/</code>和<code>/root/</code>路径下建立硬链接。</p><p>Vim的配置文件中有一个被称为最强大的终极配置文件——<a href="https://github.com/spf13/spf13-vim" target="_blank" rel="noopener">spf13</a>，这是一系列插件和配置文件的集合，不过我没有直接使用这个，只是参考了下它<code>.vimrc</code>文件的写法，我自己使用的配置文件在<a href="https://github.com/g199209/vimrc" target="_blank" rel="noopener">这里</a>，其中的注释写得很详细，就不多做说明了。</p><h2 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h2><p>Vim的插件管理功能本身也是靠插件实现的，这类插件有很多：</p><blockquote><p><a href="https://www.zhihu.com/question/24294358/answer/27362814" target="_blank" rel="noopener">vim有哪些插件管理程序？都有些什么特点？</a></p></blockquote><p>我选用的是使用最广泛且最简单的Vundle。</p><h3 id="Vundle"><a href="#Vundle" class="headerlink" title="Vundle"></a><a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="noopener">Vundle</a></h3><p>Vundle的Github页面上对其使用方法说得很清楚了，照着做就好。在<code>.vimrc</code>文件中配置好相关插件目录，常用命令就这几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:PluginList       - lists configured plugins</span><br><span class="line">:PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate</span><br><span class="line">:PluginSearch foo - searches for foo; append `!` to refresh local cache</span><br><span class="line">:PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal</span><br></pre></td></tr></table></figure><p><em>注：早期的Vundle使用<code>Bundle</code>的形式，不过这种用法已经被遗弃了，目前使用的是<code>Plugin</code>的形式。</em></p><h2 id="界面美化插件"><a href="#界面美化插件" class="headerlink" title="界面美化插件"></a>界面美化插件</h2><h3 id="Solarized"><a href="#Solarized" class="headerlink" title="Solarized"></a><a href="https://github.com/altercation/vim-colors-solarized" target="_blank" rel="noopener">Solarized</a></h3><p>据说最受欢迎的配色方案，使用下来感觉的确不错。在Vundle中添加：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plugin <span class="string">'altercation/vim-colors-solarized'</span></span><br></pre></td></tr></table></figure><p>Solarized标准的背景色是深蓝色的，在其Github页面上可以看到效果示意图，不过实际使用下来我却始终无法调出这种背景色来。后面仔细研究了其配色代码，发现蓝色背景色是其针对Gvim的配色，而我是在终端中直接使用Vim的，这时候使用的配色方案背景色是深灰色。当然也可以设置为透明的，即使用终端背景色，不过其实深灰色我看着更舒服，就没有去把它改成蓝色了，只是对部分颜色进行了一些调整，最终得到了一个<a href="https://github.com/g199209/vim-colors-solarized" target="_blank" rel="noopener">定制版的Solarized主题</a>。</p><p>最终的显示效果如下：</p><p><img src="https://pic.gaomf.store/20170117234815.png-width600" alt=""></p><h3 id="Airline"><a href="#Airline" class="headerlink" title="Airline"></a><a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="noopener">Airline</a></h3><p>状态栏增强美化插件，使用方法可参考：</p><blockquote><p><a href="http://www.zygotee.com/vim/vim-airline%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">vim-airline配置</a><br><a href="http://blog.csdn.net/the_victory/article/details/50638810" target="_blank" rel="noopener">VIM配置:vim-airline插件安装</a><br><a href="http://www.jianshu.com/p/310368097c75" target="_blank" rel="noopener">安装Vim插件vim-airline</a></p></blockquote><p>vim-ariline的使用很简单，基本无需多少配置，且可以自动和诸多其他插件配合使用，十分方便。我使用<code>bubblegum</code>主题的显示效果如下：</p><p><img src="https://pic.gaomf.store/20170118154146.png-width600" alt=""></p><h3 id="Startify"><a href="#Startify" class="headerlink" title="Startify"></a><a href="https://github.com/mhinz/vim-startify" target="_blank" rel="noopener">Startify</a></h3><p>为Vim添加一个开始界面，可以显示最近使用的文件等。</p><h2 id="功能增强插件"><a href="#功能增强插件" class="headerlink" title="功能增强插件"></a>功能增强插件</h2><h3 id="NERDTree"><a href="#NERDTree" class="headerlink" title="NERDTree"></a><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">NERDTree</a></h3><p>据说最受欢迎的Vim插件，可以在Vim中显示一个类似工程管理器的界面，用于方便的选择文件打开。一般同时配合以下两个插件一起使用：</p><ul><li><a href="https://github.com/Xuyuanp/nerdtree-git-plugin" target="_blank" rel="noopener">nerdtree-git-plugin</a>：用于显示Git状态</li><li><a href="https://github.com/jistr/vim-nerdtree-tabs" target="_blank" rel="noopener">vim-nerdtree-tabs</a>：在多Tab切换时保持NERDTree界面</li></ul><h3 id="CtrlP"><a href="#CtrlP" class="headerlink" title="CtrlP"></a><a href="https://github.com/ctrlpvim/ctrlp.vim" target="_blank" rel="noopener">CtrlP</a></h3><p>用于快速查找文件的插件。</p><h3 id="Bookmarks"><a href="#Bookmarks" class="headerlink" title="Bookmarks"></a><a href="https://github.com/MattesGroeger/vim-bookmarks" target="_blank" rel="noopener">Bookmarks</a></h3><p>用于增强书签功能的插件，可在左侧边栏显示书签，而且优化了快捷键。我觉得比<a href="https://github.com/kshenoy/vim-signature" target="_blank" rel="noopener">Signature</a>更简单好用些，按照Github说明配置即可。</p><h3 id="EasyGrep"><a href="#EasyGrep" class="headerlink" title="EasyGrep"></a><a href="https://github.com/dkprice/vim-easygrep" target="_blank" rel="noopener">EasyGrep</a></h3><p>全局搜索插件。</p><h3 id="EasyMotion"><a href="#EasyMotion" class="headerlink" title="EasyMotion"></a><a href="https://github.com/easymotion/vim-easymotion" target="_blank" rel="noopener">EasyMotion</a></h3><p>快速移动的神器，方便定位到所需位置。</p><h3 id="Fixtc-Vim"><a href="#Fixtc-Vim" class="headerlink" title="Fixtc.Vim"></a><a href="https://github.com/lilydjwg/fcitx.vim" target="_blank" rel="noopener">Fixtc.Vim</a></h3><p>在离开或重新进入插入模式时自动记录和恢复每个缓冲区各自的输入法状态，以便在普通模式下始终是英文输入模式，切换回插入模式时恢复离开前的输入法输入模式。</p><h2 id="编程相关插件"><a href="#编程相关插件" class="headerlink" title="编程相关插件"></a>编程相关插件</h2><h3 id="YouCompleteMe"><a href="#YouCompleteMe" class="headerlink" title="YouCompleteMe"></a><a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="noopener">YouCompleteMe</a></h3><p>代码补全插件，虽然效果还是比不过VS+VAssixtX，不过可以满足基本需求了。如果使用Makefile编译的话，可使用<a href="https://github.com/rizsotto/Bear" target="_blank" rel="noopener">Bear</a>生成索引数据库。</p><h3 id="Ultisnips"><a href="#Ultisnips" class="headerlink" title="Ultisnips"></a><a href="https://github.com/SirVer/ultisnips" target="_blank" rel="noopener">Ultisnips</a></h3><p>快速插入代码片段，与YCM插件配合使用。</p><h3 id="AutoPair"><a href="#AutoPair" class="headerlink" title="AutoPair"></a><a href="https://github.com/jiangmiao/auto-pairs" target="_blank" rel="noopener">AutoPair</a></h3><p>自动括号配对。</p><h3 id="TagList"><a href="#TagList" class="headerlink" title="TagList"></a><a href="https://github.com/vim-scripts/taglist.vim" target="_blank" rel="noopener">TagList</a></h3><p>列出函数、宏定义等。</p><h3 id="NerdCommenter"><a href="#NerdCommenter" class="headerlink" title="NerdCommenter"></a><a href="https://github.com/scrooloose/nerdcommenter" target="_blank" rel="noopener">NerdCommenter</a></h3><p>快速注释代码。</p><h3 id="ConqueGDB"><a href="#ConqueGDB" class="headerlink" title="ConqueGDB"></a><a href="https://github.com/vim-scripts/Conque-GDB" target="_blank" rel="noopener">ConqueGDB</a></h3><p>在Vim中集成GDB的插件，只是并不是很好用……</p><hr><blockquote><p>参考资料：<br><a href="http://feihu.me/blog/2014/intro-to-vim/" target="_blank" rel="noopener">跟我一起学习VIM - The Life Changing Editor</a><br><a href="https://github.com/yangyangwithgnu/use_vim_as_ide" target="_blank" rel="noopener">所需即所获：像 IDE 一样使用 vim</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Editor </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下Vim的编译安装</title>
      <link href="/2017/01/17/Linux_Vim_Compile/"/>
      <url>/2017/01/17/Linux_Vim_Compile/</url>
      
        <content type="html"><![CDATA[<p>基本所有Linux发行版的软件仓库中都有现成的Vim，不过这个发布版包含的功能不全，且一般都不是最新版，故我们需要自己动手，从源码自行编译最新版的Vim。本文以Ubuntu 14.04 及 Debian 3.16为例，介绍编译最新Vim 8.0的过程。</p><a id="more"></a><h2 id="卸载老版本Vim"><a href="#卸载老版本Vim" class="headerlink" title="卸载老版本Vim"></a>卸载老版本Vim</h2><p>虽然不卸载老版本的Vim也可以正常编译安装新版本的，不过既然用不到了，将其卸掉可以节省空间.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get remove vim vim-runtime gvim vim-tiny vim-common vim-gui-common</span><br></pre></td></tr></table></figure><h2 id="下载所需依赖包"><a href="#下载所需依赖包" class="headerlink" title="下载所需依赖包"></a>下载所需依赖包</h2><p>首先是基本的编译系统，一般系统都是已经安装了的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-essential libncurses5-dev</span><br></pre></td></tr></table></figure><hr><p>其次是各种脚本语言的支持，如Python、Lua、Perl等，需要注意的是，并不是不写这些程序就不用安装了，很多Vim插件都是依赖于这些功能的，所有最好全部都装上以免之后出现奇怪的问题。</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python python3 python-dev python3-dev</span><br></pre></td></tr></table></figure><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install ruby ruby-dev</span><br></pre></td></tr></table></figure><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install lua5.2 liblua5.2-dev luajit libluajit-5.1-dev</span><br></pre></td></tr></table></figure><h3 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install perl libperl-dev</span><br></pre></td></tr></table></figure><h3 id="Tcl"><a href="#Tcl" class="headerlink" title="Tcl"></a>Tcl</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install tcl8.5 tcl8.5-dev libtcl8.5</span><br></pre></td></tr></table></figure><p>Tcl的最新版本是8.6，不过此处不能选择最新版本，要选8.5版本的。</p><hr><p>如果需要GUI支持，还需要安装GUI相关依赖包，因为我不准备使用GVim等，就无需安装这些了，如有需要可阅读参考资料中的网页。</p><p>最后还需要安装一些杂项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install exuberant-ctags cscope</span><br></pre></td></tr></table></figure><h2 id="获取源代码"><a href="#获取源代码" class="headerlink" title="获取源代码"></a>获取源代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vim/vim.git</span><br></pre></td></tr></table></figure><p>切换到<code>src</code>文件夹中，之后所有操作都在此文件夹中完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> vim/src</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>使用<code>./configure --help</code>可查看帮助，我使用的设置是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">    --with-compiledby=<span class="string">"Mingfei Gao"</span> \</span><br><span class="line">    --with-features=huge \</span><br><span class="line">    --<span class="built_in">enable</span>-multibyte \</span><br><span class="line">    --<span class="built_in">enable</span>-cscope=yes \</span><br><span class="line">    --<span class="built_in">enable</span>-pythoninterp=yes \</span><br><span class="line">    --with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu \</span><br><span class="line">    --<span class="built_in">enable</span>-python3interp=yes \</span><br><span class="line">    --with-python3-config-dir=/usr/lib/python3.4/config-3.4m-x86_64-linux-gnu \</span><br><span class="line">    --<span class="built_in">enable</span>-perlinterp=yes \</span><br><span class="line">    --<span class="built_in">enable</span>-rubyinterp=yes \</span><br><span class="line">    --<span class="built_in">enable</span>-luainterp=yes \</span><br><span class="line">    --with-luajit \</span><br><span class="line">    --<span class="built_in">enable</span>-tclinterp=yes \</span><br><span class="line">    --<span class="built_in">enable</span>-gui=no \</span><br><span class="line">    --<span class="built_in">enable</span>-fail-if-missing</span><br></pre></td></tr></table></figure><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j 4 &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>这一步一般不会发生什么错误，编译时间也不是很长，几分钟就可以完成了。</p><h2 id="查看版本信息及清理"><a href="#查看版本信息及清理" class="headerlink" title="查看版本信息及清理"></a>查看版本信息及清理</h2><p>打开Vim后使用<code>:version</code>查看版本信息：</p><p><img src="https://pic.gaomf.store/20170117170247.png-height600" alt=""></p><p>最后清理下编译中间文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean &amp;&amp; make distclean</span><br></pre></td></tr></table></figure><p>现在就可以尽情享受最新版的Vim了~</p><blockquote><p>Update 2018-03-03:</p><p>以上编译选项编译出的vim可能会缺少clipboard支持，这会导致与系统剪贴板交互存在问题。同时为简化之后重复编译升级vim的过程，可编写一个脚本文件来自动执行上述操作，详见：</p><p><a href="https://github.com/g199209/vimrc" target="_blank" rel="noopener">https://github.com/g199209/vimrc</a></p></blockquote><hr><blockquote><p>参考资料：<br><a href="http://www.jianshu.com/p/3e0c242310d3" target="_blank" rel="noopener">Debian下Vim的编译</a><br><a href="http://www.cnblogs.com/zhongcq/p/3615980.html" target="_blank" rel="noopener">Linux中源码安装编译Vim</a><br><a href="https://segmentfault.com/a/1190000007005137" target="_blank" rel="noopener">源码编译Vim 8</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断终端色彩支持情况的方法</title>
      <link href="/2017/01/16/Terminal_Color/"/>
      <url>/2017/01/16/Terminal_Color/</url>
      
        <content type="html"><![CDATA[<p>黑白的世界总没有彩色的世界精彩，最初的Linux或其他系统的Shell终端肯定只有黑白的，之后逐渐出现了支持8色、16色、256色及真彩色的终端。目前主流的终端一般都支持256色，未来的趋势是支持24位真彩色。那如何判断当前使用的是哪种模式，以及如何更改设置呢？本文就以Ubuntu下Gnome-Terminal为例介绍一下设置方法，理论上应该适用于所有Linux终端。</p><a id="more"></a><h3 id="终端类型及颜色支持"><a href="#终端类型及颜色支持" class="headerlink" title="终端类型及颜色支持"></a>终端类型及颜色支持</h3><p>使用<code>tput colors</code>命令即可查看当前终端支持几种颜色；<br>使用以下命令即可列出系统所支持的所有终端类型，以及他们支持的颜色位数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> T <span class="keyword">in</span> `find /usr/share/terminfo -<span class="built_in">type</span> f -<span class="built_in">printf</span> <span class="string">'%f '</span>`;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">"<span class="variable">$T</span> `tput -T <span class="variable">$T</span> colors`"</span>;<span class="keyword">done</span>|sort -nk2|tail -n20</span><br></pre></td></tr></table></figure><p>示例输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Eterm-88color 88</span><br><span class="line">rxvt-88color 88</span><br><span class="line">xterm-88color 88</span><br><span class="line">xterm+88color 88</span><br><span class="line">Eterm-256color 256</span><br><span class="line">gnome-256color 256</span><br><span class="line">iTerm.app 256</span><br><span class="line">konsole-256color 256</span><br><span class="line">mlterm-256color 256</span><br><span class="line">mrxvt-256color 256</span><br><span class="line">nsterm 256</span><br><span class="line">nsterm-256color 256</span><br><span class="line">putty-256color 256</span><br><span class="line">rxvt-256color 256</span><br><span class="line">rxvt-unicode-256color 256</span><br><span class="line">screen-256color-bce-s 256</span><br><span class="line">screen-256color-s 256</span><br><span class="line">terminator 256</span><br><span class="line">vte-256color 256</span><br><span class="line">xterm+256color 256</span><br></pre></td></tr></table></figure><p><code>$TERM</code>变量代表当前终端类型，可使用<code>echo $TERM</code>命令查看。</p><h3 id="256色支持"><a href="#256色支持" class="headerlink" title="256色支持"></a>256色支持</h3><p>运行以下命令，若输出了完整的256种颜色，就说明当前终端支持256色：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x=`tput op` y=`<span class="built_in">printf</span> %76s`;<span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..256&#125;;<span class="keyword">do</span> o=00<span class="variable">$i</span>;<span class="built_in">echo</span> -e <span class="variable">$&#123;o:$&#123;#o&#125;</span>-3:3&#125; `tput setaf <span class="variable">$i</span>;tput setab <span class="variable">$i</span>`<span class="variable">$&#123;y// /=&#125;</span><span class="variable">$x</span>;<span class="keyword">done</span>)</span><br></pre></td></tr></table></figure><p><img src="https://pic.gaomf.store/20170116154133.png" alt=""></p><p>若只有前8种颜色，说明当前配置是8色模式，默认情况下，Ubuntu中的Gnome-Terminal就只开启了8色支持。此时可通过修改<code>~/.bashrc</code>文件将其改为256色，在<code>.bashrc</code>文件中加入以下代码即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$TERM</span>"</span> <span class="keyword">in</span></span><br><span class="line">    xterm)</span><br><span class="line">        <span class="built_in">export</span> TERM=xterm-256color</span><br><span class="line">        ;;</span><br><span class="line">    screen)</span><br><span class="line">        <span class="built_in">export</span> TERM=screen-256color</span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h3 id="真彩色支持"><a href="#真彩色支持" class="headerlink" title="真彩色支持"></a>真彩色支持</h3><p>很遗憾，Ubuntu下的终端目前尚没有支持真彩色的。可使用以下脚本代码进行检测：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'BEGIN&#123;</span></span><br><span class="line"><span class="string">    s="/\\/\\/\\/\\/\\"; s=s s s s s s s s;</span></span><br><span class="line"><span class="string">    for (colnum = 0; colnum&lt;77; colnum++) &#123;</span></span><br><span class="line"><span class="string">        r = 255-(colnum*255/76);</span></span><br><span class="line"><span class="string">        g = (colnum*510/76);</span></span><br><span class="line"><span class="string">        b = (colnum*255/76);</span></span><br><span class="line"><span class="string">        if (g&gt;255) g = 510-g;</span></span><br><span class="line"><span class="string">        printf "\033[48;2;%d;%d;%dm", r,g,b;</span></span><br><span class="line"><span class="string">        printf "\033[38;2;%d;%d;%dm", 255-r,255-g,255-b;</span></span><br><span class="line"><span class="string">        printf "%s\033[0m", substr(s,colnum+1,1);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    printf "\n";</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><p>如果支持真彩色的话，输出效果如下：</p><p><img src="https://pic.gaomf.store/687474703a2f2f7777332e73696e61696d672e636e2f6c617267652f35643464623866396777316638696e746f386776676a3230686630306f3073762e6a7067.jpg" alt=""></p><p>若不支持，是无法显示出连续的色彩的：</p><p><img src="https://pic.gaomf.store/20170116155023.png" alt=""></p><h3 id="Vim中256色设置"><a href="#Vim中256色设置" class="headerlink" title="Vim中256色设置"></a>Vim中256色设置</h3><p>要让Vim很好的支持256色需要在<code>.vimrc</code>文件中进行下设置，添加以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> t_Co=256</span><br></pre></td></tr></table></figure><p>如果使用了配色主题插件，也要在插件设置进行类似的设置，以最流行的Solarized主题为例，需要加上以下设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> g:solarized_termcolors=256</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考资料：<br><a href="http://yysfire.github.io/linux/how-to-check-linux-terminal-whether-support-256-colors.html" target="_blank" rel="noopener">如何查看Linux终端是否支持256色</a><br><a href="https://github.com/icymind/NeoSolarized" target="_blank" rel="noopener">icymind/NeoSolarized</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Git部署警告&quot;warning： LF will be replaced by CRLF&quot;的去除方法</title>
      <link href="/2017/01/13/Hexo_Git_CRLF/"/>
      <url>/2017/01/13/Hexo_Git_CRLF/</url>
      
        <content type="html"><![CDATA[<p>Windows下在使用<code>hexo d</code>命令部署博客时，会出现下面这个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line">warning: LF will be replaced by CRLF in index.html.</span><br></pre></td></tr></table></figure><p>这个警告的意思很直接，就是Git会把<code>LF</code>替换为<code>CRLF</code>，不过这是无关紧要的，完全可以禁用此功能，这样还可以避免这个警告信息刷屏。设置方法也很简单，在MinGW窗口中输入以下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br></pre></td></tr></table></figure><blockquote><p>参考资料：<br><a href="http://stackoverflow.com/questions/17628305/windows-git-warning-lf-will-be-replaced-by-crlf-is-that-warning-tail-backwar" target="_blank" rel="noopener">Windows git “warning: LF will be replaced by CRLF”, is that warning tail backward?</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux彩色man page设置方法</title>
      <link href="/2017/01/13/Linux_Colourful_Man/"/>
      <url>/2017/01/13/Linux_Colourful_Man/</url>
      
        <content type="html"><![CDATA[<p>Ubuntu中默认的<code>man</code>帮助页面是黑白的，如果将其改成彩色的会更方便阅读。实现方法主要有三种：使用<code>most</code>、使用<code>terminfo</code>、配置<code>.bashrc</code>文件。本文将介绍最简单的第三种方法。</p><a id="more"></a><p>Linux下<code>man page</code>的显示默认是通过<code>less</code>来完成的，故在<code>.bashrc</code>文件中添加<code>less</code>的相关设置参数即可使<code>man page</code>变成彩色的:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># colourful man page</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_mb=$<span class="string">'\E[01;34m'</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_md=$<span class="string">'\E[01;34m'</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_me=$<span class="string">'\E[0m'</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_us=$<span class="string">'\E[01;32m'</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_ue=$<span class="string">'\E[0m'</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_so=$<span class="string">'\E[01;33;44m'</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_se=$<span class="string">'\E[0m'</span></span><br></pre></td></tr></table></figure><p>更改完<code>.bashrc</code>文件后要用<code>source .bashrc</code>命令重新载入一下配置，之后重启终端才会生效，以上配置显示效果如下：</p><p><img src="https://pic.gaomf.store/20170113183033.png-width600" alt=""></p><p>其中<code>LESS_TERMCAP_xx</code>的含义如下：</p><table><thead><tr><th><code>termcap</code></th><th>含义</th></tr></thead><tbody><tr><td><code>mb</code></td><td>start blink</td></tr><tr><td><code>md</code></td><td>start bold</td></tr><tr><td><code>me</code></td><td>turn off bold, blink and underline</td></tr><tr><td><code>us</code></td><td>start underline</td></tr><tr><td><code>ue</code></td><td>stop underline</td></tr><tr><td><code>so</code></td><td>start standout</td></tr><tr><td><code>se</code></td><td>stop standout</td></tr></tbody></table><p>对照上面实际的<code>man page</code>页面可以看到：<code>md</code>对应蓝色部分；<code>us</code>对应绿色部分；<code>so</code>对应底部黄色状态栏。</p><p>至于具体颜色设置方法，参考以下页面：</p><blockquote><p><a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors" target="_blank" rel="noopener">ANSI escape code - Colors</a></p></blockquote><p>简而言之，在<code>&#39;\E[0x;3y;4zm&#39;</code>中：<code>x</code>代表是否加粗，<code>1</code>为加粗，<code>2</code>为正常；<code>y</code>和<code>z</code>分别代表文字前景色和背景色，使用默认值的话可省略，颜色列表如下：</p><table><tr><th>Intensity</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr><tr><th>Normal</th><td style="background: black;color:white">Black</td><td style="background:maroon;color:white">Red</td><td style="background: green;color:white">Green</td><td style="background: olive;color:white">Yellow</td><td style="background: navy;color:white">Blue</td><td style="background: purple;color:white">Magenta</td><td style="background: teal;color:white">Cyan</td><td style="background: silver;color:black">White</td></tr><tr><th>Bright</th><td style="background: gray;color:white">Black</td><td style="background: red;color:black">Red</td><td style="background: lime;color:black">Green</td><td style="background: yellow;color:black">Yellow</td><td style="background: blue;color:white">Blue</td><td style="background: fuchsia;color:black">Magenta</td><td style="background: cyan;color:black">Cyan</td><td style="background: white;color:black">White</td></tr></table>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下让进程在后台可靠运行的方法</title>
      <link href="/2017/01/10/Linux_Background_Run/"/>
      <url>/2017/01/10/Linux_Background_Run/</url>
      
        <content type="html"><![CDATA[<p>在登录到Linux服务器后运行某程序，之后断开连接，那之前运行的程序就会被中止掉。这是由于新进程默认都是当前进程的子进程，断开连接关闭当前终端就会把它的所有子进程都结束掉。不过很多时候我们需要让程序稳定的一直运行下去，这时候就需要使用一些方法来处理此问题了。IBM有一篇很好的文章深入探讨了此问题，本文就是对它的简化总结：</p><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/" target="_blank" rel="noopener">Linux 技巧：让进程在后台可靠运行的几种方法</a></p></blockquote><a id="more"></a><p>下文使用<code>python test.py</code>作为示例命令。</p><h3 id="nohup-amp"><a href="#nohup-amp" class="headerlink" title="nohup &amp;"></a>nohup &amp;</h3><p><code>nohup</code>用于让提交的命令忽略<code>hangup</code>信号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># nohup python test.py</span><br></pre></td></tr></table></figure><p>一般同时加上<code>&amp;</code>把命令放到后台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># nohup python test.py &amp;</span><br></pre></td></tr></table></figure><h3 id="setsid"><a href="#setsid" class="headerlink" title="setsid"></a>setsid</h3><p><code>setsid</code>的作用是在一个新的<code>session</code>中运行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># setsid python test.py</span><br></pre></td></tr></table></figure><p>提交的新进程的父进程会是<code>init</code>，即<code>PPID=1</code>。</p><h3 id="amp"><a href="#amp" class="headerlink" title="( &amp;)"></a>( &amp;)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># (python test.py &amp;)</span><br></pre></td></tr></table></figure><p>提交的新进程的父进程也是<code>init</code>。</p><h3 id="disown"><a href="#disown" class="headerlink" title="disown"></a>disown</h3><p><code>disown</code>用于让某个已经在运行的程序忽略<code>hangup</code>信号，先将此任务放入后台中运行，之后使用如下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># disown -h %jobspec</span><br></pre></td></tr></table></figure><p>其中<code>jobspec</code>是任务的作业号。</p><h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p><code>screen</code>用于运行很多需要放到后台中稳定运行的命令时使用，用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># screen -dmS newScreen</span><br><span class="line"># screen -list</span><br><span class="line"># screen -r newScreen</span><br><span class="line"># python test.py</span><br></pre></td></tr></table></figure><p>详细说明见IBM的原始文章。另外，在Ubuntu下，默认是没有安装<code>screen</code>的，使用命令<code>apt-get install screen</code>进行安装即可。</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH连接自动断开的解决方法</title>
      <link href="/2017/01/10/SSH_Broken_Pipe/"/>
      <url>/2017/01/10/SSH_Broken_Pipe/</url>
      
        <content type="html"><![CDATA[<p>使用SSH连接远程服务器时，如果长时间不操作，SSH连接上就没有数据传输，此时连接会自动断开，常见的错误提示是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write failed: Broken pipe</span><br></pre></td></tr></table></figure><p>这种超时断开机制估计是出于安全考虑设计的，不过这也会对正常使用造成一定影响，需要进行一些设置来避免这一问题。</p><a id="more"></a><p>核心思路就是定时发送心跳包，这样就可以保证连接上始终有数据传输，就不会触发超时断开了。客户端<code>ssh</code>和服务器端<code>sshd</code>均支持此功能，只需要配置一下就可以了，以下方法选择其一即可。</p><h3 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h3><p>如果在服务器端进行配置的话，所有连接到此服务器的会话都会产生效果。</p><p>修改<code>/etc/ssh/sshd_config</code>文件，在其中添加一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClientAliveInterval  30</span><br></pre></td></tr></table></figure><p>这样服务器端每隔30s就会向客户端发送一个<code>keep-alive</code>包，以此保持连接不会断开。还可以指定发送<code>keep-alive</code>包的最大次数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClientAliveCountMax  60</span><br></pre></td></tr></table></figure><p>若发送了60个<code>keep-alive</code>包后客户端依然没有响应，则断开SSH连接，如果不指定此参数的话会一直发送下去，也就是永远不断开连接。</p><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><p>如果没有服务器端的权限，也可在客户端进行配置，这样这个客户端所发起的所有会话都会产生效果。</p><p>修改<code>/etc/ssh/ssh_config</code>文件，与服务器端配置类似，添加以下两个参数即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerAliveInterval  </span><br><span class="line">ServerAliveCountMax</span><br></pre></td></tr></table></figure><p>此时就是客户端定时向服务器端发送<code>keep-alive</code>包。</p><h3 id="会话配置"><a href="#会话配置" class="headerlink" title="会话配置"></a>会话配置</h3><p>如果不希望或不能修改配置文件，也可以在每次建立SSH连接时通过<code>-o</code>参数指定当前会话配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -o ServerAliveInterval=30 root@192.168.1.1</span><br></pre></td></tr></table></figure><blockquote><p>参考资料：<br><a href="http://www.cnblogs.com/livingintruth/p/3473627.html" target="_blank" rel="noopener">ssh连接linux服务器不断开－ “Write failed: Broken pipe”</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware中收缩Linux虚拟机体积</title>
      <link href="/2017/01/03/VMware_Shrink_Linux/"/>
      <url>/2017/01/03/VMware_Shrink_Linux/</url>
      
        <content type="html"><![CDATA[<p>虚拟机使用一段时间后体积会越来越大，特别是进行了大程序编译等很占空间的行为后，虚拟磁盘文件经常会占用数十G的空间。而且就算之后删除了无用文件，虚拟磁盘文件的体积也不会自动缩小。此时就需要借助VMware Tools进行磁盘空间收缩。</p><a id="more"></a><p>在正确安装了VMware Tools的前提下，<code>root</code>下执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmware-toolbox-cmd disk shrink /</span><br></pre></td></tr></table></figure><p>命令中最后一个参数是虚拟磁盘的挂载点，一般就是<code>/</code>。最后若出现<code>disk shrinking complete</code>即代表压缩完成，此时在Windows资源管理器中即可看到虚拟磁盘文件的体积显著缩小，基本上就与虚拟机实际已使用空间一样大（可使用<code>df</code>确认）。</p><hr><p>若输入上述命令后提示<code>Shrink disk is disabled for this virtual machine.</code>，需要检查是否存在快照（snapshot）、是否被预分配（preallocated）、是否存在不能收缩的物理硬盘等情况。我就是因为之前<a href="/2016/12/28/VMware_Internal_SD/">添加了一块虚拟硬盘用于访问SD卡</a>，直接使用上述命令收缩硬盘就会报错，把这个虚拟硬盘删掉后即可正常收缩。</p><blockquote><p>参考资料：<br><a href="http://blog.csdn.net/cymm_liu/article/details/11963687" target="_blank" rel="noopener">vmware 收缩硬盘大小（compat，shrink，vmware-vdiskmanager）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware虚拟机中使用电脑内置SD读卡器</title>
      <link href="/2016/12/28/VMware_Internal_SD/"/>
      <url>/2016/12/28/VMware_Internal_SD/</url>
      
        <content type="html"><![CDATA[<p>为树莓派SD卡烧写系统时，需要先在虚拟机中识别到SD卡。笔记本电脑有一个内置的SD读卡器，不过将SD卡插入后，虚拟机中是无法直接找到SD卡设备的，需要我们手动添加一下。</p><a id="more"></a><p>如果使用的是外置USB读卡器，连接上电脑后VMware就会自动发现新的可移动设备，此时选择连接到虚拟机即可正常使用。不过笔记本内置的SD读卡器应该是直接连到PCIe总线上的，并不是一个USB设备，插入SD卡后，相关驱动使其在系统中表现为一块硬盘，这一点可以打开磁盘管理器确认：</p><p><img src="https://pic.gaomf.store/20161228145141.png" alt=""></p><p>此时，要想在虚拟机中访问SD卡，最好的方式就是<strong>添加一块虚拟硬盘，以硬盘的方式去访问SD卡</strong>，具体步骤可参考以下文章：</p><blockquote><p><a href="http://www.htpcguides.com/how-to-use-sd-card-reader-in-vmplayer-and-vmworkstation/" target="_blank" rel="noopener">How to Use SD Card Reader in VMPlayer and VMWorkstation</a></p></blockquote><p>其中虚拟硬盘类型选择<code>IDE</code>、<code>SCSI</code>或<code>SATA</code>都是可以正常使用的，重点在于必须要选择使用完整的磁盘，且设备要选择正确：</p><p><img src="https://pic.gaomf.store/20161228150035.png" alt=""></p><p>设备名称在主机Windows系统下的磁盘管理器中可以看到。需要注意的是，<strong>如果是在打开了VMware后再插入SD卡，VMware是无法识别到新硬盘设备的，此时重启VMware后即可正常识别</strong>。另外，在移除SD卡后需要同时移除这个虚拟硬盘，否则系统无法正常启动。</p><p>设置完成后打开Ubuntu虚拟机，使用<code>sudo fdisk -l</code>命令即可列出所有的硬盘设备，如果添加正确的话就可以看到名为<code>/dev/sd*</code>的SD卡了。</p><p>另外值得一提的是，在我的系统环境下，无论添加的是<code>IDE</code>还是<code>SATA</code>类型的虚拟硬盘，其名称均为<code>/dev/sd*</code>，并不会存在<code>/dev/hd*</code>。只是选择<code>IDE</code>设备的话，新添加的SD卡会出现在前面，即<code>/dev/sda</code>；选择<code>SATA</code>或<code>SCSI</code>设备的话，SD卡会在已有硬盘后面，即<code>/dev/sdb</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware Ubuntu虚拟机中为终端配置Shadowsocks代理</title>
      <link href="/2016/12/27/VMWare_Ubuntu_Terminal_Shadowsocks/"/>
      <url>/2016/12/27/VMWare_Ubuntu_Terminal_Shadowsocks/</url>
      
        <content type="html"><![CDATA[<p>很多常用的终端命令操作是需要联网的，比如<code>git clone</code>等，然而由于墙的存在，很多像Github这样的网站访问可靠性极差，或者直接就无法访问，这时候就需要梯子了……只使用浏览器时很简单，<code>Chrome SwitchyOmega</code> + <code>Shadowsocks</code>的方案很完美，不过涉及到终端命令时这种方案就无能为力了，此时需要使用其它一些方法来解决。</p><a id="more"></a><p>最终目标是：虚拟机中的Ubuntu系统可以使用运行于主机Windows系统中的Shadowsocks代理服务器上网，且终端命令一样可以使用代理。</p><p>解决方案是使用<a href="http://proxychains.sourceforge.net/" target="_blank" rel="noopener">ProxyChains</a>这个软件，安装过程很简单:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install proxychains</span><br></pre></td></tr></table></figure><p>之后新建一个配置文件<code>~/.proxychains/proxychains.conf</code>：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">strict_chain</span><br><span class="line">proxy_dns </span><br><span class="line">remote_dns_subnet <span class="number">224</span></span><br><span class="line">tcp_read_time_out <span class="number">15000</span></span><br><span class="line">tcp_connect_time_out <span class="number">8000</span></span><br><span class="line">localnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">quiet_mode</span><br><span class="line"></span><br><span class="line">[ProxyList]</span><br><span class="line">socks5  <span class="number">192.168</span><span class="number">.175</span><span class="number">.1</span> <span class="number">1080</span></span><br></pre></td></tr></table></figure><p>前半部分是对ProxyChains的设置，来源于以下文章：</p><blockquote><p><a href="https://segmentfault.com/a/1190000002589135" target="_blank" rel="noopener">命令行工具下使用Shadowsocks</a></p></blockquote><p>最后的<code>[ProxyList]</code>显然就是代理服务器设置，一般情况下都设置为本机<code>127.0.0.1</code>，然而这是针对Shadowsocks服务器运行于当前系统上使用的设置，此处主机Windows系统中已经运行了一个Shadowsocks服务器，我们可以直接使用这个服务器，只要将此处的IP地址设置为主机IP地址即可。</p><p>VMware虚拟机与宿主机之间的网络连接一般是通过NAT方式，在Ubuntu中使用<code>route</code>命令可以列出此时的路由表，从默认网关中可以推断出主机的IP地址，当然，也可以在VMware的网络设置中看到NAT转发中主机的IP地址，此处即为<code>192.168.175.1</code>。</p><p>最后，在Windows的Shadowsocks客户端中，需要选择“<strong>允许来自局域网的连接</strong>”，否则虚拟机是无法正常访问主机的Shadowsocks服务器的。</p><hr><p>安装配置完成后，即可通过<code>proxychains</code>来运行命令，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains git <span class="built_in">clone</span> https://github.com/g199209/Spider.git</span><br><span class="line">proxychains curl http://www.google.com</span><br></pre></td></tr></table></figure><p>在需要运行的命令前加上<code>proxychains</code>即可。</p><p>如果有大量命令均需要翻墙的话，这样输入会比较麻烦，此时可以使用<code>proxychain bash</code>命令新建一个bash，在此bash中输入的任何命令均会使用<code>proxychains</code>。</p><p>需要测试是否成功翻墙可使用<code>curl ip.gs</code>，这是一个测试当前IP地址的网站，通过返回的IP地址地理位置，可以很容易的判断出当前是否使用了Shadowsocks代理。</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS2015 &amp; Qt中文编码方式</title>
      <link href="/2016/12/12/VS2015_Qt_UTF8/"/>
      <url>/2016/12/12/VS2015_Qt_UTF8/</url>
      
        <content type="html"><![CDATA[<p>Linux下中文编码方式很好解决，统一用<code>UTF-8</code>就没问题了，然而在Windows下这个简单的问题会有很多坑……为了在VS中让Qt正确显示中文，折腾了好久终于尝试出一个可用的方法，记录如下。</p><a id="more"></a><p>Linux和Qt内部都是使用<code>UTF-8</code>处理字符的，故考虑到跨平台的需求，将源代码保存为<code>UTF-8</code>格式兼容性最好。然而如果使用不带签名的<code>UTF-8</code>格式（即Unicode(UTF-8 无签名) - 代码页 65001）保存的话，在程序中存在奇数个字符的中文字符串时，无法正常编译，此时会出现<code>error C2001:常量中有换行符</code>。关于这个问题可参考：</p><blockquote><p><a href="http://www.cnblogs.com/kuliuheng/p/3397796.html" target="_blank" rel="noopener">Visual Studio error C2001:常量中有换行符（解决办法）</a></p></blockquote><p>结论就是不要使用无签名的<code>UTF-8</code>编码源文件，无比的坑啊……另一篇文章中比较了各种编码格式的兼容性：</p><blockquote><p><a href="http://www.cnblogs.com/zyl910/archive/2012/07/26/cfile_utf8.html" target="_blank" rel="noopener">[C/C++] 各种C/C++编译器对UTF-8源码文件的兼容性测试（VC、GCC、BCB）</a></p></blockquote><p>结论是使用带签名的<code>UTF-8</code>格式（即Unicode(UTF-8 带签名) - 代码页 65001）是兼容性最好的选择。选择了这种编码方式后可以正常编译含有中文字符串的源文件了，不过要是不做任何设置的话，此时在Qt中显示出来的效果会是乱码。</p><p>为了正确显示中文，需要在使用到中文的源文件头部加上这样一句预编译指令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> execution_character_set(<span class="meta-string">"utf-8"</span>)</span></span><br></pre></td></tr></table></figure><p>这条预编译指令的作用是指定字符串的输出编码方式为<code>UTF-8</code>，注意，这与文件本身的编码方式没有关系。详细说明可参考MSDN：</p><blockquote><p><a href="https://msdn.microsoft.com/en-us/library/mt708823.aspx" target="_blank" rel="noopener">execution_character_set</a></p></blockquote><p>MSDN中还提到，这条指令已经要过时了，需要使用新方法来替代，不过目前还能使用，就不再折腾了……这条指令也是VS下特有的，GCC没有也不需要这个设置，故加上条件编译来保证跨平台移植的兼容性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> execution_character_set(<span class="meta-string">"utf-8"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样设置后，Qt中就可以正确显示中文了。需要注意的是，其实并没有必要使用<code>QTextCodec::setCodecForLocale(QTextCodec::codecForName(&quot;UTF-8&quot;))</code>来指定Qt的编码方式，因为默认情况下使用的就是<code>UTF-8</code>编码方式。</p>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV与Qt结合使用</title>
      <link href="/2016/12/10/OpenCV_and_Qt/"/>
      <url>/2016/12/10/OpenCV_and_Qt/</url>
      
        <content type="html"><![CDATA[<p>OpenCV本身能生成的GUI界面极为简陋，故一般使用MFC或Qt等框架来搭建GUI界面，并将OpenCV嵌入进去。因为我之前也用过Qt，故此处选择了Qt作为GUI框架，二者结合的主要问题在于图片的显示上，本文就以最新的OpenCV3及Qt5为例介绍一下实现方法。</p><a id="more"></a><h2 id="基本环境的搭建"><a href="#基本环境的搭建" class="headerlink" title="基本环境的搭建"></a>基本环境的搭建</h2><p>首先保证独立的Qt及OpenCV程序都能在VS上正常的编译运行起来。</p><h3 id="相关版本"><a href="#相关版本" class="headerlink" title="相关版本"></a>相关版本</h3><p>Windows 10 64-bit<br>Visual Studio 2015<br>OpenCV 3.1<br>Qt 5.7</p><h3 id="Qt-VS"><a href="#Qt-VS" class="headerlink" title="Qt @ VS"></a>Qt @ VS</h3><blockquote><p>参考之前的文章：<a href="/2016/12/09/VS2015_Qt5_7/">VS2015搭建Qt 5.7开发环境</a></p></blockquote><p>注意Qt要选32-bit，以便和OpenCV兼容。</p><h3 id="OpenCV-VS"><a href="#OpenCV-VS" class="headerlink" title="OpenCV @ VS"></a>OpenCV @ VS</h3><blockquote><p>参考之前的文章：<a href="/2016/12/06/VS2015_OpenCV31/">VS2015下编译OpenCV 3.1</a></p></blockquote><p>需要注意的是，CMake配置时有一个<code>WITH_QT</code>选项，这个选项是指OpenCV的<code>highgui</code>模块本身是否使用Qt，似乎可以不选这个选项的。如果选择了<code>WITH_QT</code>，点击<code>Configure</code>后会出现新的Qt相关路径的选项，如果Qt安装正常的话，这里的路径是会自动生成的：</p><p><img src="https://pic.gaomf.store/20161209223450.png" alt=""></p><p>点击<code>Generate</code>后会出现很多如下warning：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMake Warning (dev) in modules/highgui/CMakeLists.txt:</span><br><span class="line">  Policy CMP0020 is not set: Automatically link Qt executables to qtmain</span><br><span class="line">  target on Windows.  Run &quot;cmake --help-policy CMP0020&quot; for policy details.</span><br><span class="line">  Use the cmake_policy command to set the policy and suppress this warning.</span><br><span class="line">This warning is for project developers.  Use -Wno-dev to suppress it.</span><br></pre></td></tr></table></figure><p>相关解释可以参考<a href="https://cmake.org/cmake/help/v3.0/policy/CMP0020.html" target="_blank" rel="noopener">这里</a>，直接忽略这个警告即可。</p><p>另外，在编译OpenCV时也会出现很多和Qt有关的Warning，不过没有Error，可以忽略。</p><p>选择了<code>WITH_QT</code>后，<code>highgui</code>本身的窗口界面会变成基于Qt的，比原来要好看一些，而且自动集成了一些图片缩放、保存等功能：</p><p><img src="https://pic.gaomf.store/20161209224409.png-width600" alt=""></p><p>不过这还是满足不了我们自由设计GUI界面的需求，接下来就要讨论如何在Qt项目中使用OpenCV。</p><h2 id="数据结构转换算法"><a href="#数据结构转换算法" class="headerlink" title="数据结构转换算法"></a>数据结构转换算法</h2><p>OpenCV中使用<code>Mat</code>保存图片，而Qt中则使用<code>QImage</code>或<code>QPixmap</code>，故二者结合的核心就在于这两个类之间的转换。网上已经有人实现了转换代码：</p><blockquote><p><a href="https://asmaloney.com/2013/11/code/converting-between-cvmat-and-qimage-or-qpixmap/" target="_blank" rel="noopener">Converting Between cv::Mat and QImage or QPixmap</a></p></blockquote><p>经实际测试，上述代码基本是可以正常使用的，只是有一些小Bug需要修正下，后文会具体说明。这里将其中<code>Mat</code>-&gt;<code>QImage</code>的核心代码摘录备份如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">QImage cvMatToQImage( <span class="keyword">const</span> cv::Mat &amp;inMat )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">switch</span> ( inMat.type() )</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">// 8-bit, 4 channel</span></span><br><span class="line">     <span class="built_in">case</span> CV_8UC4:</span><br><span class="line">     &#123;</span><br><span class="line">        QImage <span class="built_in">image</span>( inMat.data,</span><br><span class="line">                      inMat.cols, inMat.rows,</span><br><span class="line">                      <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(inMat.<span class="built_in">step</span>),</span><br><span class="line">                      QImage::Format_ARGB32 );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">image</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 8-bit, 3 channel</span></span><br><span class="line">     <span class="built_in">case</span> CV_8UC3:</span><br><span class="line">     &#123;</span><br><span class="line">        QImage <span class="built_in">image</span>( inMat.data,</span><br><span class="line">                      inMat.cols, inMat.rows,</span><br><span class="line">                      <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(inMat.<span class="built_in">step</span>),</span><br><span class="line">                      QImage::Format_RGB888 );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">image</span>.rgbSwapped();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 8-bit, 1 channel</span></span><br><span class="line">     <span class="built_in">case</span> CV_8UC1:</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">static</span> QVector&lt;QRgb&gt;  sColorTable( <span class="number">256</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// only create our color table the first time</span></span><br><span class="line">        <span class="comment">// 注意：下面这种写法是错的，参考后文的说明</span></span><br><span class="line">        <span class="built_in">if</span> ( sColorTable.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i )</span><br><span class="line">           &#123;</span><br><span class="line">              sColorTable[i] = qRgb( i, i, i );</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        QImage <span class="built_in">image</span>( inMat.data,</span><br><span class="line">                      inMat.cols, inMat.rows,</span><br><span class="line">                      <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(inMat.<span class="built_in">step</span>),</span><br><span class="line">                      QImage::Format_Indexed8 );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">image</span>.setColorTable( sColorTable );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">image</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">default</span>:</span><br><span class="line">        <span class="comment">// qWarning() &lt;&lt; "cvMatToQImage() - cv::Mat image type not handled in switch:" &lt;&lt; inMat.type();</span></span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> QImage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上述代码在处理<code>CV_8UC1</code>类型时存在Bug</strong>，<code>sColorTable.isEmpty()</code>这个判断永远都是不会为真的，即使是在第一次执行时。解决方法有以下几种：<br>1.直接去掉这个<code>if</code>判断，此做法的缺点是每次都会生成颜色表，效率不高；<br>2.使用<code>sColorTable</code>中元素的值来判断是否初始化过了；<br>3.一般使用时会将这个方法封装在一个类中，此时可以将<code>sColorTable</code>设置为类变量，在构造函数中初始化即可。</p><p>以上这种方法相当于调用构造函数生成了一个新的QImage，然后复制图像数据过去。另一种思路可参考以下链接：</p><blockquote><p><a href="http://mobile.51cto.com/symbian-271260.htm" target="_blank" rel="noopener">详解 QT 框架中快速应用OpenCV 基于图片 上篇</a></p></blockquote><h2 id="Qt中图片的显示"><a href="#Qt中图片的显示" class="headerlink" title="Qt中图片的显示"></a>Qt中图片的显示</h2><p>最简单的办法是使用<code>QLabel</code>，更高效一些的方法是使用<code>QWidget</code>。使用<code>QLabel</code>时只需调用<code>setPixmap()</code>方法设置图片即可，<code>QPixmap</code>与<code>QImage</code>间的转换可用<code>QPixmap::fromImage()</code>函数完成。另外，使用<code>QLabel</code>的<code>setScaledContents()</code>方法可以设置图像自动缩放。</p><p>给出一个完整的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mat inputimg = imread(<span class="string">"pic.jpg"</span>);</span><br><span class="line">QImage img = cvMatToQImage(inputimg);</span><br><span class="line">ui.label-&gt;setScaledContents(<span class="literal">true</span>);</span><br><span class="line">ui.label-&gt;setPixmap(QPixmap::fromImage(img));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS2015搭建Qt 5.7开发环境</title>
      <link href="/2016/12/09/VS2015_Qt5_7/"/>
      <url>/2016/12/09/VS2015_Qt5_7/</url>
      
        <content type="html"><![CDATA[<p>Qt自带的IDE Qt Creator还是比较好用的，如果只开发纯粹的Qt程序使用Creator很方便。不过很多时候Qt只是作为GUI接口，程序的核心其实是其他部分，比如我在项目中用到的OpenCV等，这时如果能将Qt集成到VS中使用会更方便。本文以最新版的Qt 5.7及VS2015为例介绍集成方法。</p><a id="more"></a><h2 id="安装Qt"><a href="#安装Qt" class="headerlink" title="安装Qt"></a>安装Qt</h2><p>可以从<a href="https://www.qt.io/download-open-source/#section-2" target="_blank" rel="noopener">Qt官网</a>上下载其预编译版本，我选用的是<code>Qt 5.7.0 for Windows 32-bit (VS 2015)</code>，因为之前编译OpenCV只能使用32位（<a href="/2016/12/06/VS2015_OpenCV31/">链接</a>），故此处的Qt也选用了32位。在Windows上使用一般来说没有必要自行编译源代码，使用官方编译好的版本即可。</p><p>安装过程就是正常的程序安装过程，没有什么特殊的地方。</p><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><p>将Qt的bin目录<code>...\5.7\msvc2015\bin</code>添加到<code>PATH</code>中，这是为了在运行程序的时候能找到Qt的<code>dll</code>文件。</p><h2 id="安装VS插件"><a href="#安装VS插件" class="headerlink" title="安装VS插件"></a>安装VS插件</h2><p>之前Qt的VS插件叫做<code>Qt VS Addin</code>，这个插件似乎现在不能用了，不过我们可以用<a href="https://marketplace.visualstudio.com/items?itemName=havendv.QtPackage" target="_blank" rel="noopener">QtPackage</a>这个插件来替代。下载安装完成后，打开VS配置Qt路径：</p><p><img src="https://pic.gaomf.store/VSQT.gif" alt=""></p><p>其中名字任意取，路径要选择<code>bin\</code>文件夹所在的位置。确定后<strong>重启VS</strong>，再新建项目即有Qt相关的选项：</p><p><img src="https://pic.gaomf.store/20161209214416.png" alt=""></p><h2 id="配置工程"><a href="#配置工程" class="headerlink" title="配置工程"></a>配置工程</h2><p>建立好Qt项目后，需要添加包含目录及库目录：</p><ul><li>包含目录：<code>...\5.7\msvc2015\include\</code>; <code>$(ProjectDir)\GeneratedFiles</code></li><li>库目录：<code>...\5.7\msvc2015\lib\</code></li></ul><p>其中第二个包含目录是指当前工程的<code>GeneratedFiles</code>文件夹，由窗体文件自动生成的<code>ui_***.h</code>文件均位于这个文件夹中。</p><p>配置好后即可正常编译运行~不过需要注意的是，<strong>第一次编译运行必须选择“开始调试”，选择“生成解决方案”等会出错，且成功运行一次之后还需要执行一次“重新扫描解决方案”智能感知提示才正确。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://my.oschina.net/jthmath/blog/640227" target="_blank" rel="noopener">将 Qt 5.6 集成至 VS2015</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS2015下编译OpenCV 3.1</title>
      <link href="/2016/12/06/VS2015_OpenCV31/"/>
      <url>/2016/12/06/VS2015_OpenCV31/</url>
      
        <content type="html"><![CDATA[<p>本文介绍一下如何从源码编译OpenCV 3.1，使用的环境是Win10 64bit + VS 2015。</p><a id="more"></a><h2 id="下载源文件"><a href="#下载源文件" class="headerlink" title="下载源文件"></a>下载源文件</h2><ol><li><a href="https://github.com/opencv/opencv/releases" target="_blank" rel="noopener">OpenCV 3.1 Release</a></li><li><a href="https://cmake.org/download/" target="_blank" rel="noopener">CMake GUI 3.7.1</a></li></ol><h2 id="运行Cmake"><a href="#运行Cmake" class="headerlink" title="运行Cmake"></a>运行Cmake</h2><p>打开CMake GUI，选择<code>Browse Source...</code>指定源文件路径，<code>Browse Build...</code>指定目标文件路径；之后点击<code>Configure</code>，会弹出一个对话框选择<code>Generator</code>，对于VS2015来说选<code>Visual Studio 14 2015</code>或<code>Visual Studio 14 2015 Win64</code>，前者是32位，后者是64位。确定后CMake会自动下载一些依赖文件，所以需要保证良好的网络连接，不过其中<code>ippicv_windows_20151201.zip</code>文件会因为网络问题始终无法成功下载，可以从网上搜索这个文件下载下来，比如从<a href="https://pan.baidu.com/s/1o7efLdK" target="_blank" rel="noopener">这里</a>。</p><p>如果最终的状态是<code>Configuring done</code>，且列出了此时可用的设置，说明配置成功，再点击<code>Generate</code>即可生成VS工程，默认的配置是可以正常编译使用的。</p><p><strong>需要注意的是，选择Win32编译32位版本是完全正常的，不过选择Win64编译64位版本时，Debug版可以正常编译通过，而Release版则无法编译成功，显示编译器内部错误，根据网上的资料这应该是VS2015的Bug。故使用VS2015编译OpenCV 3.1时建议使用32位模式进行编译。</strong></p><h2 id="VS编译"><a href="#VS编译" class="headerlink" title="VS编译"></a>VS编译</h2><p>点击<code>Open Project</code>按钮打开生成的VS工程，待其完全载入后即可编译了，需要注意的是，不要使用默认的生成解决方案（F7）进行编译，这样最终得到的<code>install</code>文件夹中的内容是不全的。正确方法是在<code>INSTALL</code>工程上点右键，选择生成，单独编译生成此工程。</p><p>正常情况下是可以成功编译生成的，最终的得到的所有所需文件都位于目标文件路径下<code>.\install</code>文件夹中，其中<code>.\install\include</code>文件夹中存放的是头文件，<code>.\install\x64\vc14\bin</code>文件夹中是dll动态链接库文件，<code>.\install\x64\vc14\lib</code>和<code>.\install\x64\vc14\staticlib</code>中都是库文件。</p><p><strong>不过如果想对OpenCV源码进行Debug跟踪，是不能选用<code>.\install</code>文件夹中的库文件的，因为此处缺少<code>.pdb</code>调试文件，无法正常Debug。此时需要使用<code>.\lib</code>文件夹中的库文件，这时可以正常的跟踪到源代码中，且使用profiler分析代码性能时也可以正确定位到OpenCV内部函数上。</strong></p><h2 id="定制优化OpenCV"><a href="#定制优化OpenCV" class="headerlink" title="定制优化OpenCV"></a>定制优化OpenCV</h2><p>上面生成的文件已经是可以正常使用的了，不过自行编译源代码的一大优点就是可以根据自己的需求进行配置。</p><h3 id="使用World模块"><a href="#使用World模块" class="headerlink" title="使用World模块"></a>使用World模块</h3><p>默认情况下编译结果是很多的<code>lib</code>文件及<code>dll</code>文件，使用起来不是很方便，OpenCV提供了一个<code>World Module</code>的功能，可以把生成的文件链接在一起，合成一个<code>dll</code>及<code>lib</code>文件。选取<code>BUILD_opencv_world</code>即可。不过实际测试表明，使用了World模块后编译的时间会明显变长，故是否使用根据需要决定。</p><h3 id="去除不需要的功能"><a href="#去除不需要的功能" class="headerlink" title="去除不需要的功能"></a>去除不需要的功能</h3><p>根据需要去掉一些不需要的功能即可，如<code>WITH_1394</code>等。</p><h3 id="开启CPU指令集支持"><a href="#开启CPU指令集支持" class="headerlink" title="开启CPU指令集支持"></a>开启CPU指令集支持</h3><p>根据使用的CPU，可以开启<code>ENABLE_AVX</code>、<code>ENABLE_FMA3</code>等矢量指令集支持功能，以提高整体性能。</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组循环移位算法</title>
      <link href="/2016/11/28/Array_Shift/"/>
      <url>/2016/11/28/Array_Shift/</url>
      
        <content type="html"><![CDATA[<p>给定一个数组，将其循环右移（或左移）k位，要求时间复杂度为O(N)，空间复杂度为O(1)。</p><a id="more"></a><h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><p>OJ系统可参考以下链接：</p><blockquote><p><a href="https://www.patest.cn/contests/pat-b-practise/1008" target="_blank" rel="noopener">https://www.patest.cn/contests/pat-b-practise/1008</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先用几个简单的例子分析下：</p><p>原数组 ：1 2 3 4 5 6 7 8<br>右移1位：8 1 2 3 4 5 6 7<br>右移3位：6 7 8 1 2 3 4 5<br>右移7位：2 3 4 5 6 7 8 1</p><p>从中很容易看出，右移<code>k</code>位即是将数组最后<code>k</code>个元素与之前的元素整体交换位置。问题的关键就是如何不用辅助空间在线性时间内实现这一交换过程。</p><p>解决这一问题依赖于以下数学原理：</p><p>假设$X$、$Y$为两个序列，$X^T$代表其反转序列（即reverse），$XY$代表两个序列的拼接，则有以下结论：</p><p>$$(X^T)^T=X$$<br>$$(XY)^T=Y^TX^T$$</p><p>我们要实现的交换过程其实就是将$XY$变换为$YX$，根据以上公式有：</p><p>$$YX=(X^TY^T)^T$$</p><p>这就是所谓的经典三步翻转法。</p><p>根据以上原理很容易就可以写出代码，只需要注意两点：</p><ol><li>左移<code>k</code>位就相当于右移<code>N-k</code>位，故只需考虑一种情况即可；</li><li>移位<code>k</code>位和移位<code>k+N</code>位结果完全相同，故只需考虑<code>k % N</code>的情况即可。</li></ol><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k为正代表右移，k为负代表左移</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArrayShift</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> N, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    k = -k;</span><br><span class="line">    k %= N;</span><br><span class="line">    k = N - k;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    k %= N;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reverse(A, A + N - k);</span><br><span class="line">  reverse(A + N - k, A + N);</span><br><span class="line">  reverse(A, A + N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>reverse()</code>函数实现反转数组，在C++中可以直接使用<code>&lt;algorithm&gt;</code>头文件中的<code>reverse()</code>函数来实现。若使用C语言，自行实现此函数即可，注意要正确处理当<code>k=0</code>时<code>reverse(A+N, A+N)</code>的情况。</p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为Hexo博客移动端添加搜索功能</title>
      <link href="/2016/11/25/Blog_Search_Mobile/"/>
      <url>/2016/11/25/Blog_Search_Mobile/</url>
      
        <content type="html"><![CDATA[<p>之前已经为博客的PC端界面添加了搜索功能，用起来效果不错，不过美中不足的是，使用手机访问的时候并不能使用搜索功能。这几天折腾了一下，终于给移动端界面上也加上了搜索功能~这里来记录一下实现方法。</p><a id="more"></a><p>之前为博客添加搜索功能的方法见：</p><blockquote><p><a href="/2016/10/10/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2Yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/">为Hexo博客Yilia主题添加本地站内搜索功能</a></p></blockquote><p>要为移动端添加搜索功能，主要就是添加搜索框及搜索结果HTML样式及添加相关JS代码。</p><h2 id="添加搜索框及搜索结果区"><a href="#添加搜索框及搜索结果区" class="headerlink" title="添加搜索框及搜索结果区"></a>添加搜索框及搜索结果区</h2><p>当前主题在移动端的布局中，点击左上角的菜单按钮就会弹出一个显示友情链接、标签等信息的叠层，综合看下来将搜索框添加在这个位置较合适，最终的效果如图：</p><p><img src="https://pic.gaomf.store/20161125210304.png" alt=""></p><p>这里的搜索框和PC端基本是一样的，只是样式上做了些变化，使得整体效果更和谐。找到合适的位置添加搜索框及搜索结果区的HTML代码即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"search-form_mobile"</span>  <span class="attr">class</span>=<span class="string">"search_mobile"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"st-search-input_mobile"</span> <span class="attr">name</span>=<span class="string">"q"</span> <span class="attr">results</span>=<span class="string">"0"</span> <span class="attr">class</span>=<span class="string">"st-default-search-input_mobile"</span> <span class="attr">maxlength</span>=<span class="string">"50"</span> <span class="attr">placeholder</span>=<span class="string">"Search..."</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span> <span class="attr">autocorrect</span>=<span class="string">"off"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-times"</span> <span class="attr">onclick</span>=<span class="string">"resetSearch_mobile()"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"search_hint"</span> <span class="attr">class</span>=<span class="string">"search-hint"</span>&gt;</span>向右滑动结果打开链接~<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"local-search-result_mobile"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"no-result"</span>&gt;</span>No results found <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-spinner fa-pulse"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"loading-xml"</span>&gt;</span>Loading XML File... <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-spinner fa-pulse"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>布局和PC端的稍有差异，搜索结果区和搜索框放在了同一个<code>form</code>里面。CSS样式此处从略，如有兴趣可参考源文件：<a href="https://github.com/g199209/BlogTheme/blob/master/source/css/_partial/search.styl" target="_blank" rel="noopener">search.styl</a></p><h2 id="添加JS代码"><a href="#添加JS代码" class="headerlink" title="添加JS代码"></a>添加JS代码</h2><p>此主题移动端的时候使用的JS文件为<code>mobile.js</code>（PC端是<code>pc.js</code>），按照PC端的做法添加相关代码即可，注意搜索框等的名字要改为对应的移动端名字。这样修改后是可以实现基本功能了，然而用起来会有各种Bug，这两天的时间就主要花在解决这些Bug上了……</p><h3 id="解决触摸无响应问题"><a href="#解决触摸无响应问题" class="headerlink" title="解决触摸无响应问题"></a>解决触摸无响应问题</h3><p>直接把代码移植过来的第一个问题就是，在手机上那个搜索框实际上是没有用的，无法点击进行输入……具体原因并不清楚，只找到了可用的解决方案。在JS文件<code>search</code>函数中添加以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理移动端搜索框无法点击的问题</span></span><br><span class="line">inputArea.addEventListener(<span class="string">"touchstart"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    inputArea.focus();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">resetButton.addEventListener(<span class="string">"touchstart"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $resetButton.click();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>监听<code>touchstart</code>事件，并通过程序触发<code>focus</code>及<code>click</code>事件。</p><h3 id="解决滚动异常问题"><a href="#解决滚动异常问题" class="headerlink" title="解决滚动异常问题"></a>解决滚动异常问题</h3><p>加上以上代码后可以搜索了，只是搜索结果的滚动有各种奇怪的问题……比如只有输入单个字符的时候可以滚动、会发生点击穿透导致后面的页面滚动、只能按住标题进行滚动等等……各种尝试后决定不去解决这些问题了，直接监听触摸事件，自己重写滚动响应及滑动打开的代码。</p><p>基本思路是这样的：</p><ul><li>在<code>touchstart</code>事件中记录触摸开始的坐标点，并且判断是按在了哪个搜索结果条目上；</li><li>在<code>touchmove</code>事件中获取手指移动的方向，判断是进行垂直滚动还是水平移动搜索条目（用于打开搜索结果），之后修改对应元素的<code>marginTop</code>或<code>marginLeft</code>属性即可实现界面元素的移动；</li><li>最后在<code>touchend</code>事件中判断是否发生了滑动打开链接事件，如果有的话打开对应链接。</li></ul><p>需要注意的是，要调用<code>preventDefault()</code>来阻止触摸事件的传递，以避免各种奇怪的问题。除了基本逻辑外，还做了些处理让视觉效果更好看些，具体见以下的实现代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">TouceArea.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TouceArea.ontouchstart = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录起始点坐标</span></span><br><span class="line">    MarginOffset = <span class="built_in">parseInt</span>(ScrollArea.style.marginTop.replace(<span class="string">"px"</span>, <span class="string">""</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(MarginOffset)) &#123;</span><br><span class="line">        MarginOffset =  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StartY = e.touches[<span class="number">0</span>].pageY ;</span><br><span class="line">    StartX = e.touches[<span class="number">0</span>].pageX;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Clear Lock</span></span><br><span class="line">    ScrollVerticalLock = <span class="literal">false</span>;</span><br><span class="line">    ScrollHorizontalLock = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出点击了哪个选项</span></span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">    <span class="keyword">if</span> (TouceArea.children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> liArea;</span><br><span class="line">        <span class="keyword">var</span> i;</span><br><span class="line">        TouchedItem = <span class="literal">null</span>;</span><br><span class="line">        TouchedOpen = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TouceArea.children[<span class="number">0</span>].childNodes.length; i++) &#123;</span><br><span class="line">            liArea = TouceArea.children[<span class="number">0</span>].childNodes[i];</span><br><span class="line">            <span class="keyword">if</span> (liArea.offsetTop &gt; StartY) &#123;</span><br><span class="line">                TouchedItem = TouceArea.children[<span class="number">0</span>].childNodes[i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Deal Last One</span></span><br><span class="line">        <span class="keyword">if</span> (!TouchedItem) &#123;</span><br><span class="line">            <span class="keyword">if</span> (liArea.offsetTop + liArea.clientHeight &gt; StartY) &#123;</span><br><span class="line">                TouchedItem = TouceArea.children[<span class="number">0</span>].childNodes[TouceArea.children[<span class="number">0</span>].childNodes.length - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TouceArea.ontouchmove = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录当前坐标偏移</span></span><br><span class="line">    <span class="keyword">var</span> OffsetY = e.touches[<span class="number">0</span>].pageY - StartY;</span><br><span class="line">    <span class="keyword">var</span> OffsetX = e.touches[<span class="number">0</span>].pageX - StartX - <span class="number">20</span>;  <span class="comment">// 减去一个值，避免微小移动也触发事件，影响体验</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现水平滑动</span></span><br><span class="line">    <span class="keyword">if</span> (ScrollHorizontalLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TouchedItem &amp;&amp; OffsetX &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TouchedItem.style.marginLeft = OffsetX + <span class="string">"px"</span>;</span><br><span class="line">            <span class="keyword">if</span> (OffsetX &gt; TouchedItem.clientWidth / <span class="number">2</span>) &#123;</span><br><span class="line">                TouchedItem.style.backgroundColor = <span class="string">"rgba(13,118,13,0.60)"</span>;</span><br><span class="line">                TouchedOpen = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TouchedItem.style.backgroundColor = <span class="string">""</span>;</span><br><span class="line">                TouchedOpen = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现垂直滚动</span></span><br><span class="line">    <span class="keyword">var</span> NewMargin = OffsetY + MarginOffset;</span><br><span class="line">    <span class="keyword">if</span> (TouceArea.clientHeight + NewMargin &lt; WholeView.clientHeight * <span class="number">0.7</span>) &#123;</span><br><span class="line">        NewMargin = WholeView.clientHeight * <span class="number">0.7</span> - TouceArea.clientHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (NewMargin &gt; <span class="number">0</span>)</span><br><span class="line">        NewMargin = <span class="number">0</span>;</span><br><span class="line">    ScrollArea.style.marginTop = NewMargin + <span class="string">"px"</span>;</span><br><span class="line">    <span class="comment">//默认情况也会响应垂直滚动，故ScrollVerticalLock的判断放到后面</span></span><br><span class="line">    <span class="keyword">if</span> (ScrollVerticalLock) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断滚动方向</span></span><br><span class="line">    <span class="keyword">if</span> (!TouchedItem) &#123;</span><br><span class="line">        ScrollVerticalLock = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(OffsetY) &gt; <span class="number">15</span>) &#123;</span><br><span class="line">        ScrollVerticalLock = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (OffsetX &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ScrollHorizontalLock = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TouceArea.ontouchend = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理拖动打开链接事件</span></span><br><span class="line">    <span class="keyword">if</span> (TouchedItem) &#123;</span><br><span class="line">        TouchedItem.style.marginLeft = <span class="string">"0px"</span>;</span><br><span class="line">        TouchedItem.style.backgroundColor = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (TouchedOpen) &#123;</span><br><span class="line">            hide(); <span class="comment">// 隐藏搜索框</span></span><br><span class="line">            <span class="comment">// 待搜索框完全隐藏后再打开新链接，视觉效果更好点</span></span><br><span class="line">            <span class="built_in">window</span>.setTimeout(<span class="string">'window.location.href='</span> + <span class="string">'"'</span> + TouchedItem.children[<span class="number">0</span>].href + <span class="string">'"'</span>, <span class="number">200</span>);</span><br><span class="line">        &#125;                        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的<code>mobile.js</code>文件在<a href="https://github.com/g199209/BlogTheme/blob/master/source/js/mobile.js" target="_blank" rel="noopener">这里</a>。</p><h2 id="最终成品效果"><a href="#最终成品效果" class="headerlink" title="最终成品效果"></a>最终成品效果</h2><p>实际使用下来还是比较满意的，搜索效果像这样：</p><p><img src="https://pic.gaomf.store/Search_mobile.gif" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Blog </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N皇后问题</title>
      <link href="/2016/11/22/N_Queen_Problem/"/>
      <url>/2016/11/22/N_Queen_Problem/</url>
      
        <content type="html"><![CDATA[<p>N皇后问题是经典八皇后问题的扩展：在N*N的棋盘上，有N个皇后需要放置，需满足任意两个皇后不能位于同一行、同一列或者是同一对角线上，求一共有几种放置方法。</p><a id="more"></a><p>N皇后问题是一个经典的回溯法的例子，核心思想就是逐行（或逐列）放置，若某一行没有可供放置的位置了，说明前面的放置有误，故回溯到上一行寻找下一个可能的位置。N皇后问题是一个NP-Hard问题，其算法复杂度是指数复杂度的。下面给出两种实现方法。</p><h2 id="经典回溯非递归实现"><a href="#经典回溯非递归实现" class="headerlink" title="经典回溯非递归实现"></a>经典回溯非递归实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NQueens</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * columns;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    columns = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * N);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        columns[i] = <span class="number">-1</span>;  <span class="comment">// -1代表还未放置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">        <span class="comment">// 寻找第i列下一个可供放置的位置</span></span><br><span class="line">        <span class="keyword">for</span> (j = columns[i] + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="comment">// 检查位置是否冲突</span></span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span>; i - k &gt;= <span class="number">0</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (columns[i - k] == j || columns[i - k] == j - k || columns[i - k] == j + k) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有位置可用</span></span><br><span class="line">            <span class="keyword">if</span> (i - k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                columns[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第i列已经没有空位，需要回溯</span></span><br><span class="line">        <span class="keyword">if</span> (j == N) &#123;</span><br><span class="line">            columns[i] = <span class="number">-1</span>;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到达最后一列，找到一个解</span></span><br><span class="line">        <span class="keyword">if</span> (i == N<span class="number">-1</span>)&#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续寻找下一列</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(columns);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序很简单，就不多说明了。</p><h2 id="位运算递归实现"><a href="#位运算递归实现" class="headerlink" title="位运算递归实现"></a>位运算递归实现</h2><p>上面使用数组实现的回溯法其实效率很低，N皇后最高效的解法是位运算算法，下面给出实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> upperlimit;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter N : "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    upperlimit = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">    NQueen(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Solution : %d\n"</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NQueen</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> ld,<span class="keyword">int</span> rd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos, p;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//row == upperlim,说明皇后全部放进去了 </span></span><br><span class="line">    <span class="keyword">if</span>(row != upperlimit)&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//row，ld，rd进行“或”运算，如：000101 ，1的列表示已经放置了皇后</span></span><br><span class="line">        <span class="comment">//pos 取反得 111010，1表示可以放皇后的列  </span></span><br><span class="line">        <span class="comment">//upperlimit 是上限值,控制二进制长度:</span></span><br><span class="line">        <span class="comment">//如：(~(row | ld | rd ) = 100001011101时,upperlimit = 111111,pos= 011101 </span></span><br><span class="line">        pos = upperlimit &amp; (~(row | ld | rd ));  </span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="number">0</span>) &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// 找出可以放皇后的位置（默认从右到左），如：p=000100,表示该行右边第三个位置可以放皇后。</span></span><br><span class="line">            <span class="comment">// p就表示该行的某个可以放皇后的位置，把皇后放在这个位置上后，就把它从pos中移除并递归调用test过程。</span></span><br><span class="line">            p = pos &amp; (~pos + <span class="number">1</span>);  </span><br><span class="line">             </span><br><span class="line">            <span class="comment">// 把皇后放在这个位置上后，就把它从pos中移除并递归调用test过程。</span></span><br><span class="line">            <span class="comment">// 如：pos = 111100时,p = 000100,把皇后放在这个位置上后， pos = pos - p, pos=111000</span></span><br><span class="line">            pos = pos - p;  </span><br><span class="line">            <span class="comment">//(row|p) 是计算已经在对应列上面的皇后</span></span><br><span class="line">            <span class="comment">//(ld | p)&lt;&lt; 1 是因为由ld造成的占位在下一行要右移一下；</span></span><br><span class="line">            <span class="comment">// (rd | p)&gt;&gt; 1 是因为由rd造成的占位在下一行要左移一下</span></span><br><span class="line">            test((row|p),(ld|p)&lt;&lt;<span class="number">1</span>,(rd|p)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此算法的详细解释见：</p><blockquote><p><a href="https://my.oschina.net/CodingMen/blog/715983" target="_blank" rel="noopener">八皇后问题详解及代码实现(位运算算法)</a><br><a href="http://blog.csdn.net/hackbuteer1/article/details/6657109" target="_blank" rel="noopener">N皇后问题的两个最高效的算法</a><br><a href="http://www.matrix67.com/blog/archives/266" target="_blank" rel="noopener">位运算简介及实用技巧（三）：进阶篇(2)</a></p></blockquote><p>实际测试表明，此方法的效率是简单回溯的10倍左右。</p><hr><p>附注：1~27皇后问题的解法数量见：<a href="https://oeis.org/A000170/list" target="_blank" rel="noopener">A000170</a>，这个可以用来验证自己写的算法是否正确。</p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PMSM矢量控制算法调试流程</title>
      <link href="/2016/11/14/PMSM_Vector_Control/"/>
      <url>/2016/11/14/PMSM_Vector_Control/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">矢量控制</a>又称磁场导向控制（Field Oriented Control, FOC），这是永磁同步电机（PMSM）的主要控制方法，与BLDC的简单控制策略相比，矢量控制要更为复杂，故需要一套系统的调试方法。TI提供了一个用于支持各种电机控制算法的<a href="http://processors.wiki.ti.com/index.php/TMS320C2000_Motor_Control_Primer" target="_blank" rel="noopener">DMC库</a>，其中包含很多矢量控制中用得到的功能模块，与之配套的还有一份调试指南：</p><blockquote><p><a href="http://www.ti.com/lit/an/sprabq2/sprabq2.pdf" target="_blank" rel="noopener">Sensored Field Oriented Control of 3-Phase Permanent Magnet Synchronous Motors</a></p></blockquote><p>本文就以此为基础，结合实际调试经验，介绍一下矢量控制的基本调试流程。硬件平台基于TI C2000系列DSP，使用DMC库，不过基本方法也适用于其他各种平台。</p><a id="more"></a><h2 id="调试基本功能模块"><a href="#调试基本功能模块" class="headerlink" title="调试基本功能模块"></a>调试基本功能模块</h2><p>矢量控制中，需要获取转子位置、相电流及转速，输出是三相逆变器的占空比信号，故首先要配置好所需的硬件功能模块，并进行测试验证，这是之后所有工作的基础。</p><h3 id="配置PWM输出"><a href="#配置PWM输出" class="headerlink" title="配置PWM输出"></a>配置PWM输出</h3><p>矢量控制中，一般需要六路三组PWM输出，配置为两两互补导通的形式，在大部分MCU中可使用定时器模块来实现PWM输出，不过TI C2000系列提供了专门的<a href="/2015/12/24/C2000%20ePWM%E6%A8%A1%E5%9D%97/">ePWM模块</a>来实现这一功能。按照寄存器定义配置好模块后，需要验证配置的正确性。</p><p>断开电机连接，依次将U、V、W三相的占空比设置为0、100%、50%，使用万用表测量对应端口的电压，0占空比时输出电压应接近0V，100%占空比时接近母线电压，50%占空比时为母线电压的一半。若测量结果符合预期，说明配置正确。</p><h3 id="配置电流采样"><a href="#配置电流采样" class="headerlink" title="配置电流采样"></a>配置电流采样</h3><p>矢量控制中需要同时获得三相电流，一般采集其中两相，根据基尔霍夫定律即可推出第三相的电流。电流采集有各种方法，可以参考：</p><blockquote><p><a href="http://gitcafepage.gaomingfei.xyz/2016/01/01/%E4%B8%89%E7%9B%B8%E9%80%86%E5%8F%98%E5%99%A8%E7%94%B5%E6%B5%81%E9%87%87%E6%A0%B7%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">三相逆变器电流采样方案总结</a></p></blockquote><p>无论使用哪种方法，最后都是使用AD进行采样的，根据采样电路的结构可以推导出电流采样值与AD结果寄存器值之间的关系。所以先要配置好AD模块，一般情况下，可以使用PWM信号来触发AD采样，具体触发时机取决于使用的采样方案。配置好寄存器后，需要验证电流采样的正确性。</p><p>首先断开电机连接，使用仿真器连续读取AD采样结果寄存器的值，此时的采样值即为电流零点。观察电流零点的稳定性，一般来说，如果电流采样的稳定性较好，AD结果寄存器中只会有最后一两位在波动。若电流零点波动得较严重，说明采样稳定性很差，此时需要在程序中增加滤波算法。</p><p>之后接上电机，给U相输出一个很小的占空比，V、W两相占空比设置为0。具体占空比的值取决于母线电压及绕组电阻，可以预先估计一下，保证电流在安全范围内，一般可以取为1A左右。此时再用仿真器读取计算出的U、V、W三相电流，根据正电压产生正电流的电动机原则，<strong>U相电流应该是正的，V、W两相电流应该是负的，且V、W两相电流应基本相同。若正负号不对，需要进行调整。</strong></p><p>如有条件的话，可以使用电流探头或钳型电流表等仪器测量真实的电流值，将真实值与采样值进行对比，以此评估采样的正确性及精度。如果无法测量电流的真实值，可以改变PWM占空比，保证增大占空比电流也会增大，减小占空比电流也随之减小即可。</p><h3 id="配置角度及转速采样"><a href="#配置角度及转速采样" class="headerlink" title="配置角度及转速采样"></a>配置角度及转速采样</h3><p>角度和转速都来源于旋转编码器，一般MCU定时器中均有正交解码功能，用于解码来自编码器的信号。在C2000 系列中，有独立的eQEP模块用于获取旋转编码器的输出信息。在TI DMC库中，提供了一个<code>QEP</code>模块，此模块可以将<code>QPOSCNT</code>寄存器中的计数值转换为电角度及机械角度，使用标幺值表示。若不使用此模块，自行编写程序计算出电角度、机械角度及转速也可以。</p><p>转速的计算也有多种方法，可参考：</p><blockquote><p><a href="/2016/10/13/Encoder_Velocity_Measure/">旋转编码器速度测量方法</a></p></blockquote><p>这里配置好后只需要初步验证一下：用手旋转电机，角度采样值会发生变化即可，详细的验证放到后面步骤中进行。</p><h2 id="编写变换程序"><a href="#编写变换程序" class="headerlink" title="编写变换程序"></a>编写变换程序</h2><p>矢量控制的核心其实就在Clark与Park变换上，通过这两个变换实现了直轴与交轴的解耦。TI DMC库提供了现成的变换模块，即<code>CLARKE</code>、<code>PARK</code>及<code>IPARK</code>，可直接使用。如果是自行编写的程序，需要预先通过仿真等方法确定程序的正确性。</p><h2 id="调试SVPWM模块"><a href="#调试SVPWM模块" class="headerlink" title="调试SVPWM模块"></a>调试SVPWM模块</h2><p>其实矢量控制也并不一定要使用SVPWM（空间矢量调制）方法，也可使用其他方法（如滞环控制等）进行电流控制，不过SVPWM是最优策略，也是主流做法。TI DMC库中使用<code>SVGEN</code>模块支持SVPWM算法，也可自行编写相关程序。SVPWM的输入是<code>U_alpha</code>及<code>U_beta</code>，输出是PWM占空比，上述步骤中已经确定了PWM输出的正确性，现在再加上SVPWM算法进行验证。系统框图如下：</p><p><img src="https://pic.gaomf.store/20161114000147.png" alt=""></p><p>其中<code>Ds</code>、<code>Qs</code>、<code>Angle</code>均是调试变量，使用仿真器进行Debug时可以实时更改变量值。将<code>Qs</code>固定为0，<code>Ds</code>设置为一个较小的电压值，保证输出电流在安全范围内。之后将<code>Angle</code>由0开始，每次增加30°左右，此时电机应该是会旋转的，且每次旋转的角度应该是相同的，<strong>记录下这个旋转方向，这就是此系统固有的正方向。</strong>此时还可以验证电机的极对数，若<code>Angle</code>重复增加<code>N</code>个周期后电机回到起始点（可用记号笔进行标注），电机的极对数即为<code>N</code>。</p><p>最后还需要验证角度采样的正确性。这里设置的<code>Angle</code>即是这个电机真实的电角度，对比<code>Angle</code>的设定值与角度的采样值，二者的绝对值一般是不一样的，这是正常的，不过每次的变化量应该是相同的，包括大小与方向，也就是说，<strong>两个变量间应该存在一个固定的相位差。若二者的变化趋势相反，说明编码器A、B相接反了</strong>，可以在硬件上交换接线来解决，C2000系列中也可以通过配置<code>eQEP</code>模块来交换<code>A</code>、<code>B</code>两相。<strong>若二者每次的变化量不一样，说明电机的极对数搞错了</strong>，需要仔细检查程序。</p><h2 id="调试电流PI控制器"><a href="#调试电流PI控制器" class="headerlink" title="调试电流PI控制器"></a>调试电流PI控制器</h2><p>SVPWM模块调试正常后就可以加上电流PI控制器了，系统框图如下：</p><p><img src="https://pic.gaomf.store/20161114002838.png" alt=""></p><p>其中<code>IqRef</code>、<code>IdRef</code>及<code>Angle</code>是调试变量。从图中可以看到，这里使用了两个PI控制器，需要对其参数进行粗略的整定。</p><p>首先将<code>Angle</code>及<code>IqRef</code>设置为0，<code>IdRef</code>设置为一个安全的电流值，PI控制器参数均设置为0，此时应该是没有电流的。之后将<code>Id</code>PI控制器的<code>Kp</code>值设置为一个合适的值，具体值根据输入输出的数量级来确定，不要设置得太大，若都使用标幺值的话，可以设置为1。此时重新运行程序，观察<code>Id</code>的实际值，<code>Id</code>的值应该不等于0，不过与<code>IdRef</code>之间存在一个静差，逐步增加<code>Ki</code>，直到静差满足要求为止。将<code>Iq</code>PI控制器参数值设置为相同的即可。</p><p>之后与调试SVPWM模块时相同，逐步改变<code>Angle</code>的值，此时电机应该也是会动的。可以在程序中让<code>Angle</code>自动增加，不过增加的速度不要太快，此时电机应该会正向旋转起来。若让<code>Angle</code>自动减小，则电机会反向旋转。<strong>正转与反转应该是对称且相同的。注意，此时设置的是<code>IdRef</code>，<code>IqRef</code>需要始终保持为0。</strong></p><p>记录下旋转时角度采样值与<code>Angle</code>值，并绘制曲线进行观察，<strong>二者应该是频率相同的三角波，且有一个固定相位差</strong>。与此同时，相电流的采样值应该是比较接近正弦的波形。如下图所示：</p><p><img src="https://pic.gaomf.store/20161114130432.png" alt=""></p><p>调试PI控制器参数时也可参考相电流曲线，若曲线发生畸变，不是图中那样的正弦波形，需要降低比例及积分作用。</p><p>最后，检查采样计算出的转速值，<strong>正转时转速应该是正的，反转时是负的</strong>。根据<code>Angle</code>的变化周期可以计算出此时的实际转速，将实际转速与转速采样值进行对比，二者应该基本相同。如果有条件的话，可以进一步使用转速计进行验证。如果此处的转速符号或大小有误，需要检查程序进行修改。</p><h2 id="调试电流闭环"><a href="#调试电流闭环" class="headerlink" title="调试电流闭环"></a>调试电流闭环</h2><p>上面几步调试过程中使用的<code>Angle</code>值均是由程序计算生成的，现在需要加入实际角度采样值，完成完整的电流闭环部分。</p><p>上电开始运行时，如果没有霍尔信号或绝对值编码器，是很难获取转子绝对位置的，故一般的做法是先进行预定位操作。具体方法是：将<code>Angle</code>及<code>IqRef</code>设置为0，<code>IdRef</code>设置为合适值，此时电机会自动旋转到零点位置处，此过程中将角度累加寄存器（C2000中为<code>QPOSCNT</code>）持续置零即可，这样即完成了初始的预定位操作。</p><p>之后按上一步调试电流PI控制器中的方法，自动改变<code>Angle</code>让电机旋转起来，再观察<code>Angle</code>与角度采样值，二者应该是严格相同的。确定了角度采样值的正确性后，修改程序，使用角度采样值替代<code>Angle</code>，这样就完成了完整的电流闭环程序。此时已经不再需要使用<code>Angle</code>了，初始预定位时，只要在程序中一直将角度值清零即可。</p><p>最后验证电流闭环的正确性，在完成预定位后，依次验证<code>Id</code>与<code>Iq</code>。验证<code>Id</code>时将<code>IqRef</code>设置为0，<code>IdRef</code>设置为一个合适的正值，此时电机是不会旋转的，用手转动电机也是可以转动的，只是不同于自由转动状态，此时旋转电机时会感到阻力较大，有一个力始终在维持电机处于当前位置。验证<code>Iq</code>时同理将<code>IdRef</code>设置为0，<code>IqRef</code>设置为一个合适的值即可。<strong>需要注意的是，因为启动电流明显大于稳态电流，如果<code>IqRef</code>的值设置得过小，电机无法旋转起来，而增大<code>IqRef</code>，使电机可以旋转起来后，电机会一直加速到最高转速。</strong>为保证安全，需要对输出电压占空比进行限幅。</p><p><strong>将<code>IqRef</code>设置为正值时电机应该正转，设置为负值时电机应该反转，且正反转速应该是相同的。</strong>此时还可以进一步观察转速采样结果，如果和实际情况符合的话就可以进行下一步了。</p><h2 id="调试速度闭环"><a href="#调试速度闭环" class="headerlink" title="调试速度闭环"></a>调试速度闭环</h2><p>最后一步是加上速度闭环，此时的系统结构框图如下：</p><p><img src="https://pic.gaomf.store/FOC.png" alt=""></p><p>这就是矢量控制算法完整的控制系统结构框图。对于PMSM而言，除了在弱磁控制等情况下，<code>IdRef</code>一般是固定为0的。不过对于异步电机而言，因为要产生绕组电流，<code>IdRef</code>并不是零。<code>IqRef</code>连接至速度环PI控制器的输出上，一般会对<code>IqRef</code>的范围进行限幅，以保证电流在安全范围内。</p><p>之前已经验证了速度采样的正确性，故这里只需要整定PI控制器参数即可。方法按照通用步骤，先设置一个<code>Kp</code>，再慢慢增大<code>Ki</code>，根据设定值与实际值的曲线进一步调节参数即可。整定完成后，系统应该是完全可控的，电机会按照给定速度旋转，且正转反转应该都是没有问题的。</p><hr><p>至此，整个矢量控制的基本流程已经完全打通，接下来就可以根据具体应用场景，进一步调节参数及优化上述控制策略了。</p>]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Motor </tag>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 014. Longest Common Prefix (Easy)</title>
      <link href="/2016/11/01/LeetCode_014/"/>
      <url>/2016/11/01/LeetCode_014/</url>
      
        <content type="html"><![CDATA[<p>给出一个字符串数组，返回其最长公共前缀子序列。</p><a id="more"></a><h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><blockquote><p><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-common-prefix/</a></p><p>Write a function to find the longest common prefix string amongst an array of strings.</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>以第一个字符串为基准，依次比较每个字符即可。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">longestCommonPrefix</span><span class="params">(<span class="keyword">char</span>** strs, <span class="keyword">int</span> strsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">char</span> * res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (strsSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(n = <span class="number">0</span>;;n++) &#123;</span><br><span class="line">        tmp = strs[<span class="number">0</span>][n];</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; strsSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i][n] != tmp)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; strsSize)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(n+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res[i] = strs[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res[n] = <span class="string">'\0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先进行比较，判断出最先几个字符为相同的字符，之后再申请内存空间，复制字符串作为结果返回。之所以要分两步处理，是因为开始的时候并不知道结果字符串的长度，若采用动态分配空间的方法效率会很低。</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> n = strs.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pos = <span class="number">0</span>; pos &lt; strs[<span class="number">0</span>].size(); pos++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pos == strs[k].size() || strs[<span class="number">0</span>][pos] != strs[k][pos]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result += strs[<span class="number">0</span>][pos];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 019. Remove Nth Node From End of List (Easy)</title>
      <link href="/2016/11/01/LeetCode_019/"/>
      <url>/2016/11/01/LeetCode_019/</url>
      
        <content type="html"><![CDATA[<p>给出一个链表，移除其中倒数第N个元素。</p><a id="more"></a><h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><blockquote><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-list/</a></p><p>Given a linked list, remove the nth node from the end of list and return its head.</p><p>For example,<br>Given linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>, and <code>n = 2</code>.<br>After removing the second node from the end, the linked list becomes <code>1-&gt;2-&gt;3-&gt;5</code>.</p><p>Note:<br>Given n will always be valid.<br>Try to do this in one pass.</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>双指针，后一个指针比前一个指针先走N步，后一个指针移动到链表末尾时前一个指针指向的就是要删除的元素。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">p1</span>, * <span class="title">p2</span>, * <span class="title">tmp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">dummy</span>;</span></span><br><span class="line">    </span><br><span class="line">    dummy.next = head;</span><br><span class="line">    p1 = &amp;dummy;</span><br><span class="line">    p2 = &amp;dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p2-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tmp = p1-&gt;next;</span><br><span class="line">    p1-&gt;next = p1-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了正确的删除节点的方法，使用<code>free()</code>释放了内存空间。</p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 083. Remove Duplicates from Sorted List (Easy)</title>
      <link href="/2016/11/01/LeetCode_083/"/>
      <url>/2016/11/01/LeetCode_083/</url>
      
        <content type="html"><![CDATA[<p>给出一个有序链表，去除其中的重复元素。</p><a id="more"></a><h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><blockquote><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-list/</a></p><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p><p>For example,<br>Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.<br>Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为链表是有序的，直接从头循环搜索一遍即可。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">deleteDuplicates</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">tmp</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val == p-&gt;next-&gt;val) &#123;</span><br><span class="line">            tmp = p-&gt;next;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了正确的删除节点的方法，使用<code>free()</code>释放了内存空间。</p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu虚拟机中设置NAT使树莓派开发板可以联网</title>
      <link href="/2016/11/01/Ubuntu_NAT_Raspberry/"/>
      <url>/2016/11/01/Ubuntu_NAT_Raspberry/</url>
      
        <content type="html"><![CDATA[<p>树莓派3自带了WiFi，可以将其连接到无线热点上来联网，不过实验室没有无线路由器可用，只能将其用双绞线连接到电脑上，此时要实现树莓派能正常联网就需要在电脑上的Ubuntu虚拟机中设置NAT转发，这里来记录一下设置过程。</p><a id="more"></a><h2 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h2><p>基本的网络结构如下所示：</p><p><img src="https://pic.gaomf.store/20161101160822.png" alt=""></p><p>其中蓝色线条表示逻辑上的网络连接关系。树莓派上的LAN接口使用双绞线与电脑连接，在虚拟机中设置桥接模式，即会产生一块虚拟网卡<code>eth1</code>桥接到已有的以太网上构成局域网。虚拟机中还有一块虚拟网卡<code>eth0</code>，这是通过VMware的NAT模式产生的，VMware中运行着一个NAT服务实现了<code>eth0</code>到<code>VMnet8</code>这两块虚拟网卡间的转发，最终实现了虚拟机联网的目的。</p><p>从图中可以看到，目前树莓派只连接到了一个局域网中，并没有和Internet建立连接，要实现联网的目的，最简单的方法就是在Ubuntu虚拟机中建立<code>eth1</code>至<code>eth0</code>的NAT转发。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="开启IPv4转发"><a href="#开启IPv4转发" class="headerlink" title="开启IPv4转发"></a>开启IPv4转发</h3><p>Linux内核本身就是支持IPv4转发的，只需要开启这个功能即可。使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">echo</span> <span class="string">"1"</span> &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure><p>修改<code>ip_forward</code>文件可以实时启用IP转发，不过这是临时的，重启后会失效，要永久启用，需要修改配置文件<code>/etc/sysctl.conf</code>。在Ubuntu 14.04中，默认有下面这两行注释：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Uncomment the next line to enable packet forwarding for IPv4</span></span><br><span class="line"><span class="comment">#net.ipv4.ip_forward=1</span></span><br></pre></td></tr></table></figure><p>根据说明去掉下面那行的注释即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Uncomment the next line to enable packet forwarding for IPv4</span></span><br><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure><p>也可以在文件末尾直接添加上述语句，效果是一样的。要让修改实时生效，使用以下命令重新加载<code>sysctl.conf</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure><h3 id="配置iptables"><a href="#配置iptables" class="headerlink" title="配置iptables"></a>配置iptables</h3><p>首先确定目前防火墙的设置不会拦截来自树莓派开发板的数据包，之后使用以下命令添加NAT转发即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -t nat -A POSTROUTING -s 192.168.1.7/32 -o eth0 -j MASQUERADE</span><br></pre></td></tr></table></figure><p><code>192.168.1.7/32</code>是树莓派的IP地址；<code>eth0</code>是可以联网的网卡。</p><p>这个配置也是实时临时生效的，要让其永久生效，需要将其写入配置文件中。</p><p>首先，使用<code>iptables-save</code>工具将目前的<code>iptables</code>规则保存为文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables-save &gt; /etc/iptables.rules</span><br></pre></td></tr></table></figure><p>之后修改<code>/etc/network/interfaces</code>文件，在文件最后加上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre-up iptables-restore &lt; /etc/iptables.rules</span><br></pre></td></tr></table></figure><p><code>iptables-restore</code>工具用于载入之前保存的规则文件；<code>pre-up</code>表示建立<code>interface</code>之前执行操作，类似的还有<code>up</code>、<code>post-down</code>等，可用命令<code>man interfaces</code>查询。这里就表示在每次建立接口前加载预设规则。</p><h3 id="配置网关及DNS服务器"><a href="#配置网关及DNS服务器" class="headerlink" title="配置网关及DNS服务器"></a>配置网关及DNS服务器</h3><p>这一步是在树莓派开发板上进行的操作，根据<a href="/2016/10/27/Raspberry_Pi_Static_IP/">之前文章</a>的做法，我们为树莓派配置的是固定IP地址，故同时还要设置网关和DNS服务器，网关需要设置为Ubuntu虚拟机中<code>eth1</code>网卡的IP地址，以便将所有数据包送至Ubuntu虚拟机中。至于DNS服务器，经过测试，最好的选择是将DNS服务器设置为VMware软件生成的那个虚拟NAT网关的地址，这样VMware会自动选用主机使用的DNS服务器。</p><p>如果要临时更改DNS服务器，可修改<code>/etc/resolve.conf</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 192.168.175.2</span><br></pre></td></tr></table></figure><hr><p>通过上述方法进行设置后，树莓派就可以上网啦~此方式的实质是将Ubuntu虚拟机作为一台路由器进行网络地址转换，从而为树莓派开发板提供网络访问。</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
            <tag> Raspberry Pi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为树莓派设置静态IP地址的方法</title>
      <link href="/2016/10/27/Raspberry_Pi_Static_IP/"/>
      <url>/2016/10/27/Raspberry_Pi_Static_IP/</url>
      
        <content type="html"><![CDATA[<p>Raspbian系统默认是使用DHCP方式获取IP地址的，这就要求要有一个路由器。然而实验室里面并没有有线网和路由器可用……我只能配置成电脑用无线上网，然后用网线连接树莓派这样的网络结构。这就要求树莓派要配置成静态IP的形式，下面来总结一下配置方法。</p><a id="more"></a><p>在网上搜索“树莓派 静态IP”可以找到很多的教程文章，然而它们大部分都不适用于现在新版本的Raspbian系统了，按那些方法进行配置<strong>是错误的</strong>。2015年5月后，Raspbian Jessie发布，这一版本引入了<a href="https://wiki.archlinux.org/index.php/dhcpcd" target="_blank" rel="noopener">dhcpcd</a>，进而更改了网络部分的配置方式，导致之前的所有教程都失效了……新版本的配置方式和相关讨论见以下链接：</p><blockquote><p><a href="http://raspberrypi.stackexchange.com/questions/37920/how-do-i-set-up-networking-wifi-static-ip" target="_blank" rel="noopener">How do I set up networking/WiFi/Static IP</a></p></blockquote><p>这篇文章中提到了两种设置方法，这里对推荐使用的基于dhcpcd的新方法做一总结：</p><p>首先，<strong>不要修改</strong><code>/etc/network/interfaces</code>文件；</p><p>之后打开<code>/etc/dhcpcd.conf</code>文件，在最后添加以下代码：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface eth0</span><br><span class="line">static ip_address=<span class="number">192.168</span><span class="number">.1</span><span class="number">.7</span>/<span class="number">24</span></span><br><span class="line">static routers=<span class="number">192.168</span><span class="number">.1</span><span class="number">.3</span></span><br><span class="line">static domain_name_servers=<span class="number">192.168</span><span class="number">.175</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>其中<code>eth0</code>代表有线以太网接口，如要配置无线网，使用<code>wlan0</code>；<code>ip_address</code>就是IP地址，根据实际情况配置；<code>routers</code>是网关地址；<code>domain_name_servers</code>是DNS服务器的地址。</p><p>最后使用<code>sudo reboot</code>命令重启后即可生效。</p><p><em>相关文章：</em></p><blockquote><p><a href="/2016/06/25/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/">VMware虚拟机中嵌入式Linux开发环境网络配置</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
            <tag> Raspberry Pi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP地址中子网掩码的表示方法</title>
      <link href="/2016/10/27/IP_Mask/"/>
      <url>/2016/10/27/IP_Mask/</url>
      
        <content type="html"><![CDATA[<p>今天看到类似<code>192.168.1.1/24</code>这样的IP表示方法，去查了下后面的<code>/XX</code>是什么意思，原来这是代表子网掩码。<code>/24</code>就是掩码中前24为<code>1</code>，也就相当于<code>255.255.255.0</code>，其他值以此类推。这样指定IP的同时也就给出了子网掩码，表示起来会更方便。</p><a id="more"></a><p>另外，还看到一道关于子网掩码的<a href="https://www.nowcoder.com/questionTerminal/5ad9d4b7c6024571a36a6cadddcf0a2f" target="_blank" rel="noopener">题目</a>，摘录如下：</p><blockquote><p>某网络的IP地址空间为192.168.5.0/24，采用定长子网划分，子网掩码为255.255.255.248，则该网络的最大子网个数，每个子网内的最大可分配地址个数为各为多少？</p></blockquote><p>解答：</p><blockquote><p>题目给出的IP地址空间基于CIDR划分，前24位是网络号，后8位是主机号。子网掩码最后是248，248 = <code>1111 1000</code>。相当于主机号又被分成两部分，前5位是子网号，后3位是主机号，所以，子网个数是2^5 = 32, 主机个数为2^3 = 8。另外，主机号全0代表本地主机, 全1表示广播，所以还剩下6个有效的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 点滴之间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows防火墙允许ping请求设置方法</title>
      <link href="/2016/10/27/Windows_Ping/"/>
      <url>/2016/10/27/Windows_Ping/</url>
      
        <content type="html"><![CDATA[<p>Windows系统出于安全性考虑，在开启了防火墙时，默认情况下是不会响应来自其他主机的ping请求的。这不利于开发过程中检测网络连通性，故这时就需要开启防火墙中的ICMP回显功能。</p><a id="more"></a><p>以Windows 10为例，打开防火墙高级设置界面，在入站规则中允许ICMP回显即可，如图：</p><p><img src="https://pic.gaomf.store/20161027191757.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道字符串填充算法题</title>
      <link href="/2016/10/26/String_Fill/"/>
      <url>/2016/10/26/String_Fill/</url>
      
        <content type="html"><![CDATA[<p>偶然在idailylife的博客上看到<a href="https://boweihe.me/?p=2300" target="_blank" rel="noopener">Indeed Tokyo 笔试题一道</a>，觉得很有趣，就思考了下这题，这里记录一下。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>输入字符串<code>str=a[0] a[1] ... a[N]</code>，其中0&lt;<code>N</code>&lt;=10^5。字符串的每一位是<code>0-9</code>或<code>?</code>，需要用<code>0-9</code>填充各个问号的值，使得整个字符串成为一个数（允许前导0），并且满足任意连续10位上的字符(或理解成数字)<code>a[i] a[i+1] ... a[i+9]</code>不重复，输出解的个数。</p><p>例如，输入<code>&quot;04??2?7&quot;</code>，输出应当为120.</p></blockquote><a id="more"></a><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用回溯法暴力求解显然是不可行的，原文中作者给出了一个很好的做法：<strong>只计算str前10个字符有多少可能性。</strong>这是基于以下原理的：</p><p>对任意区间<code>a[k] a[k+1] ... a[k+9]</code>，题目要求数字均不重复，而且一共也只有10个数字可以选择，故此区间内肯定用完了所有数字。下面将此区间向前移动一步，得到<code>a[k+1] a[k+2] ... a[k+9] a[k+10]</code>，对比两个区间易知，要满足条件只能是<code>a[k] = a[k+10]</code>。由于<code>k</code>是任选的，故可以得到结论：<strong>此序列是一个以10为周期的周期序列</strong>。</p><p>原文中作者实际去填充了前10个字符中的空位，然后来依次判断每种情况的有效性，其实这是完全没有必要的，还有一种更高效的解法。假设<code>a[k]</code>为<code>?</code>，若任意<code>a[k + 10n]</code>不为<code>?</code>的话，<code>？</code>的值其实是可以唯一确定的。用此方法可以先排除一些能唯一确定的<code>?</code>，之后考虑前10个字符中剩余的<code>?</code>，这是一个简单的排列组合问题，不需要实际进行填充即可算出一共有几种填法。具体实现方法见下面的代码。</p><p>另外，下面的代码中假设给出的字符串中已经有的数字是符合要求的，这样就可以不对已有数字进行有效性检验。</p><p>扩展：这里之所以有如此巧妙的解法，关键在于可能填入的字符数量正好等于不重复区间长度，若二者不等该如何解决呢？这个问题之后有空可以再来思考下。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FillStringNum</span><span class="params">(<span class="keyword">char</span> * str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">'?'</span>) &#123;</span><br><span class="line">                Q++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Q == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算排列A(10-(n-Q), Q)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i++) &#123;</span><br><span class="line">            result *= (<span class="number">10</span> + Q - n - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] != <span class="string">'?'</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (k = i + <span class="number">10</span>; k &lt; n; k += <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[k] != <span class="string">'?'</span>) &#123;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Q++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Q == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算排列A(Q, Q) = Q!</span></span><br><span class="line">    <span class="keyword">while</span> (Q &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        result *= Q;</span><br><span class="line">        Q--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 319. Bulb Switcher (Medium)</title>
      <link href="/2016/10/26/LeetCode_319/"/>
      <url>/2016/10/26/LeetCode_319/</url>
      
        <content type="html"><![CDATA[<p><code>n</code>盏灯，初始状态为全灭，第一次翻转编号为1的倍数的灯（即所有灯），第二次翻转编号为2的倍数的灯，以此类推，第<code>n</code>次翻转编号为<code>n</code>的倍数的灯。求最后有几盏灯亮着？</p><a id="more"></a><h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><blockquote><p><a href="https://leetcode.com/problems/bulb-switcher/" target="_blank" rel="noopener">https://leetcode.com/problems/bulb-switcher/</a></p><p>There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.</p><p>Example:</p><p>Given n = 3. </p><p>At first, the three bulbs are [off, off, off].<br>After first round, the three bulbs are [on, on, on].<br>After second round, the three bulbs are [on, off, on].<br>After third round, the three bulbs are [on, off, off]. </p><p>So you should return 1, because there is only one bulb is on.</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>简单分析就可以知道，问题的关键是要求解每盏灯被翻转了奇数次还是偶数次，翻转了奇数次的灯就是最后亮着的灯。最直接的做法就是从第1盏灯开始循环判断每一轮是否翻转，若翻转次数为奇数则亮灯数加1。此方法的代码见C语言程序的方法一。然而，这种方法运行时间太长，在LeetCode上会超时，故需要使用数学分析来解决这一问题。</p><p>我们要找到翻转次数为奇数的灯，可以先考虑这么一个问题，若第<code>m</code>轮翻转了第<code>i</code>盏灯，说明<code>i</code>肯定是<code>m</code>的倍数，即存在整数<code>n</code>满足<code>m*n=i</code>，这也就意味着在第<code>n</code>轮的时候这盏灯又会被再翻转一次。那什么时候会只翻转奇数次呢？仔细一想不难发现，只有<code>i</code>为完全平方数时才有可能，此时存在<code>m*m=i</code>，就会有一轮翻转没有与之对应的另一轮翻转，翻转次数就为奇数。</p><p>用数学语言来描述这个结论就是：<strong>有且仅有完全平方数的因子个数为奇数。</strong>所以问题简化为求小于<code>n</code>的完全平方数有几个，易知这个数就是<code>(int)(sqrt(n))</code>，这样我们就可以写出只有一行代码的算法了~见C语言程序的方法二。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h3 id="C语言-方法一"><a href="#C语言-方法一" class="headerlink" title="C语言 - 方法一"></a>C语言 - 方法一</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> times;</span><br><span class="line">    <span class="keyword">int</span> remains = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第i盏灯</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        times = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第j轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                times++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开关奇数次为开</span></span><br><span class="line">        <span class="keyword">if</span> (times &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">            remains++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> remains;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法直接循环判断，在LeetCode上会超时。</p><h3 id="C语言-方法二"><a href="#C语言-方法二" class="headerlink" title="C语言 - 方法二"></a>C语言 - 方法二</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><blockquote><p><a href="/2016/10/26/LeetCode_292/">LeetCode 292. Nim Game (Easy)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 292. Nim Game (Easy)</title>
      <link href="/2016/10/26/LeetCode_292/"/>
      <url>/2016/10/26/LeetCode_292/</url>
      
        <content type="html"><![CDATA[<p>一堆石子，两个人依次从中拿1~3个，最后一个全部拿完的人获胜。给出石子数，请问先拿那个人在这种情况下是否能获胜？</p><a id="more"></a><h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><blockquote><p><a href="https://leetcode.com/problems/nim-game/" target="_blank" rel="noopener">https://leetcode.com/problems/nim-game/</a></p><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p><p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p><p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题可以算一个智力题，通过简单的逻辑分析可知，当且仅当石子的数量不为4的倍数时，先拿者可以获胜，具体推理过程在此就不多说了。这样就可以写出很简洁的Java版程序。</p><p>另外这题还可以用递归来解决，基本就相当于穷举所有情况，C语言版的代码就是用这种方法实现的。只是这种方法实际上是不可用的，计算时间会随<code>n</code>的增加而指数增加，当<code>n=50</code>时就需要超过10分钟才能计算出结果。</p><p>最好的通用方法是使用动态规划来解决这一问题，记录每次递归的中间结果即可。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> !(canWinNim(n <span class="number">-1</span>) &amp;&amp; canWinNim(n<span class="number">-2</span>) &amp;&amp; canWinNim(n<span class="number">-3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><blockquote><p><a href="/2016/10/26/LeetCode_319/">LeetCode 319. Bulb Switcher (Medium)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治法算法复杂度</title>
      <link href="/2016/10/25/divide_conquer/"/>
      <url>/2016/10/25/divide_conquer/</url>
      
        <content type="html"><![CDATA[<p>分治法是一种常用的算法设计技巧，二分法就是其最常见的特例。所谓分治，分而治之也：</p><ul><li><strong>分（divide）：递归解决较小的问题</strong></li><li><strong>治（conquer）：从子问题的解构建原问题的解</strong></li></ul><p>一般来说，至少含有两个递归的程序才叫做分治法，只有一个递归的程序是不算的。下面来总结下分治法的算法复杂度问题，摘自<a href="https://book.douban.com/subject/1139426/" target="_blank" rel="noopener">《数据结构与算法分析——C语言描述》</a>一书。</p><a id="more"></a><p>假设每次递归均可把原问题分解为$b$个规模一样的子问题，并需要求解其中的$a$个问题，将这$b$个子问题的解合并起来所需的算法复杂度为$O(N^k)$，即：</p><p>$$T(N)=aT(N/b)+\Theta (N^k)$$</p><p>此方程的解为：<br>$$T(N)=<br>\begin{cases}<br>O(N^{\log_b a}) &amp; a&gt;b^k\\<br>O(N^k \log N) &amp; a=b^k\\<br>O(N^k) &amp; a&lt;b^k<br>\end{cases}$$</p><p>其中$a \geqslant 1, b &gt; 1$</p><p>这个公式的实质是分和治的过程在争夺主导地位。大部分情况下$a=b$，此时上式可以进一步简化：<br>$$T(N)=<br>\begin{cases}<br>O(N^k) &amp; k&gt;1\\<br>O(N \log N) &amp; k=1\\<br>O(N) &amp; k&lt;1<br>\end{cases}$$</p><p>一般也不存在 $k &lt; 1$ 的情况，故我们可以得到一个最常用的结论：<br><strong>若合并复杂度为 $O(N)$, 则整个分治法的复杂度为 $O(N \log N)$ ; 若合并复杂度为 $O(N^k), k&gt;1$ , 则整个分治法的复杂度就是合并复杂度。且无论将问题分为几个子问题求解，其算法复杂度相同。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 345. Reverse Vowels of a String (Easy)</title>
      <link href="/2016/10/25/LeetCode_345/"/>
      <url>/2016/10/25/LeetCode_345/</url>
      
        <content type="html"><![CDATA[<p>反转字符串中的所有元音字母。</p><a id="more"></a><h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><blockquote><p><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-vowels-of-a-string/</a></p><p>Write a function that takes a string as input and reverse only the vowels of a string.</p><p>Example 1:<br>Given s = “hello”, return “holle”.</p><p>Example 2:<br>Given s = “leetcode”, return “leotcede”.</p><p>Note:<br>The vowels does not include the letter “y”.</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>双指针，一个<code>left</code>从头部开始找，另一个<code>right</code>从尾部开始找，若<code>left</code>及<code>right</code>均为元音，交换二者。截止条件为<code>left &gt;= right</code>。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checkVowel(c) (c==<span class="meta-string">'a'</span>||c==<span class="meta-string">'e'</span>||c==<span class="meta-string">'i'</span>||c==<span class="meta-string">'o'</span>||c==<span class="meta-string">'u'</span>||c==<span class="meta-string">'A'</span>||c==<span class="meta-string">'E'</span>||c==<span class="meta-string">'I'</span>||c==<span class="meta-string">'O'</span>||c==<span class="meta-string">'U'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">reverseVowels</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * left, *right;</span><br><span class="line">    <span class="keyword">char</span> tmpc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize pointer</span></span><br><span class="line">    left = s;</span><br><span class="line">    right = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*right != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!checkVowel(*left)) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!checkVowel(*right)) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            tmpc = *left;</span><br><span class="line">            *left = *right;</span><br><span class="line">            *right = tmpc;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里判断是否为元音字母使用了宏定义，以此提高运行效率。</p><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><blockquote><p><a href="/2016/10/25/LeetCode_344/">LeetCode 344. Reverse String (Easy)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 344. Reverse String (Easy)</title>
      <link href="/2016/10/25/LeetCode_344/"/>
      <url>/2016/10/25/LeetCode_344/</url>
      
        <content type="html"><![CDATA[<p>反转一个字符串。</p><a id="more"></a><h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><blockquote><p><a href="https://leetcode.com/problems/reverse-string/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-string/</a></p><p>Write a function that takes a string as input and returns the string reversed.</p><p>Example:<br>Given s = “hello”, return “olleh”.</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接反向复制即可。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">     <span class="keyword">char</span> * r = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((n+<span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">         r[i] = s[n - i - <span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     r[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><blockquote><p><a href="/2016/10/25/LeetCode_345/">LeetCode 345. Reverse Vowels of a String (Easy)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 167. Two Sum II - Input array is sorted (Medium)</title>
      <link href="/2016/10/25/LeetCode_167/"/>
      <url>/2016/10/25/LeetCode_167/</url>
      
        <content type="html"><![CDATA[<p>给定一个已经排序的整数集合及一个目标数，从集合中找出两个数，使其和等于目标数。</p><a id="more"></a><h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><blockquote><p><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/</a></p><p>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</p><p> The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p><p>You may assume that each input would have exactly one solution.</p><p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要充分利用数组已排序的性质，使用双指针进行操作，若两数和小于目标数，增加左侧指针；若大于目标数，减小右侧指针。具体见代码。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left, right, tmp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = numbers.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            tmp = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span> (tmp == target) &#123;</span><br><span class="line">                result.push_back(left + <span class="number">1</span>);</span><br><span class="line">                result.push_back(right + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp &lt; target) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><blockquote><p><a href="/2016/10/25/LeetCode_001/">LeetCode 001. Two Sum (Easy)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 001. Two Sum (Easy)</title>
      <link href="/2016/10/25/LeetCode_001/"/>
      <url>/2016/10/25/LeetCode_001/</url>
      
        <content type="html"><![CDATA[<p>给定一个整数集合及一个目标数，从集合中找出两个数，使其和等于目标数。</p><a id="more"></a><h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><blockquote><p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum/</a></p><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Given nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">Because nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span>,</span><br><span class="line"><span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>].</span><br></pre></td></tr></table></figure></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>最直接的思路就是直接两次循环，判断两数之和是否等于目标数。这样做算法复杂度是O(n^2)，效率很低。下面C语言版本的代码就是用这种方法实现的。</p><p>另一种高效的方法是使用字典HashMap，仅需一次循环即可，算法复杂度O(n)。以题目中的Example为例，算法原理可用下图说明：</p><p><img src="https://pic.gaomf.store/20161025161036.png" alt=""></p><p>添加到<code>Map</code>中的元素是将数组中元素值<code>Number</code>作为<code>Key</code>，而对应的数组的索引值<code>Index</code>作为<code>Value</code>的。循环过程中，先判断此数字在<code>Map</code>中是否存在，若不存在的话，将其互补元素（即<code>target</code> - <code>nums[i]</code>）添加到<code>Map</code>中，对应的值即为<strong>当前的</strong><code>i</code>值；若存在的话，返回当前<code>i</code>值与<code>Map[nums[i]]</code>的值即可。具体实现见下面C++及Java版本的代码。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> * result;</span><br><span class="line">    </span><br><span class="line">    result = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; numsSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = j;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.find(nums[i]) != <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                result.push_back(<span class="built_in">map</span>[nums[i]]);</span><br><span class="line">                result.push_back(i);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>[target - nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> [] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">                result[<span class="number">0</span>] = map.get(nums[i]);</span><br><span class="line">                result[<span class="number">1</span>] = i;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(target - nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><blockquote><p><a href="/2016/10/25/LeetCode_167/">LeetCode 167. Two Sum II - Input array is sorted (Medium)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apt与apt-get命令</title>
      <link href="/2016/10/25/apt_apt-get/"/>
      <url>/2016/10/25/apt_apt-get/</url>
      
        <content type="html"><![CDATA[<p><code>apt-get</code>是Debian及Ubuntu这类Linux发行版中最常用的软件安装命令，前几天又发现一个很相似的命令<code>apt</code>，也可以用于安装软件。去网上搜索了下这两个命令，整理如下。</p><a id="more"></a><p><code>apt-get</code>是一个传统的包管理程序，而<code>apt</code>似乎是Ubuntu Trusty之后才引入的一个新程序。具体讨论可参考下面这个链接：</p><blockquote><p><a href="http://askubuntu.com/questions/445384/what-is-the-difference-between-apt-and-apt-get" target="_blank" rel="noopener">What is the difference between apt and apt-get?</a></p></blockquote><p>重点内容摘录如下：</p><blockquote><p>They are very similar command line tools available in Trusty. Apt-get and apt-cache’s most commonly used commands are available in apt.</p><p><code>apt-get</code> may be considered as lower-level and “back-end”, and support other APT-based tools. <code>apt</code> is designed for end-users (human) and its output may be changed between versions.</p><p>The big news for this version is that we included a new <code>apt</code> binary that combines the most commonly used commands from <code>apt-get</code> and <code>apt-cache</code>. The commands are the same as their <code>apt-get</code>/<code>apt-cache</code> counterparts but with slightly different configuration options.</p></blockquote><p>一言以蔽之，<code>apt</code>可以视为是对<code>apt-get</code>及<code>apt-cache</code>中常用命令的二次打包封装，一般来说，可以直接使用<code>apt</code>来替代<code>apt-get</code>及<code>apt-cache</code>，它们之间并没有什么大的差别，而<code>apt</code>使用起来会更方便。</p><p><code>apt</code>支持以下命令操作：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>list</code></td><td>列出已安装的软件包</td></tr><tr><td><code>search</code></td><td>在源索引文件中搜索软件包</td></tr><tr><td><code>show</code></td><td>列出特定软件包的详细信息</td></tr><tr><td><code>install</code></td><td>安装软件包</td></tr><tr><td><code>remove</code></td><td>移除软件包</td></tr><tr><td><code>edit-sources</code></td><td>编辑源列表</td></tr><tr><td><code>update</code></td><td>同步源索引文件</td></tr><tr><td><code>upgrade</code></td><td>升级现有软件包</td></tr><tr><td><code>full-upgrade</code></td><td>类似<code>upgrade</code>，只是会自动删除冲突的软件包</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 160. Intersection of Two Linked Lists (Easy)</title>
      <link href="/2016/10/25/LeetCode_160/"/>
      <url>/2016/10/25/LeetCode_160/</url>
      
        <content type="html"><![CDATA[<p>两个链表，可能会有交叉，返回交叉点的元素，若没有交叉则返回<code>null</code>。</p><a id="more"></a><h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><blockquote><p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-linked-lists/</a></p><p>Write a program to find the node at which the intersection of two singly linked lists begins.<br>For example, the following two linked lists:</p></blockquote><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          <span class="built_in">a1</span> → <span class="built_in">a2</span></span><br><span class="line">                   ↘</span><br><span class="line">                     <span class="built_in">c1</span> → <span class="built_in">c2</span> → <span class="built_in">c3</span></span><br><span class="line">                   ↗            </span><br><span class="line"><span class="keyword">B: </span>    <span class="keyword">b1 </span>→ <span class="keyword">b2 </span>→ <span class="keyword">b3</span></span><br></pre></td></tr></table></figure><blockquote><p>begin to intersect at node c1.</p><p>Notes:</p><ul><li>If the two linked lists have no intersection at all, return <code>null</code>.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>若将<code>b1</code>节点连接到<code>c3</code>节点后面，此问题就转换为了<a href="/2016/10/24/LeetCode_142/">LeetCode 142. Linked List Cycle II</a>问题，可用相同方法求解，最后断开<code>c3 -&gt; b1</code>的连接即可。<a href="https://siddontang.gitbooks.io/leetcode-solution/content/linked_list/linked_list_cycle.html" target="_blank" rel="noopener">LeetCode题解</a>中就是这样做的，不过对此还可以进行优化。</p><p>开始时直接设置<code>slow</code>及<code>fast</code>指针进行移动，<code>fast</code>指针在移动过程中会遇到<code>null</code>，对此进行处理即可。第一次遇到<code>null</code>时进行连接，若第二次遇到<code>null</code>则说明两个链表没有交叉。其余步骤与LeetCode 142中的做法完全一样，具体见代码。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">getIntersectionNode</span><span class="params">(struct ListNode *headA, struct ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">slow</span>, * <span class="title">fast</span>, *<span class="title">p</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!headA || !headB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    slow = headA;</span><br><span class="line">    fast = headA;</span><br><span class="line">    p = headA;</span><br><span class="line">    tail = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!fast-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tail) &#123;</span><br><span class="line">                tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast-&gt;next = headB;</span><br><span class="line">            tail = fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tail) &#123;</span><br><span class="line">                tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast-&gt;next-&gt;next = headB;</span><br><span class="line">            tail = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (p != slow) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><blockquote><p><a href="/2016/10/24/LeetCode_141/">LeetCode 141. Linked List Cycle (Easy)</a><br><a href="/2016/10/24/LeetCode_142/">LeetCode 142. Linked List Cycle II (Medium)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 142. Linked List Cycle II (Medium)</title>
      <link href="/2016/10/24/LeetCode_142/"/>
      <url>/2016/10/24/LeetCode_142/</url>
      
        <content type="html"><![CDATA[<p>给定一个链表，返回链表中环的开始节点，若没有环，返回<code>null</code>。</p><a id="more"></a><h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><blockquote><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/</a></p><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p>Note: Do not modify the linked list.</p><p>Follow up:<br>Can you solve it without using extra space?</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>类似<a href="/2016/10/24/LeetCode_141/">LeetCode 141</a>的解法，只是之后还要求出环开始的节点，这依赖于一些数学关系，下面来简要推导一下。</p><p><img src="https://pic.gaomf.store/05171805-64db9f059a1641e7afaf3dd8223c4fe7.jpg" alt=""></p><p>如图所示，假设<code>slow</code>指针运动到$Y$节点时，<code>fast</code>指针位于环中任意位置（图中未标出），其距$Y$点的距离为$m$。首先证明当<code>slow</code>指针与<code>fast</code>指针相遇于环中某一点$Z$时，<code>slow</code>指针移动距离$b$小于环的长度$L$，且<code>fast</code>指针只会比<code>slow</code>指针多移动一圈。</p><p>假设此时<code>slow</code>指针移动距离为$b$($b$ &lt; $L$)，<code>fast</code>指针比<code>slow</code>指针多移动了$N$圈，则：<br>$$b=m+2b-NL$$<br>$$\Rightarrow b=NL-m$$<br>$$\because 0 \leqslant b \leqslant L, 0 \leqslant m \leqslant L$$<br>$$\therefore N = 1$$<br>$$\Rightarrow b=L-m$$<br>对任意$m$及$L$，均可由上式确定唯一的$b$，故原命题成立。</p><p>下面在此基础上推导$a$与$c$之间的关系，应用上面得出的结论，两指针相遇时有：</p><p>$$2(a+b)=a+b+KL$$<br>式中$K$表示相遇时<code>fast</code>指针在环中运行的圈数。<br>$$\Rightarrow a=KL-b$$<br>$$\Rightarrow a=(K-1)L+L-b$$<br>$$\Rightarrow a=(K-1)L+c$$</p><p>上式意味着，若<code>slow</code>与<code>fast</code>指针相遇于$Z$点后，<code>slow</code>指针继续前进，同时增加一个指针<code>p</code>从$X$点出发，则<code>slow</code>与<code>p</code>的相遇点必定是$Y$，这也就是需要返回的节点。根据上述思路即可写出代码。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">slow</span>, * <span class="title">fast</span>, * <span class="title">p</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    slow = head;</span><br><span class="line">    fast = head;</span><br><span class="line">    p = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != slow) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><blockquote><p><a href="/2016/10/24/LeetCode_141/">LeetCode 141. Linked List Cycle (Easy)</a><br><a href="/2016/10/25/LeetCode_160/">LeetCode 160. Intersection of Two Linked Lists (Easy)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 141. Linked List Cycle (Easy)</title>
      <link href="/2016/10/24/LeetCode_141/"/>
      <url>/2016/10/24/LeetCode_141/</url>
      
        <content type="html"><![CDATA[<p>给定一个链表，确定其中是否有环。</p><a id="more"></a><h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><blockquote><p><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle/</a></p><p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up:<br>Can you solve it without using extra space?</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>最直接的想法是用一个集合将之前出现过的节点保存起来，之后判断新节点是否在已有节点的集合中即可，不过这种方法效率较低，而且需要很大的额外空间，并不是好方法。</p><p>这个问题比较优秀的解法是，引入两个指针，一个<code>slow</code>指针一次前进一步，另一个<code>fast</code>指针一次前进两步，这两个指针相遇即是存在环的充要条件。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">slow</span>, * <span class="title">fast</span>;</span></span><br><span class="line">    slow = head;</span><br><span class="line">    fast = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow, fast;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        slow = head;</span><br><span class="line">        fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(slow != fast);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用了一种比较特殊的写法，使用了<code>try...catch...</code>语句块进行异常捕捉，当<code>fast.next.next</code>遇到<code>null</code>时即会发生异常，此时意味着到达了链表结尾，链表中不存在环，故返回<code>false</code>。</p><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><blockquote><p><a href="/2016/10/24/LeetCode_142/">LeetCode 142. Linked List Cycle II (Medium)</a></p><blockquote><p><a href="/2016/10/25/LeetCode_160/">LeetCode 160. Intersection of Two Linked Lists (Easy)</a></p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 415. Add String (Easy)</title>
      <link href="/2016/10/24/LeetCode_415/"/>
      <url>/2016/10/24/LeetCode_415/</url>
      
        <content type="html"><![CDATA[<p>给定两个字符串表示的非负整数，求其和，结果也用字符串表示。</p><a id="more"></a><h2 id="原始问题"><a href="#原始问题" class="headerlink" title="原始问题"></a>原始问题</h2><blockquote><p><a href="https://leetcode.com/problems/add-strings/" target="_blank" rel="noopener">https://leetcode.com/problems/add-strings/</a></p><p>Given two non-negative numbers <code>num1</code> and <code>num2</code> represented as string, return the sum of <code>num1</code> and <code>num2</code>.</p><p>Note:</p><p>The length of both <code>num1</code> and <code>num2</code> is &lt; 5100.<br>Both <code>num1</code> and <code>num2</code> contains only digits <code>0-9</code>.<br>Both <code>num1</code> and <code>num2</code> does not contain any leading zero.<br>You <strong>must not use any built-in BigInteger library</strong> or <strong>convert the inputs to integer</strong> directly.</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从最低位开始逐位相加即可，注意处理进位。网上搜索到的AC代码处理进位一般都使用<code>/10</code>及<code>%10</code>的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = sum / <span class="number">10</span>;</span><br><span class="line">result += sum % <span class="number">10</span> + <span class="string">'0'</span>;</span><br></pre></td></tr></table></figure><p>此方法代码简洁，不过效率很低，因为除法和取模开销会很大，故此处使用了其他方法进行处理，具体见下面的代码。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">addStrings</span><span class="params">(<span class="keyword">char</span>* num1, <span class="keyword">char</span>* num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> digits1 = <span class="built_in">strlen</span>(num1);</span><br><span class="line">    <span class="keyword">int</span> digits2 = <span class="built_in">strlen</span>(num2);</span><br><span class="line">    <span class="keyword">int</span> sumDigits = digits1 &gt; digits2 ? digits1 + <span class="number">1</span> : digits2 + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> * sumStr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((sumDigits + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    sumStr[sumDigits] = <span class="string">'\0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> carryFlag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmpNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= sumDigits; i++) &#123;</span><br><span class="line">        tmpNum = carryFlag;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= digits1) &#123;</span><br><span class="line">            tmpNum += (num1[digits1 - i] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= digits2) &#123;</span><br><span class="line">            tmpNum += (num2[digits2 - i] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (tmpNum &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            tmpNum -= <span class="number">10</span>;</span><br><span class="line">            carryFlag = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            carryFlag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sumStr[sumDigits - i] = tmpNum + <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sumStr[<span class="number">0</span>] == <span class="string">'0'</span>) &#123;</span><br><span class="line">        sumStr++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sumStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sumStr</code>数组是一次性申请分配了全部所需空间，不需要动态扩容，这样做效率很高。不过这段代码有个小瑕疵，最后去除首位不需要的<code>0</code>时直接使用了<code>sumStr++</code>，这会导致一个字节的内存泄漏问题。</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> digits1 = num1.length();</span><br><span class="line">        <span class="keyword">int</span> digits2 = num2.length();</span><br><span class="line">        <span class="keyword">int</span> sumDigits = digits1 &gt; digits2 ? digits1: digits2;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">string</span> sumStr = <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> carryFlag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= sumDigits; i++) &#123;</span><br><span class="line">            tmpNum = carryFlag;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= digits1) &#123;</span><br><span class="line">                tmpNum += (num1[digits1 - i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= digits2) &#123;</span><br><span class="line">                tmpNum += (num2[digits2 - i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (tmpNum &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                tmpNum -= <span class="number">10</span>;</span><br><span class="line">                carryFlag = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                carryFlag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            sumStr += (tmpNum + <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (carryFlag == <span class="number">1</span>) &#123;</span><br><span class="line">            sumStr += <span class="string">'1'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        reverse(sumStr.begin(), sumStr.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sumStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里使用了C++风格的<code>string</code>操作，用<code>+=</code>连接新加入的字符，最后用<code>reverse()</code>函数翻转字符串。显而易见，这样做的效率没有C语言版本高。</p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM架构及内核</title>
      <link href="/2016/10/20/ARM_Architecture_Core/"/>
      <url>/2016/10/20/ARM_Architecture_Core/</url>
      
        <content type="html"><![CDATA[<p>一般的ARM芯片都会涉及到以下一些概念：芯片型号、ARM内核名称、指令集名称等等，这些概念间既有联系也有区别。本文简要梳理下这些不同的概念，并选择一些我接触过的芯片进行下总结。一个比较完整的ARM产品线列表可参考Wikipedia页面：</p><blockquote><p><a href="https://en.wikipedia.org/wiki/List_of_ARM_microarchitectures" target="_blank" rel="noopener">List of ARM microarchitectures</a></p></blockquote><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="ARM产品家族"><a href="#ARM产品家族" class="headerlink" title="ARM产品家族"></a>ARM产品家族</h3><p>即ARM Family，就是ARM公司不同的产品系列，这个分类主要是从市场及销售角度进行的划分。1985年，ARM公司研发出未量产的第一代产品<code>ARM1</code>，之后陆续推出了<code>ARM2</code>、<code>ARM3</code>、<code>ARM6</code>三个系列的产品，不过这些产品基本都是没人知道的。直到1997年，ARM推出<code>ARM7T</code>系列产品，这才标志着ARM大规模商用推广的开始，2000年左右推出的<code>ARM9T</code>及<code>ARM9E</code>系列更成为了ARM公司里程碑式的经典产品。之后的ARM还推出了<code>ARM10E</code>及<code>ARM11</code>这两个系列。</p><p>不过估计是觉得这样的命名太混乱了，不利于市场推广，在2005年左右，ARM将其新推出的所有CPU分为3大家族，这就是现在广为人知的<code>Cortex-A</code>、<code>Cortex-M</code>及<code>Cortex-R</code>系列，到目前为止10多年来都沿用了这一名字没有变过。其中<code>Cortex-A</code>定位于对计算性能要求较高的<code>Application</code>领域；<code>Cortex-M</code>定位于低功耗、低成本的微控制器<code>Microcontroller</code>领域；<code>Cortex-R</code>定位于对安全、实时性要求较高的<code>Realtime</code>领域。</p><p>不知将来ARM的新产品会不会换个名字呢？毕竟现在的市场局势和10年前相比有了很大的变化，而且ARM还被软银收购了……我们拭目以待。</p><h3 id="ARM架构名称"><a href="#ARM架构名称" class="headerlink" title="ARM架构名称"></a>ARM架构名称</h3><p>即ARM Architecture，就是指一套处理器体系结构及其对应的指令集等，这是从技术层面进行的划分，架构的升级就意味着产品的更新与迭代。架构与处理器家族系列间并不存在一一对应的关系，比如<code>ARM7T</code>与<code>ARM9T</code>系列使用的就是相同的<code>ARMv4T</code>架构，而<code>Cortex-A</code>系列中包含了<code>ARMv7-A</code>及<code>ARMv8-A</code>两种架构。</p><p>除了基础架构外，ARM还会用后缀表示功能增强的衍生架构，比如<code>E</code>后缀代表DSP指令集增强（<code>ARMv5TE</code>）、<code>J</code>后缀代表Jazelle加速技术（<code>ARMv5TEJ</code>）等。</p><p>目前最新的架构为<code>ARMv8-A</code>。关于ARM架构的详细信息，可参考Wikipedia页面：</p><blockquote><p><a href="https://en.wikipedia.org/wiki/ARM_architecture" target="_blank" rel="noopener">ARM architecture</a></p></blockquote><h3 id="ARM内核名称"><a href="#ARM内核名称" class="headerlink" title="ARM内核名称"></a>ARM内核名称</h3><p>即ARM Core，就是实际实现出来的内核名称。ARM内核包括由ARM自己设计的公版内核及由其他架构授权合作伙伴设计的第三方内核。ARM自己设计的内核包括<code>ARM920T</code>、<code>Cortex-M3</code>、<code>Cortex-M4</code>、<code>Cortex-A5</code>、<code>Cortex-A57</code>等诸多型号；第三方内核中，最有名的就是高通的<code>Snapdragon</code>系列，包括<code>Scorpion</code>、<code>Krait</code>、<code>Kryo</code>三种型号的内核，还有苹果自己设计的<code>Ax</code>系列，目前包括<code>Swift</code>、<code>Cyclone</code>、<code>Typhoon</code>、<code>Twister</code>、<code>Hurricane</code>等型号的内核。</p><h3 id="产品名称"><a href="#产品名称" class="headerlink" title="产品名称"></a>产品名称</h3><p>就是最终的SOC芯片型号，一个SOC芯片只有CPU Core是不够的，还需要很多其他外设，整合到一起最终形成一个芯片。所以很多不同型号的芯片其实是共用一个CPU Core设计的，比如<code>STM32F4</code>系列，包含相当多的芯片型号，不过它们的CPU内核都是一样的——基于<code>ARMv7E-M</code>架构的<code>Cortex-M4</code>内核。</p><h2 id="部分ARM芯片总结"><a href="#部分ARM芯片总结" class="headerlink" title="部分ARM芯片总结"></a>部分ARM芯片总结</h2><p>这里仅选取我接触过的和一些近期比较有名的手机芯片进行总结，按照ARM架构和ARM内核进行分类排序。</p><table><thead><tr><th>芯片型号或系列</th><th>厂商</th><th>AMR内核</th><th>ARM架构</th></tr></thead><tbody><tr><td>S3C2410</td><td>Samsung</td><td>ARM920T</td><td>ARMv4T</td></tr><tr><td>STM32F0</td><td>ST</td><td>Cortex-M0</td><td>ARMv6-M</td></tr><tr><td>STM32F1</td><td>ST</td><td>Cortex-M3</td><td>ARMv7-M</td></tr><tr><td>STM32F4</td><td>ST</td><td>Cortex-M4</td><td>ARMv7E-M</td></tr><tr><td>K60</td><td>Freescale</td><td>Cortex-M4</td><td>ARMv7E-M</td></tr><tr><td>STM32F7</td><td>ST</td><td>Cortex-M7</td><td>ARMv7E-M</td></tr><tr><td>H3</td><td>Allwinner</td><td>Cortex-A7</td><td>ARMv7-A</td></tr><tr><td>BCM2836</td><td>Broadcom</td><td>4*Cortex-A7</td><td>ARMv7-A</td></tr><tr><td>S5PV210</td><td>Samsung</td><td>Cortex-A8</td><td>ARMv7-A</td></tr><tr><td>AM3359</td><td>TI</td><td>Cortex-A8</td><td>ARMv7-A</td></tr><tr><td>i.MX6DL</td><td>Freescale</td><td>2*Cortex-A9</td><td>ARMv7-A</td></tr><tr><td>BCM2837</td><td>Broadcom</td><td>4*Cortex-A53</td><td>ARMv8-A</td></tr><tr><td>MT6797</td><td>MTK</td><td>2*Cortex-A72 + 8*Cortex-A53</td><td>ARMv8-A</td></tr><tr><td>Kirin 950</td><td>Huawei</td><td>4*Cortex-A72 + 4*Cortex-A53</td><td>ARMv8-A</td></tr><tr><td>Exynos 8890</td><td>Samsung</td><td>4*Mongoose + 4*Cortex-A53</td><td>ARMv8-A</td></tr><tr><td>Snapdragon 820</td><td>Qualcomm</td><td>4*Kryo</td><td>ARMv8-A</td></tr><tr><td>A10</td><td>Apple</td><td>4*Hurricane</td><td>ARMv8-A</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>diff及patch的使用</title>
      <link href="/2016/10/19/Diff_Patch/"/>
      <url>/2016/10/19/Diff_Patch/</url>
      
        <content type="html"><![CDATA[<p>Linux下，<code>diff</code>命令用于比较两个文件的差异，也可用于创建补丁文件，而<code>patch</code>命令用于打补丁，也就是应用<code>diff</code>命令生成的补丁文件更新现有文件。下面简要总结下这两个命令的使用方法。</p><a id="more"></a><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff oldfile newfile</span><br></pre></td></tr></table></figure><p>注意：<code>diff</code>命令是<strong>按行</strong>比较两个文本文件的，所以一般只用它比较两个基本相同的文本文件，如同一份源代码的不同版本。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p><code>diff</code>一共有3种输出格式：</p><ul><li>正常格式（normal diff）</li><li>上下文格式（context diff）</li><li>合并格式（unified diff）</li></ul><p>一般使用合并格式，这种格式比较适合阅读，加上<code>-u</code>参数即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -u f1 f2</span><br></pre></td></tr></table></figure><p>关于<code>diff</code>的输出格式详细说明可参考：</p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html" target="_blank" rel="noopener">读懂diff</a></p></blockquote><h3 id="创建补丁文件"><a href="#创建补丁文件" class="headerlink" title="创建补丁文件"></a>创建补丁文件</h3><p>所谓的补丁文件其实就是<code>diff</code>的输出，将其重定向至文件即可，生成的补丁文件习惯上使用<code>.patch</code>后缀。</p><p>常用参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -ruaN oldfile newfile &gt; patchfile.patch</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>-r: 递归遍历子目录</li><li>-u: 使用合并格式输出</li><li>-a: 将所有文件视为文本文件</li><li>-N: 将未出现的文件视为空文件（比较目录时有用）</li></ul><p><code>oldfile</code>及<code>newfile</code>可以是一个目录，配合<code>-r</code>参数使用就会递归比较这两个目录。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面用一个例子来说明。</p><p>有以下文件目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── new</span><br><span class="line">│   ├── 1.txt</span><br><span class="line">│   └── 2.txt</span><br><span class="line">└── old</span><br><span class="line">    ├── 1.txt</span><br><span class="line">    └── 2.txt</span><br></pre></td></tr></table></figure><p><code>old</code>文件夹中存放的是老版本，<code>new</code>中是新版本。使用以下命令生成补丁文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -ruaN old new &gt; update.patch</span><br></pre></td></tr></table></figure><p>生成的<code>update.patch</code>文件如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">diff -aruN old/1.txt new/1.txt</span><br><span class="line"><span class="comment">--- old/1.txt   2016-10-19 00:12:51.572014429 +0800</span></span><br><span class="line"><span class="comment">+++ new/1.txt   2016-10-15 12:10:18.581633573 +0800</span></span><br><span class="line"><span class="meta">@@ -1,3 +1,3 @@</span></span><br><span class="line"><span class="deletion">-old Line 1</span></span><br><span class="line"><span class="deletion">-old Line 2</span></span><br><span class="line"><span class="deletion">-old Line 3</span></span><br><span class="line"><span class="addition">+new Line 1</span></span><br><span class="line"><span class="addition">+new Line 2</span></span><br><span class="line"><span class="addition">+new Line 3</span></span><br><span class="line">diff -aruN old/2.txt new/2.txt</span><br><span class="line"><span class="comment">--- old/2.txt   2016-10-19 00:12:51.572014429 +0800</span></span><br><span class="line"><span class="comment">+++ new/2.txt   2016-10-15 12:11:03.847494158 +0800</span></span><br><span class="line"><span class="meta">@@ -1,4 +1,4 @@</span></span><br><span class="line"><span class="deletion">-Old Line 1</span></span><br><span class="line"><span class="deletion">-Old Line 2</span></span><br><span class="line"><span class="deletion">-Old Line 3</span></span><br><span class="line"><span class="addition">+New Line 1</span></span><br><span class="line"><span class="addition">+New Line 2</span></span><br><span class="line"><span class="addition">+New Line 3</span></span><br></pre></td></tr></table></figure><hr><p>需要注意的是，使用如下命令也可以生成补丁文件：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -aruN ./old ./new &gt; update2.patch</span><br></pre></td></tr></table></figure><p>但是生成的补丁文件是不一样的：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">diff -aruN ./old/1.txt ./new/1.txt</span><br><span class="line"><span class="comment">--- ./old/1.txt 2016-10-19 00:12:51.572014429 +0800</span></span><br><span class="line"><span class="comment">+++ ./new/1.txt 2016-10-15 12:10:18.581633573 +0800</span></span><br><span class="line"><span class="meta">@@ -1,3 +1,3 @@</span></span><br><span class="line"><span class="deletion">-old Line 1</span></span><br><span class="line"><span class="deletion">-old Line 2</span></span><br><span class="line"><span class="deletion">-old Line 3</span></span><br><span class="line"><span class="addition">+new Line 1</span></span><br><span class="line"><span class="addition">+new Line 2</span></span><br><span class="line"><span class="addition">+new Line 3</span></span><br><span class="line">diff -aruN ./old/2.txt ./new/2.txt</span><br><span class="line"><span class="comment">--- ./old/2.txt 2016-10-19 00:12:51.572014429 +0800</span></span><br><span class="line"><span class="comment">+++ ./new/2.txt 2016-10-15 12:11:03.847494158 +0800</span></span><br><span class="line"><span class="meta">@@ -1,4 +1,4 @@</span></span><br><span class="line"><span class="deletion">-Old Line 1</span></span><br><span class="line"><span class="deletion">-Old Line 2</span></span><br><span class="line"><span class="deletion">-Old Line 3</span></span><br><span class="line"><span class="addition">+New Line 1</span></span><br><span class="line"><span class="addition">+New Line 2</span></span><br><span class="line"><span class="addition">+New Line 3</span></span><br></pre></td></tr></table></figure><p>差异在于<strong>文件路径不同</strong>，这会导致之后使用<code>patch</code>打补丁时所需的命令有所区别，下文再讨论这一问题。</p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><h3 id="应用补丁"><a href="#应用补丁" class="headerlink" title="应用补丁"></a>应用补丁</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch &lt; patchfile</span><br></pre></td></tr></table></figure><p>一般不需要指定需要打补丁的文件，这个可以从<code>patchfile</code>中自动推导出来，就是文件中<code>---</code>部分的<code>oldfile</code>，<code>patch</code>命令会自动将<code>newfile</code>中的变更应用于<code>oldfile</code>上。</p><h3 id="回滚补丁"><a href="#回滚补丁" class="headerlink" title="回滚补丁"></a>回滚补丁</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -R &lt; patchfile</span><br></pre></td></tr></table></figure><p>回滚补丁的意思是在对<code>oldfile</code>应用了补丁后，又需要取消这个补丁，即回滚到<code>oldfile</code>原始的状态。</p><h3 id="移去路径级别"><a href="#移去路径级别" class="headerlink" title="移去路径级别"></a>移去路径级别</h3><p>上面的用法中均是假定<code>patchfile</code>中的路径是正确的，然而很多时候这个路径会包含不需要的目录级别，这时就需要用<code>-pNum</code>参数来移去多余的路径级别：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -pNum &lt; patchfile</span><br></pre></td></tr></table></figure><p>这里的<code>Num</code>是一个数字，如<code>-p1</code>、<code>-p2</code>等。p级别告诉<code>patch</code>命令忽略掉路径名的前几个部分以正确的识别文件，总的来说，<strong>从路径最开始删除路径分隔符（<code>/</code>）及其之前的所有字符，每次加1，直到剩下的部分存在于当前工作目录中，最后得到的就是p级别</strong>。 具体使用方法见下文的示例。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>接着上文<code>diff</code>命令中的示例进行，此时我们已经有了补丁文件<code>update.patch</code>，下面来应用这个补丁，使用以下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch &lt; update.patch</span><br></pre></td></tr></table></figure><p>这样既可将<code>old</code>文件夹中的内容更新为<code>new</code>文件夹中的内容。</p><p>如果需要回滚补丁，即恢复<code>old</code>文件夹中的原始内容，使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -R &lt; update.patch</span><br></pre></td></tr></table></figure><hr><p>不过针对<code>update2.patch</code>文件，如果直接使用上述命令打补丁会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">can<span class="string">'t find file to patch at input line 4</span></span><br><span class="line"><span class="string">Perhaps you should have used the -p or --strip option?</span></span><br><span class="line"><span class="string">The text leading up to this was:</span></span><br><span class="line"><span class="string">--------------------------</span></span><br><span class="line"><span class="string">|diff -aruN ./old/1.txt ./new/1.txt</span></span><br><span class="line"><span class="string">|--- ./old/1.txt        2016-10-19 00:12:51.572014429 +0800</span></span><br><span class="line"><span class="string">|+++ ./new/1.txt        2016-10-15 12:10:18.581633573 +0800</span></span><br><span class="line"><span class="string">--------------------------</span></span><br><span class="line"><span class="string">File to patch:</span></span><br></pre></td></tr></table></figure><p>此时可以手动输入对应文件的路径<code>./old/1.txt</code>，然而这并不是一个好方法，正确的方法是使用<code>-pNum</code>参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -p1 &lt; update2.patch</span><br></pre></td></tr></table></figure><p><code>-p1</code>表示去掉第一层路径分隔符，即<code>./</code>，此时得到的<code>old</code>文件夹位于当前路径中，于是就可以正确的打补丁了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更换博客主题啦~</title>
      <link href="/2016/10/13/Blog_New_Theme_2016/"/>
      <url>/2016/10/13/Blog_New_Theme_2016/</url>
      
        <content type="html"><![CDATA[<p>前几天看到<a href="http://moxfive.xyz/" target="_blank" rel="noopener">MOxFIVE</a>的博客，很喜欢博主基于Yilia主题制作的的<a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">Yelee</a>主题，于是先是折腾了一天，把搜索功能移植过来了；之后又想把层叠目录也移植过来，又是一天折腾，然而最终也没有成功:(</p><p>后面一想，不如直接就用博主的Yelee主题吧，于是又是一天折腾，把主题由Yilia更换成了Yelee，并且根据自己的需求修改了此主题，做成了现在这个相对比较满意的效果~~</p><p>之后尽量不再折腾这些了，还是好好学习嵌入式做项目更重要……</p>]]></content>
      
      
      <categories>
          
          <category> 点滴之间 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>旋转编码器速度测量方法</title>
      <link href="/2016/10/13/Encoder_Velocity_Measure/"/>
      <url>/2016/10/13/Encoder_Velocity_Measure/</url>
      
        <content type="html"><![CDATA[<p>大部分旋转编码器均产生两路正交的输出信号，即A相与B相；部分旋转编码器还有一个Z相输出，其主要作用是进行定位，以确定零点位置。通过A、B两相信号就可以确定转速和转向。</p><a id="more"></a><p>旋转编码器的结构及其输出信号形式如下图所示：</p><p><img src="https://pic.gaomf.store/20160522152021.png-width600" alt=""></p><p>从原理上来说确定转速有两种方法：</p><p>$$v(k)\approx \frac{\Delta X}{T}\ \ \ \ \ (1)$$</p><p>$$v(k)\approx \frac{X}{\Delta T}\ \ \ \ \ (2)$$</p><p>式(1)固定时间周期，测量在一定时间内的脉冲个数，进而计算出速度。这种方法中，可以认为时间是准确的，不过脉冲数是有误差的；</p><p>式(2)固定脉冲数，测量一定脉冲数所需的时间，进而计算出速度。这种方法中，可以认为脉冲数是准确的，而时间是有误差的；</p><p>一般来说，方法(1)适用于高速情况，而方法(2)适用于低速情况。而且定时器的精度一般都高于旋转编码器，故方法(2)的精度一般要更高一些。</p><p>对于方法(2)，针对TI C2000系列DSP，我编写了一个简易Excel表格用于计算<code>QCPDR</code>、溢出次数、误差和同等情况下使用方法(1)所需的周期<code>T</code>，可以从<a href="https://pic.gaomf.store/28030%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E8%AE%A1%E7%AE%97.xlsx" target="_blank" rel="noopener">这里</a>下载。</p>]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor </tag>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为Hexo博客Yilia主题添加本地站内搜索功能</title>
      <link href="/2016/10/10/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2Yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
      <url>/2016/10/10/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2Yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>博客的站内搜索功能一直是一个缺憾，最初使用了<a href="https://swiftype.com/" target="_blank" rel="noopener">Swiftype</a>，虽然效果不是很理想，不过也正常使用了一段时间，然而之后发现使用Swiftype会导致博客标签加载不完全，进而影响正常显示。奈何我基本不懂前端，瞎折腾了很久也没能解决这个问题，最后只得禁用了Swiftype，留下的搜索框成了一个摆设。前段时候发现Hexo博客可以使用本地站内搜索，于是又折腾了一天，然而最终还是没有做出可用的搜索界面来：(本来已经不抱什么希望了，今天偶然看见<a href="http://moxfive.xyz/2016/05/31/hexo-local-search/" target="_blank" rel="noopener">让 Hexo 博客支持本地站内搜索</a>这篇文章，作者使用的主题也是基于Yilia的，顿时觉得有戏，于是又是一天折腾，终于做出了个像样的站内搜索功能来了~~写篇文章记录下折腾过程。</p><a id="more"></a><h2 id="生成索引文件"><a href="#生成索引文件" class="headerlink" title="生成索引文件"></a>生成索引文件</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>本地站内搜索都是基于索引文件的，Hexo中可通过<code>hexo-generator-search</code>插件生成XML格式的索引文件，通过<code>hexo-generator-json-content</code>插件生成JSON格式的索引文件，此处选择了<code>hexo-generator-search</code>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save hexo-generator-search</span></span><br></pre></td></tr></table></figure><p>然后在Hexo站点根目录下的<code>_config.yml</code>中添加如下配置即可：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: all</span><br></pre></td></tr></table></figure><h3 id="修改插件"><a href="#修改插件" class="headerlink" title="修改插件"></a>修改插件</h3><p>默认生成的<code>search.xml</code>文件很大，而且包含很多冗余信息，参考<a href="http://www.netcan666.com/2015/11/20/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">完美解决Hexo静态博客搜索问题</a>这篇文章对其进行精简。</p><p>首先在修改<code>node_modules/hexo-generator-search/index.js</code>文件，在其中添加3个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stripe_code = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123; <span class="comment">// 去除代码</span></span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/&lt;figure class="highlight.*?&lt;\/figure&gt;/ig</span>, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line">stripe = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123; <span class="comment">// 去除html标签</span></span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/(&lt;([^&gt;]+)&gt;)/ig</span>, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line">minify = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123; <span class="comment">// 压缩成一行</span></span><br><span class="line">    <span class="keyword">return</span> str.trim().replace(<span class="regexp">/\n/g</span>, <span class="string">' '</span>).replace(<span class="regexp">/\s+/g</span>, <span class="string">' '</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.netcan666.com/" target="_blank" rel="noopener">Netcan</a>的文章中是去除代码行数，此处改成了去除所有代码，因为一般无需对代码进行搜索。</p><p>之后修改模板文件<code>search.ejs</code>，主要目的是调用上面添加的3个函数对实际内容进行精简，修改<code>&lt;content type=&quot;html&quot;&gt;</code>标签中的内容即可：</p><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">content</span> <span class="attr">type</span>=<span class="string">"html"</span>&gt;</span><span class="tag">&lt;<span class="name">%-</span></span></span><span class="ruby">: minify(stripe(stripe_code(post.content))) <span class="params">| cdata </span></span><span class="xml"><span class="tag">%&gt;</span><span class="tag">&lt;/<span class="name">content</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">content</span> <span class="attr">type</span>=<span class="string">"html"</span>&gt;</span><span class="tag">&lt;<span class="name">%-</span></span></span><span class="ruby">: minify(stripe(stripe_code(page.content))) <span class="params">| cdata </span></span><span class="xml"><span class="tag">%&gt;</span><span class="tag">&lt;/<span class="name">content</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>精简后，生成的<code>search.xml</code>文件体积可缩小为原来的1/3.</p><blockquote><p>Update 2018-01-21:</p><p>目前新版的<code>hexo-generator-search</code>插件模板文件位置有所改变，改为了<code>templates/xml.ejs</code>文件，修改方法不变。</p></blockquote><h2 id="界面结构及样式"><a href="#界面结构及样式" class="headerlink" title="界面结构及样式"></a>界面结构及样式</h2><h3 id="添加HTML代码"><a href="#添加HTML代码" class="headerlink" title="添加HTML代码"></a>添加HTML代码</h3><p>搜索框沿用了之前Swiftype的搜索框，放在侧边栏的最上方，这个比较符合我的审美。参考<a href="http://moxfive.xyz/2016/05/31/hexo-local-search/" target="_blank" rel="noopener">MOxFIVE</a>的做法将搜索结果也放在侧边栏中，没有添加搜索重置按钮。修改<code>left-col.ejs</code>文件，在其中添加相关代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"overlay"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"intrude-less"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"search-form"</span> <span class="attr">class</span>=<span class="string">"search"</span>&gt;</span>  <span class="comment">&lt;!-- 搜索框相关 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"st-search-input"</span> <span class="attr">name</span>=<span class="string">"q"</span> <span class="attr">results</span>=<span class="string">"0"</span> <span class="attr">class</span>=<span class="string">"st-default-search-input"</span> <span class="attr">maxlength</span>=<span class="string">"30"</span> <span class="attr">placeholder</span>=<span class="string">"Search..."</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span> <span class="attr">autocorrect</span>=<span class="string">"off"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">id</span>=<span class="string">"header"</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span> <span class="attr">class</span>=<span class="string">"profilepic"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">theme.animate</span>)&#123; %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">lazy-src</span>=<span class="string">"&lt;%=theme.avatar%&gt;"</span> <span class="attr">class</span>=<span class="string">"js-avatar"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%&#125;else&#123;%</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&lt;%=theme.avatar%&gt;"</span> <span class="attr">class</span>=<span class="string">"js-avatar"</span> <span class="attr">style</span>=<span class="string">"width: 100%;height: 100%;opacity: 1;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%&#125;%</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">hgroup</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"header-author"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span><span class="tag">&lt;<span class="name">%=theme.author%</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">hgroup</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">theme.subtitle</span>)&#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"header-subtitle"</span>&gt;</span><span class="tag">&lt;<span class="name">%=theme.subtitle%</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%&#125;%</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"local-search-result"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- 搜索结果区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">'no-result'</span>&gt;</span>No results found <span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 无匹配时显示，注意请在 CSS 中设置默认隐藏 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 以下保持不变，省略 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改CSS样式"><a href="#修改CSS样式" class="headerlink" title="修改CSS样式"></a>修改CSS样式</h3><p>CSS样式直接使用了<a href="http://moxfive.xyz/2016/05/31/hexo-local-search/" target="_blank" rel="noopener">MOxFIVE</a>的样式（去掉了其中用不到的部分），在<code>style.styl</code>文件中添加以下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">form</span> <span class="selector-tag">input</span><span class="selector-class">.st-default-search-input</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">4px</span> <span class="number">9px</span> <span class="number">4px</span> <span class="number">27px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">140px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">-webkit-border-radius</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">-moz-border-radius</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">-ms-border-radius</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">-o-border-radius</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">-webkit-box-shadow</span>: inset <span class="number">0</span> <span class="number">1px</span> <span class="number">3px</span> <span class="number">0</span> <span class="built_in">rgba</span>(0,0,0,0.17);</span><br><span class="line">    <span class="attribute">-moz-box-shadow</span>: inset <span class="number">0</span> <span class="number">1px</span> <span class="number">3px</span> <span class="number">0</span> <span class="built_in">rgba</span>(0,0,0,0.17);</span><br><span class="line">    <span class="attribute">box-shadow</span>: inset <span class="number">0</span> <span class="number">1px</span> <span class="number">3px</span> <span class="number">0</span> <span class="built_in">rgba</span>(0,0,0,0.17);</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fcfcfc</span> <span class="built_in">url</span>(/img/search.png) no-repeat <span class="number">7px</span> <span class="number">7px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*搜索结果区*/</span></span><br><span class="line"><span class="selector-id">#local-search-result</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: auto -<span class="number">12%</span> auto -<span class="number">6%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">  <span class="attribute">word-break</span>: break-all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#local-search-result</span> <span class="selector-tag">ul</span><span class="selector-class">.search-result-list</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*单条搜索结果*/</span></span><br><span class="line"><span class="selector-id">#local-search-result</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0.5em</span> auto;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid <span class="number">#d3d3d3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#local-search-result</span> <span class="selector-class">.search-result-list</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(158,188,226,0.21);</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(0,0,0,0.2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*匹配的标题*/</span></span><br><span class="line"><span class="selector-id">#local-search-result</span> <span class="selector-tag">a</span><span class="selector-class">.search-result-title</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.2</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#708090</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*搜索预览段落*/</span></span><br><span class="line"><span class="selector-id">#local-search-result</span> <span class="selector-tag">p</span><span class="selector-class">.search-result</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0.4em</span> auto;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.2em</span>;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">3.6em</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.8em</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: justify;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#808080</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*匹配的关键词*/</span></span><br><span class="line"><span class="selector-id">#local-search-result</span> <span class="selector-tag">em</span><span class="selector-class">.search-keyword</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f58e90</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> dashed <span class="number">#f58e90</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.85em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*无匹配搜索结果时显示*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.no-result</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">2em</span> <span class="number">0</span> <span class="number">2em</span> <span class="number">6%</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#808080</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: font-serif serif;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid <span class="number">#d3d3d3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>input.st-default-search-input</code>是Swiftype提供的搜索框样式。</p><h3 id="添加侧边栏滚动条"><a href="#添加侧边栏滚动条" class="headerlink" title="添加侧边栏滚动条"></a>添加侧边栏滚动条</h3><p>Yilia主题的侧边栏是不会添加滚动条的，这就会造成搜索结果显示不完全，需要修改<code>main.styl</code>文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left-col</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line">    <span class="attribute">position</span>:fixed;</span><br><span class="line">    <span class="attribute">opacity</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">transition</span>:all .<span class="number">2s</span> ease-in;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">+    overflow-y: auto;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.switch-area</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">-    min-height: 500px;</span><br><span class="line">+    <span class="selector-tag">min-height</span>: 200<span class="selector-tag">px</span>;</span><br><span class="line">    <span class="selector-tag">font-size</span>: 14<span class="selector-tag">px</span>;</span><br><span class="line">    <span class="selector-class">.switch-wrap</span>&#123;</span><br><span class="line">        <span class="attribute">transition</span>: transform .<span class="number">3s</span> ease-in;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Javascript功能代码"><a href="#Javascript功能代码" class="headerlink" title="Javascript功能代码"></a><strong>Javascript功能代码</strong></h2><p>参考<a href="http://moxfive.xyz/2016/05/31/hexo-local-search/" target="_blank" rel="noopener">MOxFIVE</a>的代码，进行了以下修改：</p><ol><li>修改搜索框的名称以便和HTML代码配套；</li><li>去除重置搜索按钮相关代码；</li><li>不在新标签页中打开搜索结果；</li><li>搜索结果URL链接去掉主域名，使用相对路径表示；</li><li>保持搜索结果中标题大小写格式；</li><li><strong>对搜索结果相关度进行了打分，根据关键词出现的次数进行排序</strong></li></ol><p>首先在<code>pc.js</code>文件中添加以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">require</span>([<span class="string">'/js/search.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> inputArea = <span class="built_in">document</span>.querySelector(<span class="string">"#st-search-input"</span>);</span><br><span class="line">        <span class="keyword">var</span> $HideWhenSearch = $(<span class="string">"#toc, #tocButton, .post-list, #post-nav-button a:nth-child(2)"</span>);</span><br><span class="line">        <span class="keyword">var</span> $resultArea = $(<span class="string">"#local-search-result"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> getSearchFile = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> search_path = <span class="string">"/search.xml"</span>;</span><br><span class="line">            <span class="keyword">var</span> path = search_path;</span><br><span class="line">            searchFunc(path, <span class="string">'st-search-input'</span>, <span class="string">'local-search-result'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> getFileOnload = inputArea.getAttribute(<span class="string">'searchonload'</span>);</span><br><span class="line">        <span class="keyword">if</span> (getFileOnload === <span class="string">"true"</span>) &#123;</span><br><span class="line">            getSearchFile();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            inputArea.onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; getSearchFile() &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> HideTocArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            $HideWhenSearch.css(<span class="string">"visibility"</span>,<span class="string">"hidden"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        inputArea.oninput = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; HideTocArea() &#125;</span><br><span class="line">        inputArea.onkeydown = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">if</span>(event.keyCode==<span class="number">13</span>) <span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line">        $resultArea.bind(<span class="string">"DOMNodeRemoved DOMNodeInserted"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!$(e.target).text()) &#123;</span><br><span class="line">                $(<span class="string">".no-result"</span>).show(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              $(<span class="string">".no-result"</span>).hide();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>代码详细说明见<a href="http://moxfive.xyz/2016/05/31/hexo-local-search/" target="_blank" rel="noopener">MOxFIVE</a>的文章。</p><p>新建<code>source/js/search.js</code>文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A local search script with the help of [hexo-generator-search](https://github.com/PaicHyperionDev/hexo-generator-search)</span></span><br><span class="line"><span class="comment">// Copyright (C) 2015 </span></span><br><span class="line"><span class="comment">// Joseph Pan &lt;http://github.com/wzpan&gt;</span></span><br><span class="line"><span class="comment">// Shuhao Mao &lt;http://github.com/maoshuhao&gt;</span></span><br><span class="line"><span class="comment">// Edited by MOxFIVE &lt;http://github.com/MOxFIVE&gt;</span></span><br><span class="line"><span class="comment">// Edited by Mingfei Gao &lt;http://gaomf.cn&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> searchFunc = <span class="function"><span class="keyword">function</span>(<span class="params">path, search_id, content_id</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: path,</span><br><span class="line">        dataType: <span class="string">"xml"</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params"> xmlResponse </span>) </span>&#123;</span><br><span class="line">            <span class="comment">// get the contents from search data</span></span><br><span class="line">            <span class="keyword">var</span> datas = $( <span class="string">"entry"</span>, xmlResponse ).map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    title: $( <span class="string">"title"</span>, <span class="keyword">this</span> ).text(),</span><br><span class="line">                    content: $(<span class="string">"content"</span>,<span class="keyword">this</span>).text(),</span><br><span class="line">                    url: $( <span class="string">"url"</span> , <span class="keyword">this</span>).text()</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;).get();</span><br><span class="line">            <span class="keyword">var</span> $input = <span class="built_in">document</span>.getElementById(search_id);</span><br><span class="line">            <span class="keyword">var</span> $resultContent = <span class="built_in">document</span>.getElementById(content_id);</span><br><span class="line">            $input.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> finalHTML=<span class="string">'&lt;ul class=\"search-result-list\"&gt;'</span>;</span><br><span class="line">                <span class="keyword">var</span> str = <span class="string">""</span>;                </span><br><span class="line">                <span class="keyword">var</span> keywords = <span class="keyword">this</span>.value.trim().toLowerCase().split(<span class="regexp">/[\s\-]+/</span>);</span><br><span class="line">                $resultContent.innerHTML = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.value.trim().length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Search result Array</span></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">SearchData</span>(<span class="params">str, score</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">this</span>.str = str;</span><br><span class="line">                    <span class="keyword">this</span>.score = score;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> SearchResultArr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">                <span class="keyword">var</span> tmpscore;</span><br><span class="line">                <span class="comment">// perform local searching</span></span><br><span class="line">                datas.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> content_index = [];</span><br><span class="line">                    <span class="keyword">var</span> data_title = data.title.trim().toLowerCase();</span><br><span class="line">                    <span class="keyword">var</span> data_content = data.content.trim().replace(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>,<span class="string">""</span>).toLowerCase();</span><br><span class="line">                    <span class="keyword">var</span> data_url = data.url.replace(<span class="string">"http://gaomingfei.xyz"</span>,<span class="string">""</span>);</span><br><span class="line">                    <span class="keyword">var</span> index_title = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">var</span> index_content = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">var</span> first_occur = <span class="number">-1</span>;</span><br><span class="line">                    <span class="comment">// only match artiles with not empty titles and contents</span></span><br><span class="line">                    <span class="keyword">if</span>(data_title != <span class="string">''</span> &amp;&amp; data_content != <span class="string">''</span>) &#123;</span><br><span class="line">                        tmpscore = <span class="number">0</span>;</span><br><span class="line">                        keywords.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">keyword, i</span>) </span>&#123;</span><br><span class="line">                            index_title = data_title.indexOf(keyword);</span><br><span class="line">                            index_content = data_content.indexOf(keyword);</span><br><span class="line">                            </span><br><span class="line">                            <span class="keyword">if</span> (index_title &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                tmpscore += <span class="number">30</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (index_content &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (first_occur &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                    first_occur = index_content;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">while</span> (index_content &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                    tmpscore += <span class="number">1</span>;</span><br><span class="line">                                    index_content = data_content.indexOf(keyword, index_content + <span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// show search results</span></span><br><span class="line">                    <span class="keyword">if</span> (tmpscore &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        str = <span class="string">"&lt;li&gt;&lt;a href='"</span>+ data_url +<span class="string">"' class='search-result-title'&gt;"</span>+ <span class="string">"&gt; "</span> + data.title +<span class="string">"&lt;/a&gt;"</span>;</span><br><span class="line">                        <span class="keyword">var</span> content = data.content.trim().replace(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>,<span class="string">""</span>);</span><br><span class="line">                        <span class="comment">// cut out characters</span></span><br><span class="line">                        <span class="keyword">var</span> start = first_occur - <span class="number">6</span>;</span><br><span class="line">                        <span class="keyword">var</span> end = first_occur + <span class="number">6</span>;</span><br><span class="line">                        <span class="keyword">if</span>(start &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                            start = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(start == <span class="number">0</span>)&#123;</span><br><span class="line">                            end = <span class="number">10</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(end &gt; content.length)&#123;</span><br><span class="line">                            end = content.length;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">var</span> match_content = content.substr(start, end); </span><br><span class="line">                        <span class="comment">// highlight all keywords</span></span><br><span class="line">                        keywords.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">keyword</span>)</span>&#123;</span><br><span class="line">                            <span class="keyword">var</span> regS = <span class="keyword">new</span> <span class="built_in">RegExp</span>(keyword, <span class="string">"gi"</span>);</span><br><span class="line">                            match_content = match_content.replace(regS, <span class="string">"&lt;em class=\"search-keyword\"&gt;"</span>+keyword+<span class="string">"&lt;/em&gt;"</span>);</span><br><span class="line">                        &#125;)</span><br><span class="line">                        str += <span class="string">"&lt;p class=\"search-result\"&gt;"</span> + match_content +<span class="string">"...&lt;/p&gt;"</span></span><br><span class="line">                        </span><br><span class="line">                        SearchResultArr.push(<span class="keyword">new</span> SearchData(str, tmpscore));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Sort Search Result</span></span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">compareScore</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> b.score - a.score;</span><br><span class="line">                &#125;</span><br><span class="line">                SearchResultArr.sort(compareScore);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Final HTML</span></span><br><span class="line">                SearchResultArr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                    finalHTML += data.str;</span><br><span class="line">                &#125;)</span><br><span class="line">                $resultContent.innerHTML = finalHTML;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中打分排序标题中出现的关键词计30分，内容中的关键词一个计1分，总分越高意味着相关度越高，排在越前面。</p><hr><p>实际效果可直接使用文章左侧边栏上的搜索框进行体验，总体来说还是很令人满意的，至此终于搞定了站内搜索问题啦~~</p>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于科学与工程</title>
      <link href="/2016/09/30/%E5%85%B3%E4%BA%8E%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B/"/>
      <url>/2016/09/30/%E5%85%B3%E4%BA%8E%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><em>偶尔也写点非技术的文章吧~</em></p><p>我们很多工科学生将来都会成为工程师，而像我本科所学的化学专业则是以培养科学家为己任，那科学与工程是何关系呢？一言以蔽之，<strong>工程是科学有选择性的应用，Engineering is the purposeful use of science</strong>. 最早听到这句话是大一的时候在看MIT的公开课<a href="http://open.163.com/special/opencourse/circuits.html" target="_blank" rel="noopener">电路和电子学</a>时，第一集中，Agarwal教授高屋建瓴的分析了这门课程在整个知识体系中的地位。从麦克斯韦方程组出发，引入一些约束条件后，得到了集总元件抽象（LMP)，也就是电路理论的基础。在这里，麦克斯韦方程组就是科学，它描述的是自然的运行规律；而电路理论则是工程，它是人类根据需要对麦克斯韦方程组进行了有选择性的应用后得到的理论。所以说，科学是工程的基础，工程是科学的结晶。</p><a id="more"></a><p>科学与工程所追求的目标并不那么相同，从本质上来说，工程的目的是应用、是设计、是创造；而科学的目的是探索、是求真。正因为如此，工程很多时候是一门平衡的艺术，我们需要综合考虑各种技术和非技术因素，最终以技术为手段，去实现一个特定的目的。因为实现某一目的是一个确定的目标，所以说，工程是以结果为导向的，而科学，其实并不该以结果为导向，科学是对真理的探求，其原动力是对未知世界的好奇。刘慈欣有一部很好的短篇小说，叫<a href="http://www.kanunu8.com/book3/6644/index.html" target="_blank" rel="noopener">《朝闻道》</a>，取“朝闻道，夕死可矣”之意，其中对何谓真正的科学精神做出了一个我很欣赏的诠释——科学其实并没有什么目的，科学本身就足以让人着迷了，不是吗？</p><p>工程是实现一个特定的目的，这个目的通常是一个“有价值”的目的，比如能创造经济效益一类的。不过一个优秀的工程师往往并不局限于做这些“有价值”的事，也会出于兴趣、出于好玩等目的去做一些“没有价值”的事。之前看过无人机大神Raffaello D’Andrea的一个<a href="http://open.163.com/movie/2016/3/M/F/MBHBRK2GK_MBHBSUGMF.html" target="_blank" rel="noopener">TED演讲</a>，Raffaello在其中展示了各种令人惊叹不已的炫酷控制技术。不过，研究制作这些无人机技术有什么用呢？事实是这并不能马上创造什么商业价值，不过在演讲的最后，Raffaello说了这样一段话：</p><blockquote><p>The reality is that it is difficult to predict the impact of nascent technology. And for folks like us, the real reward is the journey and the act of creation. It’s a continual reminder of how wonderful and magical the universe we live in is, that it allows creative, clever creatures to sculpt it in such spectacular ways.</p></blockquote><p>是啊，创造本身不就是有趣而有价值的吗？从这个角度上看，工程和科学又是那么的相像。</p><p>那工程师又是怎样的人呢？之前在知乎上看过这样一句精彩的总结，“<strong>Engineers are versatile minds who create links between science, technology, and society</strong>”, 工程师们将科学、技术与社会相连接，从生活中发现问题、从社会中洞察需求，之后以技术为手段，以科学为基石去设计出解决方案，以此满足普罗大众的需求，创造人类更美好的明天。</p><p>这也就是将来我所追求的了吧，从一个具体的环节做起，扩宽自己的深度与广度，之后以技术为工具，带领着更多人去实现更大的目标——突破现有的产品，创造出更好的产品，实现自身的价值。毕竟，对于一个工程师而言，自己设计出的东西能惠及越多的人，自身的成就感也就会越强吧~</p>]]></content>
      
      
      <categories>
          
          <category> 人生之思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Android Studio中使用Lambda表达式</title>
      <link href="/2016/09/26/%E5%9C%A8Android%20Studio%E4%B8%AD%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2016/09/26/%E5%9C%A8Android%20Studio%E4%B8%AD%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Lambda表达式是Java 8中的一个重要新特性，使用Lambda表达式可以简化很多代码，比如常见的为一个按键添加点击事件<code>Listener</code>的代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do what you want...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中有用的代码很有可能只有一行，其他部分其实都没有实际意义，只是语法需要，创建了一个匿名类而已。但是，如果使用Lambda表达式之后，上述代码就可以简化为：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">btn</span><span class="selector-class">.setOnClickListener</span>(v -&gt; &#123;</span><br><span class="line">    <span class="comment">// do what you want...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果只有一行代码还可以进一步简化为：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.set<span class="constructor">OnClickListener(<span class="params">v</span> -&gt; <span class="params">doSomething</span>()</span>);</span><br></pre></td></tr></table></figure><p>可以看到，使用了Lambda表达式后可以让程序代码更加优雅简洁。关于Java 8中的Lambda表达式详情，可参考以下几篇文章：</p><blockquote><p><a href="http://www.importnew.com/16436.html" target="_blank" rel="noopener">Java8 lambda表达式10个示例</a><br><a href="http://www.liaoxuefeng.com/article/001411306573093ce6ebcdd67624db98acedb2a905c8ea4000" target="_blank" rel="noopener">Java 8新特性：lambda表达式</a></p></blockquote><p>然而遗憾的是，Android Studio中的Java版本被限制在了Java 1.7以下，与系统中安装的JDK版本无关，也就是就算安装了JDK 1.8也无法使用Java 8的新特性。不过我们依然可以通过一些方法来使用Lambda表达式的，主要方法有两种，下面将分别介绍。</p><h2 id="RetroLambda"><a href="#RetroLambda" class="headerlink" title="RetroLambda"></a><strong>RetroLambda</strong></h2><p><a href="https://github.com/orfjackal/retrolambda" target="_blank" rel="noopener">RetroLambda</a>是一个Gradle插件，用于实现让低版本的Java（Java 1.7、1.6、1.5等）支持Lambda表达式。做所周知，Android Studio使用的就是Gradle，Gradle Retrolambda插件的官方Github网站及使用说明见<a href="https://github.com/evant/gradle-retrolambda" target="_blank" rel="noopener">这里</a>。在Android Studio中的使用步骤如下：</p><p>1.安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">JDK 8</a>。</p><p>2.在<strong>项目的</strong><code>build.gradle</code>文件中添加以下代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">  <span class="keyword">repositories</span> &#123;</span><br><span class="line">     mavenCentral()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">dependencies</span> &#123;</span><br><span class="line">     <span class="keyword">classpath</span> <span class="string">'me.tatarka:gradle-retrolambda:3.3.0'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Required because retrolambda is on maven central</span></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">  mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在<strong>工程模块的</strong><code>build.gradle</code>文件中添加以下代码：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apply</span> <span class="string">plugin: 'me.tatarka.retrolambda'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">android</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">compileOptions</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">sourceCompatibility</span> <span class="string">JavaVersion.VERSION_1_8</span></span><br><span class="line">    <span class="attr">targetCompatibility</span> <span class="string">JavaVersion.VERSION_1_8</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>4.在<code>proguard-rules.pro</code>文件中添加以下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">For</span> <span class="selector-tag">retrolambda</span>  </span><br><span class="line"><span class="selector-tag">-dontwarn</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.invoke</span>.*</span><br></pre></td></tr></table></figure><p>5.还可以对Retrolambda进行一些配置，具体见<a href="https://github.com/evant/gradle-retrolambda#configuration" target="_blank" rel="noopener">Github页面的说明</a></p><p><strong>注意事项：</strong><br>retrolambda的版本这里选择了3.3.0，这是目前的最新版本，不过之后肯定会有新版本的，可以根据Github上的说明替换为最新版本。</p><p>配置完成后第一次编译时，Android Studio中的Gradle不能配置为Offline模式，否则会提示错误：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gradle <span class="keyword">sync</span> failed: No cached <span class="keyword">version</span> of <span class="keyword">me</span>.tatark<span class="variable">a:gradle</span>-retrolambd<span class="variable">a:3</span>.<span class="number">3.0</span> available <span class="keyword">for</span> offline <span class="keyword">mode</span>.</span><br></pre></td></tr></table></figure><p>因为上述配置只是指明了需要使用<code>me.tatarka:gradle-retrolambda:3.3.0</code>，此时还需要联网下载retrolambda，若配置为离线模式是无法正常下载的。不过只要编译成功一次之后，retrolambda就会被下载到缓存中，此时就可以了改回Offline模式了。</p><h2 id="Jack"><a href="#Jack" class="headerlink" title="Jack"></a><strong>Jack</strong></h2><p>Jack是Java Android Compile Kit的缩写，它是Google为Android推出的一个全新的Java编译工具链。关于Jack的详细信息可参考以下链接：</p><blockquote><p><a href="http://taobaofed.org/blog/2016/05/05/new-compiler-for-android/" target="_blank" rel="noopener">Android 新一代编译 toolchain Jack &amp; Jill 简介</a><br><a href="https://source.android.com/source/jack.html" target="_blank" rel="noopener">Compiling with Jack</a></p></blockquote><p>使用Jack也是Google官方给出的支持Java 8特性的方法：<a href="https://developer.android.com/guide/platform/j8-jack.html#supported-features" target="_blank" rel="noopener">Java 8 语言功能</a></p><p>要在Android Studio中使用Jack并开启Java 8，只需要在<strong>工程模块的</strong><code>build.gradle</code>文件中添加以下代码：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">android</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">defaultConfig</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="attr">jackOptions</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="attr">enabled</span> <span class="string">true</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">compileOptions</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">sourceCompatibility</span> <span class="string">JavaVersion.VERSION_1_8</span></span><br><span class="line">    <span class="attr">targetCompatibility</span> <span class="string">JavaVersion.VERSION_1_8</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>使用Jack后，除了支持Lambda表达式外，还可以支持更多的Java 8新特性。不过实际测试下来，使用Jack有两个很大的缺陷：</p><p>首先，Jack的编译速度明显要慢很多，而且似乎每次都要从头全部重新编译一次，同样的工程编译所需的时间是原来的5~10倍；</p><p>其次，使用Jack后就无法使用<a href="https://developer.android.com/studio/run/index.html#instant-run" target="_blank" rel="noopener">Instant Run</a>功能了，Instant Run是一个很好用的功能，在修改程序后重新推送到设备运行时不需要再次安装apk文件，基本马上就可以看到更改后的变化，这可以大幅提升工作效率。然而目前版本的Jack并没有支持Instant Run。</p><hr><p>考虑到Jack这两个缺陷实在会严重降低工作效率，在目前看来使用Jack还不是一个很好的选择。如果要使用Lambda表达式，RetroLambda是一个更好的选择。</p>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架</title>
      <link href="/2016/09/16/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2016/09/16/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>Java中提供了丰富的容器类用于存储数据，这些容器类可分为两大类：Collection和Map，Collection用于保存单个元素，而Map则以键值对的形式进行存储，就像一个小型数据库一样。Collection中又可分为List、Set、Queue三类，其中List是列表，Set是集合，Queue是队列。整个Java集合框架的结构图如下：</p><p><img src="https://pic.gaomf.store/Java%20Collections%20Framework2.png" alt=""></p><a id="more"></a><p>网上能找到的图都不是很全面，故我根据最新版的JDK 8文档绘制了此图。图中并没有包含所有的接口与类，仅仅只是最常用的部分，这些部分均位于<code>java.util</code>包中。图中蓝色的实现类就是我们实际可以直接使用的容器类了。</p><p>JDK帮助文档中还有一张各接口与存储形式的对照表，摘录如下：</p><table><thead><tr><th>Interface</th><th>Hash Table</th><th>Resizable Array</th><th>Balanced Tree</th><th>Linked List</th><th>Hash Table + Linked List</th></tr></thead><tbody><tr><td><strong>Set</strong></td><td><strong><code>HashSet</code></strong></td><td>-</td><td><strong><code>TreeSet</code></strong></td><td>-</td><td><code>LinkedHashSet</code></td></tr><tr><td><strong>List</strong></td><td>-</td><td><strong><code>ArrayList</code></strong></td><td>-</td><td><strong><code>LinkedList</code></strong></td><td>-</td></tr><tr><td><strong>Deque</strong></td><td>-</td><td><strong><code>ArrayDeque</code></strong></td><td>-</td><td><code>LinkedList</code></td><td>-</td></tr><tr><td><strong>Map</strong></td><td><strong><code>HashMap</code></strong></td><td>-</td><td><strong><code>TreeMap</code></strong></td><td>-</td><td><code>LinkedHashMap</code></td></tr></tbody></table><p>上表中加粗显示的就是最常用的实现类，一般情况下选择这几个就可以了。</p><p>接下来将各接口最常用的一些方法整理总结一下。</p><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><strong>Collection接口</strong></h2><p>所有的<code>List</code>、<code>Set</code>、<code>Queue</code>均支持以下方法：</p><p>|Function Name|<br>|–|–|–|<br>|<code>size()</code>|<code>isEmpty()</code>|<code>contains()</code>|<br>|<code>add()</code>|<code>remove()</code>|<code>iterator()</code>|<br>|<code>toArray()</code>|<code>clear()</code>|<code>forEach()</code>|</p><h2 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a><strong>Iterator接口</strong></h2><p>|Function Name|<br>|–|–|–|<br>|<code>hasNext()</code>|<code>next()</code>|<code>remove()</code>|</p><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a><strong>List接口</strong></h2><p>在<code>Collection</code>接口的基础上添加了以下方法：</p><p>|Function Name|<br>|–|–|<br>|<code>get()</code>|<code>set()</code>|<br>|<code>add(int,E)</code>|<code>remove(int)</code>|<br>|<code>indexOf()</code>|<code>lastIndexOf()</code>|</p><h2 id="ListIterator接口"><a href="#ListIterator接口" class="headerlink" title="ListIterator接口"></a><strong>ListIterator接口</strong></h2><p>在<code>Iterator</code>接口的基础上添加了以下方法：</p><p>|Function Name|<br>|–|–|<br>|<code>add()</code>|<code>set()</code>|<br>|<code>hasPrevious()</code>|<code>previous()</code>|</p><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a><strong>Set接口</strong></h2><p><code>Set</code>接口没有添加新方法，与<code>Collection</code>接口中的相同。</p><p>添加到<code>Set</code>中的类一般都要覆盖实现<code>hashCode()</code>及<code>equals()</code>函数。</p><h2 id="SortedSet接口"><a href="#SortedSet接口" class="headerlink" title="SortedSet接口"></a><strong>SortedSet接口</strong></h2><p>在<code>Set</code>接口的基础上添加了以下方法：</p><p>|Function Name|<br>|–|–|–|<br>|<code>subSet()</code>|<code>headSet()</code>|<code>tailSet()</code>|<br>|<code>first()</code>|<code>last()</code>|</p><p>添加到<code>SortedSet</code>中的类需要实现<code>Comparable</code>接口。</p><h2 id="Deque接口"><a href="#Deque接口" class="headerlink" title="Deque接口"></a><strong>Deque接口</strong></h2><p>在<code>Collection</code>接口的基础上添加了以下方法：</p><p>|Function Name|<br>|–|–|<br>|<code>addFirst()</code>|<code>addLast()</code>|<br>|<code>removeFirst()</code>|<code>removeLast()</code>|<br>|<code>getFirst()</code>|<code>getLast()</code>|</p><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a><strong>Map接口</strong></h2><p>常用函数有：</p><p>|Function Name|<br>|–|–|–|<br>|<code>put()</code>|<code>get()</code>|<code>remove()</code>|<br>|<code>size()</code>|<code>isEmpty()</code>|<br>|<code>containsKey()</code>|<code>containsValue()</code>|<br>|<code>keySet()</code>|<code>values()</code>|</p><p>添加到<code>Map</code>中的Key类一般都要覆盖实现<code>hashCode()</code>及<code>equals()</code>函数。</p><h2 id="SortedMap接口"><a href="#SortedMap接口" class="headerlink" title="SortedMap接口"></a><strong>SortedMap接口</strong></h2><p>在<code>Map</code>接口的基础上添加了以下方法：</p><p>|Function Name|<br>|–|–|–|<br>|<code>subMap()</code>|<code>headMap()</code>|<code>tailMap()</code>|<br>|<code>firstKey()</code>|<code>lastKey()</code>|</p><p><code>SortedMap</code>是按照Key来进行排序的，要求Key需要实现<code>Comparable</code>接口。</p><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a><strong>Arrays类</strong></h2><p>用于支持数组操作，常用静态函数有：</p><p>|Function Name|<br>|–|–|–|<br>|<code>asList()</code>|<code>binarySearch()</code>|<code>copyOf()</code>|<br>|<code>equals()</code>|<code>fill()</code>|<code>sort()</code>|</p><h2 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a><strong>Collections类</strong></h2><p>用于支持集合框架的通用算法，常用静态函数有：</p><p>|Function Name|<br>|–|–|–|<br>|<code>sort()</code>|<code>binarySearch()</code>|<code>copy()</code>|<br>|<code>shuffle()</code>|<code>fill()</code>|<code>reverse()</code>|</p><hr><p>关于各种容器类的具体介绍与使用方法，可参考官方的Tutorial：<a href="http://docs.oracle.com/javase/tutorial/collections/index.html" target="_blank" rel="noopener">Trail: Collections</a></p><p>以下几个链接也可供参考：</p><blockquote><p><a href="http://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener">Java 集合框架</a><br><a href="http://www.cnblogs.com/LittleHann/p/3690187.html" target="_blank" rel="noopener">Java集合类: Set、List、Map、Queue使用场景梳理</a><br><a href="http://blog.csdn.net/softwave/article/details/4166598" target="_blank" rel="noopener">Java集合类详解</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大公约数算法</title>
      <link href="/2016/08/22/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%AE%97%E6%B3%95/"/>
      <url>/2016/08/22/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>两个（或更多个）整数的最大公约数（Greatest Common Divisor, GCD）是指能同时整除它们的最大正整数，求解最大公约数最常用的算法是辗转相除法（又称欧几里得算法）及Stein算法，至于直接穷举的暴力算法，因为过于低效，实际中是不会使用的。下面来总结下这两种方法。</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><p>给定两个正整数M和N，求其最大公约数。函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> M, <span class="keyword">unsigned</span> <span class="keyword">int</span> N)</span></span>;</span><br></pre></td></tr></table></figure><p>调用此函数时保证M≥N&gt;0。</p><h2 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a><strong>辗转相除法</strong></h2><p>辗转相除法的介绍可见<a href="https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95" target="_blank" rel="noopener">维基百科</a>，其理论基础就是下面这个公式：</p><p><strong><code>GCD(M, N) = GCD(N, M%N)</code></strong></p><p>此公式的证明在此不做介绍，直接给出算法实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> M, <span class="keyword">unsigned</span> <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> Rem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Rem = M % N;</span><br><span class="line">    M = N;</span><br><span class="line">    N = Rem;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>上述算法可以进一步优化，算法中使用了一个中间变量<code>Rem</code>，它用于交换两数，其实这是没有必要的。注意到：</p><p><code>GCD(M, N) = GCD(N, M % N) = GCD(M % N, N % (M % N))</code></p><p>在第一步计算出<code>M % N</code>后，保留<code>N</code>的值其实是没有必要的，可以直接跳过这一步，使用最后一个式子进行计算即可：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M = M % <span class="built_in">N</span>;  // 这一步后，新的M的值即为M%<span class="built_in">N</span></span><br><span class="line"><span class="built_in">N</span> = <span class="built_in">N</span> % M;  // 相当于公式中的<span class="built_in">N</span>%(M%<span class="built_in">N</span>)</span><br></pre></td></tr></table></figure><p>因为这相当于计算了2次，截止条件变为<code>M</code>和<code>N</code>中的任意一个为0，否则就会出现<code>%0</code>这样的错误。返回结果是<code>M</code>和<code>N</code>中不为0那个，不过由于另一个数为0，可以用<code>M + N</code>替代。这样就可以写出代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> M, <span class="keyword">unsigned</span> <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ((M %= N) &amp;&amp; (N %= M));</span><br><span class="line">  <span class="keyword">return</span> M + N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此简单而优雅！</p><h2 id="Stein算法"><a href="#Stein算法" class="headerlink" title="Stein算法"></a><strong>Stein算法</strong></h2><p>此算法又被称为<a href="https://en.wikipedia.org/wiki/Binary_GCD_algorithm" target="_blank" rel="noopener">Binary GCD algorithm</a>，它是针对欧几里得算法的一些缺陷提出的。</p><blockquote><p>欧几里德算法是计算两个数最大公约数的传统算法，无论从理论还是从实际效率上都是很好的。但是却有一个致命的缺陷，这个缺陷在素数比较小的时候一般是感觉不到的，只有在大素数时才会显现出来。<br>一般实际应用中的整数很少会超过64位（当然现在已经允许128位了），对于这样的整数，计算两个数之间的模是很简单的。对于字长为32位的平台，计算两个不超过32位的整数的模，只需要一个指令周期，而计算64位以下的整数模，也不过几个周期而已。但是对于更大的素数，这样的计算过程就不得不由用户来设计，为了计算两个超过64位的整数的模，用户也许不得不采用类似于多位数除法手算过程中的试商法，这个过程不但复杂，而且消耗了很多CPU时间。对于现代密码算法，要求计算128位以上的素数的情况比比皆是，设计这样的程序迫切希望能够抛弃除法和取模。<br>由J. Stein 1961年提出的Stein算法很好的解决了欧几里德算法中的这个缺陷，Stein算法只有整数的移位和加减法。</p></blockquote><p>算法的理论和实现方法在此从略，此处仅摘录一下实现代码以供参考，引用自<a href="https://en.wikipedia.org/wiki/Binary_GCD_algorithm#Implementation" target="_blank" rel="noopener">WiKi</a>。</p><p>递归实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> u, <span class="keyword">unsigned</span> <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// simple cases (termination)</span></span><br><span class="line">    <span class="keyword">if</span> (u == v)</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// look for factors of 2</span></span><br><span class="line">    <span class="keyword">if</span> (~u &amp; <span class="number">1</span>) <span class="comment">// u is even</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v &amp; <span class="number">1</span>) <span class="comment">// v is odd</span></span><br><span class="line">            <span class="keyword">return</span> gcd(u &gt;&gt; <span class="number">1</span>, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// both u and v are even</span></span><br><span class="line">            <span class="keyword">return</span> gcd(u &gt;&gt; <span class="number">1</span>, v &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (~v &amp; <span class="number">1</span>) <span class="comment">// u is odd, v is even</span></span><br><span class="line">        <span class="keyword">return</span> gcd(u, v &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reduce larger argument</span></span><br><span class="line">    <span class="keyword">if</span> (u &gt; v)</span><br><span class="line">        <span class="keyword">return</span> gcd((u - v) &gt;&gt; <span class="number">1</span>, v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gcd((v - u) &gt;&gt; <span class="number">1</span>, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> u, <span class="keyword">unsigned</span> <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> shift;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* GCD(0,v) == v; GCD(u,0) == u, GCD(0,0) == 0 */</span></span><br><span class="line">  <span class="keyword">if</span> (u == <span class="number">0</span>) <span class="keyword">return</span> v;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="number">0</span>) <span class="keyword">return</span> u;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Let shift := lg K, where K is the greatest power of 2</span></span><br><span class="line"><span class="comment">        dividing both u and v. */</span></span><br><span class="line">  <span class="keyword">for</span> (shift = <span class="number">0</span>; ((u | v) &amp; <span class="number">1</span>) == <span class="number">0</span>; ++shift) &#123;</span><br><span class="line">         u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">         v &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> ((u &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* From here on, u is always odd. */</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">/* remove all factors of 2 in v -- they are not common */</span></span><br><span class="line">       <span class="comment">/*   note: v is not zero, so while will terminate */</span></span><br><span class="line">       <span class="keyword">while</span> ((v &amp; <span class="number">1</span>) == <span class="number">0</span>)  <span class="comment">/* Loop X */</span></span><br><span class="line">           v &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Now u and v are both odd. Swap if necessary so u &lt;= v,</span></span><br><span class="line"><span class="comment">          then set v = v - u (which is even). For bignums, the</span></span><br><span class="line"><span class="comment">          swapping is just pointer movement, and the subtraction</span></span><br><span class="line"><span class="comment">          can be done in-place. */</span></span><br><span class="line">       <span class="keyword">if</span> (u &gt; v) &#123;</span><br><span class="line">         <span class="keyword">unsigned</span> <span class="keyword">int</span> t = v; v = u; u = t;&#125;  <span class="comment">// Swap u and v.</span></span><br><span class="line">       v = v - u;                       <span class="comment">// Here v &gt;= u.</span></span><br><span class="line">     &#125; <span class="keyword">while</span> (v != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* restore common factors of 2 */</span></span><br><span class="line">  <span class="keyword">return</span> u &lt;&lt; shift;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a><strong>扩展问题</strong></h2><p>如果需要求多个数的最大公约数，可以先求出任意两个数的最大公约数，然后再求此数与其它数间的最大公约数，即有以下等式成立：</p><p><code>GCD(a, b, c) = GCD(a, GCD(b, c)) = GCD(c, GCD(a,b))</code></p><p>由此，易写出求N个数最大公约数的算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">GCDN</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> parmN, ...)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> M;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, parmN);</span><br><span class="line"></span><br><span class="line">  M = va_arg(ap, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (--parmN) &#123;</span><br><span class="line">    M = GCD(M, va_arg(ap, <span class="keyword">unsigned</span> <span class="keyword">int</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  va_end(ap);</span><br><span class="line">  <span class="keyword">return</span> M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>求出最大公约数的同时也就得到了最小公倍数（Lowest Common Multiple, LCM），二者存在以下关系：</p><p><code>GCD(M, N) * LCM(M, N) = M * N</code></p><p>故易得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">LCM</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> M, <span class="keyword">unsigned</span> <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> M * N / GCD(M, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最大连续子序列和问题</title>
      <link href="/2016/08/20/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2016/08/20/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最大连续子序列和问题是一个经典的算法问题，在”Data Structures and Algorithm Analysis in C”一书第2章中介绍了此问题，并给出了复杂度从O(n^3)至O(n)的4种解法，这里对此问题稍作扩展总结一下。</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><p>给定一个数字序列，求出其最大连续子序列和，并给出对应的区间。如给定{-2, 11, -4, 13, -5, -2}，最大子序列和为20，对应的区间为[1, 3]。（下标从0开始）</p><p>输出区间中至少包含一个元素，即若输入的数全部为负数，需输出最大的那个负数。</p><p>若有多个子序列和相同，返回任意一个子序列区间即可。</p><p>函数原型：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="constructor">MaxSubsequenceSum(<span class="params">const</span> <span class="params">int</span> A[], <span class="params">int</span> N, <span class="params">int</span> <span class="operator">*</span> <span class="params">left</span>, <span class="params">int</span> <span class="operator">*</span> <span class="params">right</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中<code>left</code>及<code>right</code>为输出区间。</p><p><em>注：原始问题中，不需要输出对应区间，且若均为负数输出0，此处进行了一些扩展。</em></p><h2 id="O-n-2-算法"><a href="#O-n-2-算法" class="headerlink" title="O(n^2)算法"></a><strong>O(n^2)算法</strong></h2><p>直接循环求解，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubsequenceSum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> N, <span class="keyword">int</span> * left, <span class="keyword">int</span> * right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">int</span> maxIndex, maxNum, tmpSum, maxSum;</span><br><span class="line"></span><br><span class="line">  maxNum = A[<span class="number">0</span>];</span><br><span class="line">  maxIndex = <span class="number">0</span>;</span><br><span class="line">  maxSum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[i] &gt; maxNum) &#123;</span><br><span class="line">      maxIndex = i;</span><br><span class="line">      maxNum = A[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmpSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &lt; N; j++) &#123;</span><br><span class="line">      tmpSum += A[j];</span><br><span class="line">      <span class="keyword">if</span> (tmpSum &gt; maxSum) &#123;</span><br><span class="line">        maxSum = tmpSum;</span><br><span class="line">        *left = i;</span><br><span class="line">        *right = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (maxNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    *left = maxIndex;</span><br><span class="line">    *right = maxIndex;</span><br><span class="line">    <span class="keyword">return</span> maxNum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="O-nlog-n-算法"><a href="#O-nlog-n-算法" class="headerlink" title="O(nlog(n))算法"></a><strong>O(nlog(n))算法</strong></h2><p>二分法递归求解，分成左半部分和右半部分分别求解，有三种可能：最大序列位于左半部分；最大序列位于右半部分；最大序列位于中间。只需要解决最大部分位于中间的情况即可。算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubsequenceSum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> N, <span class="keyword">int</span> * left, <span class="keyword">int</span> * right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> MaxSubSumIterate(A, <span class="number">0</span>, N - <span class="number">1</span>, left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubSumIterate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> Nl,<span class="keyword">int</span> Nr, <span class="keyword">int</span> * left, <span class="keyword">int</span> * right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> leftMax, leftMaxLeft, leftMaxRight;</span><br><span class="line">  <span class="keyword">int</span> rightMax, rightMaxLeft, rightMaxRight;</span><br><span class="line">  <span class="keyword">int</span> middleMax, middleMaxLeft, middleMaxRight;</span><br><span class="line">  <span class="keyword">int</span> tmpSum;</span><br><span class="line">  <span class="keyword">int</span> center;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base case */</span></span><br><span class="line">  <span class="keyword">if</span> (Nl == Nr) &#123;</span><br><span class="line">    *left = Nl;</span><br><span class="line">    *right = Nr;</span><br><span class="line">    <span class="keyword">return</span> A[Nl];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Left &amp; Right */</span></span><br><span class="line">  center = (Nl + Nr) / <span class="number">2</span>;</span><br><span class="line">  leftMax = MaxSubSumIterate(A, Nl, center, &amp;leftMaxLeft, &amp;leftMaxRight);</span><br><span class="line">  rightMax = MaxSubSumIterate(A, center + <span class="number">1</span>, Nr, &amp;rightMaxLeft, &amp;rightMaxRight);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Middle */</span></span><br><span class="line">  middleMax = <span class="number">0</span>;</span><br><span class="line">  tmpSum = <span class="number">0</span>;</span><br><span class="line">  middleMaxLeft = center + <span class="number">1</span>;</span><br><span class="line">  middleMaxRight= center;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = center; i &gt;= Nl; i--) &#123;</span><br><span class="line">    tmpSum += A[i];</span><br><span class="line">    <span class="keyword">if</span> (tmpSum &gt; middleMax) &#123;</span><br><span class="line">      middleMax = tmpSum;</span><br><span class="line">      middleMaxLeft = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tmpSum = middleMax;</span><br><span class="line">  <span class="keyword">for</span> (i = center + <span class="number">1</span>; i &lt;= Nr; i++) &#123;</span><br><span class="line">    tmpSum += A[i];</span><br><span class="line">    <span class="keyword">if</span> (tmpSum &gt; middleMax) &#123;</span><br><span class="line">      middleMax = tmpSum;</span><br><span class="line">      middleMaxRight = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* middleMax == 0 说明middle无效 */</span></span><br><span class="line">  <span class="keyword">if</span> (middleMax &gt; <span class="number">0</span> &amp;&amp; middleMax &gt; leftMax &amp;&amp; middleMax &gt; rightMax) &#123;</span><br><span class="line">    *left = middleMaxLeft;</span><br><span class="line">    *right = middleMaxRight;</span><br><span class="line">    <span class="keyword">return</span> middleMax;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftMax &gt;= rightMax) &#123;</span><br><span class="line">      *left = leftMaxLeft;</span><br><span class="line">      *right = leftMaxRight;</span><br><span class="line">      <span class="keyword">return</span> leftMax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      *left = rightMaxLeft;</span><br><span class="line">      *right = rightMaxRight;</span><br><span class="line">      <span class="keyword">return</span> rightMax;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="O-n-算法"><a href="#O-n-算法" class="headerlink" title="O(n)算法"></a><strong>O(n)算法</strong></h2><p>只循环一遍，逐个累加，若累加结果为正，说明需要保留，若结果为负，说明需要丢弃。在这个算法中，数据顺序输入，且无需保留，是解决此问题最完美的算法。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubsequenceSum3</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> A[], <span class="keyword">int</span> N, <span class="keyword">int</span> * left, <span class="keyword">int</span> * right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> thisSum, maxSum;</span><br><span class="line">  <span class="keyword">int</span> maxNum, maxIndex;</span><br><span class="line">  <span class="keyword">int</span> tmpLeft;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  tmpLeft = <span class="number">0</span>;</span><br><span class="line">  thisSum = <span class="number">0</span>;</span><br><span class="line">  maxNum = A[<span class="number">0</span>];</span><br><span class="line">  maxIndex = <span class="number">0</span>;</span><br><span class="line">  maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (A[i] &gt; maxNum) &#123;</span><br><span class="line">      maxIndex = i;</span><br><span class="line">      maxNum = A[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    thisSum += A[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thisSum &gt; maxSum) &#123;</span><br><span class="line">      maxSum = thisSum;</span><br><span class="line">      *right = i;</span><br><span class="line">      *left = tmpLeft;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (thisSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      thisSum = <span class="number">0</span>;</span><br><span class="line">      tmpLeft = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (maxNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    *left = maxIndex;</span><br><span class="line">    *right = maxIndex;</span><br><span class="line">    <span class="keyword">return</span> maxNum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>注：当序列中有0的时候，上面几个算法输出的区间并不相同</em></p><p>相关文章：</p><blockquote><p><a href="http://www.cnblogs.com/ccdev/archive/2012/09/09/2677328.html" target="_blank" rel="noopener">算法探讨——再议经典算法问题：求最大子序列和、绝对值最大子序列和以及其区间</a><br><a href="http://blog.csdn.net/v_JULY_v/article/details/6444021" target="_blank" rel="noopener">程序员编程艺术：第七章、求连续子数组的最大和</a><br><a href="http://blog.csdn.net/sgbfblog/article/details/8032464" target="_blank" rel="noopener">最大连续子序列和</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C标准库学习笔记(1)——time、ctype、stdarg、assert</title>
      <link href="/2016/08/02/C%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94time%E3%80%81ctype%E3%80%81stdarg%E3%80%81assert/"/>
      <url>/2016/08/02/C%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94time%E3%80%81ctype%E3%80%81stdarg%E3%80%81assert/</url>
      
        <content type="html"><![CDATA[<p>这一系列文章是对P.J. Plauger所著的《C标准库》（The Standard C Library）一书的学习笔记，此书是关于C标准库的经典著作，讲述了每一个库函数的使用方法和实现细节。C语言标准库是最顶尖程序员的智慧结晶，要深入理解其实现细节自然也是很困难的……这里记录一下阅读这本书的收获，跳过了其中不常用或太复杂的部分（<code>stddef.h</code>、<code>float.h</code>、<code>limits.h</code>、<code>errno.h</code>、<code>setjmp.h</code>、<code>signal.h</code>、<code>locale.h</code>、<code>math.h</code>）。</p><a id="more"></a><p><strong>需要注意的是，目前实际使用的Glibc或uClibc中的代码比书中描述的要更为复杂，而且实现机理也不尽相同，不过基本大同小异，所以此处主要是学习思想而不是具体的代码。</strong></p><p>相关文章：<br><a href="/2016/04/18/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93/">C语言标准库总结</a></p><h2 id="time-h"><a href="#time-h" class="headerlink" title="time.h"></a>time.h</h2><p>日期和时间操作。<strong>需要特别注意的是，书中使用的<code>time_t</code>时间戳标准是从1900年1月1日午夜开始的，这与目前广泛使用的UNIX时间戳不一样，也和Glibc的实现不一样，书中是通过<code>_TBIAS</code>这个宏定义偏置量来解决这个问题的，为了简单起见，此处对此进行了改写，忽略了偏置问题，直接将其修改为与UNIX时间戳一样。</strong></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>通常使用<code>time(NULL)</code>获取一个<code>time_t</code>类型的UNIX时间戳，这一般是一个32位整数(signed int)，指的是从1970年1月1日午夜至今的秒数，大约可以表示到2038年。如果要获取更精确的时间，可使用<code>clock()</code>函数。</p><p>其余函数用于在几种不同数据结构间进行转换，根据需要选取即可，其中<code>tm</code>类型的定义一般是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tm_sec;     <span class="comment">/* [0, 60], 1 leap second */</span></span><br><span class="line">    <span class="keyword">int</span> tm_min;     <span class="comment">/* [0, 59] */</span></span><br><span class="line">    <span class="keyword">int</span> tm_hour;    <span class="comment">/* [0, 23] */</span></span><br><span class="line">    <span class="keyword">int</span> tm_mday;    <span class="comment">/* [1, 31] */</span></span><br><span class="line">    <span class="keyword">int</span> tm_mon;     <span class="comment">/* [0, 11] */</span></span><br><span class="line">    <span class="keyword">int</span> tm_year;    <span class="comment">/* Years since 1900 */</span></span><br><span class="line">    <span class="keyword">int</span> tm_wday;    <span class="comment">/* [0, 6], Sunday, Monday... */</span></span><br><span class="line">    <span class="keyword">int</span> tm_yday;    <span class="comment">/* [0, 365], days since January 1th */</span></span><br><span class="line">    <span class="keyword">int</span> tm_isdst;   <span class="comment">/* 夏令时标志，无效则为0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，以上只是<code>time_t</code>的最小实现，实际Glibc 2.23版本的代码中除了上述成员外还添加了其它字段。<strong><code>tm_year</code>是从1900年开始的，并不是和UNIX时间戳相同的1970年。</strong></p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p><code>time()</code>和<code>clock()</code>函数是依赖于具体实现的，此处不作分析。</p><p><code>difftime()</code>函数返回两个时间戳之间的差值，考虑到<code>time_t</code>可能会被定义为无符号整数，故需要先比较二者的大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">difftime</span><span class="params">(<span class="keyword">time_t</span> t1, <span class="keyword">time_t</span> t0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t0 &lt;= t1 ? (<span class="keyword">double</span>)(t1 - t0) : -(<span class="keyword">double</span>)(t0 - t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tm</code>与<code>time_t</code>间的转换函数是<code>&lt;time.h&gt;</code>中的重点，这里主要来看一下<code>gmtime()</code>和<code>mktime()</code>的实现方法。下列代码在书中给出的代码基础上进行了些改写，主要是做了些精简，没有考虑夏令时等问题。虽然以下两段代码比Glibc中的实现要简单得多，不过经测试完全可以正常使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">short</span> lmos[] = &#123; <span class="number">0</span>, <span class="number">31</span>, <span class="number">60</span>, <span class="number">91</span>, <span class="number">121</span>, <span class="number">152</span>, <span class="number">182</span>, <span class="number">213</span>, <span class="number">244</span>, <span class="number">274</span>, <span class="number">305</span>, <span class="number">335</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">short</span> mos[] = &#123; <span class="number">0</span>, <span class="number">31</span>, <span class="number">59</span>, <span class="number">90</span>, <span class="number">120</span>, <span class="number">151</span>, <span class="number">181</span>, <span class="number">212</span>, <span class="number">243</span>, <span class="number">273</span>, <span class="number">304</span>, <span class="number">334</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONTAB(year) ((year &amp; 0x03) == 2 ? lmos : mos)</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct tm * <span class="title">gmtime</span><span class="params">(<span class="keyword">time_t</span> * timer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">ts</span>;</span></span><br><span class="line">  <span class="keyword">int</span> year;</span><br><span class="line">  <span class="keyword">int</span> days;</span><br><span class="line">  <span class="keyword">int</span> secs;</span><br><span class="line"></span><br><span class="line">  secs = *timer;</span><br><span class="line">  days = secs / <span class="number">86400</span>;          <span class="comment">// 获取天数</span></span><br><span class="line">  ts.tm_wday = (days + <span class="number">4</span>) % <span class="number">7</span>;  <span class="comment">// 1970年1月1日是星期四</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> dDay;</span><br><span class="line">  <span class="comment">/* days / 365 先求出year的初步估计，因为闰年的存在不一定准确（可能会多1年） */</span></span><br><span class="line">  <span class="comment">/* (year + 1) / 4 求出因闰年多出来的天数 */</span></span><br><span class="line">  <span class="comment">/* days与year年初的天数比较，若days小于它，说明year估计有误，需要减去1年 */</span></span><br><span class="line">  <span class="keyword">for</span> (year = days / <span class="number">365</span>; days &lt; (dDay = (year + <span class="number">1</span>) / <span class="number">4</span> + <span class="number">365</span> * year);)</span><br><span class="line">    year--;</span><br><span class="line">  days -= dDay;             <span class="comment">// 将days变成1年中的天数</span></span><br><span class="line">  ts.tm_year = year + <span class="number">70</span>;   <span class="comment">// tm_year是从1900年开始的</span></span><br><span class="line">  ts.tm_yday = days;        <span class="comment">// 总天数减去年初的天数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 从最后一个月开始，逐步向前寻找正确的月份，pm[mon]得到月初的天数 */</span></span><br><span class="line">  <span class="keyword">int</span> mon;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">short</span> * pm = MONTAB(year);</span><br><span class="line">  <span class="keyword">int</span> tmp = (year &amp; <span class="number">0x03</span>) == <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (mon = <span class="number">11</span>; days &lt; pm[mon]; mon--);</span><br><span class="line">  ts.tm_mon = mon;</span><br><span class="line">  ts.tm_mday = days - pm[mon] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据secs依次求出小时、分钟和秒 */</span></span><br><span class="line">  secs %= <span class="number">86400</span>;</span><br><span class="line">  ts.tm_hour = secs / <span class="number">3600</span>;</span><br><span class="line">  secs %= <span class="number">3600</span>;</span><br><span class="line">  ts.tm_min = secs / <span class="number">60</span>;</span><br><span class="line">  ts.tm_sec = secs % <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;ts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">short</span> lmos[] = &#123; <span class="number">0</span>, <span class="number">31</span>, <span class="number">60</span>, <span class="number">91</span>, <span class="number">121</span>, <span class="number">152</span>, <span class="number">182</span>, <span class="number">213</span>, <span class="number">244</span>, <span class="number">274</span>, <span class="number">305</span>, <span class="number">335</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">short</span> mos[] = &#123; <span class="number">0</span>, <span class="number">31</span>, <span class="number">59</span>, <span class="number">90</span>, <span class="number">120</span>, <span class="number">151</span>, <span class="number">181</span>, <span class="number">212</span>, <span class="number">243</span>, <span class="number">273</span>, <span class="number">304</span>, <span class="number">334</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONTAB(year) ((year &amp; 0x03) == 2 ? lmos : mos)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">time_t</span> mktime(struct tm * timeptr) &#123;</span><br><span class="line">  <span class="keyword">int</span> year, days, secs;</span><br><span class="line">  <span class="comment">// 检查参数有效性，不使用tm_yday &amp; tm_wday</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">  <span class="keyword">if</span> (timeptr-&gt;tm_hour &lt; <span class="number">0</span> || timeptr-&gt;tm_hour &gt; <span class="number">23</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (timeptr-&gt;tm_mday &lt; <span class="number">1</span> || timeptr-&gt;tm_mday &gt; <span class="number">31</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (timeptr-&gt;tm_min &lt; <span class="number">0</span> || timeptr-&gt;tm_min &gt; <span class="number">59</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (timeptr-&gt;tm_mon &lt; <span class="number">0</span> || timeptr-&gt;tm_mon &gt; <span class="number">11</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (timeptr-&gt;tm_sec &lt; <span class="number">0</span> || timeptr-&gt;tm_sec &gt; <span class="number">60</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (timeptr-&gt;tm_year &lt; <span class="number">70</span> || timeptr-&gt;tm_year &gt; <span class="number">138</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  year = timeptr-&gt;tm_year - <span class="number">70</span>;</span><br><span class="line">  days = (year + <span class="number">1</span>) / <span class="number">4</span> + <span class="number">365</span> * year;</span><br><span class="line">  days += MONTAB(year)[timeptr-&gt;tm_mon] + timeptr-&gt;tm_mday - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  secs = <span class="number">3600</span> * timeptr-&gt;tm_hour+ <span class="number">60</span> * timeptr-&gt;tm_min + timeptr-&gt;tm_sec;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">86400</span> * days + secs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要指出的是，上面这个<code>mktime()</code>函数没有考虑时区的问题，而<strong>标准的<code>mktime()</code>函数实现的是将由<code>tm</code>表示的地方时转换为<code>time_t</code>表示的GMT时间</strong>，所以二者并不等价。</p><p>在1970~2038年这个范围内，闰年规律符合简单的4年一闰，所以可以用<code>(year &amp; 0x03) == 2</code>来进行闰年判断。</p><p>其余<code>asctime()</code>、<code>ctime()</code>等函数用于返回格式化的时间字符串，其原理和<code>sprintf()</code>等函数大同小异，在此不作分析。</p><h2 id="ctype-h"><a href="#ctype-h" class="headerlink" title="ctype.h"></a>ctype.h</h2><p>包含字符测试及大小写转换函数。</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>提供了若干<code>isxxxx()</code>函数用于判断字符类型，并提供了大小写转换函数，具体函数列表见：<a href="/2016/04/18/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93/">C语言标准库总结</a></p><p>需要说明的是，字符集的具体定义和区域设置有关，不过常用的就是英文的情况，因为这些函数也无法处理中文编码。另外，函数接受的参数是一个<code>int</code>类型的整数，不过只有<code>unsigned char</code>类型所能表示的值加上<code>EOF</code>宏定义的值（一般为-1）是有效的，传入其它值的行为是未定义的。</p><h3 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h3><p>出于效率考虑，标准库中的实现方法是基于转换表的，这里不列举具体使用的转换表了，仅描述一下设计思路。</p><p>首先将整个字符集合划分为若干个合理设计的子集，如数字（<code>0</code><del><code>9</code>）、小写字母（<code>a</code></del><code>z</code>）、大写字母（<code>A</code>~<code>Z</code>）等，每一类用一个比特位来表示，这样就可以得到如下宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _XD  0x01  <span class="comment">/* '0'-'9', 'A'-'F', 'a'-'f' */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _UP  0x02  <span class="comment">/* 'A'-'Z' */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SP  0x04  <span class="comment">/* space */</span></span></span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure><p>任何一个字符都属于某一子集（或某几个子集）中，这样就可以根据以上宏定义得到这个字符的编码了，将全体字符编码构成一个数组，这就是所谓的转换表，书中这个数组的名字叫做<code>_Ctype</code>。这样一来，要判断某个字符是否属于某个子集就很简单了，只要检查这个字符在转换表中对应值的特定位是否被置位了就可以了，比如检查一个字符是否是大写字母：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isupper</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (_Ctype[c] &amp; _UP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>大小写间的转换也是基于转换表的，这个转换表相当于在原始ACSII表的基础上将大写字母替换为小写字母（或相反）得到的。</p><p>关于区域编码的问题此处从略。</p><h2 id="stdarg-h"><a href="#stdarg-h" class="headerlink" title="stdarg.h"></a>stdarg.h</h2><p>用于处理可变参数。</p><h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><p>可变参数函数的定义类似这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> parmN,...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, parmN);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">int</span> a = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">double</span> b = va_arg(ap, <span class="keyword">double</span>);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须要有<strong>至少一个</strong>固定参数，习惯上把最后一个固定参数叫做<code>parmN</code>。在函数中先调用<code>va_start()</code>初始化<code>va_list</code>，之后就可以通过<code>va_arg()</code>依次获取各参数，最后调用<code>va_end()</code>即可。<strong>需要注意的是，在可变参数中，应用的是“加宽”原则，也就是<code>float</code>会被扩展成<code>double</code>，<code>char</code>、<code>short</code>等会被扩展成<code>int</code>，也就是说，函数中只该使用以下这些表达式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">va_arg(ap, <span class="keyword">double</span>);</span><br><span class="line">va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">va_arg(ap, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><h3 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a>实现方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * va_list;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start(ap, A)  (void)((ap) = (char *)&amp;A)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_end(ap)       (void)(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_arg(ap, T)    (*(T *))((ap += sizeof(T)) - sizeof(T))</span></span><br></pre></td></tr></table></figure><p>这里给出的代码是简化版代码，没有考虑存储空隙及对齐问题，仅用来说明基本原理。</p><h2 id="assert-h"><a href="#assert-h" class="headerlink" title="assert.h"></a>assert.h</h2><p>提供断言。</p><h3 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h3><p>在需要使用断言的地方加入<code>assert(x)</code>即可，<code>x</code>是一个<code>int</code>，若<code>x</code>为零断言成立，此时程序会向标准错误流输出一条包含出错行号等的错误信息并调用<code>abort()</code>函数终止程序的运行。<code>assert(x)</code>返回<code>void</code>。</p><p>一般只有在程序调试时才需要终止程序运行，发布时应该去掉这个功能，为实现这一目的，可通过定义<code>NDEBUG</code>这个宏来实现，一般使用编译器预定义。</p><h3 id="实现方法-3"><a href="#实现方法-3" class="headerlink" title="实现方法"></a>实现方法</h3><p>为了对<code>NDEBUG</code>作出正确回应，头文件的基本结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> assert    <span class="comment">/* remove existing definition */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert (test) ((void) 0)  <span class="comment">/* passive form */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert (test) ...         <span class="comment">/* active form */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>其中<code>active form</code>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _Assert(<span class="keyword">char</span> *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _STR(x) _VAL(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _VAL(x) #x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(test)  ((test) ? (void) 0 : _Assert(__FILE__<span class="meta-string">":"</span>_STR(__LINE__)<span class="meta-string">" "</span>#test))</span></span><br></pre></td></tr></table></figure><p><code>_Assert()</code>是一个隐藏库函数，用于调用<code>&lt;stdio.h&gt;</code>中的其它库函数输出错误信息并调用<code>abort()</code>函数，这个很简单，没有什么问题，上述代码的关键在于后面几行宏定义上。</p><hr><p><code>__FILE__</code>及<code>__LINE__</code>这两个宏是由编译器定义的，代表当前文件名及当前代码行号，<code>__FILE__</code>是一个字符串，而<code>__LINE__</code>是一个十进制整数。</p><p><code>_STR()</code>及<code>_VAL()</code>这两个宏神奇的实现了将一个<strong>整数常量</strong>转换为<strong>字符串字面量</strong>的功能，二者缺一不可，也就是说，下面这个写法是<strong>错误的</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _STR(x) #x</span></span><br></pre></td></tr></table></figure><p>使用这个写法的话，<code>_STR(__LINE__)</code>得到的是<code>&quot;__LINE__&quot;</code>而不是期望的结果。<br>另外，<code>_STR()</code>及<code>_VAL()</code>这两个宏就是一般的宏，其名字没有任何特殊之处，改成<code>aaa()</code>一类的依然可以正常使用。至于这两个宏到底为何能起到这样的作用，想了很久也没有想清楚……只有留待将来哪时候能不能理解清楚了。</p><p>最后一句宏定义还涉及到一个字符串常量拼接操作，这也是我之前不知道的……要是想把几个字符串常量拼接起来，直接将其写在一起就可以了，中间<strong>不需要也不能用</strong><code>+</code>一类的符号进行连接。</p><p>最后还有个神奇的<code>#</code>符号，书中叫做<strong>字符串创建操作符</strong>，这个符号可以起到把大多数信息转成字符串字面量的作用，最重要的是，这个符号似乎<strong>只能用于宏定义中</strong>，如下面这段程序是完全正确的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYSTR(x) #x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * tmpstr = MYSTR(<span class="number">100</span>)<span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure><p>然而改成这样就是错误的了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * tmpstr = #<span class="number">100</span><span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure><p>考虑到预处理命令都是以<code>#</code>开头的，<code>#</code>本身应该也算是一个预处理指令，所以并不能直接用于程序中。</p><blockquote><p>Update 2017-10-06:<br>以上用法都是C语言本身的特性，现在终于能很好的理解清楚了，详见：<br><a href="/2017/10/05/string_literal_concatenate/">C语言中的字符串字面量连接</a><br><a href="/2017/10/06/C_Macro/">深入理解C语言中宏定义</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python实现网站变化监测系统</title>
      <link href="/2016/07/26/%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E5%8F%98%E5%8C%96%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F/"/>
      <url>/2016/07/26/%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E5%8F%98%E5%8C%96%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>很多时候我们都有监测某个网站变化的需求，比如是否发布新通知了，是否有新更新了等。之前使用过Chrome的几个插件来实现这个功能，不过用起来都觉得不是很方便，于是就想自己用Python写一个，之后将程序部署在服务器上即可实现24小时自动监测了。</p><p>用了几天时间写了个还算可以用的程序出来，可以实现以下功能：</p><ul><li>定时去检查网站的某页面（或某几个页面），获取此时发布的信息，并与数据库中的数据对比，如果检测到新发布的信息，则将其加入数据库中，并通过微信公众号进行自动发布；</li><li>可以实现关键词过滤功能，检查发布信息标题及内容页是否有指定关键词，如果没有的话忽略此信息；</li><li>实现了一个相对比较通用的程序架构，可以很方便的向其中添加新网站。</li></ul><a id="more"></a><p>项目已上传至GitHub：<a href="https://github.com/g199209/Spider" target="_blank" rel="noopener">https://github.com/g199209/Spider</a></p><p>这个系统其实和爬虫所用的技术基本是一样的，下面来总结下此系统的实现方法。</p><h2 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h2><p>主程序为<code>Spider.py</code>，使用时运行此程序即可，此脚本执行过程伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Initialize(WebList)</span><br><span class="line">Initialize(Log File)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> web <span class="keyword">in</span> WebList:</span><br><span class="line">        web.GET()</span><br><span class="line">        web.Update()</span><br><span class="line"></span><br><span class="line">        Handle Exception()</span><br><span class="line">    </span><br><span class="line">    Sleep()</span><br></pre></td></tr></table></figure><p>首先初始化日志及网站列表，之后进入死循环，依次从网站列表中取出各网站，检查是否有更新及发布新消息，若此过程发生异常需进行处理，最后挂起一段时间进行下一次循环。</p><p>此处的网站列表是各网站实例化对象的一个List，如果要添加新网站在此List中增加新元素即可。</p><h2 id="WebsiteBase类"><a href="#WebsiteBase类" class="headerlink" title="WebsiteBase类"></a>WebsiteBase类</h2><p><code>WebsiteBase</code>类是所有网站类的基类，其中抽象了所有网站的共性行为，此类本身不能实例化，只能用于继承。</p><p><code>WebsiteBase</code>类中的公用接口函数只有3个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造函数</span></span><br><span class="line">__init__(self, Name, DBName, AgentID, CheckContent, KeyWords, KeyWordsThreshold, encoding = <span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment"># 获取网站新消息</span></span><br><span class="line">GET(self)</span><br><span class="line"><span class="comment"># 发布新消息</span></span><br><span class="line">Update(self)</span><br></pre></td></tr></table></figure><p>下面分别说明这3个函数的实现。</p><hr><p>构造函数<code>__init__()</code>的执行流程伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">()</span>:</span></span><br><span class="line">    Initialize(Parameters)</span><br><span class="line">    Get(Wchat Password)</span><br><span class="line">    Initialize(Database)</span><br></pre></td></tr></table></figure><p>进行微信发布时需要用到的<code>corpid</code>及<code>corpsecret</code>在此处从文件中读取得到。</p><hr><p>用于发布新消息的<code>Update()</code>函数的执行流程伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Update</span><span class="params">()</span>:</span></span><br><span class="line">    Initialize(Wchat)</span><br><span class="line">    Open(Database)</span><br><span class="line">    Get(Unpublished message)</span><br><span class="line">    Publish(Unpublished message)</span><br><span class="line">    Close(Database)</span><br></pre></td></tr></table></figure><p>实际代码中还增加了很多异常处理相关的代码，此处不多说明了。</p><hr><p>用于获取网站新消息的<code>GET()</code>函数是此类的核心，其执行流程伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GET</span><span class="params">()</span>:</span></span><br><span class="line">    Open(Database)</span><br><span class="line">    Get(PageRange)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> PageRange:</span><br><span class="line">        Get(Main Page)</span><br><span class="line">        Get(Enclose)</span><br><span class="line">        Get(Tags)</span><br><span class="line">        <span class="keyword">for</span> tag <span class="keyword">in</span> Tags:</span><br><span class="line">            Get(Title &amp; URL &amp; Brief &amp; Publish Time)</span><br><span class="line">            Check(Database)</span><br><span class="line">            Check(Addition Check)</span><br><span class="line">            <span class="keyword">if</span> Unchecked:</span><br><span class="line">                Check(Keywords <span class="keyword">in</span> Title)</span><br><span class="line">                Check(Keywords <span class="keyword">in</span> URL Content)</span><br><span class="line">                Update(Database)</span><br><span class="line">            Check(Database)</span><br><span class="line">            <span class="keyword">if</span> New Message:</span><br><span class="line">                Update(Database)</span><br><span class="line">    Close(Database)</span><br></pre></td></tr></table></figure><p><code>PageRange</code>指页面参数，有时需要访问同一个网站的若干页面，就可以通过此参数来进行循环，以简化程序代码。</p><p><code>Enclose</code>指感兴趣的目标区域，先进行一次筛选，去掉无用的部分以便于后续操作。</p><p><code>Tags</code>指只包含一条消息记录的HTML部分，一般很容易从感兴趣的目标区域中分离出每一条消息记录来，之后就可以循环对每一条消息进行处理了。</p><p>对每一条消息进行处理时，先获取标题，URL地址等信息，之后先判断此条消息对应的URL之前是否访问过，要是已经访问过就跳过。Addition Check用于执行一些附加检测，如果不符合要求也跳过此条消息。如果此条消息没有被检查过，就进行关键词检查，这一步是可选的，要是没有设置关键词就跳过。检查后不符合要求也跳过此条消息，不过会将此条消息加入已检查数据库中，下次就不再检查了。最后，如果此消息通过了上述所有检查，而且是一条尚未发布的新消息，那么就将其加入待发布数据库中，之后调用<code>Update()</code>函数时会进行微信发布。</p><p><code>GET()</code>函数中包含了很多获取网页信息的方法，这些方法在此基类中都没有实现，需要具体的网站子类去实现。这类似于C++中的虚函数，不过Python中没有这个概念。</p><h2 id="具体网站子类"><a href="#具体网站子类" class="headerlink" title="具体网站子类"></a>具体网站子类</h2><p>每一个网站就是一个类，此类必须继承自<code>WebsiteBase</code>类，<code>WebsiteBase</code>类中封装了获取信息及发布信息的整个基本流程，子类中只需要实现一些与具体网站相关的方法即可，包含构造函数具体有10个。<code>Template.py</code>文件就是具体网站子类实现的一个模板文件，如果需要添加新网站只需要复制此文件，在此基础上进行修改即可。具体需要修改的内容可以参考Github项目中的ReadMe文档。</p><h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><p>因为涉及到网络连接，难免会发生超时、无法访问等各种异常，在一个良好的设计中，此时程序是不应该崩溃的，而是能跳过此异常网站继续运行其他部分，并在之后网络正常后自动恢复。</p><p>而且因为这个程序是运行在服务器上的，需要在发生异常和从异常中恢复时能提示下我，以便及时去进行处理。为实现这一目的，在<code>WebsiteBase</code>类中设置了一个<code>err</code>成员用于记录错误状态，当<code>err</code>由<code>False</code>变为<code>True</code>时自动发送一条错误报告；当<code>err</code>由<code>True</code>变为<code>False</code>时自动发送一条错误恢复报告。之所以设置为边沿触发是考虑到异常可能会持续一段时间，每次都发送报告没有什么必要。</p><p>另外，在<code>WebsiteBase</code>类中也有自己的<code>try...except</code>语句，这是为了当一个页面发生异常时并不是退出整个网站的处理，而是继续处理下一条消息记录。最后用<code>raise</code>把这个异常送至顶层进行统一处理。</p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>每一个网站子类实例都使用了两个数据库，一个用于记录哪些URL访问过了，另一个用于记录待发布信息的状态。</p><p>如果一个URL之前已经访问过了，那之后就不需要再访问了，以此优化程序的性能。而待发布信息数据库中包含了待发布的消息相关信息，还有一个<code>Published</code>字段用于记录此消息是否已经发布了，在<code>GET()</code>方法添加记录到数据库中时此字段是<code>0</code>，在<code>Update()</code>方法中会检查<code>Published</code>字段为<code>0</code>的记录依次进行发布，并将<code>Published</code>字段置为<code>1</code>。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>微信发布使用了微信企业号，这种类型的公众号没有每天发送消息的上限，极为适合用来做消息通知。企业号的另一个特性是不能自由关注，需要提前预先加到通信录中的人才能关注，这也很适合此系统的需要。关于微信的接口，其开发者帮助中有很详尽的说明，照着操作就可以了。</p><p>关于网站编码问题，有些网站用的是<code>utf-8</code>编码，有些用的是<code>gb2312</code>编码，实际测试表明，对于用<code>gb2312</code>编码的网站，若是不手动指定编码格式读到的就是乱码，所以还是建议都手动指定一下编码格式。</p><p>和爬虫一样，如果抓取频率太高的话是有可能被网站给禁掉的，网上有一些使用代理等方法，不过最简单也是最道德的解决方案是降低抓取频率，在此系统中连续抓取频率限定为3s一次，这么低的频率和正常人类访问也差不多，一般来说是不会被禁掉的，也不会对对方网站服务器造成过大的压力。</p>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Python </tag>
            
            <tag> Spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式总结</title>
      <link href="/2016/07/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2016/07/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>正则表达式（Regular Expression，在代码中常简写为regex、regexp或RE）是一个字符串，此字符串用于描述、匹配一系列符合某个句法规则的字符串。</p><p>正则表达式引擎是一种可以处理正则表达式的软件。通常，引擎是更大的应用程序的一部分。在软件世界，<strong>不同的正则表达式引擎并不完全互相兼容</strong>。<br>正则表达式引擎缺省是大小写敏感的。</p><p>此处总结下常用的正则表达式规则。</p><a id="more"></a><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>有12个字符被保留作特殊用途，它们是：<br><code>[</code> <code>]</code> <code>\</code> <code>^</code> <code>$</code> <code>.</code> <code>|</code> <code>?</code> <code>*</code> <code>+</code> <code>(</code> <code>)</code><br>如果要在正则表达式中将这些字符用作文本字符，需要用反斜杠<code>\</code>对其进行转义。<br>在编程语言中，一些特殊的字符会先被编译器处理，然后再传递给正则引擎。因此为了匹配<code>&quot;C:\temp&quot;</code>，要用正则表达式<code>&quot;C:\\temp&quot;</code>。而在C++中，正则表达式则变成了<code>&quot;C:\\\\temp&quot;</code>。</p><h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><p>不加数量限定则代表<strong>出现且仅出现一次</strong>。</p><table><thead><tr><th>模式</th><th>含义</th></tr></thead><tbody><tr><td><strong><code>*</code></strong></td><td>重复零次或更多次（<strong>任意次</strong>）</td></tr><tr><td><strong><code>+</code></strong></td><td>重复一次或更多次（<strong>至少一次</strong>）</td></tr><tr><td><strong><code>?</code></strong></td><td>重复零次或一次（<strong>至多一次</strong>）</td></tr><tr><td><code>{n}</code></td><td>重复n次</td></tr><tr><td><code>{n,}</code></td><td>重复n次或更多次（至少n次）</td></tr><tr><td><code>{n,m}</code></td><td>重复n到m次</td></tr></tbody></table><p><code>*</code> <code>+</code> <code>?</code> 的重复具有贪婪性，即试图匹配<strong>尽可能长的字符串</strong>。如需要非贪婪模式，即匹配尽可能短的字符串，在任意一个重复限制符后加上一个<code>?</code>，即：<br><code>*?</code>  <code>+?</code>  <code>??</code>  <code>{n}?</code>  <code>{n,}?</code>  <code>{n,m}?</code></p><h2 id="获取文本"><a href="#获取文本" class="headerlink" title="获取文本"></a>获取文本</h2><p>使用<strong><code>()</code></strong>。<strong><code>(exp)</code></strong>匹配<code>exp</code>,并将匹配到的文本缓存到自动命名的组里。命名规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。要获得之前匹配的文本，在表达式中使用”&quot;加上组号的形式，如”\1”。</p><p><em>在VS替换文本操作中，替换为的文本中如需包含原文本，使用”$”加上组号的形式，如”$1”。</em></p><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>用<code>[]</code>组合表示一个匹配集合，如<code>[abc]</code>，<strong>字符集中不区分顺序</strong>。可以使用连字符<code>-</code>定义一个字符范围作为字符集。</p><p>在左方括号<code>[</code>后面紧跟一个尖括号<code>^</code>，将会对字符集取反，结果是字符集将匹配任何不在方括号中的字符(<strong>包括<code>\n</code></strong>)，很重要的一点是，<strong>取反字符集必须要匹配一个字符</strong>。</p><p>在字符集中只有4个字符具有特殊含义，它们是：<br><code>]</code> <code>\</code> <code>^</code> <code>-</code></p><p><code>]</code>代表字符集定义的结束；<code>\</code>代表转义；<code>^</code>代表取反；<code>-</code>代表范围定义。<strong>其他常见的特殊字符在字符集定义内部都是正常字符，不需要转义</strong>。例如，要搜索星号<code>*</code>或加号<code>+</code>，可以用<code>[+*]</code>。当然，如果对那些通常的特殊字符进行转义，<strong>得到的正则表达式一样正确</strong>，但是这会降低可读性。</p><p>如果用<code>?*+</code>操作符来重复一个字符集，将会<strong>重复整个字符集</strong>，而不仅是它匹配的那个字符。</p><h2 id="选择匹配"><a href="#选择匹配" class="headerlink" title="选择匹配"></a>选择匹配</h2><p>即逻辑或操作，用<code>|</code>把不同的规则分隔开。通常使用<code>(?:exp1|exp2)</code>的形式。<code>(?:)</code>代表匹配但不获取匹配文本。</p><h2 id="位置锚定"><a href="#位置锚定" class="headerlink" title="位置锚定"></a>位置锚定</h2><table><thead><tr><th>模式</th><th>含义</th></tr></thead><tbody><tr><td><strong><code>^</code></strong></td><td>匹配一行字符串第一个字符前的位置，即<strong>行首</strong></td></tr><tr><td><strong><code>$</code></strong></td><td>匹配字符串中最后一个字符的后面的位置，即<strong>行尾</strong></td></tr><tr><td><strong><code>\b</code></strong></td><td>匹配一个<strong>单词边界</strong>，也就是指单词和空格间的位置。</td></tr></tbody></table><h2 id="常用字符集"><a href="#常用字符集" class="headerlink" title="常用字符集"></a>常用字符集</h2><table><thead><tr><th>模式</th><th>含义</th></tr></thead><tbody><tr><td><strong><code>.</code></strong></td><td>匹配<strong>任何单个字符</strong>（换行符<code>\n</code>除外）</td></tr><tr><td><strong><code>\d</code></strong></td><td>匹配<strong>任何数字字符</strong></td></tr><tr><td><strong><code>\s</code></strong></td><td>匹配<strong>任何空白字符</strong>，等价于<code>[ \f\n\r\t\v]</code></td></tr><tr><td><strong><code>\w</code></strong></td><td>匹配<strong>字母或数字或下划线或汉字</strong></td></tr></tbody></table><hr><p>最后附上一张相对完整的正则表达式规则以供参考：</p><p><img src="https://pic.gaomf.store/pyre_ebb9ce1c-e5e8-4219-a8ae-7ee620d5f9f1.png" alt=""></p><blockquote><p>参考资料：<br><a href="http://zh.wikipedia.org/wiki/正则表达式" target="_blank" rel="noopener">WiKi - 正则表达式</a><br><a href="http://dragon.cnblogs.com/archive/2006/05/08/394078.html" target="_blank" rel="noopener">深入浅出之正则表达式（一）</a><br><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式30分钟入门教程</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Regular Expression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫--使用re正则表达式解析文本</title>
      <link href="/2016/07/20/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8re%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90%E6%96%87%E6%9C%AC/"/>
      <url>/2016/07/20/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8re%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90%E6%96%87%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>进行文本匹配等操作最合适的工具就是正则表达式了，Python中的正则表达式模块叫做<code>re</code>，在此总结下此模块最基本的用法。关于正则表达式本身的模式字符串的构成，参考我的另一篇文章：<a href="/2016/07/20/正则表达式总结/">正则表达式总结</a></p><a id="more"></a><p>使用正则表达式首先要导入<code>re</code>模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><h2 id="Match对象"><a href="#Match对象" class="headerlink" title="Match对象"></a>Match对象</h2><p>Match对象代表一次匹配的结果，包含了很多关于此次匹配的信息，其中最重要的就是获取匹配到的字符串，一般使用<code>group()</code>方法：</p><p><strong><code>group()</code>等价于<code>group(0)</code>，返回整个匹配的子串；</strong><br><strong><code>group(num)</code>返回第<code>num</code>个组对应的字符串，从1开始。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ss = <span class="string">'Hello World!'</span></span><br><span class="line">matchObj = re.search(<span class="string">r'(\w+) (\w+)(.)'</span>, ss)</span><br><span class="line"></span><br><span class="line">print(matchObj.group(<span class="number">0</span>))</span><br><span class="line">print(matchObj.group(<span class="number">1</span>))</span><br><span class="line">print(matchObj.group(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">Hello</span><br><span class="line">!</span><br></pre></td></tr></table></figure><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><p><strong>使用<code>re.match()</code>方法</strong>，默认从字符串起始位置开始匹配一个模式，此方法一般用于检查字符串是否符合某一规则，函数基本语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.match(pattern, string)</span><br></pre></td></tr></table></figure><p>匹配成功返回一个Match对象，否则返回None。</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p><strong>使用<code>re.search()</code>方法</strong>，扫描整个字符串并返回<strong>第一个</strong>成功的匹配。匹配与搜索的区别在于：<code>re.match()</code>只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而<code>re.search()</code>匹配整个字符串，直到找到一个匹配。函数基本语法与<code>re.match()</code>相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern, string)</span><br></pre></td></tr></table></figure><p>匹配成功返回一个Match对象，否则返回None。</p><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p><strong>使用<code>re.sub()</code>方法</strong>，先根据指定模式进行搜索，再用指定字符串进行替换，函数基本语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sub(pattern, repl, string)</span><br></pre></td></tr></table></figure><p><code>repl</code>是需要替换的字符串，返回替换后的字符串，如果模式没有发现，字符将被没有改变地返回。</p><p>一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OldStr = <span class="string">'Phone Number :##137-123-4567##'</span></span><br><span class="line"></span><br><span class="line">NewStr = re.sub(<span class="string">r'\D'</span>, <span class="string">""</span>, OldStr)</span><br><span class="line">print(NewStr)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1371234567</span></span><br></pre></td></tr></table></figure><p>这段程序可以去除原字符串中的所有非数字。</p><hr><p>相关文章：</p><p><a href="/2016/06/03/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8requests%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5/">Python爬虫–使用requests获取网页</a><br><a href="/2016/07/20/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8BeautifulSoup%E8%A7%A3%E6%9E%90HTML/">Python爬虫–使用BeautifulSoup解析HTML</a></p><blockquote><p>参考资料：<br><a href="http://www.runoob.com/python/python-reg-expressions.html" target="_blank" rel="noopener">Python正则表达式</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Spider </tag>
            
            <tag> Regular Expression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫--使用BeautifulSoup解析HTML</title>
      <link href="/2016/07/20/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8BeautifulSoup%E8%A7%A3%E6%9E%90HTML/"/>
      <url>/2016/07/20/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8BeautifulSoup%E8%A7%A3%E6%9E%90HTML/</url>
      
        <content type="html"><![CDATA[<p><code>bs4</code>用于解析获取到的HTML文件，其官方中文文档为：<a href="https://www.crummy.com/software/BeautifulSoup/bs3/documentation.zh.html" target="_blank" rel="noopener">Beautiful Soup 中文文档</a>，此处列举的只是最基本最常用的一些用法。</p><a id="more"></a><p>使用BeautifulSoup首先要导入它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure><h2 id="创建-BeautifulSoup-对象"><a href="#创建-BeautifulSoup-对象" class="headerlink" title="创建 BeautifulSoup 对象"></a>创建 BeautifulSoup 对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(html)</span><br></pre></td></tr></table></figure><p>其中<code>html</code>是一段HTML文本字符串。</p><p>上述代码使用Python内置的解析器进行解析，也可指定使用其它解析器，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(html, <span class="string">"html5lib"</span>)</span><br></pre></td></tr></table></figure><h2 id="输出文档"><a href="#输出文档" class="headerlink" title="输出文档"></a>输出文档</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(soup.prettify)</span><br></pre></td></tr></table></figure><p>输出排版好HTML文档。</p><h2 id="获取标签"><a href="#获取标签" class="headerlink" title="获取标签"></a>获取标签</h2><p>直接使用标签对应的属性即可，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">soup.title</span><br><span class="line">soup.head</span><br><span class="line">soup.a</span><br><span class="line">soup.p</span><br></pre></td></tr></table></figure><p>返回的是第一个tag对象，使用<code>name</code>属性获取此标签的类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.p.name</span><br></pre></td></tr></table></figure><p>返回一个字符串，对应标签名称。</p><p>使用<code>.string</code>属性获取此标签包含的文本内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.title.string</span><br></pre></td></tr></table></figure><p>获取到的字符串不包括标签本身，另外注意需要仅当此标签不包含子标签时才能使用<code>.sting</code>属性。如果此标签包含其他子节点，可以使用<code>.contents</code>属性获取所有子节点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.head.contents</span><br></pre></td></tr></table></figure><p>返回对象是一个List。如需获取父节点，使用<code>.parent</code>属性即可，除此之外，还有些用于获取兄弟节点的<code>.next_siblings</code>等方法，此处从略。</p><p>如果要获取标签的某个属性，直接使用类似List的语法即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.p[<span class="string">'class'</span>]</span><br></pre></td></tr></table></figure><p>上述程序返回<code>&lt;p&gt;&lt;/p&gt;</code>标签的<code>class</code>属性。</p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>对于爬虫来说，BeautifulSoup的搜索功能是最有用的，最常用的函数是：</p><p><strong>find_all(name, **kwargs )</strong></p><p><code>find_all()</code>方法搜索当前标签中的所有子节点，并判断是否符合过滤器的条件。返回包含所有符合条件的tag对象的List。</p><p><code>name</code>参数可以传入很多东西，最常用的是传入目标标签名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure><p>上述代码将放回所有的<code>&lt;b&gt;&lt;/b&gt;</code>标签Tag。</p><p><code>kwargs</code>参数可以传入任意数量的属性，搜索时会匹配对应的标签属性，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">'a'</span>, id=<span class="string">'link'</span>)</span><br></pre></td></tr></table></figure><p>上述代码将会搜索包含<code>id=&quot;link&quot;</code>属性的<code>&lt;a&gt;&lt;/a&gt;</code>标签。</p><p>注意，如果标签属性的名称和关键词等冲突，可在其后面加一个<code>_</code>，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(<span class="string">'div'</span>, class_=<span class="string">'list'</span>)</span><br></pre></td></tr></table></figure><p>另外，<code>find_all()</code>方法返回的是一个List，如果只需要简单的返回第一个结果，可使用<code>find()</code>函数，用法完全相同。</p><hr><p>一般使用Beautiful Soup筛选出所需的标签后，再配合正则表达式就可以准确提取出所需的内容了。</p><p>相关文章：</p><p><a href="/2016/06/03/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8requests%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5/">Python爬虫–使用requests获取网页</a><br><a href="/2016/07/20/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8re%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90%E6%96%87%E6%9C%AC/">Python爬虫–使用re正则表达式解析文本</a></p><blockquote><p>参考资料：<br><a href="http://cuiqingcai.com/1319.html" target="_blank" rel="noopener">Python爬虫利器二之Beautiful Soup的用法</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot 2016.05 Stage1代码分析</title>
      <link href="/2016/07/15/U-Boot%202016.05%20Stage1%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2016/07/15/U-Boot%202016.05%20Stage1%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>主流Bootloader的启动过程均可分为Stage1及Stage2两部分，一般来说，Stage1完成最基本的初始化操作、搬移代码及建立C语言运行环境；Stage2完成剩余的初始化操作。故Stage1一般使用汇编完成，Stage2一般使用C语言完成，不过这只是很粗略的情况，实际上Stage1中也会使用C语言代码。</p><p>下面以之前针对S3C2440移植好的U-Boot 2016.05为例，分析U-Boot中Stage1的代码。</p><a id="more"></a><h2 id="程序入口点分析"><a href="#程序入口点分析" class="headerlink" title="程序入口点分析"></a><strong>程序入口点分析</strong></h2><p>要分析启动流程首先要找到程序入口点，也就是最先运行的代码位于何处，这是由链接过程决定的，故找到链接脚本文件<code>u-boot.lds</code>：</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ENTRY</span>(_start)</span><br><span class="line"><span class="symbol">SECTIONS</span></span><br><span class="line">&#123;</span><br><span class="line"> . = <span class="number">0x00000000</span><span class="comment">;</span></span><br><span class="line"> . = <span class="meta">ALIGN</span>(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"> <span class="meta">.text</span> :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_start)</span><br><span class="line">  *(.vectors)</span><br><span class="line">  arch/<span class="meta">arm</span>/cpu/arm920t/start.o (<span class="meta">.text</span>*)</span><br><span class="line">  *(<span class="meta">.text</span>*)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">;......省略......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，位于映像文件最前面的依次是<code>.__image_copy_start</code>、<code>.vectors</code>及<code>arch/arm/cpu/arm920t/start.o</code>文件。</p><hr><p><code>.__image_copy_start</code>位于映像文件的起始地址处，它在文件<code>arch/arm/lib/sections.c</code>中被定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> __bss_start[<span class="number">0</span>] __attribute__((section(<span class="string">".__bss_start"</span>)));</span><br><span class="line"><span class="keyword">char</span> __bss_end[<span class="number">0</span>] __attribute__((section(<span class="string">".__bss_end"</span>)));</span><br><span class="line"><span class="keyword">char</span> __image_copy_start[<span class="number">0</span>] __attribute__((section(<span class="string">".__image_copy_start"</span>)));</span><br><span class="line"><span class="keyword">char</span> __image_copy_end[<span class="number">0</span>] __attribute__((section(<span class="string">".__image_copy_end"</span>)));</span><br></pre></td></tr></table></figure><p>这个变量的用处应该是用来进行代码定位的，也就是这个变量的地址就代表映像文件的起始地址，并不占用真实的存储空间，所以此处使用了一个0长度的数组，其他变量的用处也是一样的。U-Boot作者对此的说明是：</p><blockquote><p>We need a 0-byte-size type for these symbols, and the compiler does not allow defining objects of C type ‘void’. Using an empty struct is allowed by the compiler, but causes gcc versions 4.4 and below to complain about aliasing. Therefore we use the next best thing: zero-sized arrays, which are both 0-byte-size and exempt from aliasing warnings.</p></blockquote><hr><p><code>.vectors</code>是中断向量表，对于ARM920t来说，使用的是位于<code>arch/arm/lib/vectors.S</code>中的通用向量表：</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.globl</span> _start</span><br><span class="line">    <span class="meta">.section</span> <span class="string">".vectors"</span>, <span class="string">"ax"</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">_start</span>:</span><br><span class="line">    <span class="keyword">b </span>  reset</span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">pc</span>, _undefined_instruction</span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">pc</span>, _software_interrupt</span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">pc</span>, _prefetch_abort</span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">pc</span>, _data_abort</span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">pc</span>, _not_used</span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">pc</span>, _irq</span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">pc</span>, _fiq</span><br><span class="line"></span><br><span class="line"><span class="comment">;......省略......</span></span><br></pre></td></tr></table></figure><p>可以看到，复位后会首先执行<code>b reset</code>这条指令跳转至<code>reset</code>处执行，而<code>reset</code>标号正是位于<code>arch/arm/cpu/arm920t/start.S</code>文件中：</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    .globl  reset</span><br><span class="line"><span class="symbol">reset</span>:</span><br><span class="line"><span class="comment">;   ......省略......</span></span><br></pre></td></tr></table></figure><p>所以一般都说，代码执行开始于<code>start.S</code>文件，这也就是程序的入口点。下面就从这个文件开始分析。</p><h2 id="start-S"><a href="#start-S" class="headerlink" title="start.S"></a><strong>start.S</strong></h2><p><code>start.S</code>的执行流程见下图：<br><img src="https://pic.gaomf.store/U-Boot%20Stage1_1.svg" alt=""></p><p><code>lowlevel_init</code>是平台相关的，故它位于<code>board/samsung/smdk2440/lowlevel_init.S</code>中。此处需要完成内存控制器的初始化工作，以便之后能正常使用SDRAM。对于S3C2440来说，就是初始化了<code>BWSCON</code>、<code>BANKCONn</code>、<code>REFRESH</code>、<code>BANKSIZE</code>、<code>MRSRB</code>这些寄存器。</p><p><code>_main</code>是平台无关的，位于<code>arch/arm/lib/crt0.S</code>中，crt的意思就是C-runtime startup Code，此文件的目的就是建立C语言运行环境，以便之后跳转到Stage2，下面就来分析此文件。</p><h2 id="crt0-S"><a href="#crt0-S" class="headerlink" title="crt0.S"></a><strong>crt0.S</strong></h2><p><code>crt0.S</code>文件开头的注释中说明了<code>_main</code>的执行序列，摘录如下：</p><blockquote><p>This file handles the target-independent stages of the U-Boot start-up where a C runtime environment is needed. Its entry point is _main and is branched into from the target’s start.S file.</p><p>_main execution sequence is:</p><ol><li><p>Set up initial environment for calling board_init_f().<br>This environment only provides a stack and a place to store the GD (‘global data’) structure, both located in some readily available RAM (SRAM, locked cache…). In this context, VARIABLE global data, initialized or not (BSS), are UNAVAILABLE; only CONSTANT initialized data are available. GD should be zeroed before board_init_f() is called.</p></li><li><p>Call board_init_f().<br>This function prepares the hardware for execution from system RAM (DRAM, DDR…) As system RAM may not be available yet, , board_init_f() must use the current GD to store any data which must be passed on to later stages. These data include the relocation destination, the future stack, and the future GD location.</p></li><li><p>Set up intermediate environment where the stack and GD are the ones allocated by board_init_f() in system RAM, but BSS and initialized non-const data are still not available.</p></li><li><p>For U-Boot proper (not SPL), call relocate_code().<br>This function relocates U-Boot from its current location into the relocation destination computed by board_init_f().</p></li><li><p>Set up final environment for calling board_init_r().<br>This environment has BSS (initialized to 0), initialized non-const data (initialized to their intended value), and stack in system RAM. GD has retained values set by board_init_f().</p></li><li><p>For U-Boot proper (not SPL), some CPUs have some work left to do at this point regarding memory, so call c_runtime_cpu_setup.</p></li><li><p>Branch to board_init_r().</p></li></ol></blockquote><p>其程序流程图如下：</p><p><img src="https://pic.gaomf.store/U-Boot%20Stage1_2.svg" alt=""></p><p>全局变量<code>gd</code>是一个<code>struct global_data</code>类型的结构体，此结构体的定义位于<code>include/asm-generic/global_data.h</code>文件中。此结构体保存了初始化阶段需要用到的各种全局变量，大约有100个左右，相关说明如下：</p><blockquote><p>The following data structure is placed in some memory which is available very early after boot (like DPRAM on MPC8xx/MPC82xx, or some locked parts of the data cache) to allow for a minimum set of global variables during system initialization (until we have set up the memory controller so that we can use RAM).<br>Keep it <strong>SMALL</strong> and remember to set GENERATED_GBL_DATA_SIZE &gt; sizeof(gd_t)<br>Each architecture has its own private fields. For now all are private</p></blockquote><p>下面具体说明每一步的作用：</p><h3 id="Step-1-1-初始化SP寄存器"><a href="#Step-1-1-初始化SP寄存器" class="headerlink" title="Step 1.1 初始化SP寄存器"></a>Step 1.1 <strong>初始化SP寄存器</strong></h3><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ldr </span><span class="built_in">sp</span>, =(CONFIG_SYS_INIT_SP_ADDR)</span><br><span class="line"><span class="keyword">bic </span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#7</span></span><br></pre></td></tr></table></figure><p><code>CONFIG_SYS_INIT_SP_ADDR</code>在板子的配置文件<code>include/configs/smdk2440.h</code>中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_INIT_SP_ADDR(CONFIG_SYS_SDRAM_BASE + 0x1000 - GENERATED_GBL_DATA_SIZE)</span></span><br></pre></td></tr></table></figure><p><code>GENERATED_GBL_DATA_SIZE</code>是<code>struct global_data</code>按16字节对齐后的大小。可以看到，这里是使用了SDRAM开头4K部分来作为临时堆栈。</p><h3 id="Step-1-2-board-init-f-alloc-reserve"><a href="#Step-1-2-board-init-f-alloc-reserve" class="headerlink" title="Step 1.2 board_init_f_alloc_reserve"></a>Step 1.2 <strong>board_init_f_alloc_reserve</strong></h3><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span><span class="built_in">r0</span>, <span class="built_in">sp</span></span><br><span class="line"><span class="keyword">bl </span> <span class="keyword">board_init_f_alloc_reserve</span></span><br><span class="line"><span class="keyword">mov </span><span class="built_in">sp</span>, <span class="built_in">r0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ulong <span class="title">board_init_f_alloc_reserve</span><span class="params">(ulong top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* reserve GD (rounded up to a multiple of 16 bytes) */</span></span><br><span class="line">    top = rounddown(top-<span class="keyword">sizeof</span>(struct global_data), <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为<code>GD</code>结构体分配保留空间，16字节对齐。结构体的存储方式是从低地址向高地址生长，故此处返回的就是<code>gd</code>的基地址。</p><h3 id="Step-1-3-board-init-f-init-reserve"><a href="#Step-1-3-board-init-f-init-reserve" class="headerlink" title="Step 1.3 board_init_f_init_reserve"></a>Step 1.3 <strong>board_init_f_init_reserve</strong></h3><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span><span class="built_in">r9</span>, <span class="built_in">r0</span></span><br><span class="line"><span class="keyword">bl </span> <span class="keyword">board_init_f_init_reserve</span></span><br></pre></td></tr></table></figure><p>简化版的函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_f_init_reserve</span><span class="params">(ulong base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">global_data</span> *<span class="title">gd_ptr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> *ptr;</span><br><span class="line"></span><br><span class="line">    gd_ptr = (struct global_data *)base;</span><br><span class="line">    <span class="comment">/* zero the area */</span></span><br><span class="line">    <span class="keyword">for</span> (ptr = (<span class="keyword">int</span> *)gd_ptr; ptr &lt; (<span class="keyword">int</span> *)(gd_ptr + <span class="number">1</span>); )</span><br><span class="line">        *ptr++ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>gd</code>的基地址放到<code>r9</code>中保存起来，之后将刚刚分配的保留空间清零完成初始化。</p><h3 id="Step-2-board-init-f"><a href="#Step-2-board-init-f" class="headerlink" title="Step 2 board_init_f"></a>Step 2 <strong>board_init_f</strong></h3><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov </span><span class="built_in">r0</span>, <span class="number">#0</span></span><br><span class="line"><span class="keyword">bl </span> <span class="keyword">board_init_f</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_f</span><span class="params">(ulong boot_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gd-&gt;flags = boot_flags;</span><br><span class="line">    gd-&gt;have_console = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initcall_run_list(init_sequence_f))</span><br><span class="line">        hang();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>board_init_f()</code>函数主要是调用<code>initcall_run_list(init_sequence_f)</code>函数，而此函数的作用就是依次执行<code>init_sequence_f</code>中的各函数指针，去除错误处理、Debug信息输出等部分后，简化版的函数体很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initcall_run_list</span><span class="params">(<span class="keyword">const</span> <span class="keyword">init_fnc_t</span> init_sequence[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">init_fnc_t</span> *init_fnc_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) &#123;</span><br><span class="line">        (*init_fnc_ptr)();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看一下<code>init_fnc_t init_sequence_f[]</code>这个数组，<code>init_fnc_t</code>是一个是用<code>typedef</code>定义的函数指针类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">init_fnc_t</span>)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>init_sequence_f[]</code>数组中包含的就是需要执行的初始化函数列表，这里面的函数很多，<strong>这些函数的核心目的就是填充<code>gd</code>结构体</strong>。其中比较重要的有下面这些(<strong>省略了其中大部分函数</strong>)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">init_fnc_t</span> init_sequence_f[] = &#123;</span><br><span class="line">    board_early_init_f,</span><br><span class="line">    serial_init,        <span class="comment">/* serial communications setup */</span></span><br><span class="line">    console_init_f,     <span class="comment">/* stage 1 init of console */</span></span><br><span class="line">    display_options,    <span class="comment">/* say that we are here */</span></span><br><span class="line">    print_cpuinfo,      <span class="comment">/* display cpu info (and speed) */</span></span><br><span class="line">    dram_init,          <span class="comment">/* configure available RAM banks */</span></span><br><span class="line">    show_dram_config,</span><br><span class="line">    setup_dest_addr,</span><br><span class="line">    reserve_xxxxxx,</span><br><span class="line">    setup_reloc,</span><br><span class="line">    <span class="comment">// jump_to_copy,</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>U-Boot自带的SMDK2410配置中，PLL时钟配置是在<code>board_early_init_f</code>中完成的，不过在针对2440移植时将此部分代码移到了start.S文件中，故<code>board_early_init_f</code>中只包含了GPIO端口初始化；</p><p><code>serial_init</code>及<code>console_init_f</code>完成串口终端的初始化，在此之后串口终端才会有输出。</p><p><code>display_options</code>和<code>print_cpuinfo</code>就是U-Boot运行时串口最先输出的那段版本信息。</p><p><code>dram_init</code>：对于2440来说，因为之前已经初始化好了DRAM，此处只是将DRAM大小写入<code>gd</code>中，在<code>show_dram_config</code>中将SDRAM大小信息输出至控制台。</p><p><code>setup_dest_addr</code>中根据RAM的大小计算了重定位开始地址，将RAM顶端地址存放在<code>gd-&gt;relocaddr = gd-&gt;ram_top</code>中。</p><p><code>reserve_xxxxxx</code>依次计算重定位每一部分所需的RAM空间，并从<code>gd-&gt;relocaddr</code>中减去这部分空间，其中<code>reserve_uboot</code>是计算重定位U-Boot本身（.text + .bss）的地址；<code>reserve_global_data</code>是计算重定位<code>gd</code>的地址。从这里可以看出，<strong>重定位后的代码和数据位于RAM顶端</strong>。</p><p><code>setup_reloc</code>向<code>gd</code>中填入了重定位地址信息，并完成了<code>gd</code>本身的重定位，<strong><code>gd-&gt;reloc_off</code>就是在这里计算出来的，代表重定位地址偏移量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setup_reloc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    gd-&gt;reloc_off = gd-&gt;relocaddr - CONFIG_SYS_TEXT_BASE;</span><br><span class="line">    <span class="built_in">memcpy</span>(gd-&gt;new_gd, (<span class="keyword">char</span> *)gd, <span class="keyword">sizeof</span>(<span class="keyword">gd_t</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于其他平台来说，最后还有一步<code>jump_to_copy</code>，这里会实现代码跳转，也就是不会再返回此函数，不过对于ARM平台来说，是没有这一步的，执行完<code>init_sequence_f[]</code>中的函数后会返回到<code>board_init_f()</code>中，最后回到<code>_main</code>中继续执行后面的代码。</p><h3 id="Step-3-设置中间变量"><a href="#Step-3-设置中间变量" class="headerlink" title="Step 3 设置中间变量"></a>Step 3 <strong>设置中间变量</strong></h3><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">ldr </span><span class="built_in">sp</span>, [<span class="built_in">r9</span>, <span class="symbol">#GD_START_ADDR_SP</span>] <span class="comment">/* sp = gd-&gt;start_addr_sp */</span></span><br><span class="line">    <span class="keyword">bic </span><span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">#7</span>                  <span class="comment">/* 8-byte alignment for ABI compliance */</span></span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">r9</span>, [<span class="built_in">r9</span>, <span class="symbol">#GD_BD</span>]            <span class="comment">/* r9 = gd-&gt;bd */</span></span><br><span class="line">    <span class="keyword">sub </span><span class="built_in">r9</span>, <span class="built_in">r9</span>, <span class="symbol">#GD_SIZE</span>            <span class="comment">/* new GD is below bd */</span></span><br><span class="line">    <span class="keyword">adr </span><span class="built_in">lr</span>, here</span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">r0</span>, [<span class="built_in">r9</span>, <span class="symbol">#GD_RELOC_OFF</span>]     <span class="comment">/* r0 = gd-&gt;reloc_off */</span></span><br><span class="line">    <span class="keyword">add </span><span class="built_in">lr</span>, <span class="built_in">lr</span>, <span class="built_in">r0</span></span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">r0</span>, [<span class="built_in">r9</span>, <span class="symbol">#GD_RELOCADDR</span>]     <span class="comment">/* r0 = gd-&gt;relocaddr */</span></span><br><span class="line">    <span class="keyword">b </span>  relocate_code</span><br><span class="line"><span class="symbol">here</span>:</span><br><span class="line">    <span class="keyword">bl </span> relocate_vectors</span><br></pre></td></tr></table></figure><p>这里面用到的<code>gd</code>中的值都是在<code>board_early_init_f()</code>中设置好的，其中有几句很重要的语句：</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">adr </span><span class="built_in">lr</span>, here</span><br><span class="line"><span class="keyword">ldr </span><span class="built_in">r0</span>, [<span class="built_in">r9</span>, <span class="symbol">#GD_RELOC_OFF</span>]     <span class="comment">/* r0 = gd-&gt;reloc_off */</span></span><br><span class="line"><span class="keyword">add </span><span class="built_in">lr</span>, <span class="built_in">lr</span>, <span class="built_in">r0</span></span><br></pre></td></tr></table></figure><p><code>here</code>就是下面那个标号，此处将<code>here</code>的地址加上<code>gd-&gt;reloc_off</code>这个偏移量后存放到<code>lr</code>寄存器中，之后调用<code>b   relocate_code</code>命令返回后就会返回到<code>lr</code>寄存器中的地址处。<strong>这就实现了将代码拷贝到SDRAM后从新的重定位地址处接着运行的目的。</strong>这也就是源码中这一段注释的含义：</p><blockquote><p>Set up intermediate environment (new sp and gd) and call relocate_code(addr_moni). <strong>Trick here is that we’ll return ‘here’ but relocated.</strong></p></blockquote><p>设置好这些寄存器后调用<code>relocate_code</code>实现代码重定位。</p><h3 id="Step-4-relocate-code"><a href="#Step-4-relocate-code" class="headerlink" title="Step 4 relocate_code"></a>Step 4 <strong>relocate_code</strong></h3><p>位于<code>/arch/arm/lib/relocate.S</code>中，使用汇编完成，简化版的代码如下：</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ENTRY</span>(relocate_code)</span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">r1</span>, <span class="symbol">=__image_copy_start</span> <span class="comment">/* r1 &lt;- SRC &amp;__image_copy_start */</span></span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">r2</span>, <span class="symbol">=__image_copy_end</span>   <span class="comment">/* r2 &lt;- SRC &amp;__image_copy_end */</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">copy_loop</span>:</span><br><span class="line">    <span class="keyword">ldmia </span>  <span class="built_in">r1</span>!, &#123;<span class="built_in">r10</span>-<span class="built_in">r11</span>&#125;      <span class="comment">/* copy from source address [r1]    */</span></span><br><span class="line">    <span class="keyword">stmia </span>  <span class="built_in">r0</span>!, &#123;<span class="built_in">r10</span>-<span class="built_in">r11</span>&#125;      <span class="comment">/* copy to   target address [r0]    */</span></span><br><span class="line">    <span class="keyword">cmp </span><span class="built_in">r1</span>, <span class="built_in">r2</span>          <span class="comment">/* until source end address [r2]    */</span></span><br><span class="line">    <span class="keyword">blo </span>copy_loop</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bx </span> <span class="built_in">lr</span></span><br><span class="line"><span class="symbol">ENDPROC</span>(relocate_code)</span><br></pre></td></tr></table></figure><p>在这段代码中，使用<code>ldmia</code>及<code>stmia</code>指令，每次使用<code>r10</code>及<code>r11</code>两个寄存器进行复制，<strong>实现了将<code>__image_copy_start</code>及<code>__image_copy_end</code>中的代码复制到<code>gd-&gt;reloc_off</code>处的目的</strong>。</p><p>这里省略了<code>.rel.dyn</code>部分的重定位代码，这部分代码和以上代码差不多，只是还做了些额外处理。</p><p>最后调用<code>bx lr</code>返回，此时会进行状态切换后接着运行行下面的程序，不过此时运行的程序已是位于重定位的地址处了。</p><p>之后执行的是<code>bl  relocate_vectors</code>，这个实现的是中断向量表的重定位，具体就不展开了。在此之后还调用了<code>c_runtime_cpu_setup</code>，不过对于2440来说，这里没有做任何事情，可以跳过。</p><h3 id="Step-5-清零BSS段"><a href="#Step-5-清零BSS段" class="headerlink" title="Step 5 清零BSS段"></a>Step 5 <strong>清零BSS段</strong></h3><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">ldr </span><span class="built_in">r0</span>, <span class="symbol">=__bss_start</span>    <span class="comment">/* this is auto-relocated! */</span></span><br><span class="line">    <span class="keyword">ldr </span><span class="built_in">r1</span>, <span class="symbol">=__bss_end</span>      <span class="comment">/* this is auto-relocated! */</span></span><br><span class="line">    <span class="keyword">mov </span><span class="built_in">r2</span>, <span class="number">#0x00000000</span>     <span class="comment">/* prepare zero to clear BSS */</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">clbss_l</span>:</span><br><span class="line">    <span class="keyword">cmp </span><span class="built_in">r0</span>, <span class="built_in">r1</span>              <span class="comment">/* while not at end of BSS */</span></span><br><span class="line">    <span class="keyword">strlo </span>  <span class="built_in">r2</span>, [<span class="built_in">r0</span>]        <span class="comment">/* clear 32-bit BSS word */</span></span><br><span class="line">    <span class="keyword">addlo </span>  <span class="built_in">r0</span>, <span class="built_in">r0</span>, <span class="number">#4</span>      <span class="comment">/* move to next */</span></span><br><span class="line">    <span class="keyword">blo </span>clbss_l</span><br></pre></td></tr></table></figure><p>这一步建立C语言运行环境，实际上也就是清零BSS段，代码也很好懂，根据<code>__bss_start</code>及<code>__bss_end</code>的地址循环写入0即可。只是这有一个问题，注释中有说明：“this is auto-relocated!”，这说明<code>__bss_start</code>及<code>__bss_end</code>的地址已经是重定位后的新地址了，这是如何实现的呢？<code>__bss_start</code>及<code>__bss_end</code>的定义见本文最前面<code>arch/arm/lib/sections.c</code>中的代码，是两个长度为0的数组，估计是在<code>relocate_code</code>搬运代码过程中已经搬运了这两个0长度的代码了？这个问题还需要之后来仔细思考下。</p><h3 id="Step-6-board-init-r"><a href="#Step-6-board-init-r" class="headerlink" title="Step 6 board_init_r"></a>Step 6 <strong>board_init_r</strong></h3><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bl </span>coloured_LED_init</span><br><span class="line"><span class="keyword">bl </span>red_led_on</span><br><span class="line"><span class="comment">/* call board_init_r(gd_t *id, ulong dest_addr) */</span></span><br><span class="line"><span class="keyword">mov </span><span class="built_in">r0</span>, <span class="built_in">r9</span>                  <span class="comment">/* gd_t */</span></span><br><span class="line"><span class="keyword">ldr </span><span class="built_in">r1</span>, [<span class="built_in">r9</span>, <span class="symbol">#GD_RELOCADDR</span>] <span class="comment">/* dest_addr */</span></span><br><span class="line"><span class="keyword">ldr </span><span class="built_in">pc</span>, <span class="symbol">=board_init_r</span>   <span class="comment">/* this is auto-relocated! */</span></span><br></pre></td></tr></table></figure><p>在调用<code>board_init_r</code>前还调用了两个函数：<code>coloured_LED_init</code>及<code>red_led_on</code>，不过在SMDK2410的BSP文件中没有实现这两个函数，目前使用的是<code>common/board_f.c</code>中的空函数，相关函数还有下面这些：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment"> * Coloured LED functionality</span></span><br><span class="line"><span class="comment"> ************************************************************************</span></span><br><span class="line"><span class="comment"> * May be supplied by boards if desired</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__<span class="function">weak <span class="keyword">void</span> <span class="title">coloured_LED_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;</span><br><span class="line">__<span class="function">weak <span class="keyword">void</span> <span class="title">red_led_on</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;</span><br><span class="line">__<span class="function">weak <span class="keyword">void</span> <span class="title">red_led_off</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;</span><br><span class="line">__<span class="function">weak <span class="keyword">void</span> <span class="title">green_led_on</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;</span><br><span class="line">__<span class="function">weak <span class="keyword">void</span> <span class="title">green_led_off</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;</span><br><span class="line">__<span class="function">weak <span class="keyword">void</span> <span class="title">yellow_led_on</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;</span><br><span class="line">__<span class="function">weak <span class="keyword">void</span> <span class="title">yellow_led_off</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;</span><br><span class="line">__<span class="function">weak <span class="keyword">void</span> <span class="title">blue_led_on</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;</span><br><span class="line">__<span class="function">weak <span class="keyword">void</span> <span class="title">blue_led_off</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr><p>最后来看看<code>board_init_r()</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_r</span><span class="params">(<span class="keyword">gd_t</span> *new_gd, ulong dest_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initcall_run_list(init_sequence_r))</span><br><span class="line">        hang();</span><br><span class="line">    <span class="comment">/* NOTREACHED - run_main_loop() does not return */</span></span><br><span class="line">    hang();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initcall_run_list</code>函数在上面”2.board_init_f”小节中已经分析过了，就是依次执行传入数组中的各函数，此处传入了<code>init_sequence_r</code>，这就是Stage2的初始化函数列表。</p><p>至此，Stage1结束，开始执行Stage2的初始化流程。</p>]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UART协议时序总结</title>
      <link href="/2016/07/12/UART%E5%8D%8F%E8%AE%AE%E6%97%B6%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2016/07/12/UART%E5%8D%8F%E8%AE%AE%E6%97%B6%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>UART使用异步模式工作，不需要时钟信号，其一般格式为：<strong>起始位+数据位+校验位+停止位</strong>。其中起始位1位，数据位5~8位，校验位0或1位，停止位1、1.5或2位。不过最常用的格式是<strong>1位起始位、8位数据位、没有奇偶校验、1位停止位，简记为8/N/1</strong>。</p><p>8/N/1格式的时序图如下：</p><p><img src="https://pic.gaomf.store/UART%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt=""></p><a id="more"></a><p>空闲时数据线上规定为逻辑1。</p><p>开始传输数据时先发送起始位，规定为逻辑0，接收端会检测这个下降沿，以便之后开始采样接收数据。</p><p>起始位之后是数据位，规定<strong>先发送最低位，即LSB First</strong>。因为UART没有时钟信号，故使用波特率来确定每一位的长度，不过为保证检测的准确性，实际采样频率会高于波特率，一般每一位会进行若干次采样，取中间的采样值作为这一位的结果。</p><p>奇偶校验位一般不使用。</p><p>停止位一般使用1位，规定为逻辑1，除了表示传输结束外，停止位还可以起到时钟同步的作用。</p><p>需要注意的是，这里的逻辑0并不一定是0V，这与使用的电平标准有关。<strong>对于TTL电平而言，逻辑0是0V，逻辑1是高电平（一般为3.3V或5V）；对于RS-232电平而言，逻辑0是3V<del>15V，逻辑1是-3</del>-15V。</strong></p><p>除了TX、RX、GND信号外，UART中还会有诸如RTS、CTS等流控信号，因为用得不是很多，此处就不总结了。</p>]]></content>
      
      
      <categories>
          
          <category> 点滴之间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Small Protocol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编文件后缀.s与.S的区别</title>
      <link href="/2016/07/06/%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80.s%E4%B8%8E.S%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2016/07/06/%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80.s%E4%B8%8E.S%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>使用GCC（准确说是GCC调用了as汇编器）处理汇编代码时，汇编文件的后缀有两种：<code>.s</code>与<code>.S</code>。这两种文件都是汇编代码，其区别在于：</p><p><code>.s</code>格式的汇编文件中，<strong>只能包含纯粹的汇编代码</strong>，汇编器只对其进行汇编操作，没有预处理操作；<br><code>.S</code>格式的汇编文件中，<strong>还可以使用预处理命令</strong>，汇编器会先进行预处理，然后再进行汇编。</p><p>预处理命令以<code>#</code>开头，基本与C语言中的预处理命令相同，包括<code>#define</code>、<code>#include</code>、<code>#if</code>、<code>#endif</code>等。在U-Boot和Linux内核源码中，这些汇编预处理命令用得十分广泛。</p>]]></content>
      
      
      <categories>
          
          <category> 点滴之间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下查看编辑二进制文件</title>
      <link href="/2016/07/06/Linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E7%BC%96%E8%BE%91%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
      <url>/2016/07/06/Linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E7%BC%96%E8%BE%91%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>查看二进制文件：hexdump、<strong>hd</strong>、xxd<br>编辑二进制文件：<strong>vim + xxd</strong></p><a id="more"></a><h2 id="查看二进制文件"><a href="#查看二进制文件" class="headerlink" title="查看二进制文件"></a><strong>查看二进制文件</strong></h2><p>使用<code>hexdump</code>、<code>hd</code>或<code>xxd</code>都可以，其中最简单的是使用<code>hd</code>。<code>hd</code>相当于<code>hexdump -C</code>，使用如下格式显示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000  53 04 a0 e3 00 10 a0 e3  00 10 80 e5 00 10 e0 e3  |S...............|</span><br><span class="line">00000010  38 00 9f e5 00 10 80 e5  34 10 9f e5 34 00 9f e5  |8.......4...4...|</span><br><span class="line">00000020  00 10 80 e5 30 00 9f e5  30 10 9f e5 00 20 a0 e3  |....0...0.... ..|</span><br></pre></td></tr></table></figure><p>使用<code>xxd</code>可以更灵活的控制显示的格式，具体参数使用<code>man</code>查询即可。常用的有：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>-b</code></td><td>以二进制（0 &amp; 1）模式显示（默认为十六进制模式）</td></tr><tr><td><code>-e</code></td><td>按照小端序模式显示（默认为大端序）</td></tr><tr><td><code>-g n</code></td><td>每<code>n</code>个字节归为一组显示（默认为2）</td></tr><tr><td><code>-u</code></td><td>十六进制显示使用大写字母（默认为小写）</td></tr></tbody></table><h2 id="编辑二进制文件"><a href="#编辑二进制文件" class="headerlink" title="编辑二进制文件"></a><strong>编辑二进制文件</strong></h2><p>先使用<code>vim -b</code>以二进制的方式打开文件，之后执行以下命令将文件以16进制方式显示：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%!xxd -g <span class="number">1</span></span><br></pre></td></tr></table></figure><p>按正常修改文本文件的方法修改此文件，修改完成后使用</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:%</span>!xxd -r</span><br></pre></td></tr></table></figure><p>即可返回。此处<code>xxd</code>命令可以附加的参数与查看二进制文件时使用的<code>xxd</code>相同，可以使用各种显示方式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot DM9000网卡驱动提示&quot;could not establish link&quot;的解决方法</title>
      <link href="/2016/06/26/U-Boot%20DM9000%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E6%8F%90%E7%A4%BAcould%20not%20establish%20link%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2016/06/26/U-Boot%20DM9000%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E6%8F%90%E7%A4%BAcould%20not%20establish%20link%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>使用默认的DM9000网卡驱动进行网络操作时，好像都会提示”could not establish link”，而且感觉因此造成的延迟还很严重。在网上搜索了一下，解决方法是屏蔽<code>dm9000x.c</code>文件中下面这段代码：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dm9000_init</span><span class="params">(struct eth_device *dev, <span class="keyword">bd_t</span> *bd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不做修改</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">// 屏蔽掉这段代码</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(dm9000_phy_read(<span class="number">1</span>) &amp; <span class="number">0x20</span>)) &#123;<span class="comment">/* autonegation complete bit */</span></span><br><span class="line">        udelay(<span class="number">1000</span>);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">10000</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"could not establish link\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不做修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样完全可以正常工作，不仅不会提示”could not establish link”，而且响应速度也得到了很大的提升。不过这段代码的作用究竟是什么还不清楚，将来有空了可以来仔细研究下。</p>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot 2016.05 在S3C2440上的移植——杂项</title>
      <link href="/2016/06/26/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/"/>
      <url>/2016/06/26/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>这里总结一些移植过程中零碎的问题。</p><a id="more"></a><h2 id="解决-WARNING-Caches-not-enabled-提示"><a href="#解决-WARNING-Caches-not-enabled-提示" class="headerlink" title="解决 WARNING: Caches not enabled 提示"></a><strong>解决 WARNING: Caches not enabled 提示</strong></h2><p>启动过程中会有一条提示”WARNING: Caches not enabled”，警告未开启Cache。搜索这句提示，找到如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Default implementation of enable_caches()</span></span><br><span class="line"><span class="comment"> * Real implementation should be in platform code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__<span class="function">weak <span class="keyword">void</span> <span class="title">enable_caches</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"WARNING: Caches not enabled\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向上追踪函数的调用关系，可以找到是<code>initr_caches()</code>函数调用了<code>enable_caches()</code>。然而在<code>/board/samsung/smdk2440/smdk2440.c</code>中可以看到，<code>board_init()</code>函数会开启Cache的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">board_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    icache_enable();</span><br><span class="line">    dcache_enable();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就涉及到初始化顺序了，找到初始化序列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init_fnc_t</span> init_sequence_r[] = &#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    initr_caches,</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    board_init,<span class="comment">/* Setup chipselects */</span></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以很清楚的看到，<code>board_init()</code>函数会在<code>initr_caches()</code>函数后执行。这里有两种解决方案，一种是直接忽略<code>enable_caches()</code>；另一种是将<code>board_init()</code>中的缓存使能代码移到<code>enable_caches()</code>中，这里我采用了后一种方法。注释掉<code>board_init()</code>中的那两行代码，在<code>board/samsung/smdk2440/smdk2440.c</code>文件中加入以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_caches</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    icache_enable();</span><br><span class="line">    dcache_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为原来那个<code>enable_caches()</code>函数是使用<code>__weak</code>定义的，此处直接定义此函数即可，会覆盖掉原代码中的定义。修改完成后，编译运行，可以看到这个警告不再出现了。</p><h2 id="配置环境变量保存位置"><a href="#配置环境变量保存位置" class="headerlink" title="配置环境变量保存位置"></a><strong>配置环境变量保存位置</strong></h2><p>U-boot中使用<code>saveenv</code>命令可以保存设置的环境变量，存储位置可以在NOR Flash、NAND Flash或EEPROM中，此处我选择保存在NOR Flash中。具体的存储地址和空间大小由<code>smdk2440.h</code>文件中这几个宏决定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_IS_IN_FLASH</span></span><br><span class="line"><span class="comment">/* Use Last Sector */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_ADDR         (CONFIG_SYS_FLASH_BASE + 0x1F0000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_SIZE         0x10000    <span class="comment">/* 64KB */</span></span></span><br><span class="line"><span class="comment">/* allow to overwrite serial and ethaddr */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_ENV_OVERWRITE</span></span><br></pre></td></tr></table></figure><p><code>CONFIG_ENV_IS_IN_FLASH</code>表明使用NOR Flash，<code>CONFIG_ENV_ADDR</code>和<code>CONFIG_ENV_SIZE</code>即是起始地址和大小，这里选择了NOR Flash的最后一个扇区。设置的时候要注意不要把其他数据（如U-Boot本身的代码）给覆盖了就行。</p><h2 id="配置启动参数"><a href="#配置启动参数" class="headerlink" title="配置启动参数"></a><strong>配置启动参数</strong></h2><p>为了实现上电自动引导Linux内核，需要正确设置以下3个环境变量：<code>bootcmd</code>、<code>bootargs</code>、<code>machid</code>。</p><p><code>machid</code>为U-Boot传给Linux Kernel的机器ID，内核会根据这个ID选取对应的初始化文件对开发板进行初始化，在Linux Kernel的源代码<code>include/generated/mach-types.h</code>中可以找到Mini2440开发板的机器ID为1999(0x7CF)。所以将<code>machid</code>设置为7CF即可。</p><p><code>bootcmd</code>为使用boot或bootd命令引导系统时实际调用的命令，这个根据实际情况设定，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootcmd=nand read 30008000 100000 300000;bootm 30008000</span><br></pre></td></tr></table></figure><p>当设置了<code>bootcmd</code>后，启动时就会有读秒了，超过一段时间没有按键输入自动引导系统。环境变量<code>bootdelay</code>用于指定这段延迟时间的长度，单位是秒。</p><p><code>bootargs</code>为启动参数，具体的设置值有待之后研究Linux内核时再来分析，目前使用的设置是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootargs=noinitrd console=ttySAC0,115200 root=/dev/mtdblock3 rw rootfstype=jffs2 init=/linuxrc</span><br></pre></td></tr></table></figure><blockquote><p>移植好的U-Boot见<a href="https://github.com/g199209/U-Boot_201605_S3C2440" target="_blank" rel="noopener">我的Github项目</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在U-Boot中添加自定义命令以实现自动下载程序</title>
      <link href="/2016/06/26/%E5%9C%A8U-Boot%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/"/>
      <url>/2016/06/26/%E5%9C%A8U-Boot%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>U-Boot中通过NFS下载程序是一种很普遍的方式，然而下载程序的过程并不能只用一条命令实现。以下载到NOR Flash中为例，一般需要以下几步：</p><ol><li>通过NFS将文件下载到内存中；</li><li>解除NOR Flash写保护；</li><li>擦除NOR Flash；</li><li>写入NOR Flash。</li></ol><p>每一步都需要手动输入命令，十分麻烦，所以我们可以在U-Boot中添加一个自定义命令<code>download</code>，以实现一键全自动下载的目的。下面就来介绍一下实现方法。</p><a id="more"></a><h2 id="向U-Boot中添加命令"><a href="#向U-Boot中添加命令" class="headerlink" title="向U-Boot中添加命令"></a><strong>向U-Boot中添加命令</strong></h2><p>以U-Boot 2016.05为例，其绝大部分命令都位于<code>cmd/</code>文件夹中，可以选择一个简单点的文件打开看看，就可以看到命令接口的基本结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_mycmd</span><span class="params">(<span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Do Something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">U_BOOT_CMD(</span><br><span class="line">    mycmd, <span class="number">1</span>, <span class="number">1</span>, do_mycmd,</span><br><span class="line">    <span class="string">"short description"</span>,</span><br><span class="line">    <span class="string">"help"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中<code>do_mycmd()</code>函数就是命令的执行函数，它的名字可以是任意的，只是按照U-Boot惯例一般就叫做这种形式。此函数的<code>cmdfp</code>和<code>flag</code>两个参数是由U-Boot系统传入的和命令相关的一些信息，一般用不到，重点是后两个参数。<code>argc</code>是参数个数，至少为1，表示命令本身；<code>argv</code>就是具体传入的参数字符串数组。</p><p>这个一般的函数是如何和命令关联起来的呢？靠的就是<code>U_BOOT_CMD</code>这个宏。这里不详细分析此宏的实现机理，仅从应用的角度说明一下。<code>U_BOOT_CMD</code>的命令格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U_BOOT_CMD(name,maxargs,rep,cmd,usage,help)</span><br></pre></td></tr></table></figure><p>各参数的含义为：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>name</code></td><td>命令的名称，此处直接输入即可，不要用字符串<code>&quot;xxx&quot;</code>的形式</td></tr><tr><td><code>maxargs</code></td><td>命令的最大参数个数，至少为1，表示命令本身</td></tr><tr><td><code>rep</code></td><td>是否自动重复（为1的话下次直接按Enter键会重复执行此命令）</td></tr><tr><td><code>cmd</code></td><td>命令对应的响应函数，即之前的<code>do_mycmd()</code>函数，直接使用函数名</td></tr><tr><td><code>usage</code></td><td>简短的使用说明（字符串）</td></tr><tr><td><code>help</code></td><td>输入<code>help</code>后显示的较详细的帮助文档（字符串）</td></tr></tbody></table><p>按以上格式新建一个C源文件后，将其加入Makefile中编译即可。这个文件可以放在任何地方，不过<code>cmd/</code>文件夹中存放的是通用的命令，我们自己新加入的命令最好不要放在里面，而是放在<code>board/</code>中板子相关的文件夹里，比如<code>board/samsung/smdk2440/</code>。</p><p>如果需要灵活控制是否添加此命令，可加入条件编译，仿照U-Boot本身的做法定义以下宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CMD_MYCMD</span></span><br></pre></td></tr></table></figure><p>这个定义可以放在板子的头文件中，也可加入defconfig文件中。之后在Makefile文件中加入条件编译即可：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-<span class="variable">$(CONFIG_CMD_MYCMD)</span> += mycmd.o</span><br></pre></td></tr></table></figure><h2 id="运行特定命令"><a href="#运行特定命令" class="headerlink" title="运行特定命令"></a><strong>运行特定命令</strong></h2><p>要实现自动下载，需要使用一个命令代替一系列命令，这就要求能够在程序中自动运行特定命令。U-Boot提供了一个方便的接口函数来实现这一目的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Run a command using the selected parser.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param cmdCommand to run</span></span><br><span class="line"><span class="comment"> * @param flagExecution flags (CMD_FLAG_...)</span></span><br><span class="line"><span class="comment"> * @return 0 on success, or != 0 on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_command</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure><p>只需调用此函数即可运行特定的命令。</p><h2 id="自动下载程序"><a href="#自动下载程序" class="headerlink" title="自动下载程序"></a><strong>自动下载程序</strong></h2><p>最后给出完整版的自动下载程序的实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;command.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_download</span><span class="params">(<span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"param:\nu : U-Boot;\nl : Linux;\nf : File System.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> cmd_uboot[<span class="number">5</span>] = &#123;</span><br><span class="line">        <span class="string">"nfs 30000000 /home/gmf/nfs/u-boot.bin"</span>,</span><br><span class="line">        <span class="string">"protect off all"</span>,</span><br><span class="line">        <span class="string">"erase 0 +$filesize"</span>,</span><br><span class="line">        <span class="string">"cp.b 30000000 0 $filesize"</span>,</span><br><span class="line">        <span class="string">"reset"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> cmd_linux[<span class="number">4</span>] = &#123;</span><br><span class="line">        <span class="string">"nfs 30008000 /home/gmf/nfs/uImage"</span>,</span><br><span class="line">        <span class="string">"nand erase 60000 300000"</span>,</span><br><span class="line">        <span class="string">"nand write.jffs2 30008000 60000 300000"</span>,</span><br><span class="line">        <span class="string">"bootm 30008000"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> cmd_fs[<span class="number">4</span>] = &#123;</span><br><span class="line">        <span class="string">"nfs 32000000 /home/gmf/nfs/ramdisk.gz"</span>,</span><br><span class="line">        <span class="string">"nand erase 560000 $filesize"</span>,</span><br><span class="line">        <span class="string">"nand write.jffs2 32000000 560000 $filesize"</span>,</span><br><span class="line">        <span class="string">"bootd"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(*argv[<span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'U'</span>:</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n##########\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(cmd_uboot[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n##########\n"</span>);</span><br><span class="line">            run_command(cmd_uboot[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'l'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n##########\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(cmd_linux[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n##########\n"</span>);</span><br><span class="line">            run_command(cmd_linux[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'F'</span>:</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n##########\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(cmd_fs[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n##########\n"</span>);</span><br><span class="line">            run_command(cmd_fs[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">U_BOOT_CMD(</span><br><span class="line">    download,   <span class="number">2</span>,  <span class="number">1</span>,  do_download,</span><br><span class="line">    <span class="string">"Download File (Uboot, Linux or FS)"</span>,</span><br><span class="line">    <span class="string">" - Download File:\nu : U-Boot;\nl : Linux;\nf : File System.\n"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>此处实现了自动下载<code>u-boot.bin</code>文件、<code>uImage</code>文件和<code>ramdisk.gz</code>文件，分别输入<code>download u</code>、<code>download l</code>和<code>download f</code>即可。命令执行序列位于<code>cmd_uboot</code>、<code>cmd_linux</code>及<code>cmd_fs</code>数组中。此代码结构很好进行扩展，如要加入新的选项，仿照目前的结构添加即可。</p>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware虚拟机中嵌入式Linux开发环境网络配置</title>
      <link href="/2016/06/25/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/2016/06/25/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>嵌入式Linux开发中，主机一般在VMware上运行Ubuntu等桌面Linux系统，主机与板子之间通过网线连接，以实现文件挂载、通信等目的。此时我们希望Ubuntu系统既能正常访问互联网，又能和板子进行通信。解决方法是添加两块网卡，第一块使用NAT方式，第二块使用桥接方式桥接到有线网卡上。第一块网卡(eth0)用于上网，配置为DHCP自动获取地址；第二块网卡(eth1)用于和板子连接，配置为静态IP。这样就可以同时满足这两个需求了。</p><a id="more"></a><p>需要注意的是，二者的顺序最好就按照上述顺序添加，要是将eth0与eth1反过来，会导致默认情况下无法上网的。这是由于默认情况下的路由表是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gmf@gmf:/$ route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         192.168.175.2   0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">192.168.1.0     *               255.255.255.0   U     1      0        0 eth1</span><br><span class="line">192.168.175.0   *               255.255.255.0   U     1      0        0 eth0</span><br></pre></td></tr></table></figure><p><code>default</code>记录使用eth0，若eth0是通过桥接方式连接板子的，此时显然无法上网，不过这可以通过修改路由表来解决。关于<code>route</code>命令和路由表的详细说明，可参考：</p><blockquote><p><a href="http://linux.vbird.org/linux_server/0140networkcommand.php#route" target="_blank" rel="noopener">鳥哥的 Linux 私房菜 - 5.1.2 路由修改： route</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot 2016.05 在S3C2440上的移植（4）——DM9000网卡</title>
      <link href="/2016/06/25/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94DM9000%E7%BD%91%E5%8D%A1/"/>
      <url>/2016/06/25/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94DM9000%E7%BD%91%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[<p>SMDK2410中默认使用的网卡为CS8900，而实际开发板上使用的网卡为DM9000，故需要进行替换。U-Boot中已经提供了现成的DM9000驱动程序，所以这部分移植相对比较简单，只需要更改下配置文件即可。</p><a id="more"></a><p>打开<code>include/configs/smdk2440.h</code>文件，目前网卡部分的宏定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CS8900       <span class="comment">/* we have a CS8900 on-board */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CS8900_BASE  0x19000300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_CS8900_BUS16 <span class="comment">/* the Linux driver does accesses as shorts */</span></span></span><br></pre></td></tr></table></figure><p>将其修改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_DRIVER_DM9000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_DM9000_NO_SROM       <span class="comment">//not use the dm9000 eeprom</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_NET_RANDOM_ETHADDR   <span class="comment">//set the ethaddr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_LIB_RAND             <span class="comment">//random_ethadd need rand function</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_DM9000_BASE          0x20000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9000_IO                   CONFIG_DM9000_BASE      </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DM9000_DATA                 (CONFIG_DM9000_BASE + 4 ) <span class="comment">//data address</span></span></span><br></pre></td></tr></table></figure><p>网卡的初始化入口位于<code>board/samsung/smdk2440/smdk2440.c</code>文件中，在其中找到<code>board_eth_init()</code>函数，仿照现有的CS8900网卡的形式添加DM9000的初始化代码即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">board_eth_init</span><span class="params">(<span class="keyword">bd_t</span> *bis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CS8900</span></span><br><span class="line">    rc = cs8900_initialize(<span class="number">0</span>, CONFIG_CS8900_BASE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DM9000</span></span><br><span class="line">    rc = dm9000_initialize(bis);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，需要正确设置器件的IP地址、子网掩码等信息，相关宏定义位于<code>include/configs/smdk2440.h</code>文件中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_NETMASK      255.255.255.0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_IPADDR       192.168.1.77</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SERVERIP     192.168.1.11</span></span><br></pre></td></tr></table></figure><p>这里没有指定MAC地址，会使用一个随机MAC地址，而且运行时会提示下面这个警告：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: dm9000 (eth0) using random MAC address - 4a:0a:ab:7c:96:2f</span><br></pre></td></tr></table></figure><p>解决办法就是使用使用环境变量的方法指定一个MAC地址，具体操作方法见：<a href="/2016/05/30/U-Boot%E4%B8%ADIP%E5%9C%B0%E5%9D%80%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/">U-Boot中IP地址设置方法</a></p><p>上述修改完成后编译运行，使用<code>ping</code>命令检查网络是否可正常使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GMF@2440 # ping 192.168.1.11</span><br><span class="line">dm9000 i/o: 0x20000000, id: 0x90000a46 </span><br><span class="line">DM9000: running in 16 bit mode</span><br><span class="line">MAC: 4a:0a:ab:7c:96:2f</span><br><span class="line">could not establish link</span><br><span class="line">Using dm9000 device</span><br><span class="line">host 192.168.1.11 is alive</span><br></pre></td></tr></table></figure><p>这里ping的是主机虚拟机中的Ubuntu系统，可以看到连接是没有问题的。不过有一个需要注意的问题是，目前连上网线后在电脑端并不会显示已连接，而是显示：“网络电缆被拔出”，也就是和没插网线时是一样的。不过这不影响正常使用，这个问题的具体原因有待之后再来分析。</p><p>另外，此处的移植针对的是DM9000网卡，目前有些开发板使用的是DM9000A，这是两个不同的芯片，驱动程序是不兼容的，针对DM9000A还要修改DM9000的驱动才能正常使用。这个问题也留待将来再来分析解决。</p><blockquote><p>移植好的U-Boot见<a href="https://github.com/g199209/U-Boot_201605_S3C2440" target="_blank" rel="noopener">我的Github项目</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot 2016.05 在S3C2440上的移植（3）——NAND Flash</title>
      <link href="/2016/06/25/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94Nand%20Flash/"/>
      <url>/2016/06/25/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94Nand%20Flash/</url>
      
        <content type="html"><![CDATA[<p>移植完NOR Flash后需要移植NAND Flash，下面介绍一下移植过程。开发板上使用的NAND Flash型号为Samsung K9F2G08U0B，256M x 8 Bit NAND Flash芯片。</p><a id="more"></a><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a><strong>修改配置文件</strong></h2><p>打开<code>include/configs/smdk2440.h</code>文件，在其中找到NAND Flash配置部分，将其由2410的定义修改为2440的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--- a/include/configs/smdk2440.h</span><br><span class="line">+++ b/include/configs/smdk2440.h</span><br><span class="line">@@ <span class="number">-160</span>,<span class="number">8</span> +<span class="number">160</span>,<span class="number">8</span> @@</span><br><span class="line">  * NAND configuration</span><br><span class="line">  */</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMD_NAND</span></span><br><span class="line">-<span class="meta">#<span class="meta-keyword">define</span> CONFIG_NAND_S3C2410</span></span><br><span class="line">-<span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_S3C2410_NAND_HWECC</span></span><br><span class="line">+<span class="meta">#<span class="meta-keyword">define</span> CONFIG_NAND_S3C2440</span></span><br><span class="line">+<span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_S3C2440_NAND_HWECC</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_MAX_NAND_DEVICE     1</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_NAND_BASE           0x4E000000</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>NAND Flash的相关驱动代码位于<code>dirvers/mtd/nand/</code>下，打开其中的<code>Makefile</code>文件，仿照2410的写法添加2440的支持：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--- a/drivers/mtd/nand/Makefile</span><br><span class="line">+++ b/drivers/mtd/nand/Makefile</span><br><span class="line">@@ -<span class="number">63</span>,<span class="number">6</span> +<span class="number">63</span>,<span class="number">7</span> @@ obj-$(CONFIG_NAND_MXS) += mxs_nand.o</span><br><span class="line"> obj-$(CONFIG_NAND_NDFC) += ndfc.o</span><br><span class="line"> obj-$(CONFIG_NAND_PXA3XX) += pxa3xx_nand.o</span><br><span class="line"> obj-$(CONFIG_NAND_S3C2410) += s3c2410_nand.o</span><br><span class="line">+obj-$(CONFIG_NAND_S3C2440) += s3c2440_nand.o</span><br><span class="line"> obj-$(CONFIG_NAND_SPEAR) += spr_nand.o</span><br><span class="line"> obj-$(CONFIG_TEGRA_NAND) += tegra_nand.o</span><br><span class="line"> obj-$(CONFIG_NAND_OMAP_GPMC) += omap_gpmc.o</span><br></pre></td></tr></table></figure><p>以2410的配置为基础复制一份过来：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp s<span class="number">3</span><span class="keyword">c</span><span class="number">2410</span>_nand.<span class="keyword">c</span> s<span class="number">3</span><span class="keyword">c</span><span class="number">2440</span>_nand.<span class="keyword">c</span></span><br></pre></td></tr></table></figure><p>将其中的<code>S3C2410</code>全部替换为<code>S3C2440</code>，这样，针对S3C2440的配置文件就建立好了，下面就要针对2440来修改其中的内容。</p><h2 id="修改寄存器及时序定义"><a href="#修改寄存器及时序定义" class="headerlink" title="修改寄存器及时序定义"></a><strong>修改寄存器及时序定义</strong></h2><p>2440的NAND Flash控制器寄存器定义和2410的不一样，所以要先修改<code>s3c2440_nand.c</code>中的寄存器定义。关于2410与2440的详细区别及这些寄存器的具体用处，可参考<a href="http://blog.csdn.net/sui_yirufeng/article/details/9026261" target="_blank" rel="noopener">这篇文章</a>。</p><p>将原来寄存器定义全部删掉，改成下面这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* NFCONT Register */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2440_NFCONT_SECCL        (1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2440_NFCONT_MECCL        (1&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2440_NFCONT_INITECC      (1&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2440_NFCONT_nFCE         (1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2440_NFCONT_MODE         (1&lt;&lt;0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* NFCONF Register */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2440_NFCONF_TACLS(x)     ((x)&lt;&lt;12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2440_NFCONF_TWRPH0(x)    ((x)&lt;&lt;8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2440_NFCONF_TWRPH1(x)    ((x)&lt;&lt;4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADDR */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2440_ADDR_NALE           0x08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S3C2440_ADDR_NCLE           0x0C</span></span><br></pre></td></tr></table></figure><p>以上宏定义的值是根据2440的数据手册确定的，比如NFCONT寄存器的定义如下：<br><img src="https://pic.gaomf.store/20160624155451.png" alt=""></p><p>再来看时序设置，程序中有这么一段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_S3C24XX_CUSTOM_NAND_TIMING)</span></span><br><span class="line">    tacls  = CONFIG_S3C24XX_TACLS;</span><br><span class="line">    twrph0 = CONFIG_S3C24XX_TWRPH0;</span><br><span class="line">    twrph1 =  CONFIG_S3C24XX_TWRPH1;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    tacls = <span class="number">4</span>;</span><br><span class="line">    twrph0 = <span class="number">8</span>;</span><br><span class="line">    twrph1 = <span class="number">8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>故我们需要定义相关的一些宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Timing */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_S3C24XX_CUSTOM_NAND_TIMING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_S3C24XX_TACLS        2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_S3C24XX_TWRPH0       1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_S3C24XX_TWRPH1       0</span></span><br></pre></td></tr></table></figure><p>宏定义值根据Flash芯片数据手册确定，以开发板上使用的K9F2G08U0B为例，从它的数据手册中可以查到：<br><img src="https://pic.gaomf.store/20160624193738.png" alt=""></p><p>具体变量间的对应关系可对比其时序图得到，这里就不展开了。这几个量的值会影响读写速度，需要仔细对照数据手册才能确定最优值，以取得最佳的读写性能，充分发挥出硬件的潜力。</p><h2 id="修改初始化代码"><a href="#修改初始化代码" class="headerlink" title="修改初始化代码"></a><strong>修改初始化代码</strong></h2><p>根据终端输出信息<code>NAND:  0 MiB</code>，以<code>NAND:</code>为关键词搜索，之后跟踪代码执行流程即可找到NAND Flash初始化的入口为<code>nand_init_chip()</code>函数，这个函数的主要结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nand_init_chip</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (board_nand_init(nand))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nand_scan(mtd, maxchips))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    nand_register(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>board_nand_init()</code>函数用于对NAND Flash进行底层初始化；<code>nand_scan()</code>函数用于识别NAND Flash的型号及大小。仅有<code>board_nand_init()</code>函数是和底层硬件相关的，故移植时只需关注此函数即可，此函数也位于<code>s3c2440_nand.c</code>文件中。</p><p>只需修改NFCONF及NFCONT寄存器配置，将原有代码替换为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* NFCONF */</span></span><br><span class="line">cfg = S3C2440_NFCONF_TACLS(tacls);</span><br><span class="line">cfg |= S3C2440_NFCONF_TWRPH0(twrph0 - <span class="number">1</span>);</span><br><span class="line">cfg |= S3C2440_NFCONF_TWRPH1(twrph1 - <span class="number">1</span>);</span><br><span class="line">writel(cfg, &amp;nand_reg-&gt;nfconf);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NFCONT */</span></span><br><span class="line">cfg = S3C2440_NFCONT_SECCL;</span><br><span class="line">cfg |= S3C2440_NFCONT_MECCL;</span><br><span class="line">cfg |= S3C2440_NFCONT_MODE;</span><br><span class="line">cfg |= S3C2440_NFCONT_INITECC;</span><br><span class="line">writel(cfg,&amp;nand_reg-&gt;nfcont);</span><br></pre></td></tr></table></figure><h2 id="修改写入函数"><a href="#修改写入函数" class="headerlink" title="修改写入函数"></a><strong>修改写入函数</strong></h2><p>对于S3C24x0系列CPU，是通过<code>s3c24x0_hwcontrol()</code>函数实现命令和地址的写入的。然而2410的<code>s3c24x0_hwcontrol()</code>函数不直接适用于2440，需要稍微修改一下。主要就是将NFCONF寄存器替换为NFCONT寄存器。最后修改后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c24x0_hwcontrol</span><span class="params">(struct mtd_info *mtd, <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">int</span> ctrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nand_chip</span> *<span class="title">chip</span> = <span class="title">mtd</span>-&gt;<span class="title">priv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3c24x0_nand</span> *<span class="title">nand</span> = <span class="title">s3c24x0_get_base_nand</span>();</span></span><br><span class="line"></span><br><span class="line">    debug(<span class="string">"hwcontrol(): 0x%02x 0x%02x\n"</span>, cmd, ctrl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctrl &amp; NAND_CTRL_CHANGE) &#123;</span><br><span class="line">        ulong IO_ADDR_W = (ulong)nand;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(ctrl &amp; NAND_CLE))</span><br><span class="line">            IO_ADDR_W |= S3C2440_ADDR_NCLE;</span><br><span class="line">        <span class="keyword">if</span> (!(ctrl &amp; NAND_ALE))</span><br><span class="line">            IO_ADDR_W |= S3C2440_ADDR_NALE;</span><br><span class="line">        <span class="keyword">if</span> (cmd == NAND_CMD_NONE)</span><br><span class="line">            IO_ADDR_W = (ulong)&amp;nand-&gt;nfdata;</span><br><span class="line"></span><br><span class="line">        chip-&gt;IO_ADDR_W = (<span class="keyword">void</span> *)IO_ADDR_W;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ctrl &amp; NAND_NCE)</span><br><span class="line">            writel(readl(&amp;nand-&gt;nfcont) &amp; ~S3C2440_NFCONT_nFCE, &amp;nand-&gt;nfcont);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            writel(readl(&amp;nand-&gt;nfcont) | S3C2440_NFCONT_nFCE, &amp;nand-&gt;nfcont);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmd != NAND_CMD_NONE)</span><br><span class="line">        writeb(cmd, chip-&gt;IO_ADDR_W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别需要注意的是第15~16行，很多移植资料上都没有这两行，然而实际测试表明，不加这个判断会写入失败，因此一定要加上这条语句，这是因为在写完命令和地址后，一定还要把IO端口的地址重新设置为寄存器NFDATA。</p><h2 id="修改硬件ECC函数"><a href="#修改硬件ECC函数" class="headerlink" title="修改硬件ECC函数"></a><strong>修改硬件ECC函数</strong></h2><p>在<code>include/configs/smdk2440.h</code>文件中我们定义了宏<code>CONFIG_SYS_S3C2440_NAND_HWECC</code>，此时会启用硬件ECC功能。相关函数有三个：<code>s3c24x0_nand_enable_hwecc()</code>、<code>s3c24x0_nand_calculate_ecc()</code>、<code>s3c24x0_nand_correct_data()</code>，其中需要修改的函数只有<code>s3c24x0_nand_enable_hwecc()</code>，主要还是将NFCONF寄存器改为NFCONT寄存器。修改后的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s3c24x0_nand_enable_hwecc</span><span class="params">(struct mtd_info *mtd, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3c24x0_nand</span> *<span class="title">nand</span> = <span class="title">s3c24x0_get_base_nand</span>();</span></span><br><span class="line">    debug(<span class="string">"s3c24x0_nand_enable_hwecc(%p, %d)\n"</span>, mtd, mode);</span><br><span class="line">    writel(readl(&amp;nand-&gt;nfcont) | S3C2440_NFCONT_INITECC, &amp;nand-&gt;nfcont);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h2><p>修改完成后编译运行，从终端输出中可以看到已经正确识别出了NAND Flash容量：<code>NAND:  256 MiB</code>。要进一步测试NAND Flash是否可以正常使用可使用以下方法：</p><p>使用<code>nand info</code>命令可输出NAND Flash的基本信息，若正确识别出NAND Flash的话，就会显示类似下面这样的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GMF@2440 # nand info</span><br><span class="line"></span><br><span class="line">Device 0: nand0, sector size 128 KiB</span><br><span class="line">  Page size       2048 b</span><br><span class="line">  OOB size          64 b</span><br><span class="line">  Erase size    131072 b</span><br><span class="line">  subpagesize      512 b</span><br><span class="line">  options     0x40001008</span><br><span class="line">  bbt options 0x    8000</span><br></pre></td></tr></table></figure><p>之后测试Flash的读写是否正常，可将内存中的一段数据写入Flash中再读取回来，比较二者是否相同即可。</p><p>先擦除一段空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GMF@2440 # nand erase 0 0x80</span><br><span class="line"></span><br><span class="line">NAND erase: device 0 offset 0x0, size 0x80</span><br><span class="line">Erasing at 0x0 -- 100% complete.</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>读取内存开始部分的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GMF@2440 # md.l 30000000 20         </span><br><span class="line">30000000: ea0000be e59ff014 e59ff014 e59ff014    ................</span><br><span class="line">30000010: e59ff014 e59ff014 e59ff014 e59ff014    ................</span><br><span class="line">30000020: 00000060 000000c0 00000120 00000180    `....... .......</span><br><span class="line">30000030: 000001e0 00000240 000002a0 deadbeef    ....@...........</span><br><span class="line">30000040: 0badc0de e1a00000 e1a00000 e1a00000    ................</span><br><span class="line">30000050: e1a00000 e1a00000 e1a00000 e1a00000    ................</span><br><span class="line">30000060: e51fd028 e58de000 e14fe000 e58de004    (.........O.....</span><br><span class="line">30000070: e3a0d013 e169f00d e1a0e00f e1b0f00e    ......i.........</span><br></pre></td></tr></table></figure><p>将这些数据写入NAND Flash中，并回读写入的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GMF@2440 # nand write 30000000 0 80</span><br><span class="line"></span><br><span class="line">NAND write: device 0 offset 0x0, size 0x80</span><br><span class="line"> 128 bytes written: OK</span><br><span class="line">GMF@2440 # nand read 30000100 0 80</span><br><span class="line"></span><br><span class="line">NAND read: device 0 offset 0x0, size 0x80</span><br><span class="line"> 128 bytes read: OK</span><br><span class="line">GMF@2440 # md.l 30000100 20</span><br><span class="line">30000100: ea0000be e59ff014 e59ff014 e59ff014    ................</span><br><span class="line">30000110: e59ff014 e59ff014 e59ff014 e59ff014    ................</span><br><span class="line">30000120: 00000060 000000c0 00000120 00000180    `....... .......</span><br><span class="line">30000130: 000001e0 00000240 000002a0 deadbeef    ....@...........</span><br><span class="line">30000140: 0badc0de e1a00000 e1a00000 e1a00000    ................</span><br><span class="line">30000150: e1a00000 e1a00000 e1a00000 e1a00000    ................</span><br><span class="line">30000160: e51fd028 e58de000 e14fe000 e58de004    (.........O.....</span><br><span class="line">30000170: e3a0d013 e169f00d e1a0e00f e1b0f00e    ......i.........</span><br><span class="line">GMF@2440 # cmp.l 30000000 30000100 20</span><br><span class="line">Total of 32 word(s) were the same</span><br></pre></td></tr></table></figure><p>可以看到，二者完全相同，这说明U-Boot已完全支持了目标板上的NAND Flash。</p><blockquote><p>移植好的U-Boot见<a href="https://github.com/g199209/U-Boot_201605_S3C2440" target="_blank" rel="noopener">我的Github项目</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot 2016.05 在S3C2440上的移植（2）——NOR Flash</title>
      <link href="/2016/06/24/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94Nor%20Flash/"/>
      <url>/2016/06/24/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94Nor%20Flash/</url>
      
        <content type="html"><![CDATA[<p>移植好基本框架能运行后就可以开始移植NOR Flash了，需要让U-Boot支持实际硬件平台中的NOR Flash。开发板上使用的NOR Flash型号为EN29LV160B，1024K * 16-bit。U-Boot中默认没有对此型号NOR Flash的支持，故需要添加相关代码。</p><p>U-Boot对NOR Flash的检测有两种方法，使用Legacy方法进行检测和使用CFI接口进行检测，下面将分别介绍这两种方法。其中使用CFI接口进行检测应该是更好的方法，优先使用此方法。</p><a id="more"></a><h2 id="更改NOR-Flash扇区数宏定义"><a href="#更改NOR-Flash扇区数宏定义" class="headerlink" title="更改NOR Flash扇区数宏定义"></a><strong>更改NOR Flash扇区数宏定义</strong></h2><p>无论使用哪种检测方法，都需要先修改NOR Flash扇区数的定义，这个定义在<code>include/configs/smdk2440.h</code>文件中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SYS_MAX_FLASH_SECT   (35)</span></span><br></pre></td></tr></table></figure><p>具体值根据实际使用的NOR Flash确定，在数据手册中都会有说明的，以EN29LV160B为例：<br><img src="https://pic.gaomf.store/20160623105538.png" alt=""><br>可以算出其扇区数为35。</p><h2 id="两种检测方式的切换"><a href="#两种检测方式的切换" class="headerlink" title="两种检测方式的切换"></a><strong>两种检测方式的切换</strong></h2><p>NOR flash初始化函数<code>flash_init()</code>位于<code>drivers/mtd/cfi_flash.c</code>文件中，其中有这么一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!flash_detect_legacy(cfi_flash_bank_addr(i), i))</span><br><span class="line">    flash_get_size(cfi_flash_bank_addr(i), i);</span><br></pre></td></tr></table></figure><p>第一行调用<code>flash_detect_legacy()</code>函数使用Legacy方法进行检测，第二行调用<code>flash_get_size()</code>函数使用CFI方法进行检测。再来看<code>flash_detect_legacy()</code>函数的基本结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">flash_detect_legacy</span><span class="params">(<span class="keyword">phys_addr_t</span> base, <span class="keyword">int</span> banknum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">flash_info_t</span> *info = &amp;flash_info[banknum];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (board_flash_get_legacy(base, banknum, info)) &#123;</span><br><span class="line">        <span class="comment">// 使用legacy方法进行检测</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* use CFI */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看到，使用哪种检测方法由<code>board_flash_get_legacy()</code>函数的返回值确定，如果此函数返回1，使用Legacy方法；返回0则使用CFI方法。<code>board_flash_get_legacy()</code>函数是和具体硬件平台相关的，故它位于<code>board\samsung\smdk2440\smdk2440.c</code>文件中。从SMDK2410移植过来的默认版本为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Hardcoded flash setup:</span></span><br><span class="line"><span class="comment"> * Flash 0 is a non-CFI AMD AM29LV800BB flash.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ulong <span class="title">board_flash_get_legacy</span><span class="params">(ulong base, <span class="keyword">int</span> banknum, <span class="keyword">flash_info_t</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    info-&gt;portwidth = FLASH_CFI_16BIT;</span><br><span class="line">    info-&gt;chipwidth = FLASH_CFI_BY16;</span><br><span class="line">    info-&gt;interface = FLASH_CFI_X16;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要使用Legacy方法进行检测，直接使用这段代码就可以；如果要改为使用CFI方式进行检测，将返回值改为0即可。因为实际使用的EN29LV160B与AM29LV800BB的接口方式是一样的，故其他代码无需修改，不过亦可修改下函数注释，说明一下板子实际使用的NOR Flash型号等。</p><h2 id="Legacy检测"><a href="#Legacy检测" class="headerlink" title="Legacy检测"></a><strong>Legacy检测</strong></h2><p>使用Legacy方法进行检测的基本步骤如下：</p><ol><li>依次使用AMD及Intel标准去读取Flash的厂商ID及器件ID；</li><li>根据读取到的ID查找现有的器件列表，从而获得Flash更详细的信息。</li></ol><p>从中可以看到，移植的关键就是要添加所使用的Flash芯片的配置文件。</p><p>EON公司的厂商宏定义已经存在，位于<code>include\flash.h</code>中，不需要更改，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EON_ALT_MANU0x001C001C<span class="comment">/* EON     manuf. ID in D23..D16, D7..D0 */</span></span></span><br></pre></td></tr></table></figure><p>EN29LV160B这个型号的NOR Flash不存在，需要添加相应的宏定义，可添加在EN29LV040A的宏定义下方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* EON */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EN29LV040A  0x004F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EN29LV160B  0x2249</span></span><br></pre></td></tr></table></figure><p>具体宏定义的值可参考数据手册，其中有对Device ID的描述：<br><img src="https://pic.gaomf.store/20160623100634.png" alt=""></p><p>最后找到<code>drivers/mtd/jedec_flash.c</code>文件，需要在<code>jedec_table</code>这个数组中添加此型号NOR Flash的结构体，此数组会在<code>jedec_flash_match()</code>函数中被调用，此函数代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * match jedec ids against table. If a match is found, fill flash_info entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jedec_flash_match</span><span class="params">(<span class="keyword">flash_info_t</span> *info, ulong base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ulong mask = <span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="keyword">if</span> (info-&gt;chipwidth == <span class="number">1</span>)</span><br><span class="line">        mask = <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(jedec_table); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((jedec_table[i].mfr_id &amp; mask) == (info-&gt;manufacturer_id &amp; mask) &amp;&amp;</span><br><span class="line">            (jedec_table[i].dev_id &amp; mask) == (info-&gt;device_id &amp; mask)) &#123;</span><br><span class="line">            fill_info(info, &amp;jedec_table[i], base);</span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其中会将<code>jedec_table</code>成员的<code>mfr_id</code>、<code>dev_id</code>与读取到的<code>manufacturer_id</code>、<code>device_id</code>进行对比，若相同者调用<code>fill_info()</code>函数填充<code>info</code>结构体中的其它信息。</p><p>找到<code>jedec_table</code>的定义，这是一个数组，其中每个元素都是一个<code>amd_flash_info</code>类型的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">amd_flash_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> __u16 mfr_id;</span><br><span class="line">    <span class="keyword">const</span> __u16 dev_id;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> DevSize;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> NumEraseRegions;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> CmdSet;</span><br><span class="line">    <span class="keyword">const</span> __u8 uaddr[<span class="number">4</span>];<span class="comment">/* unlock addrs for 8, 16, 32, 64 */</span></span><br><span class="line">    <span class="keyword">const</span> ulong regions[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可仿照已有配置格式添加EN29LV160B的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    .mfr_id     = (u16)EON_ALT_MANU,</span><br><span class="line">    .dev_id     = EN29LV160B,</span><br><span class="line">    .name       = <span class="string">"EON EN29LV160B"</span>,</span><br><span class="line">    .uaddr      = &#123;</span><br><span class="line">        [<span class="number">1</span>] = MTD_UADDR_0x0555_0x02AA <span class="comment">/* x16 */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    .DevSize    = SIZE_2MiB,</span><br><span class="line">    .CmdSet     = CFI_CMDSET_AMD_LEGACY,</span><br><span class="line">    .NumEraseRegions    = <span class="number">4</span>,</span><br><span class="line">    .regions    = &#123;</span><br><span class="line">        ERASEINFO(<span class="number">0x04000</span>, <span class="number">1</span>),</span><br><span class="line">        ERASEINFO(<span class="number">0x02000</span>, <span class="number">2</span>),</span><br><span class="line">        ERASEINFO(<span class="number">0x08000</span>, <span class="number">1</span>),</span><br><span class="line">        ERASEINFO(<span class="number">0x10000</span>, <span class="number">31</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>下面对其中每一个字段的含义进行说明：</p><table><thead><tr><th>字段</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td><code>.mfr_id</code></td><td>制造商ID</td><td>EON公司的宏定义已经存在，直接使用</td></tr><tr><td><code>.dev_id</code></td><td>器件型号ID</td><td>之前已经添加了此宏定义</td></tr><tr><td><code>.name</code></td><td>器件名称字符串</td><td>主要用于显示</td></tr><tr><td><code>.uaddr</code></td><td>Unlock Address</td><td>发送命令时需要写入的地址，下面详细说明</td></tr><tr><td><code>.DevSize</code></td><td>器件容量</td><td>从已有的宏定义中选择一个正确的即可</td></tr><tr><td><code>.CmdSet</code></td><td>命令集</td><td>具体有哪些可能的选择还不太清楚，这里选择了AMD兼容命令集</td></tr><tr><td><code>.NumEraseRegions</code></td><td>扇区种类</td><td>指定有几类不同大小的扇区</td></tr><tr><td><code>.regions</code></td><td>扇区分配情况</td><td>下面详细说明</td></tr></tbody></table><p><code>.uaddr</code> 这个字段是一个数组，分别用于存放8位、16位、32位访问时的地址，这里只需要写入16位访问时的地址即可。地址使用了枚举的形式，有以下一些选择：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Unlock address sets for AMD command sets.</span></span><br><span class="line"><span class="comment"> * Intel command sets use the MTD_UADDR_UNNECESSARY.</span></span><br><span class="line"><span class="comment"> * Each identifier, except MTD_UADDR_UNNECESSARY, and</span></span><br><span class="line"><span class="comment"> * MTD_UADDR_NO_SUPPORT must be defined below in unlock_addrs[].</span></span><br><span class="line"><span class="comment"> * MTD_UADDR_NOT_SUPPORTED must be 0 so that structure</span></span><br><span class="line"><span class="comment"> * initialization need not require initializing all of the</span></span><br><span class="line"><span class="comment"> * unlock addresses for all bit widths.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> uaddr &#123;</span><br><span class="line">    MTD_UADDR_NOT_SUPPORTED = <span class="number">0</span>,<span class="comment">/* data width not supported */</span></span><br><span class="line">    MTD_UADDR_0x0555_0x02AA,</span><br><span class="line">    MTD_UADDR_0x0555_0x0AAA,</span><br><span class="line">    MTD_UADDR_0x5555_0x2AAA,</span><br><span class="line">    MTD_UADDR_0x0AAA_0x0555,</span><br><span class="line">    MTD_UADDR_DONT_CARE,<span class="comment">/* Requires an arbitrary address */</span></span><br><span class="line">    MTD_UADDR_UNNECESSARY,<span class="comment">/* Does not require any address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从名称上就可以看出其意义，选用哪种根据数据手册确定；</p><p><code>.NumEraseRegions</code>、<code>.regions</code>这两个参数指定了Flash芯片的扇区配置情况，其中<code>.NumEraseRegions</code>指定有几类不同大小的扇区，<code>.regions</code>指定每一类扇区的大小及个数。从<code>amd_flash_info</code>结构体的定义中可以看到，<code>.regions</code>是一个数组，且其大小默认设置为了6，如果扇区类型过多（一般不会出现），可修改此数组大小即可。</p><p>再来看一下<code>ERASEINFO</code>，这是一个宏，其宏定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERASEINFO(size,blocks) (size&lt;&lt;8)|(blocks-1)</span></span><br></pre></td></tr></table></figure><p>其意义在于使用一个<code>ulong</code>类型的整数同时表示扇区大小及扇区个数。</p><p><code>.NumEraseRegions</code>与<code>.regions</code>配合就可以确定每一个扇区的起始地址及器件的容量，下面就来分析下这一过程。这一部分代码位于<code>fill_info()</code>函数中，以下是<code>fill_info()</code>函数的精简改写版，仅保留了计算扇区部分最核心的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fill_info</span><span class="params">(<span class="keyword">flash_info_t</span> *info, <span class="keyword">const</span> struct amd_flash_info *jedec_entry, ulong base)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 省略之前代码</span></span><br><span class="line"></span><br><span class="line">    sect_cnt = <span class="number">0</span>;</span><br><span class="line">    total_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; jedec_entry-&gt;NumEraseRegions; i++) &#123;</span><br><span class="line">        ulong erase_region_size = jedec_entry-&gt;regions[i] &gt;&gt; <span class="number">8</span>;</span><br><span class="line">        ulong erase_region_count = (jedec_entry-&gt;regions[i] &amp; <span class="number">0xff</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        total_size += erase_region_size * erase_region_count;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; erase_region_count; j++) &#123;</span><br><span class="line">            info-&gt;start[sect_cnt] = base;</span><br><span class="line">            base += (erase_region_size);</span><br><span class="line">            sect_cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    info-&gt;sector_count = sect_cnt;</span><br><span class="line">    info-&gt;size = total_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第7<del>17行的循环遍历<code>NumEraseRegions</code>，依次处理每一类扇区；第8、9行获取<code>erase_region_size</code>及<code>erase_region_count</code>，这一过程就是<code>ERASEINFO</code>宏的逆过程；第12</del>16行依次循环处理每一个扇区，计算各扇区的起始地址，并计算总的扇区数。</p><p>分析清楚了扇区的计算方法后结构体中的<code>.regions</code>部分该如何编写就很清楚了，参考数据手册中的地址分配表即可写出所需的代码。</p><p>最后编译下载运行，可以看到已经正确识别出了Flash的容量。</p><h2 id="CFI检测"><a href="#CFI检测" class="headerlink" title="CFI检测"></a><strong>CFI检测</strong></h2><p>使用Legacy方法进行检测相当于要自己手动指定Flash的信息，不是很灵活，那是否可以自动检测Flash信息呢？答案是可以的，就是使用CFI方法进行检测。CFI是一种通用的接口规范，关于其详细说明可参考Cypress公司的<a href="http://www.spansion.com/Support/Application%20Notes/Quick_Guide_to_CFI_AN.pdf" target="_blank" rel="noopener">这份文档</a>。按上面的说明将<code>board_flash_get_legacy()</code>函数的返回值改为0即可启用CFI检测，之后不用做任何配置，直接编译运行即可，极为简单方便，而且可以自动适配不同型号的Flash。<br>在两块不同的板子上测试了CFI方法，结果表明，都能正确识别出Flash，这说明CFI方法具有很好的适应性。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h2><p>要测试NOR Flash是否正常工作可使用以下方法：</p><p>使用<code>flinfo</code>命令可输出Flash的基本信息，若成功识别了Flash后，就会显示正确的信息。使用Legacy方式进行检测会输出类似这样的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GMF@2440 # flinfo</span><br><span class="line"></span><br><span class="line">Bank # 1: EON EN29LV160B flash (16 x 16)  Size: 2 MB in 35 Sectors</span><br><span class="line">  AMD Legacy command set, Manufacturer ID: 0x1C, Device ID: 0x2249</span><br><span class="line">  Erase timeout: 30000 ms, write timeout: 100 ms</span><br><span class="line"></span><br><span class="line">  Sector Start Addresses:</span><br><span class="line">  00000000   RO   00004000   RO   00006000   RO   00008000   RO   00010000   RO </span><br><span class="line">  00020000   RO   00030000   RO   00040000   RO   00050000   RO   00060000   RO </span><br><span class="line">  00070000   RO   00080000        00090000        000A0000        000B0000      </span><br><span class="line">  000C0000        000D0000        000E0000        000F0000        00100000      </span><br><span class="line">  00110000        00120000        00130000        00140000        00150000      </span><br><span class="line">  00160000        00170000        00180000        00190000        001A0000      </span><br><span class="line">  001B0000        001C0000        001D0000        001E0000        001F0000</span><br></pre></td></tr></table></figure><p>使用CFI方式进行检测则会输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GMF@2440 # flinfo</span><br><span class="line"></span><br><span class="line">Bank # 1: CFI conformant flash (16 x 16)  Size: 2 MB in 35 Sectors</span><br><span class="line">  AMD Standard command set, Manufacturer ID: 0x1C, Device ID: 0x2249</span><br><span class="line">  Erase timeout: 16384 ms, write timeout: 1 ms</span><br><span class="line"></span><br><span class="line">  Sector Start Addresses:</span><br><span class="line">  00000000   RO   00004000   RO   00006000   RO   00008000   RO   00010000   RO </span><br><span class="line">  00020000   RO   00030000   RO   00040000   RO   00050000   RO   00060000   RO </span><br><span class="line">  00070000   RO   00080000        00090000        000A0000        000B0000      </span><br><span class="line">  000C0000        000D0000        000E0000        000F0000        00100000      </span><br><span class="line">  00110000        00120000        00130000        00140000        00150000      </span><br><span class="line">  00160000        00170000        00180000        00190000        001A0000      </span><br><span class="line">  001B0000        001C0000        001D0000        001E0000        001F0000</span><br></pre></td></tr></table></figure><hr><p>之后测试Flash的读写是否正常，可将内存中的一段数据写入Flash中再读取回来，比较二者是否相同即可。</p><p>先擦除最后一个扇区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GMF@2440 # erase 1:34      </span><br><span class="line">Erase Flash Sectors 34-34 in Bank # 1 </span><br><span class="line">. done</span><br><span class="line">GMF@2440 # md.l 001F0000 20</span><br><span class="line">001f0000: ffffffff ffffffff ffffffff ffffffff    ................</span><br><span class="line">001f0010: ffffffff ffffffff ffffffff ffffffff    ................</span><br><span class="line">001f0020: ffffffff ffffffff ffffffff ffffffff    ................</span><br><span class="line">001f0030: ffffffff ffffffff ffffffff ffffffff    ................</span><br><span class="line">001f0040: ffffffff ffffffff ffffffff ffffffff    ................</span><br><span class="line">001f0050: ffffffff ffffffff ffffffff ffffffff    ................</span><br><span class="line">001f0060: ffffffff ffffffff ffffffff ffffffff    ................</span><br><span class="line">001f0070: ffffffff ffffffff ffffffff ffffffff    ................</span><br></pre></td></tr></table></figure><p>读取内存开始部分的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GMF@2440 # md.l 30000000 20</span><br><span class="line">30000000: 7effffdb defb5bbf dbf6fafa efbbffdf    ...~.[..........</span><br><span class="line">30000010: 7f5f5e5a fcfebc5d feff7f7f d95edfff    Z^_.].........^.</span><br><span class="line">30000020: def8feff fbf77d7e fbdf5e5f f3dabf6b    ....~&#125;.._^..k...</span><br><span class="line">30000030: ffde7eff debbfaf7 fbdfdfda fbbe7b7b    .~..........&#123;&#123;..</span><br><span class="line">30000040: fffbd1bf 7fdffddf 4bffd7da febfdb5f    ...........K_...</span><br><span class="line">30000050: 7f5b7aff fedffffa 5affeb7f d7df7fde    .z[........Z....</span><br><span class="line">30000060: 5fff5afa 7fdeeeda fbbfebdb 5f4fddff    .Z._..........O_</span><br><span class="line">30000070: fc7e7ffe 5bfdda7e ff7bdbfb b7fffbfa    ..~.~..[..&#123;.....</span><br></pre></td></tr></table></figure><p>将这些数据写入Flash的最后一个扇区，并回读写入的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GMF@2440 # cp.l 30000000 001F0000 20</span><br><span class="line">Copy to Flash... 9....8....7....6....5....4....3....2....1..done</span><br><span class="line">GMF@2440 # md.l 001F0000 20         </span><br><span class="line">001f0000: 7effffdb defb5bbf dbf6fafa efbbffdf    ...~.[..........</span><br><span class="line">001f0010: 7f5f5e5a fcfebc5d feff7f7f d95edfff    Z^_.].........^.</span><br><span class="line">001f0020: def8feff fbf77d7e fbdf5e5f f3dabf6b    ....~&#125;.._^..k...</span><br><span class="line">001f0030: ffde7eff debbfaf7 fbdfdfda fbbe7b7b    .~..........&#123;&#123;..</span><br><span class="line">001f0040: fffbd1bf 7fdffddf 4bffd7da febfdb5f    ...........K_...</span><br><span class="line">001f0050: 7f5b7aff fedffffa 5affeb7f d7df7fde    .z[........Z....</span><br><span class="line">001f0060: 5fff5afa 7fdeeeda fbbfebdb 5f4fddff    .Z._..........O_</span><br><span class="line">001f0070: fc7e7ffe 5bfdda7e ff7bdbfb b7fffbfa    ..~.~..[..&#123;.....</span><br><span class="line">GMF@2440 # cmp.l 30000000 001F0000 20</span><br><span class="line">Total of 32 word(s) were the same</span><br></pre></td></tr></table></figure><p>可以看到，二者完全相同，这说明U-Boot已完全支持了目标板上的NOR Flash。</p><blockquote><p>移植好的U-Boot见<a href="https://github.com/g199209/U-Boot_201605_S3C2440" target="_blank" rel="noopener">我的Github项目</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nor Flash中的启动扇区（Boot Sector, Boot Block）</title>
      <link href="/2016/06/23/Nor%20Flash%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8%E6%89%87%E5%8C%BA%EF%BC%88Boot%20Sector,%20Boot%20Block%EF%BC%89/"/>
      <url>/2016/06/23/Nor%20Flash%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8%E6%89%87%E5%8C%BA%EF%BC%88Boot%20Sector,%20Boot%20Block%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在Nor Flash中，有个启动扇区（Boot Sector，有时也被称为启动块）的概念，这个概念应该是只针对Nor Flash的，因为Nand Flash无法直接寻址，故Nand Flash中是没有Boot Sector的。</p><p>一个Nor Flash一般被分为若干块（Block）<strong>或</strong>若干扇区（Sector），这应该只是不同厂家用的名字不同，并不存在一个Block中包含若干Sector的说法。<strong>这些扇区的大小一般并不相同，通常情况下会配置为大量大容量扇区加上少量小容量扇区的结构，这些小扇区就被称之为启动扇区。</strong></p><a id="more"></a><p>这样设计是考虑到小容量扇区的擦写速度比较快，而且一般可以对其进行写保护，故可用其存放Bootloader及其他一些用户配置数据。实际上可以有多个小扇区，这些小扇区中具体哪一个是启动扇区，还是都是启动扇区，这一问题并没有明确的说法，也无需纠结于此。</p><p>根据启动扇区的地址不同，可分为两大类：Top Boot &amp; Bottom Boot。<strong>Top Boot是指Boot Sector位于最高地址处；Bottom Boot是指Boot Sector位于最低地址处，</strong>一般同一型号的Nor Flash都会同时提供这两个版本，除了地址分配的差异外，其它的主要参数二者应该完全相同。</p><p>一张比较清晰的对比图如下：<br><img src="https://pic.gaomf.store/ZnJvbT1jc2RuJnVybD13WndwbUwyQUROMElUTTFFek53Z0RNdklUWnNsbVp3VjNMbjlHYmk5Q2RsNW1MNGxtYjFGbWJwaDJZdWNXYnBkMmJzSjJMdm9EYzBSSGE.jpg" alt=""></p><p>下面以AMD公司的Am29LV160D为例来具体看看这个问题。</p><p>Am29LV160D可配置为2M * 8-Bit或1M * 16-Bit，这个是通过一个引脚电平来确定的，下面仅讨论1M * 16-Bit的配置。在此配置下，Am29LV160D被分为35个扇区：</p><ul><li>1个8Kword扇区</li><li>2个4Kwork扇区</li><li>1个16Kword扇区</li><li>31个32Kword扇区</li></ul><p>这些扇区中，前面那4个扇区就是Boot Sector。AMD公司同时提供了Top Boot和Bottom Boot两种芯片，见下图：<br><img src="https://pic.gaomf.store/20160623005443.png" alt=""></p><p>对于Top Boot的器件来说，其扇区分配如下：<br><img src="https://pic.gaomf.store/20160623005627.png" alt=""><br>可以看到，其中小容量扇区被安排到了最高地址处，即最后几个扇区。</p><p>对于Bottom Boot的器件来说，其扇区分配如下：<br><img src="https://pic.gaomf.store/20160623005756.png" alt=""><br>可以看到，其中小容量扇区被安排到了最低地址处，即最前几个扇区。</p><hr><p>不过实际上，像U-Boot这类Bootloader的体积一般都会超过100KByte的，此时显然无法只用启动扇区保存，所以说这时候启动扇区就仅仅只是个名字，使用时也无需特别关注的。不过Top Boot和Bottom Boot器件的器件ID等可能会有所区别，使用时需要注意一下。</p>]]></content>
      
      
      <categories>
          
          <category> 点滴之间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串口终端picocom的使用</title>
      <link href="/2016/06/22/%E4%B8%B2%E5%8F%A3%E7%BB%88%E7%AB%AFpicocom%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/06/22/%E4%B8%B2%E5%8F%A3%E7%BB%88%E7%AB%AFpicocom%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Linux下的串口终端程序主要有这几个：minicom、kermit、picocom。其中用的最多的应该是minicom，不过picocom最为简单易用，从其名字pico-com上也可以看出，这是一个比mini-com更精简的串口终端，不过其功能足够满足大多数时候的需求。</p><p>使用时，指定波特率和串口设备文件即可打开终端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo picocom -b 115200 /dev/ttyUSB0</span><br></pre></td></tr></table></figure><a id="more"></a><p>一般情况下，USB转串口的名字都是 <code>ttyUSB*</code>，需要注意的是，<strong>必须使用<code>sudo</code>命令或以root的身份运行picocom</strong>，这是由于<code>ttyUSB*</code>设备的权限一般都是660，普通用户没有读写权限。</p><p>成功打开后会显示一些基本信息，并进入正常终端模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">picocom v1.7</span><br><span class="line"></span><br><span class="line">port is        : /dev/ttyUSB0</span><br><span class="line">flowcontrol    : none</span><br><span class="line">baudrate is    : 115200</span><br><span class="line">parity is      : none</span><br><span class="line">databits are   : 8</span><br><span class="line">escape is      : C-a</span><br><span class="line">local echo is  : no</span><br><span class="line">noinit is      : no</span><br><span class="line">noreset is     : no</span><br><span class="line">nolock is      : no</span><br><span class="line">send_cmd is    : sz -vv</span><br><span class="line">receive_cmd is : rz -vv</span><br><span class="line">imap is        : </span><br><span class="line">omap is        : </span><br><span class="line">emap is        : crcrlf,delbs,</span><br><span class="line"></span><br><span class="line">Terminal ready</span><br></pre></td></tr></table></figure><p>如要退出，先按<code>Ctrl + A</code>进入转义模式，再按<code>Ctrl + Q</code>即可正常退出。</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jlink为S3C2440下载程序提示&quot;Unable to halt cpu core&quot;的解决办法</title>
      <link href="/2016/06/20/Jlink%E4%B8%BAS3C2440%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F%E6%8F%90%E7%A4%BAUnable%20to%20halt%20cpu%20core%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2016/06/20/Jlink%E4%B8%BAS3C2440%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F%E6%8F%90%E7%A4%BAUnable%20to%20halt%20cpu%20core%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>今天使用JLink为S3C2440下载U-Boot程序时发现连不上设备了，选择Connect后提示”Unable to halt cpu core. Failed to connect”，然而之前明明是正常的，于是开始寻找解决方案。</p><a id="more"></a><p>首先使用J-Link Commander尝试连接，不出意外，打开程序后提示”Unable to halt cpu core”，然而尝试复位后就可以连接了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">VTarget = 3.300V</span><br><span class="line">Info: TotalIRLen = 4, IRPrint = 0x01</span><br><span class="line">Info: Using DBGRQ to halt CPU</span><br><span class="line">Info: Resetting TRST in order to halt CPU</span><br><span class="line">Info: CP15.0.0: 0x41129200: ARM, Architecure 4T</span><br><span class="line">Info: J-Link: ARM9, 920 core</span><br><span class="line"></span><br><span class="line">****** Error: Unable to halt CPU core</span><br><span class="line">Found 1 JTAG device, Total IRLen = 4:</span><br><span class="line"><span class="meta"> #</span><span class="bash">0 Id: 0x0032409D, IRLen: 04, Unknown device</span></span><br><span class="line">Found 1 JTAG device, Total IRLen = 4:</span><br><span class="line"><span class="meta"> #</span><span class="bash">0 Id: 0x0032409D, IRLen: 04, Unknown device</span></span><br><span class="line">Found ARM with core Id 0x0032409D (ARM9)</span><br><span class="line"><span class="meta">J-Link&gt;</span><span class="bash">Regs</span></span><br><span class="line">CPU is not halted !</span><br><span class="line"><span class="meta">J-Link&gt;</span><span class="bash">r</span></span><br><span class="line">Reset delay: 0 ms</span><br><span class="line">Reset type NORMAL: Using RESET pin, halting CPU after Reset</span><br><span class="line">Info: TotalIRLen = 4, IRPrint = 0x01</span><br><span class="line">Info: CP15.0.0: 0x41129200: ARM, Architecure 4T</span><br><span class="line">Info: CP15.0.1: 0x0D172172: ICache: 16kB (64*8*32), DCache: 16kB (64*8*32)</span><br><span class="line">Info: Cache type: Separate, Write-back, Format A</span><br><span class="line"><span class="meta">J-Link&gt;</span><span class="bash">Regs</span></span><br><span class="line">PC: (R15) = 00000000, CPSR = 600000D3 (SVC mode, ARM FIQ dis. IRQ dis.)</span><br><span class="line">R0 = 33B1C948, R1 = 00000000, R2 = 33B1C058, R3 = 19000300</span><br><span class="line">R4 = 33B1C948, R5 = 33B1C058, R6 = 19000300, R7 = 00000000</span><br><span class="line">USR: R8 =33FEC9A0, R9 =33B1BF08, R10=DEADBEEF, R11 =000185BC, R12 =00000000</span><br><span class="line">     R13=FF7CFAEF, R14=BFBFFD9E</span><br><span class="line">FIQ: R8 =E7EF7AF0, R9 =BEBFBFFB, R10=FDA3FBFD, R11 =FCF82DF3, R12 =9FDFFD30</span><br><span class="line">     R13=FDFFDF79, R14=FFEDE3F9, SPSR=00000010</span><br><span class="line">SVC: R13=33B1BE80, R14=33F59374, SPSR=00000013</span><br><span class="line">ABT: R13=FFDFFEFF, R14=4FFFEF77, SPSR=40000014</span><br><span class="line">IRQ: R13=BF9E36F9, R14=69F7FFFF, SPSR=00000010</span><br><span class="line">UND: R13=FBBAD9FF, R14=00000008, SPSR=700000DB</span><br></pre></td></tr></table></figure><p>再回到J-Flash ARM中，设置菜单中有一项”Use following init sequence”，按照<a href="/2015/10/31/%E4%BD%BF%E7%94%A8JLink%E4%B8%BA2440%20NOR%20Flash%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/">之前的做法</a>是设置成了”Reset &amp; Delay 2ms”。注意上面J-Link Commander的输出信息，输入<code>r</code>进行复位后第一行就是:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reset <span class="keyword">delay</span>: <span class="number">0</span> ms</span><br></pre></td></tr></table></figure><p>复位延时是0ms。受此启发，将J-Flash ARM中的复位延时也改为0ms，此时再尝试连接，发现可以建立连接了。不过问题并没有解决，之后下载程序时会提示错误：”PC of target system has unexpected value after programming”，这也就是之前为何要设置成”Reset &amp; Delay 2ms”的原因（详见<a href="/2015/10/31/%E4%BD%BF%E7%94%A8JLink%E4%B8%BA2440%20NOR%20Flash%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/">使用JLink为2440 NOR Flash下载程序</a>）。</p><p>面对这个矛盾的问题，我想到的解决方案是：<strong>使用两次复位，第一次延时设置为0ms，这是为了能顺利建立连接；第二次复位延时设置为2ms，这是为了能顺利下载程序</strong>。实际测试表明，这样设置后的确能正常工作了。虽然表面上看问题是解决了，不过这种解决方案不明不白的，还是要深入分析下问题的原因。</p><hr><p>之前屡次实验的结果是：</p><ul><li>直接在程序运行时去连接 -&gt; 无法连接</li><li>切换到NAND Flash启动（其中没有程序）后去连接 -&gt; 正常连接</li><li>复位延时0ms后连接 -&gt; 正常连接</li><li>复位延时2ms后连接 -&gt; 无法连接</li></ul><p>从中可以看到，只要是程序运行起来后均无法正常连接，复位延时2ms后连接可以视为此时程序已经运行起来了，而复位延时0ms后连接相当于程序还没运行就去连接。JATG的连接过程相当于中断（Halt）CPU的过程，这也就意味着问题是由于程序造成的，程序运行起来后因为某些原因导致CPU无法被Halt了。为验证此猜想，在启动代码中，关闭了中断和看门狗后就加入一个死循环指令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">b</span> .</span><br></pre></td></tr></table></figure><p>然后再编译下载运行，此时就可以去掉第一次复位了，连接过程很正常，而且在程序运行中打开J-Link Commander也可以直接连上了，说明JLink此时成功的Halt并连接上了CPU。<strong>这就确定应该是程序中有些问题，导致CPU在某些时候进入了异常状态，从而无法使用JTAG连接。</strong></p><p>既然确定了是程序中的问题，那么是程序中的什么问题造成的呢？联想到之前测试时发现U-Boot的输出每次都不太一样，有些时候可以正常输出用户交互命令行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span>:    serial</span><br><span class="line">Out:   serial</span><br><span class="line">Err:   serial</span><br><span class="line">Net:   CS8900-0</span><br><span class="line">Error: CS8900-0<span class="built_in"> address </span><span class="keyword">not</span> set.</span><br><span class="line"></span><br><span class="line">SMDK2440 #</span><br></pre></td></tr></table></figure><p>然而更多的时候会卡在<code>Net:</code>处：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">In:</span>    serial</span><br><span class="line"><span class="symbol">Out:</span>   serial</span><br><span class="line"><span class="symbol">Err:</span>   serial</span><br><span class="line"><span class="symbol">Net:</span></span><br></pre></td></tr></table></figure><p>这就暗示我们会不会是网卡设置出错了呢。LT2440开发板上使用的DM9000网卡连接在了Bank 4上，目前的程序没有对其访问模式做设置，然而根据网上的各种资料，其访问模式应该要设置为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B4_BWSCON    (DW16 + WAIT + UBLB)</span></span><br></pre></td></tr></table></figure><p>即加入等待和启用UB/LB。按这个进行设置后，编译下载运行一切正常。至此，问题已经完全搞清楚了，<strong>因为对网卡的总线访问模式有误，导致CPU进入了异常状态，从而无法建立JTAG连接，修正此问题后一切正常。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 点滴之间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
            <tag> Bootloader </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot 2016.05 在S3C2440上的移植（1）——基本运行</title>
      <link href="/2016/06/19/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E8%BF%90%E8%A1%8C/"/>
      <url>/2016/06/19/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>相关环境：<br>系统版本：Ubuntu 16.04 64bit<br>U-boot 版本：2016.05<br>交叉编译链GCC版本为5.20，使用crosstool-ng自行制作。</p><p>基本运行的目标是能够顺利的编译通过，是之后移植修改的基础。</p><a id="more"></a><h2 id="创建2440配置文件"><a href="#创建2440配置文件" class="headerlink" title="创建2440配置文件"></a>创建2440配置文件</h2><p>复制2410的板子配置文件，以便在此基础上建立2440的配置文件。<br>涉及到的文件可在<code>board/samsung/smdk2410/MAINTAINERS</code>文件中找到。此文件实际上是一个代码维护说明，指出了这个板子的配置包含哪些文件，由谁维护等，其内容如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SMDK2410 BOARD</span><br><span class="line"><span class="symbol">M:</span>      David Müller <span class="params">&lt;d.mueller@elsoft.ch&gt;</span></span><br><span class="line"><span class="symbol">S:</span>      Maintained</span><br><span class="line"><span class="symbol">F:</span>      board<span class="meta-keyword">/samsung/</span>smdk2410/</span><br><span class="line"><span class="symbol">F:</span>      include<span class="meta-keyword">/configs/</span>smdk2410.h</span><br><span class="line"><span class="symbol">F:</span>      configs/smdk2410_defconfig</span><br></pre></td></tr></table></figure><p>从中可以看到，有三处需要复制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cp -r board/samsung/smdk2410/ board/samsung/smdk2440/</span><br><span class="line">mv board/samsung/smdk2440/smdk2410.c board/samsung/smdk2440/smdk2440.c</span><br><span class="line"></span><br><span class="line">cp -r include/configs/smdk2410.h include/configs/smdk2440.h</span><br><span class="line"></span><br><span class="line">cp -r configs/smdk2410_defconfig configs/smdk2440_defconfig</span><br></pre></td></tr></table></figure><h3 id="MAINTAINERS文件"><a href="#MAINTAINERS文件" class="headerlink" title="MAINTAINERS文件"></a>MAINTAINERS文件</h3><p>修改<code>board/samsung/smdk2440/MAINTAINERS</code>文件，将其中2410的部分全部改为2440：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- board/samsung/smdk2410/MAINTAINERS</span></span><br><span class="line"><span class="comment">+++ board/samsung/smdk2440/MAINTAINERS</span></span><br><span class="line"><span class="meta">@@ -1,6 +1,6 @@</span></span><br><span class="line"><span class="deletion">-SMDK2410 BOARD</span></span><br><span class="line"><span class="deletion">-M:     David Müller &lt;d.mueller@elsoft.ch&gt;</span></span><br><span class="line"><span class="addition">+SMDK2440 BOARD</span></span><br><span class="line"><span class="addition">+M:     Mingfei Gao  &lt;G199209@gmail.com&gt;</span></span><br><span class="line"> S:     Maintained</span><br><span class="line"><span class="deletion">-F:     board/samsung/smdk2410/</span></span><br><span class="line"><span class="deletion">-F:     include/configs/smdk2410.h</span></span><br><span class="line"><span class="deletion">-F:     configs/smdk2410_defconfig</span></span><br><span class="line"><span class="addition">+F:     board/samsung/smdk2440/</span></span><br><span class="line"><span class="addition">+F:     include/configs/smdk2440.h</span></span><br><span class="line"><span class="addition">+F:     configs/smdk2440_defconfig</span></span><br></pre></td></tr></table></figure><h3 id="Kconfig文件"><a href="#Kconfig文件" class="headerlink" title="Kconfig文件"></a>Kconfig文件</h3><p>同理修改<code>board/samsung/smdk2440/Kconfig</code>文件：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- board/samsung/smdk2410/Kconfig</span></span><br><span class="line"><span class="comment">+++ board/samsung/smdk2440/Kconfig</span></span><br><span class="line"><span class="meta">@@ -1,7 +1,7 @@</span></span><br><span class="line"><span class="deletion">-if TARGET_SMDK2410</span></span><br><span class="line"><span class="addition">+if TARGET_SMDK2440</span></span><br><span class="line"> </span><br><span class="line"> config SYS_BOARD</span><br><span class="line"><span class="deletion">-       default "smdk2410"</span></span><br><span class="line"><span class="addition">+       default "smdk2440"</span></span><br><span class="line"> </span><br><span class="line"> config SYS_VENDOR</span><br><span class="line">        default "samsung"</span><br><span class="line"><span class="meta">@@ -10,6 +10,6 @@</span></span><br><span class="line">        default "s3c24x0"</span><br><span class="line"> </span><br><span class="line"> config SYS_CONFIG_NAME</span><br><span class="line"><span class="deletion">-       default "smdk2410"</span></span><br><span class="line"><span class="addition">+       default "smdk2440"</span></span><br><span class="line"> </span><br><span class="line"> endif</span><br></pre></td></tr></table></figure><h3 id="Makefile文件"><a href="#Makefile文件" class="headerlink" title="Makefile文件"></a>Makefile文件</h3><p>同理修改<code>board/samsung/smdk2440/Makefile</code>文件：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- board/samsung/smdk2410/Makefile</span></span><br><span class="line"><span class="comment">+++ board/samsung/smdk2440/Makefile</span></span><br><span class="line"><span class="meta">@@ -4,6 +4,9 @@</span></span><br><span class="line"> #</span><br><span class="line"> # SPDX-License-Identifier:     GPL-2.0+</span><br><span class="line"> #</span><br><span class="line"><span class="addition">+# Modified by Mingfei Gao</span></span><br><span class="line"><span class="addition">+# 2016.06.17</span></span><br><span class="line"><span class="addition">+#</span></span><br><span class="line"> </span><br><span class="line"><span class="deletion">-obj-y  := smdk2410.o</span></span><br><span class="line"><span class="addition">+obj-y  := smdk2440.o</span></span><br><span class="line"> obj-y  += lowlevel_init.o</span><br></pre></td></tr></table></figure><h3 id="smdk2440-c文件"><a href="#smdk2440-c文件" class="headerlink" title="smdk2440.c文件"></a>smdk2440.c文件</h3><p>同理修改<code>board/samsung/smdk2440/smdk2440.c</code>文件：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- board/samsung/smdk2410/smdk2410.c</span></span><br><span class="line"><span class="comment">+++ board/samsung/smdk2440/smdk2440.c</span></span><br><span class="line"><span class="meta">@@ -96,8 +96,8 @@</span></span><br><span class="line"> </span><br><span class="line"> int board_init(void)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-       /* arch number of SMDK2410-Board */</span></span><br><span class="line"><span class="deletion">-       gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDK2410;</span></span><br><span class="line"><span class="addition">+       /* arch number of SMDK2440-Board */</span></span><br><span class="line"><span class="addition">+       gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDK2440;</span></span><br><span class="line"> </span><br><span class="line">        /* adress of boot parameters */</span><br><span class="line">        gd-&gt;bd-&gt;bi_boot_params = 0x30000100;</span><br></pre></td></tr></table></figure><h3 id="smdk2440-defconfig文件"><a href="#smdk2440-defconfig文件" class="headerlink" title="smdk2440_defconfig文件"></a>smdk2440_defconfig文件</h3><p>修改<code>configs/smdk2440_defconfig</code>文件：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- configs/smdk2410_defconfig</span></span><br><span class="line"><span class="comment">+++ configs/smdk2440_defconfig</span></span><br><span class="line"><span class="meta">@@ -1,7 +1,7 @@</span></span><br><span class="line"> CONFIG_ARM=y</span><br><span class="line"><span class="deletion">-CONFIG_TARGET_SMDK2410=y</span></span><br><span class="line"><span class="addition">+CONFIG_TARGET_SMDK2440=y</span></span><br><span class="line"> CONFIG_HUSH_PARSER=y</span><br><span class="line"><span class="deletion">-CONFIG_SYS_PROMPT="SMDK2410 # "</span></span><br><span class="line"><span class="addition">+CONFIG_SYS_PROMPT="SMDK2440 # "</span></span><br><span class="line"> CONFIG_CMD_USB=y</span><br><span class="line"> # CONFIG_CMD_SETEXPR is not set</span><br><span class="line"> CONFIG_CMD_DHCP=y</span><br></pre></td></tr></table></figure><h3 id="arch-arm-Kconfig文件"><a href="#arch-arm-Kconfig文件" class="headerlink" title="arch/arm/Kconfig文件"></a>arch/arm/Kconfig文件</h3><p>因为前面修改了<code>smdk2440_defconfig</code>文件，将其中的配置项名称由<code>CONFIG_TARGET_SMDK2410</code>改成了<code>CONFIG_TARGET_SMDK2440</code>，故还需要修改<code>arch/arm/Kconfig</code>文件，在其中添加<code>SMDK2440</code>的板子配置才行：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/arch/arm/Kconfig</span></span><br><span class="line"><span class="comment">+++ b/arch/arm/Kconfig</span></span><br><span class="line">@@ -96,6 +96,10 @@ config TARGET_SMDK2410</span><br><span class="line">        bool "Support smdk2410"</span><br><span class="line">        select CPU_ARM920T</span><br><span class="line"> </span><br><span class="line"><span class="addition">+config TARGET_SMDK2440</span></span><br><span class="line"><span class="addition">+       bool "Support smdk2440"</span></span><br><span class="line"><span class="addition">+       select CPU_ARM920T</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> config TARGET_ASPENITE</span><br><span class="line">        bool "Support aspenite"</span><br><span class="line">        select CPU_ARM926EJS</span><br><span class="line">@@ -854,6 +858,7 @@ source "board/phytec/pcm051/Kconfig"</span><br><span class="line"> source "board/phytec/pcm052/Kconfig"</span><br><span class="line"> source "board/ppcag/bg0900/Kconfig"</span><br><span class="line"> source "board/samsung/smdk2410/Kconfig"</span><br><span class="line"><span class="addition">+source "board/samsung/smdk2440/Kconfig"</span></span><br><span class="line"> source "board/sandisk/sansa_fuze_plus/Kconfig"</span><br><span class="line"> source "board/schulercontrol/sc_sps_1/Kconfig"</span><br><span class="line"> source "board/siemens/draco/Kconfig"</span><br></pre></td></tr></table></figure><h3 id="mach-types-h文件"><a href="#mach-types-h文件" class="headerlink" title="mach-types.h文件"></a>mach-types.h文件</h3><p><code>smdk2440.c</code>中将<code>MACH_TYPE_SMDK2410</code>改成了<code>MACH_TYPE_SMDK2440</code>，此时需要在<code>arch/arm/include/asm/mach-types.h</code>中添加对应的代码才行：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/arch/arm/include/asm/mach-types.h</span></span><br><span class="line"><span class="comment">+++ b/arch/arm/include/asm/mach-types.h</span></span><br><span class="line">@@ -57,6 +57,7 @@ extern unsigned int __machine_arch_type;</span><br><span class="line"> #define MACH_TYPE_IQ80321              169</span><br><span class="line"> #define MACH_TYPE_KS8695               180</span><br><span class="line"> #define MACH_TYPE_SMDK2410             193</span><br><span class="line"><span class="addition">+#define MACH_TYPE_SMDK2440             1999</span></span><br><span class="line"> #define MACH_TYPE_CEIVA                200</span><br><span class="line"> #define MACH_TYPE_VOICEBLUE            218</span><br><span class="line"> #define MACH_TYPE_H5400                220</span><br><span class="line">@@ -1648,6 +1649,19 @@ extern unsigned int __machine_arch_type;</span><br><span class="line"> # define machine_is_smdk2410() (0)</span><br><span class="line"> #endif</span><br><span class="line"> </span><br><span class="line"><span class="addition">+#ifdef CONFIG_ARCH_SMDK2440</span></span><br><span class="line"><span class="addition">+# ifdef machine_arch_type</span></span><br><span class="line"><span class="addition">+#  undef machine_arch_type</span></span><br><span class="line"><span class="addition">+#  define machine_arch_type     __machine_arch_type</span></span><br><span class="line"><span class="addition">+# else</span></span><br><span class="line"><span class="addition">+#  define machine_arch_type     MACH_TYPE_SMDK2440</span></span><br><span class="line"><span class="addition">+# endif</span></span><br><span class="line"><span class="addition">+# define machine_is_smdk2440()  (machine_arch_type == MACH_TYPE_SMDK2440)</span></span><br><span class="line"><span class="addition">+#else</span></span><br><span class="line"><span class="addition">+# define machine_is_smdk2440()  (0)</span></span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> #ifdef CONFIG_ARCH_CEIVA</span><br><span class="line"> # ifdef machine_arch_type</span><br><span class="line"> #  undef machine_arch_type</span><br></pre></td></tr></table></figure><p>此处<code>MACH_TYPE</code>的宏定义值是根据Linux kernel中的定义值来确定的，二者最好匹配起来，不过要是不同也没有关系，在引导内核的时候也可以通过环境变量来设置这个值。</p><h3 id="smdk2440-h文件"><a href="#smdk2440-h文件" class="headerlink" title="smdk2440.h文件"></a>smdk2440.h文件</h3><p>修改<code>include/configs/smdk2440.h</code>文件：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/include/configs/smdk2440.h</span></span><br><span class="line"><span class="comment">+++ b/include/configs/smdk2440.h</span></span><br><span class="line"><span class="meta">@@ -18,8 +18,8 @@</span></span><br><span class="line">  * (easy to change)</span><br><span class="line">  */</span><br><span class="line"> #define CONFIG_S3C24X0         /* This is a SAMSUNG S3C24x0-type SoC */</span><br><span class="line"><span class="deletion">-#define CONFIG_S3C2410         /* specifically a SAMSUNG S3C2410 SoC */</span></span><br><span class="line"><span class="deletion">-#define CONFIG_SMDK2410                /* on a SAMSUNG SMDK2410 Board */</span></span><br><span class="line"><span class="addition">+#define CONFIG_S3C2440         /* specifically a SAMSUNG S3C2440 SoC */</span></span><br><span class="line"><span class="addition">+#define CONFIG_SMDK2440                /* on a SAMSUNG SMDK2440 Board */</span></span><br><span class="line"> </span><br><span class="line"> #define CONFIG_SYS_TEXT_BASE   0x0</span><br></pre></td></tr></table></figure><h3 id="添加交叉编译链路径"><a href="#添加交叉编译链路径" class="headerlink" title="添加交叉编译链路径"></a>添加交叉编译链路径</h3><p>最后，添加交叉编译链的路径，根据U-Boot README说明，可以不修改Makefile文件，而是使用环境变量<code>CROSS_COMPILE</code>来指定交叉编译链，不过这里还是采用了修改Makefile文件的方法。修改顶层Makefile文件，即<code>Makefile</code>：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/Makefile</span></span><br><span class="line"><span class="comment">+++ b/Makefile</span></span><br><span class="line">@@ -246,6 +246,8 @@ ifeq ($(HOSTARCH),$(ARCH))</span><br><span class="line"> CROSS_COMPILE ?=</span><br><span class="line"> endif</span><br><span class="line"> </span><br><span class="line"><span class="addition">+CROSS_COMPILE = "/home/gmf/uboot/toolchain/x-tools/arm-s3c2440-linux-gnueabi/bin/arm-s3c2440-linux-gnueabi-"</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> KCONFIG_CONFIG ?= .config</span><br><span class="line"> export KCONFIG_CONFIG</span><br></pre></td></tr></table></figure><h3 id="测试编译"><a href="#测试编译" class="headerlink" title="测试编译"></a>测试编译</h3><p>至此，已成功创建2440的配置文件，使用以下命令进行配置和编译：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">make</span> smdk2440_defconfig</span><br><span class="line"><span class="keyword">make</span> <span class="keyword">all</span></span><br></pre></td></tr></table></figure><p>顺利编译后就会在U-Boot根目录下生成所需的<code>u-boot.bin</code>文件。当然，此文件目前还是针对2410的，接下来需要针对2440进行修改移植。</p><h2 id="Stage-1代码移植"><a href="#Stage-1代码移植" class="headerlink" title="Stage 1代码移植"></a>Stage 1代码移植</h2><p>第一阶段代码一般是汇编代码，用于初始化硬件，建立C语言运行环境等。从<code>README</code>文件中可以找到U-Boot初始化流程的说明，位于<code>Board Initialisation Flow</code>部分，其中提到最初执行的启动代码为<code>start.S</code>文件，对于2440来说，就是<code>arch/arm/cpu/arm920t/start.S</code>文件，下面针对2440来修改此文件。</p><h3 id="修改屏蔽中断代码"><a href="#修改屏蔽中断代码" class="headerlink" title="修改屏蔽中断代码"></a>修改屏蔽中断代码</h3><p>修改屏蔽中断的代码：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@@ -78,6 +78,10 @@ copyex:</span><br><span class="line"> ldrr1, =0x3ff</span><br><span class="line"> ldrr0, =INTSUBMSK</span><br><span class="line"> strr1, [r0]</span><br><span class="line"><span class="addition">+# elif defined(CONFIG_S3C2440)</span></span><br><span class="line"><span class="addition">+ldrr1, =0x7fff</span></span><br><span class="line"><span class="addition">+ldrr0, =INTSUBMSK</span></span><br><span class="line"><span class="addition">+strr1, [r0]</span></span><br><span class="line"> # endif</span><br><span class="line"> </span><br><span class="line"> /* FCLK:HCLK:PCLK = 1:2:4 */</span><br></pre></td></tr></table></figure><p>此处的设置参考2440数据手册中对<code>INTSUBMSK</code>寄存器的说明：<br><img src="https://pic.gaomf.store/20160618160432.png" alt=""></p><h3 id="更改时钟设置"><a href="#更改时钟设置" class="headerlink" title="更改时钟设置"></a>更改时钟设置</h3><p>更改时钟设置，默认<code>start.S</code>中只有时钟分频设置，PLL的设置放在Stage 2中进行。对此进行下修改，在此完成所有时钟部分的初始化设置。一般都将2400配置为：FCLK=400M；HCLK=100M；PCLK=50M，需要将原来的：</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* FCLK:HCLK:PCLK = 1:2:4 */</span></span><br><span class="line"><span class="comment">/* defualt FCLK is 120 MHz ! */</span></span><br><span class="line"><span class="keyword">ldr </span>    <span class="built_in">r0</span>, <span class="symbol">=CLKDIVN</span></span><br><span class="line"><span class="keyword">mov </span>    <span class="built_in">r1</span>, <span class="number">#3</span></span><br><span class="line"><span class="keyword">str </span>    <span class="built_in">r1</span>, [<span class="built_in">r0</span>]</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize Clock */</span></span><br><span class="line"># <span class="meta">if</span> defined(CONFIG_S3C2440)</span><br><span class="line">    <span class="symbol">#define</span> MPLLCON <span class="number">0x4C000004</span></span><br><span class="line">    <span class="symbol">#define</span> UPLLCON <span class="number">0x4C000008</span></span><br><span class="line"></span><br><span class="line">    <span class="symbol">#define</span> S3C2440_MPLL_400M ((<span class="number">92</span> &lt;&lt; <span class="number">12</span>) <span class="title">| (1 &lt;&lt; 4) |</span> (<span class="number">1</span>))</span><br><span class="line">    <span class="symbol">#define</span> S3C2440_UPLL_48M  ((<span class="number">56</span> &lt;&lt; <span class="number">12</span>) <span class="title">| (2 &lt;&lt; 4) |</span> (<span class="number">2</span>))         </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FCLK:HCLK:PCLK = 1:4:8 */</span></span><br><span class="line">    <span class="keyword">ldr </span>    <span class="built_in">r0</span>, <span class="symbol">=CLKDIVN</span></span><br><span class="line">    <span class="keyword">mov </span>    <span class="built_in">r1</span>, <span class="number">#5</span></span><br><span class="line">    <span class="keyword">str </span>    <span class="built_in">r1</span>, [<span class="built_in">r0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* MMU Set Async Bus Mode */</span></span><br><span class="line">    <span class="keyword">mrc </span>    <span class="built_in">p15</span>, <span class="number">0</span>, <span class="built_in">r0</span>, <span class="built_in">c1</span>, <span class="built_in">c0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">orr </span>    <span class="built_in">r0</span>, <span class="built_in">r0</span>, <span class="number">#0xC0000000</span></span><br><span class="line">    mcr     <span class="built_in">p15</span>, <span class="number">0</span>, <span class="built_in">r0</span>, <span class="built_in">c1</span>, <span class="built_in">c0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set PLL */</span></span><br><span class="line">    <span class="keyword">ldr </span>    <span class="built_in">r0</span>, <span class="symbol">=MPLLCON</span></span><br><span class="line">    <span class="keyword">ldr </span>    <span class="built_in">r1</span>, <span class="symbol">=S3C2440_MPLL_400M</span></span><br><span class="line">    <span class="keyword">str </span>    <span class="built_in">r1</span>, [<span class="built_in">r0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some delay between MPLL and UPLL */</span></span><br><span class="line">    <span class="keyword">mov </span>    <span class="built_in">r0</span>, #(<span class="number">1</span> &lt;&lt; <span class="number">13</span>)</span><br><span class="line">    <span class="keyword">mov </span>    <span class="built_in">r1</span>, <span class="number">#0</span></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">    <span class="keyword">subs </span>   <span class="built_in">r0</span>, <span class="built_in">r0</span>, <span class="number">#1</span></span><br><span class="line">    <span class="keyword">cmp </span>    <span class="built_in">r0</span>, <span class="built_in">r1</span></span><br><span class="line">    <span class="keyword">bne </span>    <span class="number">1</span>b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ldr </span>    <span class="built_in">r0</span>, <span class="symbol">=UPLLCON</span></span><br><span class="line">    <span class="keyword">ldr </span>    <span class="built_in">r1</span>, <span class="symbol">=S3C2440_UPLL_48M</span></span><br><span class="line">    <span class="keyword">str </span>    <span class="built_in">r1</span>, [<span class="built_in">r0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Some delay */</span></span><br><span class="line">    <span class="keyword">mov </span>    <span class="built_in">r0</span>, #(<span class="number">1</span> &lt;&lt; <span class="number">14</span>)</span><br><span class="line">    <span class="keyword">mov </span>    <span class="built_in">r1</span>, <span class="number">#0</span></span><br><span class="line"><span class="number">2</span>:</span><br><span class="line">    <span class="keyword">subs </span>   <span class="built_in">r0</span>, <span class="built_in">r0</span>, <span class="number">#1</span></span><br><span class="line">    <span class="keyword">cmp </span>    <span class="built_in">r0</span>, <span class="built_in">r1</span></span><br><span class="line">    <span class="keyword">bne </span>    <span class="number">2</span>b</span><br><span class="line"></span><br><span class="line"># <span class="meta">else</span></span><br><span class="line">    <span class="comment">/* FCLK:HCLK:PCLK = 1:2:4 */</span></span><br><span class="line">    <span class="comment">/* defualt FCLK is 120 MHz ! */</span></span><br><span class="line">    <span class="keyword">ldr </span>    <span class="built_in">r0</span>, <span class="symbol">=CLKDIVN</span></span><br><span class="line">    <span class="keyword">mov </span>    <span class="built_in">r1</span>, <span class="number">#3</span></span><br><span class="line">    <span class="keyword">str </span>    <span class="built_in">r1</span>, [<span class="built_in">r0</span>]</span><br><span class="line"># <span class="meta">endif</span></span><br></pre></td></tr></table></figure><h3 id="修改SDRAM设置"><a href="#修改SDRAM设置" class="headerlink" title="修改SDRAM设置"></a>修改SDRAM设置</h3><p><code>start.S</code>文件会跳转到<code>board/samsung/smdk2440/lowlevel_init.S</code>中继续执行，下面来修改此文件。</p><p>修改SDRAM刷新周期、预充电时间，根据SDRAM的数据手册刷新要求为8192/64ms，一般HCLK设置为100M，故需要将<code>REFCNT</code>的值改为1268；Trp根据数据手册为20ns，故选择3 clk即可；另外2440中没有Tchr寄存器，需要删掉：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@@ -105,8 +105,7 @@</span></span><br><span class="line"> /* REFRESH parameter */</span><br><span class="line"> #define REFEN                  0x1     /* Refresh enable */</span><br><span class="line"> #define TREFMD                 0x0     /* CBR(CAS before RAS)/Auto refresh */</span><br><span class="line"><span class="deletion">-#define Trp                    0x0     /* 2clk */</span></span><br><span class="line"><span class="addition">+#define Trp                    0x1     /* 3clk */</span></span><br><span class="line"> #define Trc                    0x3     /* 7clk */</span><br><span class="line"><span class="deletion">-#define Tchr                   0x2     /* 3clk */</span></span><br><span class="line"><span class="deletion">-#define REFCNT                 1113    /* period=15.6us, HCLK=60Mhz, (2048+1-15.6*60) */</span></span><br><span class="line"><span class="addition">+#define REFCNT                 1268    /* period=7.81us, HCLK=100Mhz, (2048+1-7.81*100) */</span></span><br><span class="line"> /<span class="comment">**************************************/</span></span><br></pre></td></tr></table></figure><hr><p>Stage 1中，<code>start.S</code>还会跳转去执行<code>_main</code>，不过这个是平台无关的代码，移植时不需要考虑。下面开始移植Stage 2代码。</p><h2 id="Stage-2代码移植"><a href="#Stage-2代码移植" class="headerlink" title="Stage 2代码移植"></a>Stage 2代码移植</h2><p>因为在Stage 1中已经完成了PLL时钟的初始化，这里将Stage 2中的相关代码全部删掉。所在文件为<code>board/samsung/smdk2440/smdk2440.c</code>：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- a/board/samsung/smdk2440/smdk2440.c</span></span><br><span class="line"><span class="comment">+++ b/board/samsung/smdk2440/smdk2440.c</span></span><br><span class="line"><span class="meta">@@ -16,36 +16,6 @@</span></span><br><span class="line"> </span><br><span class="line"> DECLARE_GLOBAL_DATA_PTR;</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-#define FCLK_SPEED 1</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-#if (FCLK_SPEED == 0)          /* Fout = 203MHz, Fin = 12MHz for Audio */</span></span><br><span class="line"><span class="deletion">-#define M_MDIV 0xC3</span></span><br><span class="line"><span class="deletion">-#define M_PDIV 0x4</span></span><br><span class="line"><span class="deletion">-#define M_SDIV 0x1</span></span><br><span class="line"><span class="deletion">-#elif (FCLK_SPEED == 1)                /* Fout = 202.8MHz */</span></span><br><span class="line"><span class="deletion">-#define M_MDIV 0xA1</span></span><br><span class="line"><span class="deletion">-#define M_PDIV 0x3</span></span><br><span class="line"><span class="deletion">-#define M_SDIV 0x1</span></span><br><span class="line"><span class="deletion">-#endif</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-#define USB_CLOCK 1</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-#if (USB_CLOCK == 0)</span></span><br><span class="line"><span class="deletion">-#define U_M_MDIV       0xA1</span></span><br><span class="line"><span class="deletion">-#define U_M_PDIV       0x3</span></span><br><span class="line"><span class="deletion">-#define U_M_SDIV       0x1</span></span><br><span class="line"><span class="deletion">-#elif (USB_CLOCK == 1)</span></span><br><span class="line"><span class="deletion">-#define U_M_MDIV       0x48</span></span><br><span class="line"><span class="deletion">-#define U_M_PDIV       0x3</span></span><br><span class="line"><span class="deletion">-#define U_M_SDIV       0x2</span></span><br><span class="line"><span class="deletion">-#endif</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-static inline void pll_delay(unsigned long loops)</span></span><br><span class="line"><span class="deletion">-&#123;</span></span><br><span class="line"><span class="deletion">-       __asm__ volatile ("1:\n"</span></span><br><span class="line"><span class="deletion">-         "subs %0, %1, #1\n"</span></span><br><span class="line"><span class="deletion">-         "bne 1b" : "=r" (loops) : "0" (loops));</span></span><br><span class="line"><span class="deletion">-&#125;</span></span><br><span class="line"> </span><br><span class="line"> /*</span><br><span class="line">  * Miscellaneous platform dependent initialisations</span><br><span class="line">@@ -53,27 +23,8 @@ static inline void pll_delay(unsigned long loops)</span><br><span class="line"> </span><br><span class="line"> int board_early_init_f(void)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-       struct s3c24x0_clock_power * const clk_power =</span></span><br><span class="line"><span class="deletion">-                                       s3c24x0_get_base_clock_power();</span></span><br><span class="line">        struct s3c24x0_gpio * const gpio = s3c24x0_get_base_gpio();</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-       /* to reduce PLL lock time, adjust the LOCKTIME register */</span></span><br><span class="line"><span class="deletion">-       writel(0xFFFFFF, &amp;clk_power-&gt;locktime);</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-       /* configure MPLL */</span></span><br><span class="line"><span class="deletion">-       -       writel((M_MDIV &lt;&lt; 12) + (M_PDIV &lt;&lt; 4) + M_SDIV,</span></span><br><span class="line"><span class="deletion">-              &amp;clk_power-&gt;mpllcon);</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-       /* some delay between MPLL and UPLL */</span></span><br><span class="line"><span class="deletion">-       pll_delay(4000);</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-       /* configure UPLL */</span></span><br><span class="line"><span class="deletion">-       writel((U_M_MDIV &lt;&lt; 12) + (U_M_PDIV &lt;&lt; 4) + U_M_SDIV,</span></span><br><span class="line"><span class="deletion">-              &amp;clk_power-&gt;upllcon);</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-       /* some delay between MPLL and UPLL */</span></span><br><span class="line"><span class="deletion">-       pll_delay(8000);</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line">        /* set up the I/O ports */</span><br><span class="line">        writel(0x007FFFFF, &amp;gpio-&gt;gpacon);</span><br><span class="line">        writel(0x00044555, &amp;gpio-&gt;gpbcon);</span><br></pre></td></tr></table></figure><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><p>做完上面的修改后，编译UBoot：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">make</span> smdk2440_defconfig</span><br><span class="line"><span class="keyword">make</span> <span class="keyword">all</span></span><br></pre></td></tr></table></figure><p>将生成的<code>u-boot.bin</code>文件通过JTAG烧写到板子的Nor Flash中，之后连上串口（Serial 0），波特率设置为115200，复位后即可看到串口有数据输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">U-Boot 2016.05-gf52ee9c-dirty (Jun 19 2016 - 16:45:57 +0800)</span><br><span class="line"></span><br><span class="line">CPUID: 32440001</span><br><span class="line">FCLK:      400 MHz</span><br><span class="line">HCLK:      100 MHz</span><br><span class="line">PCLK:       50 MHz</span><br><span class="line">DRAM:  64 MiB</span><br><span class="line">WARNING: Caches not enabled</span><br><span class="line">Flash: 0 Bytes</span><br><span class="line">NAND:  0 MiB</span><br><span class="line">*** Warning - bad CRC, using default environment</span><br><span class="line"></span><br><span class="line">In:    serial</span><br><span class="line">Out:   serial</span><br><span class="line">Err:   serial</span><br><span class="line">Net:   CS8900-0</span><br><span class="line">Error: CS8900-0 address not set.</span><br><span class="line"></span><br><span class="line">SMDK2440 #</span><br></pre></td></tr></table></figure><p>这说明U-Boot已经运行起来了，不过没有识别出Flash，而且网卡配置有误，故我们还需要继续进行修改。</p><blockquote><p>移植好的U-Boot见<a href="https://github.com/g199209/U-Boot_201605_S3C2440" target="_blank" rel="noopener">我的Github项目</a>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenSSH使用多个私钥（SSH Key）配置</title>
      <link href="/2016/06/17/OpenSSH%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%A7%81%E9%92%A5%EF%BC%88SSH%20Key%EF%BC%89%E9%85%8D%E7%BD%AE/"/>
      <url>/2016/06/17/OpenSSH%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%A7%81%E9%92%A5%EF%BC%88SSH%20Key%EF%BC%89%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>在使用SSH时，有时候需要针对不同网站使用不同私钥，最简单的方法就是在<code>.ssh</code>目录（一般为<code>~/.ssh/</code>）下创建一个配置文件<code>config</code>，其内容示例如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line"></span><br><span class="line">Host git<span class="selector-class">.oschina</span><span class="selector-class">.net</span></span><br><span class="line">IdentityFile ~/.ssh/id_rsa_oscchain</span><br></pre></td></tr></table></figure><p>这样在登录github.com时使用<code>id_rsa_github</code>，而登录git.oschina.net时使用<code>id_rsa_oscchain</code>。如果登陆一个没有在<code>config</code>文件中出现的地址，则会使用默认的<code>id_rsa</code>文件。</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crosstool-ng参数配置</title>
      <link href="/2016/06/16/crosstool-ng%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/"/>
      <url>/2016/06/16/crosstool-ng%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>本文以Samsung S3C2440处理器为例，介绍使用crosstool-ng制作交叉编译链时该如何针对特定的目标CPU进行配置。一般来说，常用的CPU架构都有至少一个现成的示例配置文件，对于S3C2440来说，一般选用<code>arm-unknown-linux-gnueabi</code>，下面就以这个示例配置为基础进行修改。</p><a id="more"></a><p><strong>crosstool-ng版本为1.22.0</strong>。</p><h2 id="Paths-and-misc-options"><a href="#Paths-and-misc-options" class="headerlink" title="Paths and misc options"></a><strong>Paths and misc options</strong></h2><p>这部分是crosstool-ng本身的配置，目的是为了提高编译效率与工作效率，具有通用性，在制作不同交叉编译链时都是一样的。</p><p>重要配置参数如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">4</span>) <span class="built_in">Number</span> <span class="keyword">of</span> parallel jobs</span><br></pre></td></tr></table></figure><p>将此值设置为所需线程数即可，一般设置为CPU线程数（对于支持超线程的CPU来说就是核心数 * 2）。</p><blockquote><p>此处的多线程参数，crosstool-ng内部是将其传给<code>make</code>的<code>-j</code>参数实现的，如：<code>make -j4</code></p></blockquote><hr><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[*] <span class="keyword">Debug</span> crosstool-NG                                                    </span><br><span class="line">  [*]   <span class="keyword">Save</span> intermediate steps                                             </span><br><span class="line">    [*]     gzip <span class="built_in">saved</span> <span class="built_in">states</span> (<span class="keyword">NEW</span>)</span><br></pre></td></tr></table></figure><p>开启逐步编译功能，如果编译过程出错，只要找到最后成功的那一步，使用如下命令即可恢复编译：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ct-ng <span class="tag">&lt;<span class="name">last_successful_step</span>&gt;</span>+</span><br></pre></td></tr></table></figure><p>关于此功能的详细用法参考<a href="http://www.crifan.com/files/doc/docbook/crosstool_ng/release/html/crosstool_ng.html#restore_from_fail_step" target="_blank" rel="noopener">这里</a>。此外，crosstool-ng还可以实现出错时不立刻退出，即<code>Interactive shell on failed commands</code>，在此不多做说明，可参考<a href="http://www.crifan.com/files/doc/docbook/crosstool_ng/release/html/crosstool_ng.html#error_but_not_exit" target="_blank" rel="noopener">这里的说明。</a></p><hr><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="variable">$&#123;CT_TOP_DIR&#125;</span>/.build) Working directory</span><br><span class="line">(<span class="variable">$&#123;build&#125;</span>/src) Local tarballs directory</span><br><span class="line">(<span class="variable">$&#123;build&#125;</span>/x-tools/<span class="variable">$&#123;CT_TARGET&#125;</span>)<span class="built_in"> Prefix </span>directory</span><br></pre></td></tr></table></figure><p>分别是值工作路径、源码包保存路径及目标安装路径。<br>工作路径：编译时生成的所有文件都放在这里面，一般使用默认配置即可；<br>源码包保存路径：所需各模块的源码包存放路径，如果之前下载好了可以直接放到这个路径中，如果没有的话crosstool-ng会自动下载。一般将此路径改为工作目录下的<code>./src/</code>目录；<br>目标安装路径：生成的交叉编译链存放的路径，改为需要路径，一般也放在当前工作目录下。</p><h2 id="Target-options"><a href="#Target-options" class="headerlink" title="Target options"></a><strong>Target options</strong></h2><p>重要配置参数如下：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[*]</span> Use the MMU</span><br></pre></td></tr></table></figure><p>是否使用MMU，S3C2440有MMU。</p><hr><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Endianness:</span> (Little endian)</span><br></pre></td></tr></table></figure><p>字节序，S3C2440为小端，大部分ARM处理器均为小端。</p><hr><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bitness: (<span class="number">32</span>-bit)</span><br></pre></td></tr></table></figure><p>CPU运算位数，S3C2440为32 bit，最新型号的ARM Cortex-A处理器为64 bit。</p><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(arm920t) Emit assembly for CPU</span><br></pre></td></tr></table></figure><p>目标CPU核心名称，对应GCC中的<code>-mcpu</code>参数。对于S3C2440来说，其ARM核为ARM920T。设置了这个参数后，<code>Architecture level</code>及<code>Tune for CPU</code>这两个选项就会自动消失。关于这个问题，参考我的另一篇博客文章：<a href="/2016/06/15/GCC%E4%B8%AD-march%E3%80%81-mtune%E3%80%81-mcpu%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E8%AE%BE%E7%BD%AE/">GCC中-march、-mtune、-mcpu三个参数的设置</a>。</p><hr><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Floating</span> <span class="selector-tag">point</span>: (software (no FPU))</span><br><span class="line">()  <span class="selector-tag">Use</span> <span class="selector-tag">specific</span> <span class="selector-tag">FPU</span></span><br></pre></td></tr></table></figure><p>与FPU相关配置，S3C2440没有FPU，如果有FPU的话，按实际情况设置即可，其中<code>Use specific FPU</code>对应GCC中的<code>-mfpu</code>参数，可以指定所用的FPU的类型。</p><hr><p>配置好的界面：<br><img src="https://pic.gaomf.store/20160615172011.png" alt=""></p><h2 id="Toolchain-options"><a href="#Toolchain-options" class="headerlink" title="Toolchain options"></a><strong>Toolchain options</strong></h2><p>重要配置参数如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[ ]</span> Build Static Toolchain</span><br></pre></td></tr></table></figure><p>构建静态链接的交叉编译链，这里的静态链接是指交叉编译链本身，不是它编译出来的文件。这个主要是用于需要发布交叉编译链时，如果其他主机没有所需版本的系统库，使用动态链接就会出错，这是就需要使用静态链接。不过静态链接会增大生成的可执行文件的体积，这里只考虑在本机上用，故不选择这个选项。</p><hr><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">gmf20160615</span>)  Toolchain ID string</span><br></pre></td></tr></table></figure><p>可以自定义一个版本号，接在标准默认版本号的后面。</p><hr><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">s3c2440</span>) Tuple's vendor string</span><br></pre></td></tr></table></figure><p>指定交叉编译链标准命名<code>arch-vendor-kernel-system</code>中的第二部分<code>vendor</code>。</p><hr><p>配置好的界面：<br><img src="https://pic.gaomf.store/20160615220831.png" alt=""></p><h2 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a><strong>Operating System</strong></h2><p>重要配置参数如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Target OS (<span class="name">linux</span>)</span><br></pre></td></tr></table></figure><p>目标系统，可以选择<code>bare-metal</code>或<code>linux</code>。<br>编译Bootloader时严格来说是该选择<code>bare-metal</code>的，不过这样编译Bootloader和编译其他应用就要选用两套不同的交叉编译链，使用起来不是很方便。实际上使用针对<code>linux</code>的交叉编译链来编译Bootloader也是可以的，而编译Kernel时必须选择<code>linux</code>，故此处一般都选择<code>linux</code>。相关说明如下：</p><blockquote><p>You probably want to say ‘y’ here if you plan to use your compiler to build bootloaders. It is not yet suitable to build Linux kernels, though, because the APCI stuff relies on the target C library headers being available?!?!…</p></blockquote><hr><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux kernel version (<span class="number">4.3</span> (<span class="name">mainline</span>))</span><br></pre></td></tr></table></figure><p>Linux kernel版本，可以从列表中选择，也可以自定义一个tar包，自定义tar包的版本有何要求之后再来研究。</p><hr><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[*] <span class="keyword">Build </span><span class="keyword">shared </span>libraries</span><br></pre></td></tr></table></figure><p>是否编译共享库，编译Linux应用时不需要，不过编译Bootloader和Linux kernel等东西时需要，为了保证通用性，一般选上这个。</p><hr><p>配置好的界面：<br><img src="https://pic.gaomf.store/20160615223725.png" alt=""></p><h2 id="Binary-utilities"><a href="#Binary-utilities" class="headerlink" title="Binary utilities"></a><strong>Binary utilities</strong></h2><p>使用默认配置，重要配置参数如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Binary </span>format: (ELF)</span><br></pre></td></tr></table></figure><p>生成的二进制文件的格式，当<code>Target options</code>中选择了MMU后，此处只能选择ELF格式；若没有MMU，此处一般选择Flat格式。</p><hr><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[*]</span> Show Linaro versions</span><br></pre></td></tr></table></figure><p>选择是否使用Linaro binutils，这是另一套binutils，专为ARM架构做过优化，相关说明：</p><blockquote><p>Linaro is maintaining some advanced/more stable/experimental versions of binutils, especially for the ARM architecture. Those versions have not been blessed by the binutils comunity (nor have they been cursed either!), but they look to be pretty much stable, and even more stable than the upstream versions. YMMV…</p></blockquote><blockquote><p>Linaro binutils is a release of the GNU binutils with bug fixes and enhancements for ARM platforms. GNU binutils is a collection of tools including the ld linker and as assembler.</p></blockquote><p>对此目前还没有研究过，就选用主流的社区版本就行了。</p><h2 id="C-library-amp-C-compiler-amp-Debug-facilities-amp-Companion-libraries-amp-Companion-tools"><a href="#C-library-amp-C-compiler-amp-Debug-facilities-amp-Companion-libraries-amp-Companion-tools" class="headerlink" title="C-library &amp; C compiler &amp; Debug facilities &amp; Companion libraries &amp; Companion tools"></a><strong>C-library &amp; C compiler &amp; Debug facilities &amp; Companion libraries &amp; Companion tools</strong></h2><p>主要是各种C标准库、编译器、调试工具及其它一些库的版本选择及相关配置，它们之间似乎并不能任意组合，故这里都选用默认配置。</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC中-march、-mtune、-mcpu三个参数的设置</title>
      <link href="/2016/06/15/GCC%E4%B8%AD-march%E3%80%81-mtune%E3%80%81-mcpu%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
      <url>/2016/06/15/GCC%E4%B8%AD-march%E3%80%81-mtune%E3%80%81-mcpu%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>在配置交叉编译链时，需要指定目标CPU的型号，根据网上广为流传的说法，需要同时指定<code>-march</code>、<code>-mtune</code>、<code>-mcpu</code>这三个参数，并且这三个参数还是不同的。在使用crosstool-ng时，就对应<code>CT_ARCH_ARCH</code>、<code>CT_ARCH_TUNE</code>、<code>CT_ARCH_CPU</code>这三个参数，针对S3C2440，网上所有文章中的设置均是：</p><blockquote><p>Architecture level = CT_ARCH_ARCH = -march = armv4t<br>Emit assembly for CPU = CT_ARCH_CPU = -mcpu = arm9tdmi<br>Tune for CPU = CT_ARCH_TUNE = -mtune = arm920t</p></blockquote><a id="more"></a><p>比如以下这些文章：</p><blockquote><p><a href="http://www.crifan.com/crosstool_ng_architecture_level_emit_assembly_for_cpu_tune_for_cpu_for_tq2440_s3c2440_arm920t/" target="_blank" rel="noopener">【整理】crosstool-ng中的Architecture level，Emit assembly for CPU，Tune for CPU对于TQ2440的S3C2440的ARM920T填写何值</a><br><a href="http://blog.csdn.net/woshidahuaidan2011/article/details/51344312" target="_blank" rel="noopener">第一部分：crosstool-ng 制作交叉编译工具链 for s3c2440</a><br><a href="http://blog.csdn.net/HumorRat/article/details/5615298" target="_blank" rel="noopener">用crosstool-ng建立自己的ARM交叉编译工具链 (适用于S3C6410以及其它处理器)</a></p></blockquote><p><strong>这样设置不能说是错的，然而并不是推荐的设置方法。老版本的GCC的确是需要这样同时设置三个参数的，然而新版本的GCC（具体是哪个版本之后估计不可考了）并不需要这样设置，只需要使用<code>-mcpu</code>(<code>CT_ARCH_CPU</code>)这一个参数就可以了。</strong>网上很多近些年来的文章还这样说其实是以讹传讹。</p><p>以GCC 5.2.0为例，其帮助文档中关于这三个参数的说明如下（ARM部分）：</p><p>-march=name</p><blockquote><p>This specifies the name of the target ARM architecture.  GCC uses this nameto determine what kind of instructions it can emit when generating assemblycode.  This option can be used in conjunction with or instead of the -mcpu=option.<br>Permissible names are: armv2, armv2a, armv3, armv3m, armv4,armv4t, armv5, armv5t, armv5e, armv5te, armv6, armv6j, armv6t2, armv6z,armv6zk, armv6-m, armv7, armv7-a, armv7-r, armv7-m, armv7e-m, armv7ve,armv8-a, armv8-a+crc, iwmmxt, iwmmxt2, ep9312.</p></blockquote><hr><p>-mtune=name</p><blockquote><p>This option specifies the name of the target ARM processor for which GCCshould tune the performance of the code.  For some ARM implementationsbetter performance can be obtained by using this option.<br>Permissible namesare: arm2, arm250, arm3, arm6, arm60, arm600, arm610, arm620, arm7, arm7m,arm7d, arm7dm, arm7di, arm7dmi, arm70, arm700, arm700i, arm710, arm710c,arm7100, arm720, arm7500, arm7500fe, arm7tdmi, arm7tdmi-s, arm710t,arm720t, arm740t, strongarm, strongarm110, strongarm1100, strongarm1110,arm8, arm810, arm9, arm9e, arm920, <strong>arm920t</strong>, arm922t, arm946e-s, arm966e-s,arm968e-s, arm926ej-s, arm940t, <strong>arm9tdmi</strong>, arm10tdmi, arm1020t, arm1026ej-s,arm10e, arm1020e, arm1022e, arm1136j-s, arm1136jf-s, mpcore, mpcorenovfp,arm1156t2-s, arm1156t2f-s, arm1176jz-s, arm1176jzf-s, cortex-a5, cortex-a7,cortex-a8, cortex-a9, cortex-a12, cortex-a15, cortex-a53, cortex-a57,cortex-a72, cortex-r4, cortex-r4f, cortex-r5, cortex-r7, cortex-m7,cortex-m4, cortex-m3, cortex-m1, cortex-m0, cortex-m0plus,cortex-m1.small-multiply, cortex-m0.small-multiply,cortex-m0plus.small-multiply, exynos-m1, marvell-pj4, xscale, iwmmxt,iwmmxt2, ep9312, fa526, fa626, fa606te, fa626te, fmp626, fa726te, xgene1.<br>Additionally, this option can specify that GCC should tune the performance<br>of the code for a big.LITTLE system.  Permissible names are:<br>cortex-a15.cortex-a7, cortex-a57.cortex-a53, cortex-a72.cortex-a53.</p></blockquote><hr><p>-mcpu=name</p><blockquote><p>This specifies the name of the target ARM processor.  <strong>GCC uses this name to derive the name of the target ARM architecture (as if specified by -march)and the ARM processor type for which to tune for performance (as if specified by -mtune).  Where this option is used in conjunction with -marchor -mtune, those options take precedence over the appropriate part of this option.</strong><br><strong>Permissible names for this option are the same as those for -mtune.</strong></p></blockquote><p><strong>特别注意其中对<code>-mcpu</code>参数的说明，指定了<code>-mcpu</code>后，GCC编译器会自动推导出<code>-march</code>及<code>-mtune</code>，故不需要再指定这两个参数，只需要给出<code>-mcpu</code>即可，而且<code>-mcpu</code>的可能取值与<code>-mtune</code>完全相同</strong>。比如S3C2440，只需要加上<code>-mcpu=arm920t</code>即可。</p><p>在crosstool-ng的新版本（比如1.22.0）中，使用menuconfig进行配置时，一旦设置了<code>Emit assembly for CPU</code>这个选项，<code>Architecture level</code>及<code>Tune for CPU</code>这两个选项就会自动消失。最初在配置的时候还以为是Bug，后面仔细研究下才发现这是crosstool-ng已根据GCC的新特性进行了升级。</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Linux </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crosstool-ng的基本使用流程</title>
      <link href="/2016/06/15/crosstool-ng%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2016/06/15/crosstool-ng%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>按照<a href="/2016/06/14/crosstool-ng%E7%9A%84%E5%AE%89%E8%A3%85/">crosstool-ng的安装</a>中的做法安装好crosstool-ng后就可以使用crosstool-ng了，基本使用流程在其官网上有说明：<a href="http://crosstool-ng.org/#using_a_released_version" target="_blank" rel="noopener">Using a released version</a>，这里做下总结。</p><a id="more"></a><p><strong>需要注意的是，目前新版本的crosstool-ng不能以root身份运行，否则会提示以下错误：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR]  You must NOT be root to run crosstool-NG</span><br></pre></td></tr></table></figure><p>故下面的所有操作都<strong>不要</strong>在root下进行。当然，如果非要用root运行的话也是可以的，见本文最后的附注。</p><h2 id="创建工作目录"><a href="#创建工作目录" class="headerlink" title="创建工作目录"></a>创建工作目录</h2><p>一般专门创建一个工作目录用于之后的编译过程：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/toolchain</span><br><span class="line">cd ~/toolchain</span><br><span class="line"><span class="built_in">mkdir</span> src</span><br><span class="line"><span class="built_in">mkdir</span> x-tools</span><br><span class="line"><span class="keyword">export</span> build=<span class="string">"$(pwd)"</span></span><br></pre></td></tr></table></figure><p>这里创建了工作目录<code>~/toolchain/</code>及两个子文件夹<code>~/toolchain/src</code>、<code>~/toolchain/x-tools</code>，分别用于存放下载到的源码tarball及最终生成的交叉编译链。</p><p>最后新建了一个<code>build</code>变量，代表当前工作目录。</p><h2 id="使用Sample示例配置"><a href="#使用Sample示例配置" class="headerlink" title="使用Sample示例配置"></a>使用Sample示例配置</h2><p>crosstool-ng中自带了很多示例配置，可用以下命令列出所有Samples及查看某个特定的示例的主要配置参数：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ct-ng </span><span class="built_in">list-samples</span></span><br><span class="line"><span class="built_in">ct-ng</span> <span class="string">show-</span>&lt;<span class="string">sample&gt;</span></span><br></pre></td></tr></table></figure><p>如果有合适的示例配置可用的话，可以在其基础上进行修改。<strong>在工作目录中</strong>执行<code>ct-ng &lt;sample&gt;</code>，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ct-ng arm-unknown-linux-gnueabi</span><br></pre></td></tr></table></figure><p>此命令会自动在当前目录下创建示例的配置文件，shell输出类似这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  LN    config</span><br><span class="line">  MKDIR config.gen</span><br><span class="line">  IN    config.gen/arch.in</span><br><span class="line">  IN    config.gen/kernel.in</span><br><span class="line">  IN    config.gen/cc.in</span><br><span class="line">  IN    config.gen/binutils.in</span><br><span class="line">  IN    config.gen/libc.in</span><br><span class="line">  IN    config.gen/debug.in</span><br><span class="line">  CONF  config/config.in</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> configuration written to .config</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"></span><br><span class="line">***********************************************************</span><br><span class="line"></span><br><span class="line">Initially reported by: Alexander BIGGA</span><br><span class="line">URL: http://sourceware.org/ml/crossgcc/2008-06/msg00031.html</span><br><span class="line"></span><br><span class="line">***********************************************************</span><br><span class="line"></span><br><span class="line">Now configured for "arm-unknown-linux-gnueabi"</span><br></pre></td></tr></table></figure><p><strong>网上很多教程中都说要手动复制配置文件，目前新版本的crosstool-ng不需要这样做，而且手动复制还会出错，直接使用上述命令生成示例配置即可。</strong></p><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>一般来说，示例配置是不能直接使用的，需要对其进行一些修改，<strong>在工作目录中</strong>输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ct-ng menuconfig</span><br></pre></td></tr></table></figure><p>会进入下图这样的menuconfig配置界面：<br><img src="https://pic.gaomf.store/20160615105843.png" alt=""></p><p>一般需要更改下路径，进入<code>Paths and misc options</code>，修改<code>Local tarballs directory</code> &amp; <code>Prefix directory</code>。前者是下载的源码包存放的路径，后者是生成的交叉编译链存放的路径，将其改为之前在工作目录下新建的文件夹即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">($</span><span class="bash">&#123;build&#125;/src) Local tarballs directory</span></span><br><span class="line"><span class="meta">($</span><span class="bash">&#123;build&#125;/x-tools/<span class="variable">$&#123;CT_TARGET&#125;</span>) Prefix directory</span></span><br></pre></td></tr></table></figure><p>具体参数的配置方法见：<a href="/2016/06/16/crosstool-ng%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/">crosstool-ng参数配置</a></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>配置完成后使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ct-ng build</span><br></pre></td></tr></table></figure><p>命令即可开始编译。crosstool-ng会先下载所需的tar包，之后进行编译。如果没有出现错误的话，最终会在<code>Prefix directory</code>中生成所需的交叉编译链，可使用tar进行打包。使用时将其中的<code>bin</code>目录加入<code>PATH</code>中即可。</p><hr><h2 id="附：以root身份运行crosstool-ng的方法"><a href="#附：以root身份运行crosstool-ng的方法" class="headerlink" title="附：以root身份运行crosstool-ng的方法"></a>附：以root身份运行crosstool-ng的方法</h2><p>出于安全性考虑，crosstool-ng默认不能以root身份运行，如果确定要在root下运行，需要在配置中开启这一选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- Paths and misc options --</span><br><span class="line">[*] Try features marked as EXPERIMENTAL</span><br><span class="line">    [*]   Allow building as root user (READ HELP!) (NEW)</span><br></pre></td></tr></table></figure><p>在这一选项的HELP文档中，可以看到crosstool-ng的作者极力反对用root运行：）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">│ CT_ALLOW_BUILD_AS_ROOT:                                                                                                  │  </span><br><span class="line"> │                                                                                                                          │  </span><br><span class="line"> │ You normally do *not* need to be root to build a toolchain using                                                         │  </span><br><span class="line"> │ crosstool-NG. In fact, it is *VERY* dangerous to run as root, as                                                         │  </span><br><span class="line"> │ crosstool-NG will, as part of the build process, remove a few                                                            │  </span><br><span class="line"> │ directories. If anything goes wrong, running as root can ruin                                                            │  </span><br><span class="line"> │ your host distribution.                                                                                                  │  </span><br><span class="line"> │                                                                                                                          │  </span><br><span class="line"> │ I can't stress it enough:  DO  NOT  RUN  AS  ROOT  !!                                                                    │  </span><br><span class="line"> │                                                                                                                          │  </span><br><span class="line"> │ Do not run as root, you've been warned.                                                                                  │  </span><br><span class="line"> │ Do not come whining, if it nukes your host system.                                                                       │  </span><br><span class="line"> │ Do not come whining, if you lose any data.                                                                               │  </span><br><span class="line"> │ Do not run as root.                                                                                                      │  </span><br><span class="line"> │                                                                                                                          │  </span><br><span class="line"> │ Do not run as root, you've been warned.                                                                                  │  </span><br><span class="line"> │ Do not come whining, if the Earth stops rotating.                                                                        │  </span><br><span class="line"> │ Do not come whining, if kittens are smashed.                                                                             │  </span><br><span class="line"> │ Do not run as root.                                                                                                      │  </span><br><span class="line"> │                                                                                                                          │  </span><br><span class="line"> │ Do not run as root, do not run as root!                                                                                  │  </span><br><span class="line"> │ (ad libitum)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crosstool-ng的安装</title>
      <link href="/2016/06/14/crosstool-ng%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2016/06/14/crosstool-ng%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>crosstool-ng用于制作交叉编译器，其本身作为Linux下的一个软件，也需要进行编译安装。下面简要记录下安装过程。</p><a id="more"></a><p>开发环境：<br>Ubuntu 16.04 64bit<br>gcc v5.3.1<br>make v4.1</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>在crosstool-ng的首页<a href="http://crosstool-ng.org/" target="_blank" rel="noopener">crosstool-ng.org</a>上可以下载到其源代码，目前最新版本是<a href="http://crosstool-ng.org/download/crosstool-ng/crosstool-ng-1.22.0.tar.bz2" target="_blank" rel="noopener">crosstool-ng-1.22.0</a>。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>解压下载到的tar包，切换到<code>crosstool-ng</code>文件夹中执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>这一步的目的是生成<code>Makefile</code>文件，使用<code>configure</code>的默认配置即可。</p><p>在Ubuntu环境下，因为安装的开发工具不全，可能会提示缺少一些工具，这时候用<code>apt-get</code>安装缺少的工具即可。不过有几个提示不是那么直接：</p><p>错误提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure: error: missing required tool: makeinfo</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install texinfo</span><br></pre></td></tr></table></figure><hr><p>错误提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure: error: could not find GNU awk</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gawk</span><br></pre></td></tr></table></figure><hr><p>错误提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure: error: could not find GNU libtool &gt;= 1.5.26</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libtool libtool-bin</span><br></pre></td></tr></table></figure><p>这里仅安装<code>libtool</code>是不够的，还需要安装<code>libtool-bin</code>。</p><hr><p>错误提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure: error: could not find curses header, required for the kconfig frontends</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure><p>这里缺少的是<code>ncurses</code>这个库，对应的Ubuntu下的包是<code>libncurses5-dev</code>。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>配置完生成<code>Makefile</code>后直接用<code>make</code>进行编译即可，这一步在我使用的开发环境下没有发生任何错误。可能出现的错误及解决方法可参考<a href="http://www.crifan.com/files/doc/docbook/crosstool_ng/release/html/crosstool_ng.html#crosstoool_ng_install_self_common_errors" target="_blank" rel="noopener">这里的说明</a>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>编译完后使用<code>make install</code>安装即可，默认安装在<code>/usr/local/bin</code>、<code>/usr/local/lib</code>等目录下，如需更改安装目录，可在<code>./configure</code>配置时进行设置，具体可使用<code>./configure -h</code>命令查看帮助文档中的说明。一般来说，<code>/usr/local/bin</code>目录已经在环境变量<code>PATH</code>中了，故不需要再手动添加。</p><p>安装完成后使用<code>ct-ng version</code>命令进行测试，如果能正确输出如下版本信息说明安装正确：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">This is crosstool-NG version crosstool-ng-1.22.0</span><br><span class="line"></span><br><span class="line">Copyright (C) 2008  Yann E. MORIN &lt;yann.morin.1998@free.fr&gt;</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转编码器绝对位置测量方法</title>
      <link href="/2016/06/06/%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%9D%E5%AF%B9%E4%BD%8D%E7%BD%AE%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95/"/>
      <url>/2016/06/06/%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%9D%E5%AF%B9%E4%BD%8D%E7%BD%AE%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>一般的旋转编码器本身只能提供相对位置信息，不过配合零点信号（即Z相信号）即可确定绝对位置，下面结合TI C2000系列单片机来讨论具体实现方法。</p><a id="more"></a><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a><strong>基本原理</strong></h2><p>在C2000系列单片机中，使用QEQP模块对旋转编码器输入信号进行处理，先根据输入的A、B、Z三相信号生成<code>QCLK</code>内部时钟信号、<code>QDIR</code>方向信号及<code>QI</code>同步信号，这部分工作是由QDU（Quadrature Decoder Unit）子模块完成的。输入信号的极性，输出的来源等均可配置，具体详见数据手册。</p><p>生成的<code>QCLK</code>信号来源于A、B两相信号跳变沿，此信号与<code>QDIR</code>方向信号一起确定<code>QPOSCNT</code>寄存器的计数增减，具体时序图如下：<br><img src="https://pic.gaomf.store/20160606154932.png" alt=""></p><p>从理论上说，只要确定了一点的绝对位置，就可以通过读取<code>QPOSCNT</code>寄存器获取任意时刻的绝对位置，以两对极电机为例，示例性代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theta = _IQmpyI32(_IQ(PI / QEP_LINE), EQep1Regs.QPOSCNT);</span><br></pre></td></tr></table></figure><p><strong>此处的<code>theta</code>是电角度而不是机械角度，</strong><code>QEP_LINE</code>为编码器线数。对于两对极电机来说，假设<code>QPOSCNT</code>的初值是0，电机完整的顺时针转过一圈后<code>QPOSCNT</code>中的值应该是<code>4 * QEP_LINE</code>，使用上式计算得到的对应电角度就是<code>4PI rad</code>。</p><p>再考虑到电机的对称性及角度的周期性，<code>theta</code>的范围在<code>[0, 2PI)</code>内即可，对应的<code>QPOSCNT</code>的范围就是<code>[0, 2 * QEP_LINE)</code>。在C2000单片机中，可以通过<code>QPOSMAX</code>寄存器来设置这个最大值，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EQep1Regs.QEPCTL.bit.PCRM = <span class="number">1</span>;         <span class="comment">// 0 : QPOSCNT reset on an index event</span></span><br><span class="line">                                       <span class="comment">// 1 : QPOSCNT reset on the maximum position</span></span><br><span class="line">EQep1Regs.QPOSMAX = <span class="number">2</span> * QEP_LINE - <span class="number">1</span>;  <span class="comment">// Set the maximum position</span></span><br></pre></td></tr></table></figure><p>然而，这有两个问题，首先是初始时刻的绝对位置如何确定；其次是如何消除累积误差。解决方法是：初始时刻的绝对位置通过霍尔信号进行估测，累积误差通过Z相同步信号来消除。下面分别来讨论这两个问题。</p><h2 id="初始时刻定位"><a href="#初始时刻定位" class="headerlink" title="初始时刻定位"></a><strong>初始时刻定位</strong></h2><p>初始时刻的位置确定比较简单，只要预先测定出Ha、Hb、Hc三个霍尔信号输出与绝对角度间的关系，在启动时通过查表的方法即可大致估算出初始角度。因为这一估算过程本来就不要求也不可能精确，故也无需测定霍尔信号跳变沿的准确位置，粗略的使用示波器观察信号估计一下即可。<br>示例性代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EQep1Regs.QPOSCNT = GetHall();</span><br></pre></td></tr></table></figure><p>这句代码在初始化EQEP模块的时候调用一次，<code>GetHall()</code>函数可返回根据Hall信号猜测出的<code>QPOSCNT</code>寄存器的初值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hall signal delt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HALL_DELT  (QEP_LINE / 3)</span></span><br><span class="line"><span class="comment">// Hall signal offset</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HALLOFFSET (HALL_DELT / 2)</span></span><br><span class="line"></span><br><span class="line"><span class="function">Uint32 <span class="title">GetHall</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Uint16 Ha, Hb, Hc;</span><br><span class="line">  Uint16 HallSignal;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输入斯密特触发器处进行了取反</span></span><br><span class="line">  <span class="comment">// 此处再次取反获取原信号</span></span><br><span class="line">  Ha = ~GpioDataRegs.GPADAT.bit.GPIO9  &amp; <span class="number">0x01</span>;</span><br><span class="line">  Hb = ~GpioDataRegs.GPADAT.bit.GPIO23 &amp; <span class="number">0x01</span>;</span><br><span class="line">  Hc = ~GpioDataRegs.GPADAT.bit.GPIO10 &amp; <span class="number">0x01</span>;</span><br><span class="line"></span><br><span class="line">  HallSignal = (Ha &lt;&lt; <span class="number">2</span>) + (Hb &lt;&lt; <span class="number">1</span>) + Hc;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (HallSignal)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x00</span>:  <span class="comment">// 000</span></span><br><span class="line">    <span class="keyword">return</span> HALLOFFSET + <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x01</span>:  <span class="comment">// 001</span></span><br><span class="line">    <span class="keyword">return</span> HALLOFFSET + HALL_DELT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x03</span>:  <span class="comment">// 011</span></span><br><span class="line">    <span class="keyword">return</span> HALLOFFSET + <span class="number">2</span> * HALL_DELT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x07</span>:  <span class="comment">// 111</span></span><br><span class="line">    <span class="keyword">return</span> HALLOFFSET + <span class="number">3</span> * HALL_DELT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x06</span>:  <span class="comment">// 110</span></span><br><span class="line">    <span class="keyword">return</span> HALLOFFSET + <span class="number">4</span> * HALL_DELT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0x04</span>:  <span class="comment">// 100</span></span><br><span class="line">    <span class="keyword">return</span> HALLOFFSET + <span class="number">5</span> * HALL_DELT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    __asm (<span class="string">"      ESTOP0"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Z相同步信号"><a href="#Z相同步信号" class="headerlink" title="Z相同步信号"></a><strong>Z相同步信号</strong></h2><p>Z相信号用于对<code>QPOSCNT</code>寄存器进行同步定位，这个信号需要仔细考虑下，否则会造成之后得到的绝对位置存在误差。首先需要考虑的是，Z相信号本身是一个存在一定宽度的脉冲信号，从旋转编码器的原理上来看，正转和反转时Z相信号的上升沿和下降沿对应的绝对位置是不同的，正转时的上升沿对应反转时的下降沿，反之亦然。<strong>这就需要在正转和反转时使用不同的边沿触发同步事件</strong>，C2000单片机中可以很方便的实现这一功能，只需要设置<code>IEI</code>寄存器即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EQep1Regs.QEPCTL.bit.IEI = <span class="number">3</span>;  <span class="comment">// 0 : Does nothing</span></span><br><span class="line">                               <span class="comment">// 2 : Initializes QPOSCNT on rising edge of QEPI</span></span><br><span class="line">                               <span class="comment">// 3 : Initializes QPOSCNT on rising or falling edge of QEPI depends on direction</span></span><br></pre></td></tr></table></figure><p>同步事件发生时写入<code>QPOSCNT</code>中的值由<code>QPOSINIT</code>寄存器确定：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EQep1Regs.QPOSINIT = INDEX_OFFSET;    <span class="comment">// eQEP Position Counter Initialization Value</span></span><br></pre></td></tr></table></figure><p>这里就涉及到<code>INDEX_OFFSET</code>这个值怎么确定的问题，因为Z相脉冲并不是严格的出现于绝对零点位置处，故需要进行角度校正。</p><h2 id="角度校正"><a href="#角度校正" class="headerlink" title="角度校正"></a><strong>角度校正</strong></h2><p>角度校正的基本思想是，记录下Z相信号对应的绝对角度值，将其写入<code>QPOSINIT</code>寄存器即可，即上述代码中的<code>INDEX_OFFSET</code>宏定义的值。<strong>要确定绝对角度，必须要有一个基准，在进行角度校正时，使用预定位的方式确定绝对角度的零点。</strong></p><p>具体做法是， 使能三相逆变器，使用SVPWM算法生成一个<code>Ualpha &gt; 0；Ubeta = 0</code>的矢量，<code>Ualpha</code>不宜设置得过大，以免电流过大，此时电机会旋转至绝对零点处。之后使能EQEP模块，将<code>QPOSCNT</code>的值设为0，<code>SEI</code>设为0，以禁用<code>QI</code>信号信号的自动同步复位功能；与此同时，使能<code>IEL</code>，以便在<code>QI</code>信号发生时自动锁存<code>QPOSCNT</code>寄存器的值。以上初始化过程用代码表示如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EQep1Regs.QPOSCNT = <span class="number">0</span>;</span><br><span class="line">EQep1Regs.QEPCTL.bit.IEI = <span class="number">0</span>;  <span class="comment">// Does nothing on rising or falling edge of QEPI</span></span><br><span class="line">EQep1Regs.QEPCTL.bit.IEL = <span class="number">3</span>;  <span class="comment">// Latch QPOSCNT on rising or falling edge of QEPS depends on direction</span></span><br></pre></td></tr></table></figure><p>按照以上步骤初始化EQEP模块后，禁用三相逆变器，此时电机可以自由旋转。用手旋转电机以产生<code>QI</code>信号，此时<code>QPOSCNT</code>寄存器中的值会被自动锁存在<code>QPOSILAT</code>寄存器中，可以正反多旋转几次电机，记录下若干次<code>QPOSILAT</code>寄存器中的值取平均值即可。读取寄存器的值可以通过使用仿真器进入调试模式实现。</p><p>计算得到的平均值即<code>QI</code>信号对应的绝对角度值，将此值定义为<code>INDEX_OFFSET</code>宏写入<code>QPOSINIT</code>寄存器中即可。</p><blockquote><p>注：上述叙述假设编码器Z相信号连接至了<code>QEPI</code>输入端上，若连接至了<code>QEPS</code>输入端处，只需将<code>QI</code>相关部分改为<code>QS</code>即可，二者的功能基本相同。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor </tag>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫--使用requests获取网页</title>
      <link href="/2016/06/03/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8requests%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5/"/>
      <url>/2016/06/03/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8requests%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p><code>requests</code>包用于获取网站的内容，使用HTTP协议，基于<code>urllib3</code>实现。其官方中文文档为：<a href="http://cn.python-requests.org/zh_CN/latest/" target="_blank" rel="noopener">Requests: HTTP for Humans</a></p><p><code>requests</code>的基本使用方法很简单，这里记录一些最常用的方法，完整的介绍见其官方文档，以下介绍基于Python 3.5。</p><a id="more"></a><p> 使用<code>requests</code>首先需要导入它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br></pre></td></tr></table></figure><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p>最基本的方法是<code>GET</code>请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">'http://www.zju.edu.cn/'</span></span><br><span class="line">r = requests.get(url)</span><br></pre></td></tr></table></figure><p>返回的<code>r</code>是一个<code>Response</code>类对象，包含所有返回数据，可以从这个<code>Response</code>中提取所需的信息。</p><p>除了<code>get()</code>外，常用的请求还有<code>post()</code>，用法完全相同。除此之外<code>requests</code>也支持其它各种请求方法，具体参见其文档说明。</p><p><em>可通过<code>r.url()</code>获取请求的URL。</em></p><h2 id="读取响应内容"><a href="#读取响应内容" class="headerlink" title="读取响应内容"></a>读取响应内容</h2><p>使用<code>Response</code>的<code>text</code>属性即可:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(url)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p><code>text</code>属性是针对相应内容是文本（如HTML等）的情况下使用，如果返回的数据是二进制数据（如图片等），则通过<code>content</code>属性来读取二进制比特流：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(url)</span><br><span class="line">f = open(<span class="string">'file'</span>, <span class="string">'wb'</span>)</span><br><span class="line">f.write(r.content)</span><br></pre></td></tr></table></figure><p>如果返回的数据是json，<code>requests</code>中自带了一个解析器，可以直接使用<code>json()</code>函数进行解析，返回的是一个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">'http://ip.taobao.com/service/getIpInfo.php'</span></span><br><span class="line">payload = &#123;<span class="string">'ip'</span>: <span class="string">'23.91.98.188'</span>&#125;</span><br><span class="line">r = requests.get(url, params = payload)</span><br><span class="line">print(r.json()[<span class="string">'data'</span>][<span class="string">'country_id'</span>])</span><br></pre></td></tr></table></figure><p>上面这个例子演示了淘宝的IP查询服务。</p><h2 id="附加查询参数"><a href="#附加查询参数" class="headerlink" title="附加查询参数"></a>附加查询参数</h2><p>可以构造类似<code>http://www.baidu.com/s?ie=utf-8&amp;wd=Python</code>这样的查询URL，其中附加在<code>?</code>之后的部分就是查询参数，可以手动构造这样一个字符串，不过<code>requests</code>中提供了更优雅的解决方案，使用一个字典作为<code>params</code>参数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">'http://www.baidu.com/s'</span></span><br><span class="line">payload = &#123;<span class="string">'wd'</span>: <span class="string">'Python'</span>, <span class="string">'ie'</span>: <span class="string">'utf-8'</span>&#125;</span><br><span class="line">r = requests.get(url, params = payload)</span><br></pre></td></tr></table></figure><h2 id="附加表单"><a href="#附加表单" class="headerlink" title="附加表单"></a>附加表单</h2><p>与附加查询参数类似，在<code>POST</code>请求中，可以附加表单信息，这一般用于实现登录或提交信息等，使用一个字典作为<code>data</code>参数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = &#123;<span class="string">'username'</span>:<span class="string">'username'</span>, <span class="string">'password'</span>:<span class="string">'passwd'</span>&#125;</span><br><span class="line">r = requests.post(url, data = payload)</span><br></pre></td></tr></table></figure><h2 id="读取与设置响应数据的编码"><a href="#读取与设置响应数据的编码" class="headerlink" title="读取与设置响应数据的编码"></a>读取与设置响应数据的编码</h2><p>一般情况下<code>requests</code>均能从响应头部获得正确的编码，不过若头部没有相应信息，则需要手动设置，不然可能会出错。使用<code>Response</code>的<code>encoding</code>属性即可:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get()</span><br><span class="line">f.write(r.text, encoding = r.encoding)</span><br><span class="line">r.encoding = <span class="string">'gb2312'</span></span><br><span class="line">r.encdoing = <span class="string">'utf-8'</span></span><br></pre></td></tr></table></figure><h2 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h2><p>使用一个字典作为<code>proxies</code>参数即可，下面这段代码演示了使用ShadowSocks作为代理的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxies = &#123;</span><br><span class="line">  <span class="string">'http'</span> : <span class="string">'socks5://127.0.0.1:1080'</span>,</span><br><span class="line">  <span class="string">'https'</span>: <span class="string">'socks5://127.0.0.1:1080'</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(url, proxies=proxies)</span><br></pre></td></tr></table></figure><h2 id="获取响应状态码"><a href="#获取响应状态码" class="headerlink" title="获取响应状态码"></a>获取响应状态码</h2><p>使用<code>Response</code>的<code>status_code</code>属性即可:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(url)</span><br><span class="line">print(r.status_code)</span><br></pre></td></tr></table></figure><h2 id="自定义请求头部"><a href="#自定义请求头部" class="headerlink" title="自定义请求头部"></a>自定义请求头部</h2><p>传递一个字典作为<code>headers</code>参数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36'</span>&#125;</span><br><span class="line">r = requests.get(url, headers = header)</span><br></pre></td></tr></table></figure><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话可以跨请求保持某些参数，它也会在同一个Session实例发出的所有请求之间保持cookies。使用如下方法新建一个会话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br></pre></td></tr></table></figure><p>会话对象<code>s</code>具有主要的Requests API的所有方法。会话一般用于连续发起一系列请求的时候使用，它会自动处理cookies的问题，十分方便。</p><hr><p>相关文章：</p><p><a href="/2016/07/20/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8BeautifulSoup%E8%A7%A3%E6%9E%90HTML/">Python爬虫–使用BeautifulSoup解析HTML</a><br><a href="/2016/07/20/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8re%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90%E6%96%87%E6%9C%AC/">Python爬虫–使用re正则表达式解析文本</a></p><blockquote><p>参考资料：<br><a href="http://www.zhidaow.com/post/python-requests-install-and-brief-introduction" target="_blank" rel="noopener">python requests的安装与简单运用</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python爬虫抓取网页</title>
      <link href="/2016/06/03/%E4%BD%BF%E7%94%A8Python%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E7%BD%91%E9%A1%B5/"/>
      <url>/2016/06/03/%E4%BD%BF%E7%94%A8Python%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p>可以使用Python实现一个基本的爬虫，用来抓取网站上的特定内容。之前写过一个自动查询成绩的小程序，只是之后好久不用也忘了当初是怎么实现的了……最近又想研究下Python爬虫，故写点文章来记录一下。</p><a id="more"></a><p>使用Python实现一个爬虫的方法有很多，相关的包有<code>urllib</code>、<code>urllib2</code>、<code>requests</code>、<code>bs4</code>、<code>scrapy</code>、<code>pyspider</code>等，此处我选择了<code>requests</code> + <code>bs4</code> + <code>re</code>(正则表达式包)的解决方案。<strong><code>requests</code>用于获取网站数据，<code>bs4</code>及<code>re</code>配合用于解析获取到的HTML数据。</strong>关于学习Python爬虫的技术路线，可参考知乎上的<a href="https://www.zhihu.com/question/20899988/answer/96904827" target="_blank" rel="noopener">这个回答</a>。</p><p>需要安装requests及BeautifulSoup4这两个依赖包，最好使用<code>pip</code>自动安装：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> requests</span><br><span class="line">pip <span class="keyword">install</span> beautifulsoup4</span><br></pre></td></tr></table></figure><p>关于这几个包的具体使用参考可我的这些文章：</p><p><a href="/2016/06/03/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8requests%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5/">Python爬虫–使用requests获取网页</a><br><a href="/2016/07/20/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8BeautifulSoup%E8%A7%A3%E6%9E%90HTML/">Python爬虫–使用BeautifulSoup解析HTML</a><br><a href="/2016/07/20/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8re%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90%E6%96%87%E6%9C%AC/">Python爬虫–使用re正则表达式解析文本</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NFS服务器的搭建</title>
      <link href="/2016/05/30/NFS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2016/05/30/NFS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">NFS</a>是Network File System的缩写，用于在Linux系统间实现磁盘文件共享。严格来说NFS是一种文件系统（类似Ext2、FAT32等），而不是一种传输协议（如FTP、HTTP等），它依赖于<a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8" target="_blank" rel="noopener">RPC协议</a>进行数据传输。</p><p>下面以Ubuntu 14.04为例，介绍NFS的搭建方法。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure><p><code>apt-get</code>会自动安装所有依赖包。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h2><p>NFS的配置文件为<code>/etc/exports</code>，编辑此文件，格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">共享路径      允许IP段(参数)</span><br><span class="line"><span class="comment"># 示例如下：</span></span><br><span class="line">/root/nfs    *(rw,sync,no_root_squash,no_subtree_check)</span><br></pre></td></tr></table></figure><p>上述参数设置也是最常用的设置，全部可用参数及其含义可参考<a href="http://blog.csdn.net/yusiguyuan/article/details/9494385" target="_blank" rel="noopener">这篇文章</a>。另外，使用<code>man exports</code>命令可以获得关于此文件更详细的说明。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a><strong>运行</strong></h2><h3 id="开启NFS"><a href="#开启NFS" class="headerlink" title="开启NFS"></a>开启NFS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/nfs-kernel-server start</span><br></pre></td></tr></table></figure><h3 id="停止NFS"><a href="#停止NFS" class="headerlink" title="停止NFS"></a>停止NFS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/nfs-kernel-server stop</span><br></pre></td></tr></table></figure><h3 id="重启NFS"><a href="#重启NFS" class="headerlink" title="重启NFS"></a>重启NFS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/nfs-kernel-server restart</span><br></pre></td></tr></table></figure><h3 id="测试运行情况"><a href="#测试运行情况" class="headerlink" title="测试运行情况"></a>测试运行情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showmount -e</span><br></pre></td></tr></table></figure><p>如果NFS已启用，此命令会显示出共享目录。</p><h3 id="查看挂载点情况"><a href="#查看挂载点情况" class="headerlink" title="查看挂载点情况"></a>查看挂载点情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showmount -a</span><br></pre></td></tr></table></figure><p>显示已与客户端连上的目录信息</p><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t nfs NFS服务器IP:共享目录 本地挂载点目录</span><br></pre></td></tr></table></figure><hr><p>注：</p><blockquote><p>目前较新版本的NFS已不依赖于portmap，而使用rpcbind代替，网上相关文章中与portmap相关的部分已不再需要。</p></blockquote><p>参考：</p><blockquote><p><a href="http://lxw66.blog.51cto.com/5547576/1308679" target="_blank" rel="noopener">Linux下nfs搭建</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot中IP地址设置方法</title>
      <link href="/2016/05/30/U-Boot%E4%B8%ADIP%E5%9C%B0%E5%9D%80%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
      <url>/2016/05/30/U-Boot%E4%B8%ADIP%E5%9C%B0%E5%9D%80%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>U-Boot中网络IP、网关等的设置保存在环境变量中，一共有下面这几个：</p><table><thead><tr><th>名称</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>ethaddr</code></td><td>MAC地址</td><td><code>08:08:11:18:12:27</code></td></tr><tr><td><code>ipaddr</code></td><td>本地IP地址</td><td><code>192.168.1.7</code></td></tr><tr><td><code>serverip</code></td><td>提供下载服务的计算机IP地址</td><td><code>192.168.1.3</code></td></tr><tr><td><code>getewayip</code></td><td>网关IP地址</td><td><code>192.168.1.1</code></td></tr><tr><td><code>netmask</code></td><td>子网掩码</td><td><code>255.255.255.0</code></td></tr></tbody></table><p>使用<code>setenv</code>命令进行设置，使用<code>printenv</code>命令查看目前环境变量，最后如果需要永久保存当前环境变量设置的话使用<code>saveenv</code>命令保存。</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot版本命名规则及源码下载途径</title>
      <link href="/2016/05/27/U-Boot%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E5%8F%8A%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E9%80%94%E5%BE%84/"/>
      <url>/2016/05/27/U-Boot%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E5%8F%8A%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E9%80%94%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>U-Boot的正式发布版本（即Released Versions）每2个月更新一次，并且正常情况下都是在此月中旬的某个周一进行更新，这被称为“<a href="http://www.denx.de/wiki/U-Boot/ReleaseCycle" target="_blank" rel="noopener">U-Boot Release Cycle</a>”。<br>U-Boot所有发布版本的源码皆可以从其官方ftp上下载到，地址为：<a href="ftp://ftp.denx.de/pub/u-boot/" target="_blank" rel="noopener">ftp://ftp.denx.de/pub/u-boot/</a></p><a id="more"></a><p>其源代码使用Git进行管理，如果想获取最新的代码或参与贡献代码，可追踪其<a href="http://git.denx.de/u-boot.git/" target="_blank" rel="noopener">Git Repository</a>。</p><p>自从2008年10月之后，U-Boot正式发布版本的命名就使用了基于时间戳的版本号，版本号中包含发布年份及月份，rc后缀代表Release Candidate。几个例子如下：</p><blockquote><p>U-Boot v2009.11     - Release November 2009<br>U-Boot v2009.11.1   - Release 1 in version November 2009 stable tree<br>U-Boot v2010.09-rc1 - Release candidate 1 for September 2010 release</p></blockquote><p>如对各发布版本的一些统计信息有兴趣，可参考其官网上的<a href="http://www.denx.de/wiki/U-Boot/ReleaseCycle" target="_blank" rel="noopener">Statistics</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 点滴之间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中实现多线程的方法</title>
      <link href="/2016/05/24/Android%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2016/05/24/Android%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在Android中，所有耗时操作都不能放在主线程（即UI线程）中执行，否则会引起ANR异常，进而导致应用程序崩溃。解决办法是使用多线程，将耗时操作放到异步子线程中执行。</p><p>Android中实现多线程有两种基本方法：<br><strong>1. Thread + Handler</strong><br><strong>2. AsyncTask</strong></p><a id="more"></a><p>其中AsyncTask可以视为是对Thread + Handler机制的再次封装实现。<strong>一般来说，数据简单、耗时较短的单个后台异步处理使用AsyncTask，此方法实现代码较为简单，而且更新UI控件更为简单；而执行时间长且逻辑复杂的多后台任务则使用Thread + Handler，此方法与AsyncTask相比能更好的利用系统资源，但是和UI线程的通信会更为复杂。</strong></p><p>Android系统推荐使用AsyncTask来处理简单的异步操作，<strong>通常是在Activity中通过内部类的方式来使用AsyncTask，若不使用内部类，则无法直接更新UI控件，这就失去了使用AsyncTask的意义，不如直接使用Thread + Handler机制来实现多线程。</strong></p><p>在Android中，线程池是有限的，创建过多的异步线程会导致ANR异常，除此之外，使用AsyncTask还需要注意以下<a href="http://ruikye.com/2014/08/28/AsyncTask-%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">这些问题</a>：</p><blockquote><ol><li>由于 AsyncTask 内部的线程池是 static 类型，整个进程共用一个线程池；如果使用不当，会产生阻塞问题，尤其是单任务顺序执行的情况下，一个任务执行时间过长会阻塞其他任务的执行</li><li>static 线程另外一个问题是，如果第一次调用 AsyncTask 在非 UI 线程中，那么以后使用 AsyncTask时，onPosExecute 也会在非 UI 线程中，此时如果执行 UI 操作会 Crash，所以第一次使用 AsyncTask 一定要在 UI 线程中使用，尤其是使用第三方 SDK 时要注意这点</li><li>通常使用 AsyncTask 是在 Activity 中使用匿名的内部类来使用，内部类的一个问题是会保持外部类的实例，如果 AsyncTask 中的异步任务在 Activity 退出时还没执行完或者阻塞了，那么这个保持的外部的 Activity 实例得不到释放，会引起 OOM 问题，解决办法是：在 AsyncTask 使用弱引用外部实例，或者保证在 Activity 退出时，所有的 AsyncTask 已执行完成或被取消</li></ol></blockquote><p>关于AsyncTask导致的内存泄漏问题，可参考下面这篇文章：</p><blockquote><p><a href="http://huxian99.github.io/2015/09/15/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8DAsyncTask%E7%9A%84%E4%B8%8D%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">Android内存泄漏－AsyncTask的不正确使用</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C28x IQmath库使用</title>
      <link href="/2016/05/15/IQmath%E5%BA%93%E6%80%BB%E7%BB%93/"/>
      <url>/2016/05/15/IQmath%E5%BA%93%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>IQmath库是TI C28x系列DSP中使用的一个高度优化且高精度的数学库，用于使用定点算法实现浮点运算。在DSP编程中，出于性能的考虑，应尽量使用IQmath库代替ANSI C中的math库。IQmath库同时支持C和C++，此处仅讨论使用C语言的情况。</p><p>IQmath的官方使用手册为<code>SPRC990 C28x IQmath Library</code>，在ControlSUITE中可以找到这份文档的最新版本。</p><a id="more"></a><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h2><ol><li><strong>添加库文件<code>IQmath.lib</code>或<code>IQmath_f32.lib</code>，后者用于带FPU单元的DSP；</strong></li><li><strong>包含头文件<code>IQmathLib.h</code>；</strong></li><li><strong>修改CMD文件，添加其中与IQmath相关的部分。</strong></li></ol><h2 id="Q格式"><a href="#Q格式" class="headerlink" title="Q格式"></a><strong>Q格式</strong></h2><p><a href="https://en.wikipedia.org/wiki/Q_%28number_format%29" target="_blank" rel="noopener">Q格式</a>是一种定点小数表示方法，具体来说，二者的转换关系为：</p><p>*<em>定点数 = 浮点数 * 2^Q *</em></p><p>在C2000中，统一使用32位来表示。Q<em>N</em>格式对应数据类型为_iq<em>N</em>，表示使用<em>N</em>位来表示小数，其余32-<em>N</em>位表示整数，故Q0其实就是一般的32位整数。具体的Q1~Q30的取值范围及精度见下表：</p><p><img src="https://pic.gaomf.store/20160515095003.png" alt=""></p><p><code>_iq</code>类型代表使用<code>GLOBAL_Q</code>定义的精度，<code>GLOBAL_Q</code>在<code>IQmathLib.h</code>文件中定义，默认为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GLOBAL_Q</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLOBAL_Q 24 <span class="comment">/* Q1 to Q29 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可直接更改<code>IQmathLib.h</code>文件中的定义，也可使用如下方法覆盖此定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLOBAL_Q 21 <span class="comment">/* Set the Local Q value */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IQmathLib.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a><strong>常用函数</strong></h2><p>函数命名惯例为：<code>_IQNxxx()</code>，其中<code>N</code>代表使用的Q格式，省略的话使用<code>GLOBAL_Q</code>中的定义；<code>xxx</code>为函数名，如<code>sin</code>、<code>exp</code>等。下面列举一些常用函数，其中的<code>N</code>大部分都可以省略使用<code>GLOBAL_Q</code>。</p><h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><table><thead><tr><th>函数原型</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>_iqN _IQN(float F)</code></strong></td><td>将<code>float</code>转为<code>_iqN</code>格式</td></tr><tr><td><strong><code>float _IQNtoF(_qiN A)</code></strong></td><td>将<code>_iqN</code>格式转为<code>float</code></td></tr><tr><td><strong><code>_iqN _IQtoIQN(_iq A)</code></strong></td><td>将全局<code>_iq</code>格式转为<code>_iqN</code>格式</td></tr><tr><td><strong><code>_iq _IQNtoIQ(_iqN A)</code></strong></td><td>将<code>_iqN</code>格式转为全局<code>_iq</code>格式</td></tr><tr><td><strong><code>long _IQNint(_iqN A)</code></strong></td><td>提取整数部分</td></tr><tr><td><strong><code>_iqN _IQNfrac(_iqN A)</code></strong></td><td>提取小数部分</td></tr><tr><td><strong><code>_iqN _atoIQN(char *S)</code></strong></td><td>将字符串转为<code>_iqN</code>格式</td></tr><tr><td><strong><code>int _IQNtoa(char *S, const *format, long x)</code></strong></td><td>将<code>_iqN</code>格式转为字符串</td></tr></tbody></table><h3 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h3><p>对于相同<code>_iqN</code>格式的两个数之间的加减法，可以使用<code>+</code>、<code>-</code>直接进行，注意不要溢出即可；对于不同<code>_iqN</code>格式的两个数，需要转换为相同<code>_iqN</code>格式后再进行加减。</p><table><thead><tr><th>函数原型</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>_iqN _IQNmpy(_iqN A, _iqN B)</code></strong></td><td>基本乘法</td></tr><tr><td><strong><code>_iqN _IQNrsmpy(_iqN A, _iqN B)</code></strong></td><td>带凑整(rounding)和饱和(saturation)的乘法</td></tr><tr><td><strong><code>_iqN _IQNmpyI32(_iqN A, long B)</code></strong></td><td><code>_iqN</code>与<code>long</code>相乘</td></tr><tr><td><strong><code>_iqN _IQNdiv(_iqN A, _iqN B)</code></strong></td><td>基本除法</td></tr></tbody></table><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><table><thead><tr><th>函数原型</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>_iqN _IQNsin(_iqN A)</code></strong></td><td>正弦</td></tr><tr><td><strong><code>_iqN _IQNcos(_iqN A)</code></strong></td><td>余弦</td></tr><tr><td><strong><code>_iqN _IQNtan(_iqN A)</code></strong></td><td>正切</td></tr><tr><td><strong><code>_iqN _IQNasin(_iqN A)</code></strong></td><td>反正弦</td></tr><tr><td><strong><code>_iqN _IQNacos(_iqN A)</code></strong></td><td>反余弦</td></tr><tr><td><strong><code>_iqN _IQNatan(_iqN A)</code></strong></td><td>反正切</td></tr></tbody></table><h3 id="其它常用函数"><a href="#其它常用函数" class="headerlink" title="其它常用函数"></a>其它常用函数</h3><table><thead><tr><th>函数原型</th><th>说明</th></tr></thead><tbody><tr><td><strong><code>_iqN _IQNabs(_iqN A)</code></strong></td><td>绝对值</td></tr><tr><td><strong><code>_iqN _IQNexp(_iqN A)</code></strong></td><td>exp</td></tr><tr><td><strong><code>_iqN _IQNlog(_iqN A)</code></strong></td><td>自然对数</td></tr><tr><td><strong><code>_iqN _IQNsqrt(_iqN A)</code></strong></td><td>开平方</td></tr><tr><td><strong><code>_iqN _IQNisqrt(_iqN A)</code></strong></td><td>开平方后取倒数</td></tr><tr><td><strong><code>_iqN _IQNmag(_iqN A, _iqN B)</code></strong></td><td>欧氏距离</td></tr></tbody></table><h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><p>完整的IQmath函数及性能评估表如下：<br><img src="https://pic.gaomf.store/20160515101508.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体内存边界对齐问题</title>
      <link href="/2016/04/28/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E8%BE%B9%E7%95%8C%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/"/>
      <url>/2016/04/28/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E8%BE%B9%E7%95%8C%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>结构体成员在内存中并不是紧凑排列的，这就是所谓的结构体内存边界对齐问题，默认情况下会按照其自然边界对齐，本文将具体研究下这一问题。</p><a id="more"></a><p>先来看一个简单的小程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span>  a;</span><br><span class="line">  <span class="keyword">int</span>   b;</span><br><span class="line">  <span class="keyword">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TestStruct</span> <span class="title">MyStruct</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Struct size is : %d\n"</span>, <span class="keyword">sizeof</span>(MyStruct));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Offset of a is: %p\n"</span>, (<span class="keyword">char</span> *)&amp;MyStruct.a - (<span class="keyword">char</span> *)&amp;MyStruct);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Offset of b is: %p\n"</span>, (<span class="keyword">char</span> *)&amp;MyStruct.b - (<span class="keyword">char</span> *)&amp;MyStruct);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Offset of c is: %p\n\n"</span>, (<span class="keyword">char</span> *)&amp;MyStruct.c - (<span class="keyword">char</span> *)&amp;MyStruct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用GCC编译运行，输出结果为：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Struct size <span class="keyword">is</span> : <span class="number">12</span></span><br><span class="line"><span class="keyword">Offset</span> <span class="keyword">of</span> a <span class="keyword">is</span>: <span class="number">00000000</span></span><br><span class="line"><span class="keyword">Offset</span> <span class="keyword">of</span> b <span class="keyword">is</span>: <span class="number">00000004</span></span><br><span class="line"><span class="keyword">Offset</span> <span class="keyword">of</span> c <span class="keyword">is</span>: <span class="number">00000008</span></span><br></pre></td></tr></table></figure><p>从结果中可以很明显的看到，<strong>结构体成员在内存中并不是紧凑排列的</strong>，这就是所谓的内存边界对齐问题。进行结构体内存边界对齐是为了让CPU读取数据时效率达到最大化，关于这个问题此处不深入研究，仅引用一个<a href="http://blog.csdn.net/wengwuzi/article/details/3177576" target="_blank" rel="noopener">网上的解释</a>：</p><blockquote><p>字，双字，和四字在自然边界上不需要在内存中对齐。（对字，双字，和四字来说，自然边界分别是偶数地址，可以被4整除的地址，和可以被8整除的地址。）<br>无论如何，为了提高程序的性能，数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；然而，对齐的内存访问仅需要一次访问。<br>一个字或双字操作数跨越了4字节边界，或者一个四字操作数跨越了8字节边界，被认为是未对齐的，从而需要两次总线周期来访问内存。一个字起始地址是奇数但却没有跨越字边界被认为是对齐的，能够在一个总线周期中被访问。<br>某些操作双四字的指令需要内存操作数在自然边界上对齐。如果操作数没有对齐，这些指令将会产生一个通用保护异常（#GP）。双四字的自然边界是能够被16 整除的地址。其他的操作双四字的指令允许未对齐的访问（不会产生通用保护异常），然而，需要额外的内存总线周期来访问内存中未对齐的数据。 </p></blockquote><p>下面主要分析一下编译器是如何处理结构体内存边界对齐问题的。</p><!--more--><h2 id="自然边界对齐"><a href="#自然边界对齐" class="headerlink" title="自然边界对齐"></a><strong>自然边界对齐</strong></h2><p>如果不手动指定对齐方式，就按照自然边界对齐原则进行对齐。<br><strong>所谓自然边界，对于8bit数据来说，任何地址都是其自然边界；对于16bit数据来说，偶数地址是其自然边界（即最低位地址为0）;对于32bit数据来说，能被4整除的地址是其自然边界（即最低两位地址为0）；对于64bit数据来说，能被8整除的地址是其自然边界（即最低3位地址为0）。</strong></p><p>结构体按照自然边界对齐原则进行对齐即是指：</p><ul><li><strong>结构体中的每个成员都存放在其自然边界上;</strong></li><li><strong>各个成员严格按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同；</strong></li><li><strong>结构体整体的对齐方式与其成员中长度最长那个元素相同；</strong></li><li><strong>为满足以上要求，在成员间和结构体最后可使用空字节进行填充。</strong></li></ul><p>根据以上原则就很好理解默认对齐方式了，下面给出几种结构体声明方式及其对应的内存分配情况图。图中每一个单元格代表一字节数据，灰色部分代表不属于此结构体的部分。</p><h3 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span>  a;</span><br><span class="line">  <span class="keyword">int</span>   b;</span><br><span class="line">  <span class="keyword">short</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://pic.gaomf.store/20160428151020.png" alt=""></p><h3 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span>   a;</span><br><span class="line">  <span class="keyword">char</span>  b;</span><br><span class="line">  <span class="keyword">short</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://pic.gaomf.store/20160428151511.png" alt=""></p><h3 id="Case-3"><a href="#Case-3" class="headerlink" title="Case 3"></a>Case 3</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">short </span>a<span class="comment">;</span></span><br><span class="line">  char  <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">short </span>c<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic.gaomf.store/20160428151945.png" alt=""></p><h3 id="Case-4"><a href="#Case-4" class="headerlink" title="Case 4"></a>Case 4</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> a;</span><br><span class="line">  <span class="keyword">int</span>  b;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://pic.gaomf.store/20160428152324.png" alt=""></p><h2 id="指定边界对齐"><a href="#指定边界对齐" class="headerlink" title="指定边界对齐"></a><strong>指定边界对齐</strong></h2><p>可使用一些编译器预处理指令来手动指定对齐方式，不同的编译器有不同的预处理指令，此处仅简要总结下GCC中的预处理指令。</p><h3 id="pragma-pack-n"><a href="#pragma-pack-n" class="headerlink" title="#pragma pack(n)"></a><strong>#pragma pack(n)</strong></h3><p>其中<code>n</code>必须为2的若干次幂，如1，2，4，8，16等；若不指定n，相当于恢复默认的自然边界对齐方式。这个指令的效果是：<strong>按照<code>#pragma pack</code>指定的数值和这个数据成员自身长度中比较小的值来对齐。</strong>也就是说，当<code>#pragma pack</code>的值等于或超过所有数据成员长度的时候，这个值的大小将不产生任何效果，也就是说，这条指令仅可用于减小间隙。</p><p>用自然边界对齐中的Case 1为例，使用<code>#pragma pack(1)</code>强制对齐至1字节地址处：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span>  a;</span><br><span class="line">  <span class="keyword">int</span>   b;</span><br><span class="line">  <span class="keyword">short</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>程序输入为：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Struct size <span class="keyword">is</span> : <span class="number">7</span></span><br><span class="line"><span class="keyword">Offset</span> <span class="keyword">of</span> a <span class="keyword">is</span>: <span class="number">00000000</span></span><br><span class="line"><span class="keyword">Offset</span> <span class="keyword">of</span> b <span class="keyword">is</span>: <span class="number">00000001</span></span><br><span class="line"><span class="keyword">Offset</span> <span class="keyword">of</span> c <span class="keyword">is</span>: <span class="number">00000005</span></span><br></pre></td></tr></table></figure><p>内存分配情况如下所示：<br><img src="https://pic.gaomf.store/20160428155020.png" alt=""></p><h3 id="attribute-aligned-n"><a href="#attribute-aligned-n" class="headerlink" title="__attribute((aligned(n)))"></a><strong>__attribute((aligned(n)))</strong></h3><p>同样，<code>n</code>需要为2的若干次幂，这条指令仅可以用于增加间隙。</p><p>用自然边界对齐中的Case 2为例，使用<code>__attribute((aligned(4)))</code>将每个成员都强制对齐至4字节地址处：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span>   a <span class="constructor">__attribute((<span class="params">aligned</span>(4)</span>));</span><br><span class="line">  <span class="built_in">char</span>  b <span class="constructor">__attribute((<span class="params">aligned</span>(4)</span>));</span><br><span class="line">  short c <span class="constructor">__attribute((<span class="params">aligned</span>(4)</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>程序输出为：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Struct size <span class="keyword">is</span> : <span class="number">12</span></span><br><span class="line"><span class="keyword">Offset</span> <span class="keyword">of</span> a <span class="keyword">is</span>: <span class="number">00000000</span></span><br><span class="line"><span class="keyword">Offset</span> <span class="keyword">of</span> b <span class="keyword">is</span>: <span class="number">00000004</span></span><br><span class="line"><span class="keyword">Offset</span> <span class="keyword">of</span> c <span class="keyword">is</span>: <span class="number">00000008</span></span><br></pre></td></tr></table></figure><p>内存分配情况如下图：<br><img src="https://pic.gaomf.store/20160428160448.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> C </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM Cortex-M内核复位启动过程分析</title>
      <link href="/2016/04/27/ARM%20Cortex-M%E5%86%85%E6%A0%B8%E5%A4%8D%E4%BD%8D%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2016/04/27/ARM%20Cortex-M%E5%86%85%E6%A0%B8%E5%A4%8D%E4%BD%8D%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>ARM Cortex-M内核的复位启动过程也被称为复位序列(Reset sequence)，下面就来简要总结分析下这一过程。</p><a id="more"></a><p>ARM Cortex-M内核的复位启动过程与其他大部分CPU不同，也与之前的ARM架构（ARM920T、ARM7TDMI等）不相同。大部分CPU复位后都是从<code>0x0000_0000</code>处取得第一条指令开始运行的，然而在ARM Cortex-M内核中并不是这样的。其复位序列为：</p><ol><li><strong>从地址<code>0x0000_0000</code>处取出<code>MSP</code>的初始值；</strong></li><li><strong>从地址<code>0x0000_0004</code>处取出<code>PC</code>的初始值，然后从这个值对应的地址处取指。</strong></li></ol><p>即下图所示过程：<br><img src="https://pic.gaomf.store/20160427172324.png" alt=""></p><p>事实上，地址<code>0x0000_0004</code>开始存放的就是默认中断向量表（有些资料中将地址<code>0x0000_0000</code>处的MSP指针初始值也算作中断向量表的一部分，这个说法似乎不太妥当），ARM Cortex-M内核的中断向量表布局情况如下图所示：</p><p><img src="https://pic.gaomf.store/20160427200250.png" alt=""></p><p><em>注意：中断向量表的位置可以改变，此处是默认情况下的设置。</em></p><p><strong>值得注意的是，在ARM Cortex-M内核中，发生异常后，并不是去执行中断向量表中对应位置处的代码，而是将对应位置处的数据存入<code>PC</code>中，然后去此地址处进行取指。简而言之，在ARM Cortex-M的中断向量表中不应该放置跳转指令，而是该放置ISR程序的入口地址。</strong></p><p>有了上面的分析就很好理解复位序列了，复位其实就相当于发生了一次<code>Reset</code>异常，而从图中可以看到，地址<code>0x0000_0004</code>处存放的正是<code>Reset</code>异常对应的中断处理函数入口地址。</p><p>另外还有两个细节问题需要注意：</p><ol><li><code>0x0000_0000</code>处存放的<code>MSP</code>初始值最低三位需要是0；</li><li><strong><code>0x0000_0004</code>处存放的地址最低位必须是1。</strong></li></ol><p>第一个问题是因为ARM AAPCS中对栈使用的约定是这样的：</p><blockquote><p>5.2.1.1<br>Universal stack constraints<br>At all times the following basic constraints must hold:<br>Stack-limit &lt; SP &lt;= stack-base. The stack pointer must lie within the extent of the stack.<br>SP mod 4 = 0. The stack must at all times be aligned to a word boundary.<br>5.2.1.2<br>Stack constraints at a public interface<br>The stack must also conform to the following constraint at a public interface:<br>SP mod 8 = 0. The stack must be double-word aligned.</p></blockquote><p>简而言之，规约规定，栈任何时候都必须4字节对齐，在调用入口需8字节对齐，而且<code>SP</code>的最低两位在硬件上就被置为0了。</p><p>第二个问题与<code>ARM</code>模式与<code>Thumb</code>模式有关。ARM中<code>PC</code>中的地址必须是32位对齐的，其最低两位也被硬件上置0了，故写入<code>PC</code>中的数据最低两位并不代表真实的取址地址。ARM中使用最低一位来判断这条指令是<code>ARM</code>指令还是<code>Thumb</code>指令，<strong>若最低位为0，代表<code>ARM</code>指令；若最低位为1，代表<code>Thumb</code>指令</strong>。在Cortex-M内核中，并不支持<code>ARM</code>模式，若强行切换到<code>ARM</code>模式会引发一个Hard Fault。</p><hr><p>最后写一段小程序来验证下以上分析。这段程序基于STM32F4系列单片机，作用是让<code>PA0</code>管脚输出高电平。这应该也是实现这一目的最精简的写法了。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">rAHB1ENR</span>        <span class="meta">EQU</span>     <span class="number">0x40023830</span></span><br><span class="line"><span class="symbol">AHB1ENRValue</span>    <span class="meta">EQU</span>     <span class="number">0x00000001</span></span><br><span class="line">    </span><br><span class="line"><span class="symbol">rMODER</span>          <span class="meta">EQU</span>     <span class="number">0x40020000</span></span><br><span class="line"><span class="symbol">MODERValue</span>      <span class="meta">EQU</span>     <span class="number">0xA8000001</span></span><br><span class="line">    </span><br><span class="line"><span class="symbol">rODR</span>            <span class="meta">EQU</span>     <span class="number">0x40020014</span></span><br><span class="line"><span class="symbol">ODRVaule</span>        <span class="meta">EQU</span>     <span class="number">0x00000001</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">AREA</span> RESET, <span class="meta">DATA</span>, <span class="meta">READONLY</span></span><br><span class="line">    <span class="meta">DCD</span> <span class="number">0x00000400</span></span><br><span class="line">    <span class="meta">DCD</span> Start</span><br><span class="line"></span><br><span class="line">    <span class="meta">AREA</span> <span class="title">|.text|</span>, <span class="meta">CODE</span>, <span class="meta">READONLY</span></span><br><span class="line">    <span class="meta">ENTRY</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">Start</span></span><br><span class="line">    <span class="keyword">LDR </span><span class="built_in">R0</span>, <span class="symbol">=rAHB1ENR</span></span><br><span class="line">    <span class="keyword">LDR </span><span class="built_in">R1</span>, <span class="symbol">=AHB1ENRValue</span></span><br><span class="line">    <span class="keyword">STR </span><span class="built_in">R1</span>, [<span class="built_in">R0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">LDR </span><span class="built_in">R0</span>, <span class="symbol">=rMODER</span></span><br><span class="line">    <span class="keyword">LDR </span><span class="built_in">R1</span>, <span class="symbol">=MODERValue</span></span><br><span class="line">    <span class="keyword">STR </span><span class="built_in">R1</span>, [<span class="built_in">R0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">LDR </span><span class="built_in">R0</span>, <span class="symbol">=rODR</span></span><br><span class="line">    <span class="keyword">LDR </span><span class="built_in">R1</span>, <span class="symbol">=ODRVaule</span></span><br><span class="line">    <span class="keyword">STR </span><span class="built_in">R1</span>, [<span class="built_in">R0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">B </span>.  </span><br><span class="line">    <span class="meta">END</span></span><br></pre></td></tr></table></figure><p>第11行使用<code>DCD</code>伪指令分配了4个字节的存储空间，并将其值设置为<code>0x0000_0400</code>；第12行同理，将<code>Start</code>标号处的地址放置在偏移量为4字节的位置处；第17行<code>Start</code>标号之后的部分就是程序主体，依次完成了GPIOA端口RCC时钟使能、PA0设置为输出模式、PA0置高这三个步骤。</p><p>程序在链接时会将<code>RESET</code>段放置在目标文件开头，故相当于在地址<code>0x0000_0000</code>处的数据为<code>0x0000_0400</code>，在地址<code>0x0000_0004</code>处的数据为<code>Start</code>部分的入口地址。</p><p>不过需要指出的是，实际上在STM32F4芯片中，内部Flash的地址是从<code>0x0800_0000</code>处开始的，在BOOT管脚设置为Flash启动的时候，芯片内部会自动将<code>0x0000_0000</code><del><code>0x000F_FFFF</code>区域映射至<code>0x0800_0000</code></del><code>0x080F_FFFF</code>处，此时可以视为二者是等价的。</p><p>使用Debug模式进行调试，复位后CPU寄存器的值如下所示：<br><img src="https://pic.gaomf.store/20160427215016.png" alt=""></p><p>Flash中的数据如图：<br><img src="https://pic.gaomf.store/20160427215242.png" alt=""></p><p>可以看到，编译器很智能的将<code>0x0800_0004</code>处的数据设置为了<code>0x0800_0009</code>，而不是<code>Start</code>标号真实的地址值，这说明了这是一条<code>Thumb-2</code>指令。复位后<code>PC</code>中的值是<code>0x0800_0008</code>，<code>SP</code>中的值是<code>0x0000_0400</code>，与预期结果完全相同。</p><p><em>最后顺便提一下，上面那段简单的程序有个问题，实际上<code>Start</code>部分的程序是占用了中断向量表的空间，这在没有异常发生的时候是没有问题的，不过一旦有异常发生，显然程序执行是会出错的。</em></p>]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
            <tag> Bootrom </tag>
            
            <tag> Top </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Socket Error： Address already in use的解决办法</title>
      <link href="/2016/04/27/Python%20Socket%20Error%20Address%20already%20in%20use%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2016/04/27/Python%20Socket%20Error%20Address%20already%20in%20use%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>之前用Python写了个简单的TCP通信程序，放在腾讯云上24小时运行。不过有个问题，有时候使用<code>kill -9 pid</code>命令结束掉python进程后，再次运行程序就会提示<code>Address already in use</code>这个错误，然而等一段时间再去运行就可以了。</p><p>造成这个问题的原因在于此时TCP连接还没有完全关闭，而Socket默认不支持地址复用。深入的原因打算等之后仔细学习TCP/IP协议的时候再来研究，目前只是要找一个解决方案。</p><a id="more"></a><p>找到的解决方案也很简单，在绑定前调用<code>setsockopt()</code>函数让Socket允许地址复用即可，即以下代码：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MySocket = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_STREAM)</span><br><span class="line">MySocket.setsockopt(<span class="built_in">socket</span>.SOL_SOCKET, <span class="built_in">socket</span>.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">MySocket.bind(TCPADDR)</span><br></pre></td></tr></table></figure><p>第2行代码就是调用<code>setsockopt()</code>函数，其中<code>SOL_SOCKET</code>代表对Socket层进行设置，<code>SO_REUSEADDR</code>代表是否允许在bind过程中本地地址可重复使用，最后的<code>1</code>表示允许。</p>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
            <tag> Debug </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C2000 DSP中全局变量清零问题</title>
      <link href="/2016/04/24/C2000%20DSP%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%B8%85%E9%9B%B6%E9%97%AE%E9%A2%98/"/>
      <url>/2016/04/24/C2000%20DSP%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%B8%85%E9%9B%B6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>一般情况下，未明确赋初值的全局变量会被自动清零，而且ANSI C中<em>似乎</em>也有这一规定，之前写程序都默认这是没有例外的规定了。然而，前段时间在调试28030程序的时候发现，未赋初值的全局变量并没有被清零，而是一个随机值，这说明<strong>在TI的DSP中，全局变量并不会自动清零</strong>。TI论坛中的<a href="http://www.deyisupport.com/question_answer/microcontrollers/c2000/f/56/t/101473.aspx" target="_blank" rel="noopener">这个讨论</a>也证实了这一结论，由此可见，TI的编译器的确有些很特别的地方……下面来具体谈谈全局变量清零这个问题。</p><a id="more"></a><p>全局变量一般被称为<code>.bss</code>段，ARM编译器中也将其称为<code>ZI-data</code>段，即”Zero Initialize”之意。<code>.bss</code>段是不占用ROM空间的，程序运行起来后<code>.bss</code>段显然应该是在RAM中的，这就有一个问题，RAM中的<code>.bss</code>段是什么时候完成清零的呢？答案是在进入<code>main()</code>函数之前，由启动代码或库函数完成清零操作，如果使用了操作系统，则由Bootloader完成这一工作。</p><p>以ARM MDK附带的启动代码为例，在执行完使用汇编语言编写的启动代码后，程序并没有跳转到<code>main()</code>处，而是跳转到了<code>__main()</code>处执行。<code>__main()</code>函数是一个库函数，这个函数最重要的作用就是完成所谓的“段拷贝”工作，具体来说，就是完成了以下三个步骤：</p><ol><li>将非零(只读和读写)运行区域从其载入地址复制到运行地址；</li><li>清零<code>ZI-data</code>区域（即<code>.bss</code>段）；</li><li>跳转到<code>__rt_entry</code>，最终会跳转到<code>main()</code>处，用户程序开始执行。</li></ol><p>由此可见，是否对全局变量进行清零完全是由启动代码和库函数决定的，而TI的编译器就没有链接完成这一工作所需的库函数，自然也就无法完成全局变量自动清零的工作了。解决这一问题的方法有两个：</p><ol><li><strong>在声明全局变量显式的赋初值0</strong></li><li><strong>程序中仿照<code>__main()</code>库函数的写法，自己写一个清零函数完成这一工作</strong></li></ol><p>值得注意的是，通过请教导师得知，<strong>这并不是TI编译器的设计缺陷，TI的编译器是专门这样设计的</strong>，这样设计的目的在于赋予程序员更大的灵活性。在某些情况下，是需要对全局变量进行选择性清零或其它操作的。</p><p>一个实际的例子是：假设使用了看门狗，在某些情况下系统看门狗复位了，对于某些控制系统而言，这时是要求系统在最短的时间内恢复之前的工作状态的。这种情况下，一般在程序开头加上一段检测代码，检测复位原因，如果是正常上电复位，则对全局变量进行清零操作；若判断出是看门狗复位，则自动执行之前的程序。系统软复位时并没有掉电，故RAM中的数据不会丢失。因为此时并没有对全局变量进行清零，之前的全局变量数据全部都在，此时就可以很快的恢复之前的工作状态，并且还可以使用一些全局变量辅助判断之前的错误复位的原因。</p>]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> DSP </tag>
            
            <tag> C </tag>
            
            <tag> Runtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言中函数指针的声明及使用</title>
      <link href="/2016/04/21/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/04/21/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>函数指针一般的声明方式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Return (* pf)(Params);</span><br></pre></td></tr></table></figure><p>其中<code>Return</code>代表返回值的类型，<code>Params</code>代表函数参数列表，如下面两个比较简单的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (* pf1)(<span class="keyword">int</span>, <span class="keyword">char</span> *);</span><br><span class="line"><span class="keyword">int</span> * (* pf2)(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><p>使用的时候可以使用以下两种等价的赋值及调用方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign</span></span><br><span class="line">pf = FunctionName;</span><br><span class="line">pf = &amp;FunctionName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call</span></span><br><span class="line">pf();</span><br><span class="line">(*pf)();</span><br></pre></td></tr></table></figure><p>更为复杂一点的问题是，如果一个函数指针作为函数的参数与函数的返回值时该如何进行声明呢？</p><p>作为函数参数的情况比较简单，像这样处理即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>), <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="keyword">void</span> (* pf)(<span class="keyword">int</span>, <span class="keyword">int</span>), <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pf(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，声明并定义了一个函数<code>Fun()</code>，这个函数接受3个参数，后两个参数为<code>int</code>，第一个参数的类型是<code>void (*)(int, int)</code>，这是一个函数指针，指向一个返回值为<code>void</code>，参数为两个<code>int</code>的函数。</p><hr><p>然而如何处理函数指针作为返回值的情况呢？标准库<code>&lt;signal.h&gt;</code>中的<code>signal()</code>函数就是一个这样的函数，其声明形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (* signal(<span class="keyword">int</span> sig, <span class="keyword">void</span> (* handler)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>这个函数声明一眼看过去不是很好懂，下面来仔细分析一下。</p><p>如果我们要声明一个整形变量<code>a</code>，可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure><p>如果要改为声明一个返回值为整形的函数<code>fun()</code>，可以视为只要将声明变量时使用的<code>a</code>改为<code>fun()</code>即可，即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>用同样的思路来分析声明一个返回值为函数指针的函数的声明方法，只要将函数指针声明中的变量名部分换为函数体即可。用实例分析一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (* pf)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>这里面<code>pf</code>是一个函数指针，指向一个输入参数为<code>int</code>，返回值为<code>void</code>的函数。将其中的<code>pf</code>换为一个函数<code>fun()</code>，即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (* fun())(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>这样就得到了一个返回值为函数指针的函数<code>fun()</code>，它返回的函数指针其实就是上面的<code>pf</code>。</p><p>理解了这样的声明方式后再来看<code>signal()</code>函数的声明就不那么难理解了。先看最里层：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (* handler)(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>这是一个函数指针<code>handler</code>，带一个<code>int</code>参数，返回值为空。</p><p>再向外一层：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(<span class="keyword">int</span> sig, <span class="keyword">void</span> (* handler)(<span class="keyword">int</span>))</span><br></pre></td></tr></table></figure><p>这是一个函数<code>signal()</code>，其参数为一个整形和一个函数指针。那这个函数的返回值是什么呢？由上面的分析易知，也是一个函数指针，这个函数指针的原型是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (* Returnpf)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>对比<code>Returnpf</code>和<code>handler</code>的声明，可以看到二者是完全一样的。这时候就可以利用<code>typedef</code>这个好东西来简化之前那个复杂的<code>signal()</code>函数的声明了，具体做法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (* signal(<span class="keyword">int</span> sig, <span class="keyword">void</span> (* handler)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* <span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> sig, <span class="keyword">sighandler_t</span> handler);</span><br></pre></td></tr></table></figure><p>其中第1行与第5行的声明是完全等价的，使用第5行这种声明方式就显得直观多了。</p><hr><p>最后编写了两个简单的测试程序来进一步熟悉下函数指针的使用方法。</p><p>不使用<code>typedef</code>的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function declaration</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintStr</span><span class="params">(<span class="keyword">char</span> *(*)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"><span class="keyword">char</span> *(* Run(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>)))(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Msg1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Great than 0!\r\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Msg2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Less than 0!\r\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintStr</span><span class="params">(<span class="keyword">char</span> *(* Fun)(<span class="keyword">void</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(Fun());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *(* Run(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> (* SumFun)(<span class="keyword">int</span>, <span class="keyword">int</span>)))(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(SumFun(a, b) &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> Msg1;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> Msg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PrintStr(Run(<span class="number">1</span>,<span class="number">2</span>,Sum));</span><br><span class="line">  PrintStr(Run(<span class="number">-1</span>,<span class="number">-2</span>,Sum));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>typedef</code>的版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Typedef</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(* MySumFun)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> * (* MyCharFun)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function declaration</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintStr</span><span class="params">(MyCharFun)</span></span>;</span><br><span class="line"><span class="function">MyCharFun <span class="title">Run</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, MySumFun)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Msg1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Great than 0!\r\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Msg2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Less than 0!\r\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintStr</span><span class="params">(MyCharFun Fun)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(Fun());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MyCharFun <span class="title">Run</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, MySumFun Fun)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(Fun(a, b) &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> Msg1;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> Msg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PrintStr(Run(<span class="number">1</span>,<span class="number">2</span>,Sum));</span><br><span class="line">  PrintStr(Run(<span class="number">-1</span>,<span class="number">-2</span>,Sum));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行输出结果均为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Great than 0!</span><br><span class="line"></span><br><span class="line">Less than 0!</span><br></pre></td></tr></table></figure><p>使用<code>typedef</code>的版本明显可读性要好得多。</p>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言标准库总结</title>
      <link href="/2016/04/18/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93/"/>
      <url>/2016/04/18/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>标准库（Standard Library）是C语言重要的一部分，不过学习C语言这么长时间，都没有细致的了解过标准库到底中包含哪些内容，这几天打算来仔细看看这部分内容。</p><p>C语言标准库有各种不同的实现，比如最著名的<a href="https://www.gnu.org/software/libc/" target="_blank" rel="noopener">glibc</a>， 用于嵌入式Linux的<a href="https://uclibc.org/" target="_blank" rel="noopener">uClibc</a>，还有ARM公司的自己的C语言标准库及精简版的MicroLib等。不同标准库的实现并不相同，而且提供的函数也不完全相同，不过有一个它们都支持的最小子集，这也就是最典型的C语言标准库。</p><p>这个C语言标准库中一共包含15个头文件，粗略的按常用程度排序列举如下：</p><a id="more"></a><table><thead><tr><th>Header File</th><th>Content</th></tr></thead><tbody><tr><td>**<a href="#stdio"><code>&lt;stdio.h&gt;</code></a> **</td><td><strong>输入和输出</strong></td></tr><tr><td><strong><a href="#stdlib"><code>&lt;stdlib.h&gt;</code></a></strong></td><td><strong>最常用的一些系统函数</strong></td></tr><tr><td><strong><a href="#string"><code>&lt;string.h&gt;</code></a></strong></td><td><strong>字符串处理</strong></td></tr><tr><td><strong><a href="#math"><code>&lt;math.h&gt;</code></a></strong></td><td><strong>数学函数</strong></td></tr><tr><td><strong><a href="#ctype"><code>&lt;ctype.h&gt;</code></a></strong></td><td><strong>字符类测试</strong></td></tr><tr><td><strong><a href="#time"><code>&lt;time.h&gt;</code></a></strong></td><td><strong>时间和日期</strong></td></tr><tr><td>**<a href="#stdarg"><code>&lt;stdarg.h&gt;</code></a> **</td><td><strong>可变参数列表</strong></td></tr><tr><td><strong><a href="#signal"><code>&lt;signal.h&gt;</code></a></strong></td><td><strong>信号</strong></td></tr><tr><td><strong><a href="#assert"><code>&lt;assert.h&gt;</code></a></strong></td><td><strong>断言</strong></td></tr><tr><td><a href="#setjmp"><code>&lt;setjmp.h&gt;</code></a></td><td>非局部跳转</td></tr><tr><td><a href="#errno"><code>&lt;errno.h&gt;</code></a></td><td>定义错误代码</td></tr><tr><td><a href="#stddef"><code>&lt;stddef.h&gt;</code></a></td><td>一些常数、类型和变量</td></tr><tr><td><a href="#locale"><code>&lt;locale.h&gt;</code></a></td><td>本土化</td></tr><tr><td><a href="#float"><code>&lt;float.h&gt;</code></a></td><td>浮点数运算</td></tr><tr><td><a href="#limits"><code>&lt;limits.h&gt;</code></a></td><td>定义整数数据类型的取值范围</td></tr></tbody></table><p>在这里不准备列举所有库函数的详细用法，如需查询具体的库函数用法，可以参考以下几个链接：</p><blockquote><p><a href="http://ganquan.info/standard-c/" target="_blank" rel="noopener">Standard C 语言标准函数库速查 (Cheat Sheet)</a><br><a href="http://wiki.jikexueyuan.com/project/c/c-standard-library.html" target="_blank" rel="noopener">C标准库参考手册</a><br><a href="http://www.tutorialspoint.com/c_standard_library/" target="_blank" rel="noopener">C Standard Library Reference Tutorial</a></p></blockquote><p>本文总结的是不完整的C标准库，仅列举一些常用且最重要的部分。</p><p>关于C标准库本身的实现分析，可参考我的学习笔记：<br><a href="/2016/08/02/C%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%281%29%E2%80%94%E2%80%94time%E3%80%81ctype%E3%80%81stdarg%E3%80%81assert/">C标准库学习笔记(1)——time、ctype、stdarg、assert</a></p><p><span id="stdio"></span></p><h2 id="stdio-h"><a href="#stdio-h" class="headerlink" title="stdio.h"></a><strong>stdio.h</strong></h2><p>输入和输出。</p><p>在其中定义了以下一些常用的类型及常量：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>FILE</code></td><td>文件指针</td></tr><tr><td><code>EOF</code></td><td>End Of File，表示文件的结尾</td></tr><tr><td><code>stderr</code></td><td>标准错误流</td></tr><tr><td><code>stdin</code></td><td>标准输入流</td></tr><tr><td><code>stdout</code></td><td>标准输出流</td></tr></tbody></table><p>其中<code>stderr</code>、<code>stdin</code>、<code>stdout</code>为宏定义，是指向<code>FILE</code>类型的指针。</p><p><code>&lt;stdio.h&gt;</code>中的函数有很多，大致可分为对标准输入输出流的操作、对文件流的操作、对标准错误流的操作、对字符串的操作这几大类。</p><h3 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h3><p>其实从<code>stdin</code>与<code>stdout</code>的定义中也可以看到，标准输入输出流也就是文件，只是一般情况下已经默认定义为键盘和屏幕。这与Linux中一切皆文件的思想一脉相承。</p><p>常用的函数有以下这些：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>int printf(const char * format, ...)</code></td><td>格式化输出数据至<code>stdout</code></td></tr><tr><td><code>int scanf(const char * format, ...)</code></td><td>由<code>stdin</code>读取格式化输入数据</td></tr><tr><td><code>int putchar(int c)</code></td><td>向<code>stdout</code>输出一个字符</td></tr><tr><td><code>int getchar(void)</code></td><td>由<code>stdin</code>读入一个字符</td></tr><tr><td><code>int puts(const char * s)</code></td><td>向<code>stdout</code>输出一串字符串</td></tr><tr><td><code>char * gets(char * s)</code></td><td>由<code>stdin</code>读入一串字符串</td></tr></tbody></table><p>另外，<code>vprintf()</code>函数主要用于需要自己实现一些类似<code>printf()</code>的函数时使用，关于这个函数的用处可参考<a href="http://stackoverflow.com/questions/1485805/whats-the-difference-between-the-printf-and-vprintf-function-families-and-when" target="_blank" rel="noopener">StackOverflow上的讨论</a>，用于文件流的<code>vfprintf()</code>与用于字符串的<code>vsprintf()</code>的用处也是相似的。</p><h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><p>对文件的操作是<code>&lt;stdio.h&gt;</code>中的核心，其他函数均可视为对特定文件的操作，大部分函数均以<code>f****()</code>命名。</p><p>最重要的函数是以下这几个：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>FILE * fopen(const char * filename, const char * mode)</code></td><td>打开文件，失败返回<code>NULL</code></td></tr><tr><td><code>int fclose(FILE * stream)</code></td><td>关闭文件，成功返回0，失败返回<code>EOF</code></td></tr><tr><td><code>size_t fread(void * ptr, size_t size, size_t nmemb, FILE * stream)</code></td><td>读取文件内容</td></tr><tr><td><code>size_t fwrite(cosnt void * ptr, size_t size, size_t nmemb, FILE * stream)</code></td><td>写入文件内容</td></tr></tbody></table><p>只使用这4个函数就可以完成基本的文件读写操作了，其它函数可以视为是为了更方便的进行文件读写而引入的。在Linux中，文件不仅仅是指磁盘上的一个file，也有可能是一个设备等，不过都可以以统一的方式进行读写。常用的打开模式有<code>r</code>(读)、<code>w</code>(写)、<code>a</code>(附加)、<code>b</code>(二进制)等。</p><hr><p>与标准输入输出流的操作相同，对文件的操作也有以下这些函数：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>int fprintf(FILE * stream, const char * format, ...)</code></td><td>格式化输出数据至文件</td></tr><tr><td><code>int fscanf(FILE * stream, cosnt char * format, ...)</code></td><td>由文件读取格式化输入数据</td></tr><tr><td><code>int putc(int c, FILE * stream)</code></td><td>向文件输出一个字符</td></tr><tr><td><code>int getc(FILE * stream)</code></td><td>由文件读入一个字符</td></tr><tr><td><code>int fputc(int c, FILE * stream)</code></td><td>向文件输出一个字符</td></tr><tr><td><code>int fgetc(FILE * stream)</code></td><td>由文件读入一个字符</td></tr><tr><td><code>int fputs(const char * s, FILE * stream)</code></td><td>向文件输出一串字符串（或比特流）</td></tr><tr><td><code>char * fgets(char * s, int n, FILE * stream)</code></td><td>由文件读入一串字符串（或比特流）</td></tr></tbody></table><p>其中<code>putc()</code>与<code>fputc()</code>、<code>getc()</code>与<code>fgetc()</code>的区别在于前者可能是使用宏定义实现的，而后者一定是函数，具体分析可以参考<a href="http://www.cnblogs.com/aqxin/archive/2011/05/20/2052069.html" target="_blank" rel="noopener">这篇文章</a>。</p><hr><p>用于对文件进行修改（如删除文件等）的函数有以下这些：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>int remove(const char * filename)</code></td><td>删除文件，成功返回0</td></tr><tr><td><code>int rename(const char * old, const char * new)</code></td><td>更改文件名称或位置，成功返回0</td></tr><tr><td><code>FILE * tmpfile(void)</code></td><td>以wb+形式创建一个临时二进制文件</td></tr></tbody></table><p>其中<code>tmpfile()</code>创建的临时文件在调用<code>fclose()</code>关闭时会被自动删除。</p><hr><p>对文件流的定位通常使用以下这些函数：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>int fseek(FILE * stream, long int offset, int fromwhere)</code></td><td>移动文件流的读写位置，错误返回非0</td></tr><tr><td><code>long int ftell(FILE * stream)</code></td><td>取得文件流的读取位置</td></tr><tr><td><code>void rewind(FILE * stream)</code></td><td>重设读取目录的位置为开头位置</td></tr><tr><td><code>int feof(FILE * stream)</code></td><td>检测文件结束符</td></tr></tbody></table><p><code>whence</code>可设置为<code>SEEK_SET</code>、<code>SEEK_END</code>或<code>SEEK_CUR</code>。</p><hr><p>使用这两个函数处理读写文件流操作中的错误：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>int ferror(FILE * stream)</code></td><td>检查流是否有错误</td></tr><tr><td><code>void clearerr(FILE * stream)</code></td><td>复位错误标志</td></tr></tbody></table><hr><p>与缓冲(Buffer)机制有关的函数常用的有以下这两个：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>void setbuf(FILE * stream, char * buf)</code></td><td>把缓冲区与流相联</td></tr><tr><td><code>int fflush(FILE * stream)</code></td><td>更新缓冲区，成功返回0，错误返回<code>EOF</code></td></tr></tbody></table><h3 id="其他流操作"><a href="#其他流操作" class="headerlink" title="其他流操作"></a>其他流操作</h3><p>对<code>stderr</code>的操作通过以下函数完成：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>void perror(const char * s)</code></td><td>打印出错误原因信息字符串</td></tr></tbody></table><p>此函数将上一个函数发生错误的原因输出到<code>stderr</code>，此错误原因依照全局变量<code>errno</code>的值来决定要输出的字符串，<code>errno</code>在<code>&lt;errno.h&gt;</code>中声明。</p><hr><p>对字符串也提供了格式化输入输出函数：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>int sprintf(char * s, const char * format, ...)</code></td><td>格式化字符串复制</td></tr><tr><td><code>int sscanf(const char * s, const char * format, ...)</code></td><td>格式化字符串输入</td></tr></tbody></table><p><span id="stdlib"></span></p><h2 id="stdlib-h"><a href="#stdlib-h" class="headerlink" title="stdlib.h"></a>stdlib.h</h2><p>最常用的一些系统函数。</p><p>在其中定义了以下一些常用的类型及常量：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>size_t</code></td><td><code>sizeof</code>运算符产生的数据类型，一般是一个无符号整数</td></tr><tr><td><code>wchar_t</code></td><td>一个宽字符的大小</td></tr><tr><td><code>NULL</code></td><td>空</td></tr><tr><td><code>RANDMAX</code></td><td><code>rand()</code>的最大返回值</td></tr></tbody></table><p>下面分类整理一下其中的重要函数。</p><h3 id="内存管理函数"><a href="#内存管理函数" class="headerlink" title="内存管理函数"></a>内存管理函数</h3><p>最常用的是以下两个函数：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>void * malloc(size_t size)</code></td><td>从堆上动态分配内存空间</td></tr><tr><td><code>void free(void * ptr)</code></td><td>释放之前分配的内存空间</td></tr></tbody></table><p>还有一些常用的内存控制函数位于<code>&lt;string.h&gt;</code>中。</p><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>常用函数有：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>int abs(int j)</code></td><td>int类型数据绝对值</td></tr><tr><td><code>long labs(long j)</code></td><td>long类型数据绝对值</td></tr><tr><td><code>int rand(void)</code></td><td>产生一个随机数</td></tr><tr><td><code>void srand(unsigned int seed)</code></td><td>初始化随机数种子</td></tr></tbody></table><p>关于<code>rand()</code>与<code>srand()</code>的用法，之前写的<a href="/2015/11/16/C%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/">这篇文章</a>中进行了总结。</p><h3 id="字符串转换函数"><a href="#字符串转换函数" class="headerlink" title="字符串转换函数"></a>字符串转换函数</h3><p>常用的有以下这3个函数：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>int atoi(const char * nptr)</code></td><td>将字符串转换为整数（int）</td></tr><tr><td><code>long atol(const char * nptr)</code></td><td>将字符串转换为长整数（long）</td></tr><tr><td><code>double atof(const char * nptr)</code></td><td>将字符串转换为浮点型数（double）</td></tr></tbody></table><h3 id="环境函数"><a href="#环境函数" class="headerlink" title="环境函数"></a>环境函数</h3><p>常用的函数有：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>int system(const char * string)</code></td><td>执行Shell（或命令行）命令</td></tr><tr><td><code>char * getenv(const char * name)</code></td><td>获取环境变量中的内容</td></tr><tr><td><code>int exit(int stauts)</code></td><td>结束进程</td></tr></tbody></table><h3 id="搜索和排序函数"><a href="#搜索和排序函数" class="headerlink" title="搜索和排序函数"></a>搜索和排序函数</h3><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>void qsort(void * base, size_t nmemb, size_t size, int (* compar)(const void *, const void *))</code></td><td>快速排序算法</td></tr><tr><td><code>void * bsearch(const void * key, const void * base, size_t nmemb, size_t size, int (* compar)(const void *, const void *))</code></td><td>在数组进行二分法查找某一元素，要求数组预先已排好序</td></tr></tbody></table><hr><p>在<code>&lt;stdlib.h&gt;</code>中还有一些用于进行多字节字符处理的函数，此处没有列出。</p><p><span id="string"></span></p><h2 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h2><p><code>&lt;string.h&gt;</code>中除了字符串处理函数，还有一些内存管理函数：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>void * memset(void * dest, int c, size_t n)</code></td><td>将一段内存空间填上某值</td></tr><tr><td><code>void * memcpy(void * dest, const void * src, size_t n)</code></td><td>复制一段内存内容</td></tr><tr><td><code>int memcmp(const void * s1, const void * s2, size_t n)</code></td><td>比较两段内存内容</td></tr><tr><td><code>void * memchr(const void * s, int c, size_t n)</code></td><td>在某一段内存范围中查找特定字节</td></tr></tbody></table><hr><p>常用的字符串操作函数有：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>char * strcat(char * deat, const char * src)</code></td><td>连接两个字符串</td></tr><tr><td><code>char * strcpy(char * dest, const char * src)</code></td><td>复制字符串</td></tr><tr><td><code>int strcmp(const char * s1, const char * s2)</code></td><td>比较两个字符串</td></tr><tr><td><code>size_t strlen(const char * s)</code></td><td>获取一个字符串的长度</td></tr><tr><td><code>char * strtok(char * s1, const char * s2)</code></td><td>分割字符串</td></tr></tbody></table><p>以下这些函数用于进行字符串查找：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>char * strchr(const char * s, int c)</code></td><td>正向查找一个字符</td></tr><tr><td><code>char * strrchr(const char * s, int c)</code></td><td>反向查找一个字符</td></tr><tr><td><code>char * strstr(const char * s1, const char * s2)</code></td><td>查找一个字符串</td></tr><tr><td><code>char * strpbrk(const char * s1, const char * s2)</code></td><td>查找一个字符集合</td></tr></tbody></table><p><span id="math"></span></p><h2 id="math-h"><a href="#math-h" class="headerlink" title="math.h"></a>math.h</h2><p>标准数学库，常用函数如下：</p><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>double sin(double x)</code></td><td>正弦</td></tr><tr><td><code>double cos(double x)</code></td><td>余弦</td></tr><tr><td><code>double tan(double x)</code></td><td>正切</td></tr><tr><td></td><td></td></tr><tr><td><code>double asin(double x)</code></td><td>反正弦</td></tr><tr><td><code>double acos(double x)</code></td><td>反余弦</td></tr><tr><td><code>double atan(double x)</code></td><td>反正切</td></tr><tr><td><code>double atan2(double y, double x)</code></td><td>计算y/x的反正切</td></tr></tbody></table><h3 id="双曲三角函数"><a href="#双曲三角函数" class="headerlink" title="双曲三角函数"></a>双曲三角函数</h3><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>double sinh(double x)</code></td><td>双曲正弦</td></tr><tr><td><code>double cosh(double x)</code></td><td>双曲余弦</td></tr><tr><td><code>double tanh(double x)</code></td><td>双曲正切</td></tr></tbody></table><h3 id="指数与对数"><a href="#指数与对数" class="headerlink" title="指数与对数"></a>指数与对数</h3><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>double exp(double x)</code></td><td>e的n次幂</td></tr><tr><td><code>double pow(double x, double y)</code></td><td>x的y次幂</td></tr><tr><td><code>double sqrt(double x)</code></td><td>开根号</td></tr><tr><td></td><td></td></tr><tr><td><code>double log(double x)</code></td><td>e为底的对数</td></tr><tr><td><code>double log10(double x)</code></td><td>10为底的对数</td></tr></tbody></table><h3 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h3><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>double ceil(double x)</code></td><td>向上取整</td></tr><tr><td><code>double floor(double x)</code></td><td>向下取整</td></tr></tbody></table><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>double fabs(double x)</code></td><td>计算绝对值</td></tr></tbody></table><p><span id="ctype"></span></p><h2 id="ctype-h"><a href="#ctype-h" class="headerlink" title="ctype.h"></a>ctype.h</h2><p>包含字符测试及大小写转换函数。</p><h3 id="字符测试"><a href="#字符测试" class="headerlink" title="字符测试"></a>字符测试</h3><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>isalpha(c)</code></td><td>是否为字母</td></tr><tr><td><code>isupper(c)</code></td><td>是否为大写字母</td></tr><tr><td><code>islower(c)</code></td><td>是否为小写字母</td></tr><tr><td></td><td></td></tr><tr><td><code>isdigit(c)</code></td><td>是否为数字</td></tr><tr><td><code>isxdigit(c)</code></td><td>是否为16进制数字（数字 &amp; A<del>F &amp; a</del>f）</td></tr><tr><td></td><td></td></tr><tr><td><code>isalnum(c)</code></td><td>是否为字母及数字</td></tr><tr><td></td><td></td></tr><tr><td><code>ispunct(c)</code></td><td>是否为标点符号</td></tr><tr><td><code>isspace(c)</code></td><td>是否为空白字符（空格、\r(CR)、\n(LF)、\t(TAB)、\v(VT)、\f(FF)）</td></tr><tr><td><code>iscntrl(c)</code></td><td>是否为控制字符（ASCII 0 ~ 37(0x1F) &amp; 177(0x7F)）</td></tr><tr><td></td><td></td></tr><tr><td><code>isgraph(c)</code></td><td>是否为可显示字符（字母 &amp; 数字 &amp; 标点）</td></tr><tr><td><code>isprint(c)</code></td><td>是否为可打印字符（字母 &amp; 数字 &amp; 标点 &amp; 空白）</td></tr></tbody></table><h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>tolower(c)</code></td><td>转换为小写</td></tr><tr><td><code>toupper(c)</code></td><td>转换为大写</td></tr></tbody></table><p><span id="time"></span></p><h2 id="time-h"><a href="#time-h" class="headerlink" title="time.h"></a>time.h</h2><p>日期及时间操作。定义了<code>time_t</code>、<code>clock_t</code>及<code>tm</code>这几种类型，常用函数有：</p><h3 id="获取时间及相关计算"><a href="#获取时间及相关计算" class="headerlink" title="获取时间及相关计算"></a>获取时间及相关计算</h3><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>time_t time(time_t * timer)</code></td><td>获取UNIX时间戳，一般传入<code>NULL</code></td></tr><tr><td><code>clock_t clock(void)</code></td><td>获取CPU时钟计数</td></tr><tr><td><code>double difftime(time_t time1, time_t time0)</code></td><td>计算时间差，<code>time1</code> - <code>time0</code></td></tr><tr><td></td><td></td></tr><tr><td><code>struct tm * gmtime(const time_t * timer)</code></td><td>GMT时间</td></tr><tr><td><code>struct tm * localtime(const time_t * timer)</code></td><td>地方时时间</td></tr><tr><td><code>time_t mktime(struct tm * timeptr)</code></td><td>地方时时间</td></tr></tbody></table><h3 id="转换为可阅读的字符串"><a href="#转换为可阅读的字符串" class="headerlink" title="转换为可阅读的字符串"></a>转换为可阅读的字符串</h3><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>char * ctime(const time_t * timer)</code></td><td>返回标准时间字符串，地方时时间，等价于<code>asctime(localtime())</code></td></tr><tr><td><code>char * asctime(const struct tm * timeptr)</code></td><td>返回标准时间字符串</td></tr><tr><td><code>size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *)</code></td><td>返回自定义格式时间字符串</td></tr></tbody></table><p><span id="stdarg"></span></p><h2 id="stdarg-h"><a href="#stdarg-h" class="headerlink" title="stdarg.h"></a>stdarg.h</h2><p>用于支持可变参数，定义了<code>va_list</code>这个结构体，通过以下三个宏进行操作：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>void va_start(va_list ap, parmN)</code></td><td>初始化<code>va_list</code></td></tr><tr><td><code>type va_arg(va_list ap, type)</code></td><td>从<code>va_list</code>中获取一个<code>type</code>类型的参数</td></tr><tr><td><code>void va_end(va_list ap)</code></td><td>释放<code>va_list</code></td></tr></tbody></table><p><span id="signal"></span></p><h2 id="signal-h"><a href="#signal-h" class="headerlink" title="signal.h"></a>signal.h</h2><p>定义了信号(Signal)处理的相关宏及函数，这与Linux中的信号机制密切相关，包含下面两个函数：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>signal()</code></td><td>设置处理特定Signal的Handler</td></tr><tr><td><code>raise(int sig)</code></td><td>产生一个Signal</td></tr></tbody></table><p><code>signal()</code>函数原型如下：<br><code>void (* signal(int sig, void (* handler)(int)))(int);</code></p><p><span id="assert"></span></p><h2 id="assert-h"><a href="#assert-h" class="headerlink" title="assert.h"></a>assert.h</h2><p>此头文件的唯一目的是提供<code>assert(int x)</code>这个宏，如果断言非真，程序会在标准错误流输出错误信息，并调用<code>abort()</code>函数使程序异常终止。</p><p><span id="setjmp"></span></p><h2 id="setjmp-h"><a href="#setjmp-h" class="headerlink" title="setjmp.h"></a>setjmp.h</h2><p>非局部跳转，用于从一个深层次嵌套中直接返回至最外层，通过这两个宏完成：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>int setjmp(jmp_buf env)</code></td><td>设置跳转点</td></tr><tr><td><code>void longjmp(jmp_buf env, int val)</code></td><td>进行跳转</td></tr></tbody></table><p><span id="errno"></span></p><h2 id="errno-h"><a href="#errno-h" class="headerlink" title="errno.h"></a>errno.h</h2><p>声明了一个外部整形变量<code>errno</code>用于表示错误，可用<code>perror(const char * s)</code>输出错误原因，其中<code>s</code>是错误提示前缀。</p><p>标准使用方法是：在一个库函数调用之前把它设为0，然后在下一个库函数调用前测试它，任何非零值均表示错误。示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    y = <span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (errno != <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">"Error"</span>);</span><br></pre></td></tr></table></figure><p><span id="stddef"></span></p><h2 id="stddef-h"><a href="#stddef-h" class="headerlink" title="stddef.h"></a>stddef.h</h2><p>定义了一些标准定义，如<code>size_t</code>、<code>wchar_t</code>、<code>NULL</code>等，这些定义也会出现在其他的头文件里。还定义了以下这个宏：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>offsetof(type, member)</code></td><td>返回结构体中某一成员相对于结构体起始地址的偏移量</td></tr></tbody></table><p><span id="locale"></span></p><h2 id="locale-h"><a href="#locale-h" class="headerlink" title="locale.h"></a>locale.h</h2><p>国家、文化和语言规则集称为区域设置，主要影响字符串格式，通过以下函数进行设置：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>setlocale()</code></td><td>设置或恢复本地化信息</td></tr></tbody></table><p><span id="float"></span></p><h2 id="float-h"><a href="#float-h" class="headerlink" title="float.h"></a>float.h</h2><p>用宏定义的方式定义了浮点数的最大值、最小值等信息。</p><p><span id="limits"></span></p><h2 id="limits-h"><a href="#limits-h" class="headerlink" title="limits.h"></a>limits.h</h2><p>定义了基本数据类型（int、char、short等）的最大值及最小值。常用宏定义有：</p><table><thead><tr><th>Name</th><th>Comment</th></tr></thead><tbody><tr><td><code>CHAR_BIT</code></td><td>一个字节的比特数</td></tr><tr><td><code>SCHAR_MIN</code></td><td>带符号字符最小值</td></tr><tr><td><code>SCHAR_MAX</code></td><td>带符号字符最大值</td></tr><tr><td><code>UCHAR_MAX</code></td><td>无符号字符最大值</td></tr><tr><td><code>CHAR_MIN</code></td><td><code>char</code>的最小值</td></tr><tr><td><code>CHAR_MAX</code></td><td><code>char</code>的最大值</td></tr><tr><td><code>SHRT_MIN</code></td><td>带符号短整型最小值</td></tr><tr><td><code>SHRT_MAX</code></td><td>带符号短整型最大值</td></tr><tr><td><code>USHRT_MAX</code></td><td>无符号短整型最大值</td></tr><tr><td><code>INT_MIN</code></td><td>带符号整形最小值</td></tr><tr><td><code>INT_MAX</code></td><td>带符号整形最大值</td></tr><tr><td><code>UINT_MAX</code></td><td>无符号整形最大值</td></tr><tr><td><code>LONG_MIN</code></td><td>带符号长整形最小值</td></tr><tr><td><code>LONG_MAX</code></td><td>带符号长整形最大值</td></tr><tr><td><code>ULONG_MAX</code></td><td>无符号长整形最大值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP中确定报文结束的方法</title>
      <link href="/2016/04/14/HTTP%E4%B8%AD%E7%A1%AE%E5%AE%9A%E6%8A%A5%E6%96%87%E7%BB%93%E6%9D%9F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2016/04/14/HTTP%E4%B8%AD%E7%A1%AE%E5%AE%9A%E6%8A%A5%E6%96%87%E7%BB%93%E6%9D%9F%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>HTTP中，确定报文结束有几种不同方法，较为常见的是：</p><ul><li><strong>关闭TCP连接</strong></li><li><strong>通过<code>Content-Length</code>检测</strong></li></ul><p>若不关闭TCP连接，也不在HTTP头部加上<code>Content-Length</code>字段，则无法正确确定HTTP报文是否结束，对于浏览器来说，此时就会一直处于加载状态。</p><a id="more"></a><p>这几天学习Python Socket编程时就遇到了这个问题，下面是一段最简单的HTTP服务器代码，无论收到什么请求都返回一个<code>Hello World!</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_STREAM</span><br><span class="line"></span><br><span class="line">HTTPResponse =<span class="string">'HTTP/1.1 200 OK\r\n\r\n&lt;html&gt;Hello World!&lt;/html&gt;'</span></span><br><span class="line"></span><br><span class="line">WebSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">WebSocket.bind((<span class="string">'localhost'</span>, <span class="number">80</span>))</span><br><span class="line">WebSocket.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">HTTPSocket, addr = WebSocket.accept()  <span class="comment"># Wait Connection</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'Waiting HTTP Request...'</span></span><br><span class="line">  Request = HTTPSocket.recv(<span class="number">1024</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">print</span> <span class="string">'Send HTTP Response!'</span></span><br><span class="line">  HTTPSocket.sendall(HTTPResponse)</span><br></pre></td></tr></table></figure><p>然而，这段代码是无法正常工作的，运行之后使用浏览器访问<code>http://localhost/</code>，得到的结果是这样的：</p><p><img src="https://pic.gaomf.store/20160414085934.png" alt=""></p><p>从Shell的输出结果来看，HTTP响应报文已经发送成功了，此时服务器已经在等待下一次请求了，而浏览器却始终处于<code>Connecting</code>状态中。</p><p>可以通过由服务器主动关闭TCP连接来解决这一问题，修改后的代码是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_STREAM</span><br><span class="line"></span><br><span class="line">HTTPResponse =<span class="string">'HTTP/1.1 200 OK\r\n\r\n&lt;html&gt;Hello World!&lt;/html&gt;'</span></span><br><span class="line"></span><br><span class="line">WebSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">WebSocket.bind((<span class="string">'localhost'</span>, <span class="number">80</span>))</span><br><span class="line">WebSocket.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'Waiting HTTP Request...'</span></span><br><span class="line">  HTTPSocket, addr = WebSocket.accept()  <span class="comment"># Wait Connection</span></span><br><span class="line">  Request = HTTPSocket.recv(<span class="number">1024</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">print</span> <span class="string">'Send HTTP Response!'</span></span><br><span class="line">  HTTPSocket.sendall(HTTPResponse)</span><br><span class="line"></span><br><span class="line">  HTTPSocket.close()  <span class="comment"># Close Connection</span></span><br></pre></td></tr></table></figure><p>修改后就可以正常运行了：<br><img src="https://pic.gaomf.store/20160414085607.png" alt=""></p><p>如果不关闭TCP连接，也可以通过加上<code>Content-Length</code>字段来解决这一问题，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_STREAM</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add Content-Length</span></span><br><span class="line">HTTPResponse =<span class="string">'HTTP/1.1 200 OK\r\nContent-Length: 25\r\n\r\n&lt;html&gt;Hello World!&lt;/html&gt;'</span></span><br><span class="line"></span><br><span class="line">WebSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">WebSocket.bind((<span class="string">'localhost'</span>, <span class="number">80</span>))</span><br><span class="line">WebSocket.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">HTTPSocket, addr = WebSocket.accept()  <span class="comment"># Wait Connection</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'Waiting HTTP Request...'</span></span><br><span class="line">  Request = HTTPSocket.recv(<span class="number">1024</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">print</span> <span class="string">'Send HTTP Response!'</span></span><br><span class="line">  HTTPSocket.sendall(HTTPResponse)</span><br></pre></td></tr></table></figure><p>这样浏览器也可以正常访问服务器，运行结果和之前关闭TCP连接完全相同。</p><p>一般来说，没有必要始终维持着一个TCP连接，所以最佳的解决方案是：使用<code>Content-Length</code>字段，并且在每次响应之后关闭TCP连接，即以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_STREAM</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add Content-Length</span></span><br><span class="line">HTTPResponse =<span class="string">'HTTP/1.1 200 OK\r\nContent-Length: 25\r\n\r\n&lt;html&gt;Hello World!&lt;/html&gt;'</span></span><br><span class="line"></span><br><span class="line">WebSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">WebSocket.bind((<span class="string">'localhost'</span>, <span class="number">80</span>))</span><br><span class="line">WebSocket.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">print</span> <span class="string">'Waiting HTTP Request...'</span></span><br><span class="line">  HTTPSocket, addr = WebSocket.accept()  <span class="comment"># Wait Connection</span></span><br><span class="line">  Request = HTTPSocket.recv(<span class="number">1024</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">print</span> <span class="string">'Send HTTP Response!'</span></span><br><span class="line">  HTTPSocket.sendall(HTTPResponse)</span><br><span class="line"></span><br><span class="line">  HTTPSocket.close()  <span class="comment"># Close Connection</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言运算符优先级与结合性</title>
      <link href="/2016/04/08/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E6%80%A7/"/>
      <url>/2016/04/08/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>整理下C语言中的运算符优先级与结合性问题，方便将来查阅。</p><a id="more"></a><p>总结：</p><ul><li><strong>单目运算符高于双目运算符，高于三目运算符，高于赋值运算符，逗号运算符优先级最低</strong></li><li><strong>单目运算符中，成员选择、数组下标、括号、函数调用的优先级高于其它</strong></li><li><strong>双目运算符中，算数运算高于移位，高于大于小于，高于==及！=，高于位运算，高于逻辑运算</strong></li></ul><p>比较容易出错的有下面这些：<br><img src="https://pic.gaomf.store/1-120205192420113.jpg" alt=""></p><p>完整的表格如下：</p><table><tbody><tr><th><p>优先级</p></th><th><p>运算符</p></th><th><p>名称或含义</p></th><th><p>使用形式</p></th><th><p>结合方向</p></th><th><p>说明</p></th></tr><tr><td rowspan="4"><p>1</p></td><td><p>[]</p></td><td><p>数组下标</p></td><td><p>数组名[常量表达式]</p></td><td rowspan="4"><p>左到右</p></td><td>&nbsp;</td></tr><tr><td><p>()</p></td><td><p>圆括号</p></td><td><p>（表达式）/函数名(形参表)</p></td><td>&nbsp;</td></tr><tr><td><p>.</p></td><td><p>成员选择（对象）</p></td><td><p>对象.成员名</p></td><td>&nbsp;</td></tr><tr><td><p>-&gt;</p></td><td><p>成员选择（指针）</p></td><td><p>对象指针-&gt;成员名</p></td><td>&nbsp;</td></tr><tr><td rowspan="9"><p>2</p></td><td><p>-</p></td><td><p>负号运算符</p></td><td><p>-表达式</p></td><td rowspan="9"><p>右到左</p></td><td><p>单目运算符</p></td></tr><tr><td><p>(类型)</p></td><td><p>强制类型转换</p></td><td><p>(数据类型)表达式</p></td><td>&nbsp;</td></tr><tr><td><p>++</p></td><td><p>自增运算符</p></td><td><p>++变量名/变量名++</p></td><td><p>单目运算符</p></td></tr><tr><td><p>- -</p></td><td><p>自减运算符</p></td><td><p>- -变量名/变量名- -</p></td><td><p>单目运算符</p></td></tr><tr><td><p> \* </p></td><td><p>取值运算符</p></td><td><p>\*指针变量</p></td><td><p>单目运算符</p></td></tr><tr><td><p>&amp;</p></td><td><p>取地址运算符</p></td><td><p>&amp;变量名</p></td><td><p>单目运算符</p></td></tr><tr><td><p>!</p></td><td><p>逻辑非运算符</p></td><td><p>!表达式</p></td><td><p>单目运算符</p></td></tr><tr><td><p>~</p></td><td><p>按位取反运算符</p></td><td><p>~表达式</p></td><td><p>单目运算符</p></td></tr><tr><td><p>sizeof</p></td><td><p>长度运算符</p></td><td><p>sizeof(表达式)</p></td><td>&nbsp;</td></tr><tr><td rowspan="3"><p>3</p></td><td><p>/</p></td><td><p>除</p></td><td><p>表达式/表达式</p></td><td rowspan="3"><p>左到右</p></td><td><p>双目运算符</p></td></tr><tr><td><p> \* </p></td><td><p>乘</p></td><td><p>表达式\* 表达式</p></td><td><p>双目运算符</p></td></tr><tr><td><p>%</p></td><td><p>余数（取模）</p></td><td><p>整型表达式%整型表达式</p></td><td><p>双目运算符</p></td></tr><tr><td rowspan="2"><p>4</p></td><td><p>+</p></td><td><p>加</p></td><td><p>表达式+表达式</p></td><td rowspan="2"><p>左到右</p></td><td><p>双目运算符</p></td></tr><tr><td><p>-</p></td><td><p>减</p></td><td><p>表达式-表达式</p></td><td><p>双目运算符</p></td></tr><tr><td rowspan="2"><p>5</p></td><td><p>&lt;&lt;</p></td><td><p>左移</p></td><td><p>变量&lt;&lt;表达式</p></td><td rowspan="2"><p>左到右</p></td><td><p>双目运算符</p></td></tr><tr><td><p>&gt;&gt;</p></td><td><p>右移</p></td><td><p>变量&gt;&gt;表达式</p></td><td><p>双目运算符</p></td></tr><tr><td rowspan="4"><p>6</p></td><td><p>&gt;</p></td><td><p>大于</p></td><td><p>表达式&gt;表达式</p></td><td rowspan="4"><p>左到右</p></td><td><p>双目运算符</p></td></tr><tr><td><p>&gt;=</p></td><td><p>大于等于</p></td><td><p>表达式&gt;=表达式</p></td><td><p>双目运算符</p></td></tr><tr><td><p>&lt;</p></td><td><p>小于</p></td><td><p>表达式&lt;表达式</p></td><td><p>双目运算符</p></td></tr><tr><td><p>&lt;=</p></td><td><p>小于等于</p></td><td><p>表达式&lt;=表达式</p></td><td><p>双目运算符</p></td></tr><tr><td rowspan="2"><p>7</p></td><td><p>==</p></td><td><p>等于</p></td><td><p>表达式==表达式</p></td><td rowspan="2"><p>左到右</p></td><td><p>双目运算符</p></td></tr><tr><td><p>!=</p></td><td><p>不等于</p></td><td><p>表达式!= 表达式</p></td><td><p>双目运算符</p></td></tr><tr><td><p>8</p></td><td><p>&amp;</p></td><td><p>按位与</p></td><td><p>表达式&amp;表达式</p></td><td><p>左到右</p></td><td><p>双目运算符</p></td></tr><tr><td><p>9</p></td><td><p>^</p></td><td><p>按位异或</p></td><td><p>表达式^表达式</p></td><td><p>左到右</p></td><td><p>双目运算符</p></td></tr><tr><td><p>10</p></td><td><p>|</p></td><td><p>按位或</p></td><td><p>表达式|表达式</p></td><td><p>左到右</p></td><td><p>双目运算符</p></td></tr><tr><td><p>11</p></td><td><p>&amp;&amp;</p></td><td><p>逻辑与</p></td><td><p>表达式&amp;&amp;表达式</p></td><td><p>左到右</p></td><td><p>双目运算符</p></td></tr><tr><td><p>12</p></td><td><p>||</p></td><td><p>逻辑或</p></td><td><p>表达式||表达式</p></td><td><p>左到右</p></td><td><p>双目运算符</p></td></tr><tr><td><p>13</p></td><td><p>?:</p></td><td><p>条件运算符</p></td><td><p>表达式1? 表达式2: 表达式3</p></td><td><p>右到左</p></td><td><p>三目运算符</p></td></tr><tr><td rowspan="11"><p>14</p></td><td><p>=</p></td><td><p>赋值运算符</p></td><td><p>变量=表达式</p></td><td rowspan="11"><p>右到左</p></td><td>&nbsp;</td></tr><tr><td><p>/=</p></td><td><p>除后赋值</p></td><td><p>变量/=表达式</p></td><td>&nbsp;</td></tr><tr><td><p>*=</p></td><td><p>乘后赋值</p></td><td><p>变量*=表达式</p></td><td>&nbsp;</td></tr><tr><td><p>%=</p></td><td><p>取模后赋值</p></td><td><p>变量%=表达式</p></td><td>&nbsp;</td></tr><tr><td><p>+=</p></td><td><p>加后赋值</p></td><td><p>变量+=表达式</p></td><td>&nbsp;</td></tr><tr><td><p>-=</p></td><td><p>减后赋值</p></td><td><p>变量-=表达式</p></td><td>&nbsp;</td></tr><tr><td><p>&lt;&lt;=</p></td><td><p>左移后赋值</p></td><td><p>变量&lt;&lt;=表达式</p></td><td>&nbsp;</td></tr><tr><td><p>&gt;&gt;=</p></td><td><p>右移后赋值</p></td><td><p>变量&gt;&gt;=表达式</p></td><td>&nbsp;</td></tr><tr><td><p>&amp;=</p></td><td><p>按位与后赋值</p></td><td><p>变量&amp;=表达式</p></td><td>&nbsp;</td></tr><tr><td><p>^=</p></td><td><p>按位异或后赋值</p></td><td><p>变量^=表达式</p></td><td>&nbsp;</td></tr><tr><td><p>|=</p></td><td><p>按位或后赋值</p></td><td><p>变量|=表达式</p></td><td>&nbsp;</td></tr><tr><td><p>15</p></td><td><p>,</p></td><td><p>逗号运算符</p></td><td><p>表达式,表达式,&hellip;</p></td><td><p>左到右</p></td><td><p>从左向右顺序运算</p></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MCS-51 基本数据类型</title>
      <link href="/2016/03/25/MCS-51%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2016/03/25/MCS-51%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>以Keil C51编译器为例，MCS-51上基本数据类型及其占用空间如下表：</p><a id="more"></a><table><thead><tr><th>数据类型</th><th>占用空间</th><th>范围</th></tr></thead><tbody><tr><td>char</td><td>1 Byte (8 bits)</td><td>0 ~ 255</td></tr><tr><td>signed char</td><td>1 Byte (8 bits)</td><td>-128 ~ +127</td></tr><tr><td>short</td><td>2 Bytes (16 bits)</td><td>-32768 ~ +32767</td></tr><tr><td>unsigned short</td><td>2 Bytes (16 bits)</td><td>0 ~ 65535</td></tr><tr><td>int</td><td>2 Bytes (16 bits)</td><td>-32768 ~ +32767</td></tr><tr><td>unsigned int</td><td>2 Byte (16 bits)</td><td>0 ~ 65535</td></tr><tr><td>long</td><td>4 Bytes (32 bits)</td><td>-2147483648 ~ +2147483647</td></tr><tr><td>unsigned long</td><td>4 Bytes (32 bits)</td><td>0 ~ 4294967295</td></tr><tr><td>float</td><td>4 Bytes (32 bits)</td><td>±1.175494E-38～±3.402823E+38</td></tr><tr><td>double</td><td>4 Bytes (32 bits)</td><td>±1.175494E-38～±3.402823E+38</td></tr><tr><td>* (Pointer)</td><td>3 Bytes (24 bits)</td><td>-</td></tr><tr><td>bit</td><td>1 bit</td><td>0 or 1</td></tr><tr><td>sbit</td><td>1 bit</td><td>0 or 1</td></tr><tr><td>sfr</td><td>1 Byte (8 bits)</td><td>0 ~ 255</td></tr><tr><td>sfr16</td><td>2 Bytes (16 bits)</td><td>0 ~ 65535</td></tr></tbody></table><p>关于MCS-51中的指针，分为通用指针（3字节）、xdata指针（2字节）、code指针（2字节）、idata指针（1字节），详见以下文章：</p><blockquote><p><a href="http://blog.csdn.net/onicolascage/article/details/46670373" target="_blank" rel="noopener">C51:Keil c51指针变量</a><br><a href="http://wenku.baidu.com/view/7f42b0e19b89680203d825e7.html" target="_blank" rel="noopener">关于Keil C51指针的使用</a></p></blockquote><p>参考资料：</p><blockquote><p><a href="http://www.baiheee.com/Documents/100623/100623155050.html" target="_blank" rel="noopener">KEIL C51编译器所支持的数据类型及各其长度</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> MCS-51 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半导体存储器总结</title>
      <link href="/2016/03/22/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2016/03/22/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><span id="summary"></span></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>半导体存储器在任何一个包含处理器的系统中都是必不可少的一部分，一般将其分为RAM与ROM两大类；根据系统掉电后存储内容是否可以保持又可分为易失（Volatile）与非易失（Non-volatile）两大类。下面是常见的半导体存储器分类图</p><p><img src="https://pic.gaomf.store/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E6%80%BB%E7%BB%93.svg" alt=""></p><a id="more"></a><p><span id="principle"></span></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>基本所有的存储器都是做成阵列结构的，即所谓的Memory Array，其中每个最小存储单元称为一个Cell，一般是存储1 bit数据，不过目前也有新工艺（如MLC、TLC）可以在一个存储单元内存放超过1 bit的数据。Memory Cell的结构示意图如下<br><img src="https://pic.gaomf.store/Circuit20160225153539.png" alt=""></p><p><span id="ROM"></span></p><h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h3><p>ROM全称Read Only Memory，在一般正常工作状态下，它是只读的。不过，也有一些ROM中的内容可对其进行编程修改，这就是所谓的可编程ROM；与此对应的就是不可编程ROM，即Mask ROM（掩膜 ROM）。<br>ROM的工作原理可参考以下视频：<a href="https://www.youtube.com/watch?v=I4qL4ZK765w" target="_blank" rel="noopener">sec 16-04 Memory Concepts</a></p><p><span id="MROM"></span></p><h4 id="MROM"><a href="#MROM" class="headerlink" title="MROM"></a>MROM</h4><p>MROM即Mask ROM，其Memory cell简化结构示意图如下<br><img src="https://pic.gaomf.store/Circuit20160225153755.png" alt=""></p><p>从中可以看到，MOSFET源极连接关系在芯片掩膜中就确定了，所以MROM是无法编程的，其中的内容也是不会发生改变的。在MCU中，MROM一般用于实现一些固化于芯片内部的功能，如引导程序，某些内置的库函数等。</p><p><span id="PROM"></span></p><h4 id="PROM"><a href="#PROM" class="headerlink" title="PROM"></a>PROM</h4><p>PROM即User-Programable ROM，亦称OTP ROM（One-Time Programable ROM）。PROM基于熔丝技术，即Fusible-Link，其Memory cell简化结构示意图如下<br><img src="https://pic.gaomf.store/Circuit20160225154524.png" alt=""></p><p>在出厂时，所有熔丝均处于图(b)的状态，即存储器中存储的内容是0。用户可对其进行编程，用大电流使源极熔丝熔断即可将此位置为1。此编程过程是一次性不可逆的，也就是所谓的一次编程（OTP）。</p><p>上面的原理图中描述的是基于熔丝原理的PROM，事实上，目前更为广泛使用的是反熔丝技术。二者的区别在于，熔丝（Fuse）在初始状态是闭合的，可通过编程使其断开；反熔丝（Antifuse）在初始状态是断开的，可通过编程使其闭合。反熔丝技术的基本原理见下图<br><img src="https://pic.gaomf.store/CircuitAntiFuse.GIF" alt=""></p><p><span id="Flash"></span></p><h4 id="EPROM-amp-EEPROM-amp-Flash"><a href="#EPROM-amp-EEPROM-amp-Flash" class="headerlink" title="EPROM &amp; EEPROM &amp; Flash"></a>EPROM &amp; EEPROM &amp; Flash</h4><p>EPROM、EEPROM及Flash的基本原理是相同的，都是基于浮栅技术（<a href="https://en.wikipedia.org/wiki/Floating-gate_MOSFET" target="_blank" rel="noopener">Floating-gate MOSFET</a>）。浮栅MOS管的结构示意图如下<br><img src="https://pic.gaomf.store/Circuitfgmos.jpg" alt=""></p><p>悬浮栅极位于两层二氧化硅绝缘层之间，因此存储于其中的电荷可以得到长久的保持。EPROM、EEPROM及Flash的Memory cell简化结构示意图如下<br><img src="https://pic.gaomf.store/Circuit20160225163857.png" alt=""></p><p>三者的区别主要在于其编程的方式不同。<br>EPROM通过紫外线（UV）照射进行数据擦除，浮栅中的电荷形成光电流泄漏走；EEPROM与Flash均是通过超薄氧化层的Fowler-Nordheim隧道电流使浮栅充放电。</p><p>EEPROM的Memory cell是由FLOTOX(Floating- gate tuneling oxide transister)及一个附加的晶体管（Transister）组成，由于FLOTOX的特性及两管结构，所以可以单元读/写。技术上，Flash是结合EPROM和EEPROM技术达到的，很多Flash使用雪崩热电子注入方式来编程，擦除和EEPROM一样用Fowler-Nordheim tuneling。但主要的不同是，Flash对芯片提供大块或整块的擦除，这就降低了设计的复杂性，它可以不要EEPROM单元里那个多余的Tansister，所以可以做到高集成度，大容量。另外Flash的浮栅工艺也有所不同，写入速度更快。</p><p><span id="RAM"></span></p><h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><p>RAM全称Random Access Memory，顾名思义，RAM可根据存储单元的行地址和列地址进行快速读取或写入操作。随机访问的含义是RAM可以直接读取或写入任意一个存储单元，因此，从这个意义上来说，NOR Flash似乎也该算作RAM的一种，不过一般情况下还是把它归为ROM。而严格地说，DRAM不属于Random Access，因为在DRAM中数据读取是突发（Burst）传输的。<br>RAM可分为三大类，SRAM、DRAM及nvSRAM。</p><p><span id="SRAM"></span></p><h4 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h4><p>SRAM即Static RAM，所谓的Static是指它没有刷新操作，在不掉电的情况下Memory Cell可无限长时间的保存数据。SRAM的工作原理可参考以下视频：<a href="https://www.youtube.com/watch?v=SHJPFNI5Mzo" target="_blank" rel="noopener">sec 16 02 Static RAMs</a><br>其Memory cell简化结构示意图如下<br><img src="https://pic.gaomf.store/Circuit20160225182323.png" alt=""></p><p>这是典型的6晶体管结构的SRAM（6T Cell），该结构的SRAM每个存储单元由六个MOS管组成，Q1、Q2、Q5、Q6构成双稳态触发器，Q3、Q4的开关状态由同一个选择信号CE控制。A1与A2是输入输出Buffer。</p><p><span id="DRAM"></span></p><h4 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h4><p>DRAM即Dynamic RAM，所谓的Dynamic是指每个一段时间就要对每个Memory Cell进行一次刷新操作，否则数据就会丢失。DRAM的工作原理可参考以下视频：<a href="https://www.youtube.com/watch?v=TUa2KgYiN6o" target="_blank" rel="noopener">sec 16 03 Dynamic RAMs</a><br>其Memory cell简化结构示意图如下<br><img src="https://pic.gaomf.store/Circuit20160225183052.png" alt=""></p><p>DRAM每个存储单元由一个MOS管及其寄生电容构成，由于数据信号的状态由电容的电荷量决定，因此每隔一段时间需对电容做一次充放电的刷新操作。</p><p><span id="nvSRAM"></span></p><h4 id="nvSRAM"><a href="#nvSRAM" class="headerlink" title="nvSRAM"></a>nvSRAM</h4><p>nvSRAM即Non-volatile SRAM，某些地方将NOR Flash也算作nvSRAM的一种，不过一般认为的nvSRAM是指FRAM、MRAM一类的新型SRAM，这类器件读取速度与传统的SRAM不相上下，而且掉电后还可以保持之前的数据，是一类很有发展潜力的存储器。其中FRAM就是一种很有代表性的新型存储器。<br>FRAM目前主要由日本富士通公司（Fujitsu）生产，其核心在于使用PZT(锆钛酸铅，Pb{ZrTi}O3)晶粒作为电容存储数据。关于FRAM的详细技术说明，可参考Fujitsu的<a href="https://www.fujitsu.com/downloads/MICRO/fme/fram/fram-guide-book.pdf" target="_blank" rel="noopener">FRAM Guide Book</a>。</p><p>除此之外，还有一种nvSRAM是将电池与SRAM封装在了一起，这个从严格意义上来说并不能算nvSRAM，仅仅只是SRAM+电池而已。</p><p><span id="Register"></span></p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>一般并不把使用Flip-Flop的寄存器算作存储器的一种，不过实际上它起到的作用和存储器是一样的。在进行嵌入式系统编程时经常涉及到寄存器，其实质就是若干个并联的触发器（Flip-Flop）。以4位寄存器为例，其原理图如下<br><img src="https://pic.gaomf.store/Circuitflip-flop-register.gif" alt=""></p><p><span id="Application"></span></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>选取几种比较有代表性的器件介绍下其应用。</p><p><span id="PROM2"></span></p><h3 id="PROM-1"><a href="#PROM-1" class="headerlink" title="PROM"></a>PROM</h3><p>PROM一般用于OTP芯片中，这类芯片仅可进行一次编程，其价格与使用Flash的同类产品相比有很大优势。部分MCU内部也会有一小块OTP区域供用户使用。<br>除此之外，部分FPGA和CPLD也使用PROM工艺，这还成为了其一大特色，一般用于航天和军工等可靠性要求极高的场合。这类器件使用的是反熔丝工艺，具有以下一些优点：</p><ul><li>编程不可逆，抗高低温，稳定性极高</li><li>抗辐射强</li><li>寿命长</li></ul><p><span id="EEPROM2"></span></p><h3 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h3><p>EEPROM一般用于保存一些系统参数，最常用的分立EEPROM芯片为24Cxx系列，包括容量不同的24C02、24C04、24C08、24C16，分别能存储2k、4k、8k、16k bit数据。<br>24Cxx系列的引脚定义如下<br><img src="https://pic.gaomf.store/Circuit24Cxx.png" alt=""><br><img src="https://pic.gaomf.store/Circuit20160225202124.png" alt=""></p><p>24Cxx系列通过标准I2C接口与MCU进行通信。<code>A0</code>-<code>A2</code>引脚是器件地址输入，可以将多片24Cxx（24C16除外）同时接到I2C总线上以达到扩大容量的目的，不过这个功能一般不使用。<code>WP</code>引脚是写保护，一般也不使用，直接接地即可。</p><p>两个典型操作的时序图如下：<br><img src="https://pic.gaomf.store/Circuit20160225203151.png-height" alt=""><br><img src="https://pic.gaomf.store/Circuit20160225203259.png-height" alt=""></p><p><span id="Flash2"></span></p><h3 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h3><p>Flash一般作为系统的主要存储设备用来保存程序和数据，可分为两种，NOR Flash与NAND Flash。<strong>Nor Flash数据线和地址线分开，可以实现RAM一样的随机寻址功能，可以读取任何一个字节。但是擦除仍要按块（Block）来擦。NAND Flash同样是按块擦除，但是数据线和地址线复用，不能利用地址线随机寻址，读取只能按页（Page）来读取。</strong>二者的结构对比见下图<br><img src="https://pic.gaomf.store/Circuit20160225211221.png" alt=""></p><p>由于NAND Flash引脚上复用，因此读取速度比NOR Flash慢一点，但是擦除和写入速度比NOR Flash快很多。NAND Flash内部电路更简单，因此数据密度大，体积小，成本也低。因此大容量的Flash都是NAND型的。小容量的1MB～16MB的Flash多是NOR型的。二者的尺寸及密度对比见下图<br><img src="https://pic.gaomf.store/Circuit20160225211551.png" alt=""></p><p>二者的综合性能比较见下图<br><img src="https://pic.gaomf.store/Circuit20160225211819.png" alt=""></p><p>从使用上来说，NOR Flash也要比NAND Flash简单。另外，<strong>因为NAND Flash无法直接寻址，故程序无法在NAND Flash中运行，需要将其拷贝到RAM中才能运行。</strong></p><p>关于NAND Flash与NOR Flash的详细比较，可参考M-System公司的技术白皮书:</p><blockquote><p><a href="https://focus.ti.com/pdfs/omap/diskonchipvsnor.pdf" target="_blank" rel="noopener">Two Flash Technologies Compared: NOR vs NAND</a>。</p></blockquote><hr><p>对于NOR Flash而言，因为它有独立的地址线和数据线，其使用方法较为简单，只要将其接到CPU的地址总线和数据总线上即可，可参考下面这张工作模式图：<br><img src="https://pic.gaomf.store/Circuit20160225214312.png" alt=""></p><p>至于具体的读取和擦除操作的命令及时序图，参考所使用的芯片的数据手册即可。</p><hr><p>对于NAND Flash而言，它没有专用的地址线，而是通过控制接口与CPU 相连，数据总线为8-bit或16-bit。以K9F1G08U0B为例，其内部存储单元的组织形式如图所示：<br><img src="https://pic.gaomf.store/Circuit20160225222049.png" alt=""></p><p>一般NAND Flash有以下这些信号线：<br><img src="https://pic.gaomf.store/Circuit20160225223229.png" alt=""></p><p>大部分CPU中均集成了NAND Flash控制器，此时只需要将对应引脚连接起来，然后根据CPU数据手册进行配置即可。如果需要自己实现NAND Flash控制器，那就需要根据NAND Flash的命令集及时序图进行编程了，这个对大部分NAND Flash应该都是基本通用的。具体可进一步参考相关文章，如</p><blockquote><p><a href="http://alanwu.blog.51cto.com/3652632/1429438" target="_blank" rel="noopener">NAND Flash操作技术详解</a></p></blockquote><hr><p>从单个存储单元能存储的比特数来看，Flash芯片又可分为三种，SLC，MLC及TLC。这三者的区别简单来说就是SLC在每个存储单元中只存储1-bit数据，MLC为2-bit，而TLC为3-bit。关于这个问题，可进一步参考Micron公司的文章<a href="https://www.micron.com/products/nand-flash/tlc-mlc-and-slc-devices" target="_blank" rel="noopener">TLC MLC and SLC Devices</a>和<a href="http://www.mydigitaldiscount.com/everything-you-need-to-know-about-slc-mlc-and-tlc-nand-flash.html" target="_blank" rel="noopener">这篇博客文章</a>。</p><p><span id="eMMC2"></span></p><h3 id="eMMC"><a href="#eMMC" class="headerlink" title="eMMC"></a>eMMC</h3><p>eMMC并不是一种存储介质，它是Embedded Multi Meida Card的缩写，而MMC就是指常见的SD卡、TF卡一类的存储卡。MMC相当于一种接口标准，可通过SPI或SDIO总线进行访问，而eMMC就是指符合这种接口标准的存储芯片。它是由NAND Flash加主控封装在一起做出来的，与种类繁多的NAND Flash相比，eMMC统一了接口形式，可以使用和操作SD卡一样的方式去控制NAND Flash。</p><p>eMMC与NAND Flash相比，其优点在于更为稳定可靠，内部集成的主控IC会自动完成坏块处理等工作。另外，如果直接使用NAND Flash的话，产品升级就需要重新修改不少软件，而使用eMMC则不需要，这有助于减小开发新产品的工作量。</p><p>Samsung、SanDisk、Kingston、Toshiba等公司均提供eMMC芯片，容量从2G~64G不等，基本所有的eMMC均使用BGA封装。</p><p><span id="SRAM2"></span></p><h3 id="SRAM-1"><a href="#SRAM-1" class="headerlink" title="SRAM"></a>SRAM</h3><p>SRAM的特点在于其的高速与小容量，它是目前读写速度最快的存储设备，但它也较为昂贵。CPU内部的Cache使用的就是SRAM，嵌入式SoC内部集成的内存也都是SRAM。SRAM可以直接对任意地址寻址，其读取是严格意义上的随机的（Random）。<br>SRAM基本上可以分为两大类：异步（<a href="http://www.issi.com/US/product-asynchronous-sram.shtml" target="_blank" rel="noopener">Asynchronous</a>）SRAM和同步（<a href="http://www.issi.com/US/product-synchronous-sram.shtml" target="_blank" rel="noopener">Synchronous</a>）SRAM。异步SRAM的访问独立于时钟，数据输入和输出都由地址的变化控制。同步SRAM的所有访问都在时钟的上升/下降沿启动。地址、数据输入和其它控制信号均于时钟信号相关。<br><a href="http://www.issi.com/" target="_blank" rel="noopener">ISSI</a>公司提供了很多型号的SRAM可供选择，从类型上来看主要有<a href="http://www.issi.com/US/product-synchronous-sram.shtml#jump3" target="_blank" rel="noopener">ZBT SRAM</a>、<a href="http://www.issi.com/US/product-quad_p_ddr2_p.shtml" target="_blank" rel="noopener">DDR SRAM</a>、<a href="http://www.issi.com/US/product-quad_p_ddr2_p.shtml" target="_blank" rel="noopener">QDR SRAM</a>等。</p><p>ZBT SRAM即Zero Bus Turnaround，零翻转SRAM。对于普通SRAM而言，由于读操作和写操作驱动方不同，当出现类似写-读-写操作时，相邻操作之间需插入一个空闲周期以便切换驱动方法。在读写操作切换频繁的应用中，这种空闲周期将严重地影响存储性能。对于ZBT SRAM，在读写操作之间不存在空闲周期，即读写操作可无缝连接，从而提高了存储性能。</p><p>SRAM主要应用于高速缓存，是决定整个系统性能的关键部分。然而，ZBT SRAM的运行频率无法超过200MHz，随着系统的升级，ZBT SRAM已无法满足更高性能系统的要求，由此又诞生了QDR/DDR SRAM（升级后分别为QDR II/DDR II SRAM），其中DDR II SRAM又分为CIO（Common IO）和SIO（Separated IO）两大类。QDR是指四倍数据速率（Quad Data Rate），DDR的双倍数据速率是通过双边沿对数据采样实现的，QDR的数据采样同样基于双边沿，且进一步将数据的读端口和写端口分开，利用同一组地址和控制信号实现对这两个端口的访问，输入输出同时进行，从而实现四倍数据速率的同时，消除了读写操作之间的空闲周期，提高了存储效率。</p><p><span id="DRAM2"></span></p><h3 id="DRAM-1"><a href="#DRAM-1" class="headerlink" title="DRAM"></a>DRAM</h3><p>DRAM一般作为系统的主内存，常用的DRAM可进一步分为SDRAM（Synchronous）、DDR SDRAM、DDR2 SDRAM、DDR3 SDRAM等。SDRAM即同步动态随机存储器，同步指存储器的工作需要参考时钟。对于同步存储器件，有三个与工作速率相关的重要指标：内核工作频率，时钟频率和数据传输速率。</p><p>不同类型的SDRAM的区别主要在于其读取速度不同，见下图和下表：<br><img src="https://pic.gaomf.store/CircuitSDRAM%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87.png" alt=""></p><p><img src="https://pic.gaomf.store/Circuitsdram_cpr1.png" alt=""></p><p>SDRAM需要定时进行刷新，这一般是由专用的控制器模块或驱动芯片完成的，绝大部分CPU和一些高端MCU中都集成了控制器模块，只需要将对应的引脚连接起来，再进行相应的配置后即可使用了。</p><p><span id="PSRAM2"></span></p><h3 id="PSRAM"><a href="#PSRAM" class="headerlink" title="PSRAM"></a>PSRAM</h3><p><a href="http://www.issi.com/US/product-cellular-ram.shtml" target="_blank" rel="noopener">PSRAM</a>即Pseudo static random access memory，伪静态随机存储器。它的内部存储颗粒其实与SDRAM的结构类似，不过外部接口则与SRAM类似。可以视为是内部集成了控制器的SDRAM，这主要用于没有SDRAM控制器的MCU应用中。它的容量介于SRAM与SDRAM之间。</p><p><span id="FRAM2"></span></p><h3 id="FRAM"><a href="#FRAM" class="headerlink" title="FRAM"></a>FRAM</h3><p>FRAM在某些时候可用于替代SRAM或EEPROM及Flash。TI就在各大MCU厂商中率先使用了FRAM，<a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/msp/ultra-low_power/msp430frxx_fram/overview.page" target="_blank" rel="noopener">MSP430FR</a>系列MCU中就只有FRAM。详细信息可参考TI的文章<a href="http://www.ti.com/lsds/ti/microcontrollers_16-bit_32-bit/msp/ultra-low_power/msp430frxx_fram/what_is_fram.page" target="_blank" rel="noopener">What is FRAM</a>。</p><p>下面这个Demo视频中演示了FRAM的读取速度：<br><a href="https://www.youtube.com/watch?v=hQMRMvXjjHE" target="_blank" rel="noopener">FRAM Write Speed Demo (FRAM vs. SRAM vs. EEPROM)</a></p><p><span id="Compare"></span></p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>可参考<a href="https://www.fujitsu.com/downloads/MICRO/fme/fram/fram-guide-book.pdf" target="_blank" rel="noopener">FRAM Guide Book</a>中的比较表格：<br><img src="https://pic.gaomf.store/Circuit20160225194159.png" alt=""></p><p>最后对各种存储器的应用范围做一总结：<br>*<em>Msak ROM和PROM一般作为芯片的一部分存在；<br>EPROM已基本被淘汰；<br>EEPROM用于需要能够很方便的进行随机存储（单字节操作）的场合，且其容量一般不大；<br>Flash用于大量数据的存储，其中NOR Flash容量较小，不过能进行随机读操作，也可以运行程序；NAND Flash容量较大，不过只能按页操作，不可在其中运行程序；<br>SRAM容量较小，用在对速度要求高的地方，如果需要掉电后保存数据，可考虑使用FRAM；<br>DRAM容量较大，用于当做系统的主内存。<br>*</em></p><p><span id="Reference"></span></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>[1] <a href="http://www.amazon.com/Digital-Electronics-Practical-Approach-Edition/dp/0132543036" target="_blank" rel="noopener">William Kleitz. Digital Electronics: A Practical Approach with VHDL (9th Edition). Pearson Prentice Hall, 2011.</a><br>[2] <a href="http://www.wangdali.net/%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0/" target="_blank" rel="noopener">存储器概述</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> HW Component </tag>
            
            <tag> Flash </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Altium Designer导出Gerber文件方法</title>
      <link href="/2016/03/04/Altium%20Designer%E5%AF%BC%E5%87%BAGerber%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/"/>
      <url>/2016/03/04/Altium%20Designer%E5%AF%BC%E5%87%BAGerber%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>详细步骤参考<a href="http://d1.amobbs.com/bbs_upload782111/files_27/ourdev_540478.pdf" target="_blank" rel="noopener">此文档</a>与<a href="http://pcbask.maihui.net/?/article/18" target="_blank" rel="noopener">这篇文章</a>，此处仅简要记录一下所需的操作步骤。</p><a id="more"></a><ol><li><p>将坐标原点设置为板子的左下角</p></li><li><p>在<code>Drill Drawing</code>层添加字符串<code>.Legned</code>，这是孔位图生成的位置，一般放在板子右侧下方</p></li><li><p>输出<code>Gerber Files</code></p></li><li><p>1 <code>General</code>选项卡中，单位<code>Inches</code>，格式<code>2:5</code></p></li><li><p>2 <code>Layers</code>选项卡中，选中所需层，一般不要选<code>Mirror</code>，不要选<code>Mechanical Lyaers(s) to Add to All Plots</code>中的层</p></li><li><p>3 <code>Drill Drawing</code>选项卡中，勾选<code>Drill Drawing Plots</code>，<code>.Legend Symbols</code>选<code>Characters</code></p></li><li><p>4 <code>Apetures</code>选项卡中勾选<code>RS274X</code></p></li><li><p>5 <code>Advanced</code>选项卡中，选取<code>Suppress leading zeros</code>、<code>Reference to relative origin</code>、<code>Unsorted(raster)</code>，其余用默认值即可</p></li><li><p>输出<code>NC Drill Files</code>，单位<code>Inches</code>，格式<code>2:5</code>，选取<code>Suppress leading zeros</code>、<code>Reference to relative origin</code>、<code>Optimize change location commands</code>，其余用默认值即可</p></li><li><p>打包输出文件，并不是所有输出文件都是必要的，不过出于简单考虑，可以全部一起打包即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客修改Archive页面显示文章数量</title>
      <link href="/2016/03/03/Hexo%E5%8D%9A%E5%AE%A2%E4%BF%AE%E6%94%B9Archive%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%95%B0%E9%87%8F/"/>
      <url>/2016/03/03/Hexo%E5%8D%9A%E5%AE%A2%E4%BF%AE%E6%94%B9Archive%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>之前配置的<a href="https://swiftype.com/" target="_blank" rel="noopener">Swiftype</a>站内搜索功能很不稳定，经常因为网络问题无法返回搜索结果，所以要找写过的某篇文章就不太方便。为解决这个问题，有一个方法是在<a href="http://gaomf.cn/archives">Archive</a>页面上不分页，然后就可以用浏览器自带的搜索功能来搜索标题了。</p><p>默认情况下，Hexo无法对主页、Archive页面、标签页面每页显示文章数量进行单独设置，所以需要安装<code>hexo-generator-archive</code>插件来实现这个功能。</p><a id="more"></a><p>使用如下命令安装：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">archive</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>安装好后修改<code>_config.yml</code>中的相关配置，分别对<code>index</code>、<code>archive</code>、<code>tag</code>及<code>category</code>页面进行设置即可：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Pagination</span></span><br><span class="line"><span class="meta">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="symbol">index_generator:</span></span><br><span class="line"><span class="symbol">  per_page:</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">archive_generator:</span></span><br><span class="line"><span class="symbol">  per_page:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">tag_generator:</span></span><br><span class="line"><span class="symbol">  per_page:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">category_generator:</span></span><br><span class="line"><span class="symbol">  per_page:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure><p>参考资料：</p><blockquote><p><a href="http://www.yuzhewo.com/2015/11/21/Hexo%E7%A8%8B%E5%BA%8Farchive%E9%A1%B5%E9%9D%A2%E6%95%B0%E9%87%8F%E8%AE%BE%E7%BD%AE/" target="_blank" rel="noopener">Hexo程序archive页面数量设置</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Population Count算法</title>
      <link href="/2016/02/24/Population%20Count%E7%AE%97%E6%B3%95/"/>
      <url>/2016/02/24/Population%20Count%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>所谓<a href="http://en.wikichip.org/wiki/population_count" target="_blank" rel="noopener">Population Count</a>算法，即是指计算一个二进制数中1的个数的算法。具体来说，就是任意给定一个无符号整数N，求N的二进制表示中1的个数，比如N = 5（0101）时，返回2；N = 15（1111）时，返回4。</p><p>这个问题是一个经典的面试题目，在实际中也有应用。关于这个问题，以下两篇博客文章中有较详细的论述：</p><blockquote><p><a href="http://github.tiankonguse.com/blog/2014/11/16/bit-count-more/" target="_blank" rel="noopener">详解二进制数中1的个数</a><br><a href="http://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html" target="_blank" rel="noopener">算法-求二进制数中1的个数</a></p></blockquote><p>在此，仅对其中一些较为常规和较为巧妙的方法做一总结，并比较一下他们的执行效率。</p><a id="more"></a><h2 id="直接法1"><a href="#直接法1" class="headerlink" title="直接法1"></a>直接法1</h2><p>直接逐位判断，最直接也是最低效的方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">CountOne1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> N = <span class="number">8</span> * <span class="keyword">sizeof</span>(num);</span><br><span class="line">  <span class="keyword">char</span> Count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (N--)</span><br><span class="line">  &#123;</span><br><span class="line">    Count += num &amp; <span class="number">1</span>;</span><br><span class="line">    num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--more--><h2 id="直接法2"><a href="#直接法2" class="headerlink" title="直接法2"></a>直接法2</h2><p>在“直接法1”的基础上进行改进，当移位结果为0后就退出循环，这样循环次数与首位1的位置有关。最优情况下只循环一次，最坏情况下循环N次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">CountOne2</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> Count;</span><br><span class="line">  <span class="keyword">for</span> (Count = <span class="number">0</span>; num != <span class="number">0</span>; num &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Count += num &amp; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逐次清除最低位1"><a href="#逐次清除最低位1" class="headerlink" title="逐次清除最低位1"></a>逐次清除最低位1</h2><p>此方法利用<code>num &amp;= (num - 1)</code>可清除最低位1的原理进行计数。<br><code>num</code>与<code>num - 1</code>的区别在于，<code>num</code>的最低位1在<code>num - 1</code>中变为了0，故二者取与后即可清除最低位1.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountOne3</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> Count;</span><br><span class="line">  <span class="keyword">for</span> (Count = <span class="number">0</span>; num != <span class="number">0</span>; Count++)</span><br><span class="line">  &#123;</span><br><span class="line">      num &amp;= (num - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分支法"><a href="#分支法" class="headerlink" title="分支法"></a>分支法</h2><p>思路类似二分法，两两相加后即可得到结果，见下图：<br><img src="https://pic.gaomf.store/Software2010060623161414.jpg" alt=""><br>在<a href="http://github.tiankonguse.com/blog/2014/11/16/bit-count-more/" target="_blank" rel="noopener">详解二进制数中1的个数</a>中对此有详细描述。此方法复杂度为Log(N)(之前几种方法复杂度均为N)，对于32位整数只需要计算5次即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">CountOne4</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  num = (num &amp; <span class="number">0x55555555</span>) + ((num &gt;&gt; <span class="number">1</span>)  &amp; <span class="number">0x55555555</span>); </span><br><span class="line">  num = (num &amp; <span class="number">0x33333333</span>) + ((num &gt;&gt; <span class="number">2</span>)  &amp; <span class="number">0x33333333</span>); </span><br><span class="line">  num = (num &amp; <span class="number">0x0f0f0f0f</span>) + ((num &gt;&gt; <span class="number">4</span>)  &amp; <span class="number">0x0f0f0f0f</span>); </span><br><span class="line">  num = (num &amp; <span class="number">0x00ff00ff</span>) + ((num &gt;&gt; <span class="number">8</span>)  &amp; <span class="number">0x00ff00ff</span>); </span><br><span class="line">  num = (num &amp; <span class="number">0x0000ffff</span>) + ((num &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> num ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h2><p>这是一种很巧妙的方法，在此对其原理不多做说明，可参考之前提到的那两篇博客文章。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">CountOne5</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> tmp = num - ((num &gt;&gt; <span class="number">1</span>) &amp; <span class="number">033333333333</span>) - ((num &gt;&gt; <span class="number">2</span>) &amp; <span class="number">011111111111</span>);</span><br><span class="line">  <span class="keyword">return</span> ( (tmp + (tmp &gt;&gt; <span class="number">3</span>) ) &amp; <span class="number">030707070707</span>) % <span class="number">63</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CPU指令实现"><a href="#CPU指令实现" class="headerlink" title="CPU指令实现"></a>CPU指令实现</h2><p>部分CPU中直接提供了指令来完成这一操作，这无疑是效率最高且最为简洁的方法。</p><p>在Intel x86中，如果CPU支持<a href="https://en.wikipedia.org/wiki/SSE4" target="_blank" rel="noopener">SSE4</a>指令集，那可以使用POPCNT指令来计算二进制数中1的个数，实验表明，这应该是一个单周期指令，所以这无疑是最优的解决方案。</p><p>在MSVC下，可通过<code>_mm_popcnt_u32()</code>函数来调用POPCNT指令，详细信息可参考<a href="https://msdn.microsoft.com/en-us/library/bb514083.aspx" target="_blank" rel="noopener">MSDN上的帮助</a>。<br>调用示例如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;nmmintrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Count = _mm_popcnt_u32(num);</span><br></pre></td></tr></table></figure><p>在GCC下，可直接调用<code>__builtin_popcountll()</code>函数，编译时加上编译选项<code>-mpopcnt</code>即可，此时编译器会自动使用POPCNT指令。</p><p>在ARM中，也有类似的指令，比如<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0081b/CHDJJGAJ.html" target="_blank" rel="noopener">POPCOUNT宏</a>（需要约10个时钟周期），<a href="http://www.arm.com/zh/products/processors/technologies/neon.php" target="_blank" rel="noopener">NEON</a> SIMD指令集中的<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489g/CIHCFDBJ.html" target="_blank" rel="noopener">VCNT</a>及<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0802a/CNT_advsimd_vector.html" target="_blank" rel="noopener">CNT</a>指令。</p><p>POPCNT指令应该是有其实际重要作用的，比如在OpenCV的编译过程中就可以选择是否启用POPCNT指令。</p><h2 id="执行时间对比"><a href="#执行时间对比" class="headerlink" title="执行时间对比"></a>执行时间对比</h2><p>毫无疑问，直接调用CPU指令是最佳的解决方案，将其执行时间规定为1，对其他算法的执行时间进行归一化处理，结果如下：<br><img src="https://pic.gaomf.store/20160224Graph.png-height" alt=""></p><p>从中可以看到，除了特别简单的情况下（如0x01），分枝法与三分法的执行效率是最好的，且这两种算法是稳定的算法，其执行时间不依赖于输入数据。逐次清除最低位1法在1的个数较少时也不失为一种好方法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Matlab调用Origin作图</title>
      <link href="/2016/01/28/Matlab%E8%B0%83%E7%94%A8Origin%E4%BD%9C%E5%9B%BE/"/>
      <url>/2016/01/28/Matlab%E8%B0%83%E7%94%A8Origin%E4%BD%9C%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>Matlab作出的图普遍没有Origin作出的美观好看，而且导出为eps或emf格式后会有各种奇怪的Bug。目前普遍采用的一种方法是，将Matlab数据导出为mat文件后再导入Origin中手工作图，这种方式需要不少重复性劳动，并不是一种很完美的解决方案。<br>前几天偶然看到Origin提供了COM接口可供Matlab调用，于是就研究了下可否用Matlab调用Origin来生成所需的emf格式图片，最终经过一番折腾，基本完成了这个目标。</p><a id="more"></a><p>之所以能用Matlab来调用Origin，这要依赖于Origin中提供的<a href="http://www.originlab.com/index.aspx?go=Products/Origin/Programming/AutomationServer" target="_blank" rel="noopener">Automation Server</a>服务。这个服务提供了一个COM接口来供其他程序调用，官方提供了Matlab、VB、Excel、C#、LabVIEW等诸多程序调用Origin的例子。Automation Server的详细使用方法可参考其<a href="http://www.originlab.com/doc/COM" target="_blank" rel="noopener">官方帮助文档</a>。</p><p>Matlab调用Origin的示例程序位于<code>&lt;Install Path&gt;\Samples\COM Server and Client\MATLAB</code>路径下（以Origin 2015为例，其他版本的位置可能有所不同）。一共有两个m文件，<code>CreatePlotInOrigin.m</code>及<code>MATLABCallOrigin.m</code>，前者用于实现调用Origin绘图，并将结果保存到剪贴板中，后者演示了如何创建工作表(Worksheet)，如何插入新列等操作。另外一个<code>CreatePlotInOrigin.opj</code>文件是供<code>CreatePlotInOrigin.m</code>调用的一个Origin模板文件。</p><p>根据这两个示例程序基本就可以依葫芦画瓢写出一个符合自己要求的程序了，然而这其中并没有导出emf格式图片的示例，于是开始研究其官方帮助文档……官方帮助文档很多地方都语焉不详，而且其间还经历了种种坑，比如<a href="http://GaoMF.cn/2016/01/27/Origin%20Script%20Window%20%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/">上篇文章</a>这个。不过最终还是找到了正确的解决办法，就是使用Origin <a href="http://www.originlab.com/doc/X-Function" target="_blank" rel="noopener">X-Function</a>中的<a href="http://www.originlab.com/doc/X-Function/ref/expGraph" target="_blank" rel="noopener">expGraph</a>命令。</p><hr><p>最终找到的较好的解决方案是这样的：</p><p>首先，用Origin生成一个空白模板工程，其中包含了基本的Worksheet结构及Graph样式，比如示例文件中提供的这个：<br><img src="https://pic.gaomf.store/Matlab20160128204513.png" alt=""></p><p>这个模板工程需要保证只要向Worksheet中填入数据，Graph中就能生成所需的图，就像这样：<br><img src="https://pic.gaomf.store/Matlab20160128205045.png" alt=""></p><p>这里的Worksheet和Graph可以不止有一个，不过一般情况下一个就足够了。</p><p>制作好了模板文件后，在Matlab程序中只需要通过COM接口调用Origin，打开这个模板文件，然后向其中的Worksheet填入正确的数据，最后导出图片文件即可。<br>Matlab程序如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 调用Origin作图并保存为emf格式的图片</span></span><br><span class="line"><span class="comment">% 作者 : 高明飞</span></span><br><span class="line"><span class="comment">% 日期 : 2016-01-27</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% mdata : 需要填充到Origin Worksheet中的数据</span></span><br><span class="line"><span class="comment">% template : Origin模板函数名，不含后缀，需要保存在当前工作目录下，如'CreatePlotInOrigin'</span></span><br><span class="line"><span class="comment">% fdir : 输出图片目标文件夹，如'D:\image'</span></span><br><span class="line"><span class="comment">% fname : 输出图片文件名，不含后缀，如'abc'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OriginPlot</span><span class="params">(mdata, template, fdir, fname)</span></span></span><br><span class="line"><span class="comment">% Obtain Origin COM Server object</span></span><br><span class="line"><span class="comment">% This will connect to an existing instance of Origin, or create a new one if none exist</span></span><br><span class="line">originObj=actxserver(<span class="string">'Origin.ApplicationSI'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Clear "dirty" flag in Origin to suppress prompt for saving current project</span></span><br><span class="line">invoke(originObj, <span class="string">'IsModified'</span>, <span class="string">'false'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Load the custom template project</span></span><br><span class="line">dir = pwd;</span><br><span class="line">dir = strcat(dir, <span class="string">'\', template, '</span>.opj');</span><br><span class="line">invoke(originObj, <span class="string">'Load'</span>, dir);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Send this data over to the Data1 worksheet</span></span><br><span class="line">invoke(originObj, <span class="string">'PutWorksheet'</span>, <span class="string">'Data1'</span>, mdata);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Save graph</span></span><br><span class="line">cmd = <span class="string">'expGraph type:=emf overwrite := rename tr1.unit := 2 tr1.width := 10000 path:= "'</span>;</span><br><span class="line">cmd = strcat(cmd, fdir, <span class="string">'" filename:= "'</span>, fname, <span class="string">'.emf";'</span>);</span><br><span class="line">invoke(originObj, <span class="string">'Execute'</span>, cmd);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Release</span></span><br><span class="line">release(originObj);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面这段程序中要求Worksheet的名称需要为<code>Data1</code>，这是由<code>invoke(originObj, &#39;PutWorksheet&#39;, &#39;Data1&#39;, mdata);</code>这句代码确定的；<br>导出的图片为emf格式，图像宽度为10000像素，因为这是矢量图，所以文件体积并不大的。</p><p>以上这个版本只是个最基本的版本，不过一般使用也够用了，更多的高级功能，比如动态调整坐标轴名称，动态调整x、y轴的范围以适应不同数据等之后有空再来研究……</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Origin Script Window 执行脚本代码的方法</title>
      <link href="/2016/01/27/Origin%20Script%20Window%20%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2016/01/27/Origin%20Script%20Window%20%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在<a href="http://www.originlab.com/" target="_blank" rel="noopener">Origin</a>中，有一个Script Window可用于执行LabTalk和X-Function脚本程序，可通过菜单栏上的<code>Window</code>-&gt;<code>Script Window</code>打开。<strong>然而这个Script Window有一个大坑，就是它诡异的执行代码的方式。</strong></p><a id="more"></a><p>这个Script Window是像这样的：<br><img src="https://pic.gaomf.store/Software20160127165933.png" alt=""></p><p>界面上并没有一个执行按钮，按正常思路应该是输完一行代码后敲一下回车就会执行这行代码了，<strong>然而，这个Script Window却不是这样的，其运行代码的方式极为诡异……</strong></p><p>在Script Window中，<strong>输完一行代码后按回车键的作用是正常的换行</strong>，要想执行代码，需要<strong>把光标输入点移动到这一行之前的任意位置处（即不要是行尾即可），然后再按回车键，这样就会执行这一行代码了</strong>。另一个更坑的问题是，这样也仅仅只是执行这一行代码，并不是执行所有代码……<strong>要执行某一行代码就需要把光标移动到这一行中间按回车才行……</strong></p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>集成式负载开关</title>
      <link href="/2016/01/24/%E9%9B%86%E6%88%90%E5%BC%8F%E8%B4%9F%E8%BD%BD%E5%BC%80%E5%85%B3/"/>
      <url>/2016/01/24/%E9%9B%86%E6%88%90%E5%BC%8F%E8%B4%9F%E8%BD%BD%E5%BC%80%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>在很多系统中，需要能够控制某些支路的电流通断，常用的方法是使用一个PMOS管或是一个PMOS管加上一个NMOS管，典型的分立器件方案如下：</p><a id="more"></a><p><img src="https://pic.gaomf.store/Circuit3757.b1.png-550x0.png-width300" alt=""></p><p>此电路的完整仿真分析见：</p><blockquote><p><a href="/2017/05/05/Discrete_Load_Switch/">带软启动的分立负载开关电路</a></p></blockquote><p>出于节省空间的考虑，也可使用一个单独的集成式负载开关来实现这一目的，典型器件如<a href="http://www.ti.com/product/tps27081a" target="_blank" rel="noopener">TPS27081A</a>。这一类器件内部基本原理框图如下所示:</p><p><img src="https://pic.gaomf.store/Circuit1780.b3.jpg-550x0.jpg-width300" alt=""></p><p>这类器件除了基本的开关功能外，其压摆率可以进行控制，以此减小浪涌电流，这也被称为“软启动”功能。</p><p>关于负载开关更详细的说明可参考以下一些文章：</p><blockquote><p><a href="http://www.deyisupport.com/blog/b/power_house/archive/2015/11/11/52182.aspx?sp_rid_pod4=MTE1NzI3NDI1MDQ1S0&sp_mid_pod4=50500000&detailID=20971220" target="_blank" rel="noopener">什么是负载开关？</a><br><a href="https://e2e.ti.com/blogs_/b/analogwire/archive/2015/02/23/how-to-save-power-using-load-switches" target="_blank" rel="noopener">How to save power using load switches</a><br><a href="http://www.ti.com/lit/an/slva652/slva652.pdf" target="_blank" rel="noopener">Load Switches: What Are They, Why Do You Need Them And How Do You Choose The Right One?</a></p></blockquote><p>TI器件选型：</p><blockquote><p><a href="http://www.ti.com/lsds/ti/power-management/integrated-load-switches-products.page" target="_blank" rel="noopener">Products for Integrated Load Switches</a><br>封装形式多样，如SOT、QFN、DSBGA等。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HW Component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartus中配置FPGA未使用引脚状态方法</title>
      <link href="/2016/01/12/Quartus%E4%B8%AD%E9%85%8D%E7%BD%AEFPGA%E6%9C%AA%E4%BD%BF%E7%94%A8%E5%BC%95%E8%84%9A%E7%8A%B6%E6%80%81%E6%96%B9%E6%B3%95/"/>
      <url>/2016/01/12/Quartus%E4%B8%AD%E9%85%8D%E7%BD%AEFPGA%E6%9C%AA%E4%BD%BF%E7%94%A8%E5%BC%95%E8%84%9A%E7%8A%B6%E6%80%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>FPGA开发中未使用的引脚一般需要配置为输入悬空状态，即“As input tri-stated”，配置方法也很简单，下面以Quartus 14.0为例说明一下：</p><a id="more"></a><p><img src="https://pic.gaomf.store/FPGA20160112.gif" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IGBT与MOSFET比较</title>
      <link href="/2016/01/11/IGBT%E4%B8%8EMOSFET%E5%BC%82%E5%90%8C/"/>
      <url>/2016/01/11/IGBT%E4%B8%8EMOSFET%E5%BC%82%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<p>大功率IGBT与MOSFET都属于功率器件，一般都用来当做开关管，本文对这两种器件进行些简要的比较。</p><a id="more"></a><h2 id="电路符号"><a href="#电路符号" class="headerlink" title="电路符号"></a><strong>电路符号</strong></h2><p>IGBT（Insulated Gate Bipolar Transistor, 绝缘闸双极晶体管）的电路符号如下：<br><img src="https://pic.gaomf.store/CircuitIGBT_SYMBOL.png" alt=""></p><p>三个极分别称为：<br>G：Gate，栅极<br>C：Collector，集电极<br>E：Emitter，发射极</p><p>MOSFET（Metal-Oxide-Semiconductor Field-Effect Transistor, 金属氧化物半导体场效应管）的电路符号如下：<br><img src="https://pic.gaomf.store/CircuitMOSFET_Symbol.png" alt=""></p><p>三个极分别称为：<br>G：Gate，栅极<br>D：Drain，漏极<br>S：Source，源极</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h2><p>IGBT与MOSFET的结构对比如下：<br><img src="https://pic.gaomf.store/Circuit0514_WTDrenesas_FO.gif" alt=""></p><p>从结构上来说，<strong>IGBT可以视为一个MOSFET与一个三极管的组合</strong>，即可用下面这个等效电路来表示：<br><img src="https://pic.gaomf.store/Circuit20160111223222.png" alt=""></p><h2 id="应用特性"><a href="#应用特性" class="headerlink" title="应用特性"></a><strong>应用特性</strong></h2><p>一言以蔽之：<strong>IGBT高压高功率性能优越，而MOSFET高频性能优越</strong>，见下图：<br><img src="https://pic.gaomf.store/Circuit20160111223914.png" alt=""></p><h2 id="控制方法"><a href="#控制方法" class="headerlink" title="控制方法"></a><strong>控制方法</strong></h2><p>二者的驱动电路基本完全相同，可以相互替换。</p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h2><p>对于MOSFET来说,仅由多子承担的电荷运输没有任何存储效应,因此,很容易实现极短的开关时间。POWER MOSFET其高频特性十分优秀，所以MOSFET可用于较高频率的场合。在低电源电压下动作时之功率损失（POWER LOSS）远低于以往之组件，但是问题是,在高压的”开”状态下的源漏电阻很高(压降高),而且随着器件的电压等级迅速增长（耐压越高导通电阻越大,除了采用COOLMOS管芯的以外)。因而其传导损耗就很高,特别在高功率应用时,很受限制。</p><p>和MOSFET有所不同,IGBT器件中少子也参与了导电,IGBT是采用MOS结构的双极器件导通电阻小(发热就少)高耐压,因而可大大降低导通压降。但另一方面,存储电荷的增强与耗散引发了开关损耗、延迟时间(存储时间)、以及在关断时还会引发集电极拖尾电流。同时存在的电流尾巴和较高的IGBT集电极到发射极电压将产生关闭开关损耗，这样就限制了IGBT的上限频率。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p><strong>MOSFET一般在较低功率应用及较高频应用（即功率&lt;1kW及开关频率≥100kHz）中表现较好，而IGBT则在较低频及较高功率设计中表现卓越。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><blockquote><p><a href="http://www.irf.com/technical-info/whitepaper/choosewisely.pdf" target="_blank" rel="noopener">IGBT or MOSFET: Choose Wisely</a><br><a href="http://www.infineon.com/dgdl/Infineon-Description_IGBT-AN-v1.0-en.pdf?fileId=db3a30433f565836013f5ca72d4e29db" target="_blank" rel="noopener">IGBT (Insulated Gate Bipolar Transistor)</a><br><a href="http://www.mosigbt.com/igbtzhishi/78.html" target="_blank" rel="noopener">IGBT、MOSFET与三极管的区别</a><br><a href="http://www.mosigbt.com/igbtzhishi/26.html" target="_blank" rel="noopener">IGBT与MOSFET的区别</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor </tag>
            
            <tag> HW Component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三相逆变器电流采样方案总结</title>
      <link href="/2016/01/01/%E4%B8%89%E7%9B%B8%E9%80%86%E5%8F%98%E5%99%A8%E7%94%B5%E6%B5%81%E9%87%87%E6%A0%B7%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"/>
      <url>/2016/01/01/%E4%B8%89%E7%9B%B8%E9%80%86%E5%8F%98%E5%99%A8%E7%94%B5%E6%B5%81%E9%87%87%E6%A0%B7%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>当使用三相逆变器进行电机控制时，经常需要获取相电流以进行闭环控制，这就涉及到一个电流采样问题。尽管现在有许多电流检测方法，但低成本、大批量应用中常见的只有三种，其它都是昂贵的实验室系统、新兴技术或很少使用的方法<sup>[1]</sup>。常用技术包括：采样电阻、霍尔元件与电流互感器。这些技术又可进一步细分，详见下图：<br><img src="https://pic.gaomf.store/Motor20151231154652.png-width300" alt=""><br>本文将具体介绍这些方案。</p><a id="more"></a><h2 id="霍尔元件"><a href="#霍尔元件" class="headerlink" title="霍尔元件"></a><strong>霍尔元件</strong></h2><p>使用霍尔元件进行电流检测最大的优势是霍尔传感器与载流导体之间没有电气接触，导体的电位可偏置几百伏且确保传感器良好运行。因此，使用霍尔元件进行电流检测时都是直接测量相电流的，如图所示<sup>[1]</sup>：<br><img src="https://pic.gaomf.store/Motor20151231132945.png" alt=""></p><p>图中的Current Sensor即是霍尔传感器。在此图中，使用了3个霍尔传感器来测量三相电流，但一般情况下，只需使用2个霍尔传感器即可。根据基尔霍夫电流定律，三相电流之和必为0，故可以通过两相的电流来推出第三相电流。</p><h3 id="开环霍尔元件与闭环霍尔元件"><a href="#开环霍尔元件与闭环霍尔元件" class="headerlink" title="开环霍尔元件与闭环霍尔元件"></a><strong>开环霍尔元件与闭环霍尔元件</strong></h3><p>霍尔传感器从原理上可分为两大类，开环霍尔元件和闭环霍尔元件，其测量原理示意图如下<sup>[2]</sup>：<br><img src="https://pic.gaomf.store/Motor20151231133811.png" alt=""></p><p>开环霍尔元件直接检测由待测电流激发出的磁场磁感应强度；闭环霍尔元件则是在磁环上又缠绕了一组线圈，其中电流通过反馈确定，以保证最终磁环中的磁感应强度为0，这样通过测量线圈中电流的大小即可推算出待测电流的大小。<br>闭环霍尔元件与开环霍尔元件相比，其检测精度较高，并且在响应时间、带宽等指标上也优于开环霍尔元件；不过其缺点在于结构较为复杂，这也就导致了其体积较大且成本较高。目前，开环霍尔元件使用的更多，且随着技术的发展，开环霍尔元件的检测精度也在不断提高，与闭环霍尔元件的差距并不是很大。</p><h3 id="传感器IC"><a href="#传感器IC" class="headerlink" title="传感器IC"></a><strong>传感器IC</strong></h3><p>一般情况下，直接选用现成的霍尔电流传感器IC进行电流检测。提供这类产品的厂家有很多，其中最为常用的为<a href="http://www.allegromicro.com/" target="_blank" rel="noopener">Allegro</a>公司的产品，下面就对此做一简要介绍。</p><p>Allegro公司的产品全部均为开环霍尔传感器，不过根据其宣传资料中的说明，其性能已经可以做到接近闭环霍尔元件的水平。其产品根据检测电流范围分为3个系列：</p><ul><li><a href="http://www.allegromicro.com/zh-CN/Products/Current-Sensor-ICs/Zero-To-Fifty-Amp-Integrated-Conductor-Sensor-ICs.aspx" target="_blank" rel="noopener">0至50A整合式导体传感器IC</a><br><img src="https://pic.gaomf.store/Motor0-50_Static.png" alt=""></li><li><a href="http://www.allegromicro.com/zh-CN/Products/Current-Sensor-ICs/Fifty-To-Two-Hundred-Amp-Integrated-Conductor-Sensor-ICs.aspx" target="_blank" rel="noopener">50至200A整合式导体传感器IC</a><br><img src="https://pic.gaomf.store/Motor0-200_Static.png" alt=""></li><li><a href="http://www.allegromicro.com/zh-CN/Products/Current-Sensor-ICs/SIP-Package-Zero-To-Thousand-Amp-Sensor-ICs.aspx" target="_blank" rel="noopener">SIP封装0到&gt;1000A传感器IC</a><br><img src="https://pic.gaomf.store/Motor0-1000A.png" alt=""></li></ul><p>从上面的传感器原理示意图中可以看到，Allegro公司的整合式导体传感器IC不需要额外的磁环，待测电流从传感器芯片中流过，这在电流不大（&lt;200A）时使用起来很方便。不过这种结构无法承载特别大的电流，故需要测量大电流（&gt;200A）时需要使用其SIP封装的传感器并使用外置的磁环进行测量。<br>在使用外置磁环时，不同磁环对应的磁感应强度与电流的关系并不相同，故需要进行标定。然而，精确提供一个很大的参考电流来进行标定并不容易，故在这种情况下，一般选用专业厂家使用Allegro传感器配合磁环做出来的模块。</p><p>下面简要介绍下上海粲斯电子科技有限公司的QFO12HC系列电流传感器模块。<br>此模块外形如图所示：<br><img src="https://pic.gaomf.store/MotorQFO12HC2.bmp" alt=""><br>传感器通电后，当被测电流从传感器箭头方向穿过，即可在输出端测得同相电压值。输出电压与待测电流间为线性关系，可使用<code>Vout = (Vcc/5)×(2.5+2×Ip/Ipmax)</code>进行计算，其中<code>Ipmax</code>为原边额定输入电流，<code>Ip</code>为待测电流。厂家已经对模块进行过标定处理，故直接上电即可使用，无需进行任何配置，使用起来极为方便。<br>对一个<code>Ipmax = 600A</code>的模块进行了测试，测试结果如下：<br><img src="https://pic.gaomf.store/Motor20151231152955.png" alt=""></p><p>电流使用电子负载进行设定，输出电压用万用表测得。从测试结果中可以看到，在0~10A这一范围内，模块的线性度很好，回归系数&gt;0.999，线性度为0.0176 %F.S。</p><h2 id="电流互感器"><a href="#电流互感器" class="headerlink" title="电流互感器"></a><strong>电流互感器</strong></h2><p>电流互感器其实就是一个变压器，它的一次侧绕组匝数很少，串在需要测量的电流的线路中，二次侧绕组匝数比较多，串接在测量仪表和保护回路中，电流互感器在工作时，它的二次侧回路始终是闭合的，因此测量仪表和保护回路串联线圈的阻抗很小，电流互感器的工作状态接近短路。电流互感器是把一次侧大电流转换成二次侧小电流来测量 ，二次侧不可开路。其原理示意图如下<sup>[1]</sup>：<br><img src="https://pic.gaomf.store/7aec54e736d12f2e9dcac7c44dc2d56284356842.jpg" alt=""></p><p>电流互感器一般用于电力电子系统中，而且一般是以一个仪表产品的形态出现。值得一提的是，广泛使用的钳型电流表实质上就是一个电流互感器。</p><h2 id="采样电阻"><a href="#采样电阻" class="headerlink" title="采样电阻"></a><strong>采样电阻</strong></h2><p>在绝大部分低成本应用中，都是使用采样电阻来进行电流采样的，故此方法可以说是最重要的电流采样方案。采样电阻被称为Sense Resistor或Shunt Resistor，其阻值一般较小，在1mΩ~1Ω之间。<br>在简单的应用中，使用一般的两触点电阻即可。根据功率不同可选择不同形式的电阻，如贴片电阻、康铜丝、水泥电阻等。然而，在需要进行精确电流采样的场合，使用普通的两触点电阻就不合适了。由于采样电阻本身的阻值很小，焊料的电阻并不能忽略，它们不确定，且随温度变化，会影响测量输出。此时，应该选用4触点的采样电阻。不过在三相逆变器相电流采样的过程中，一般是不需要考虑这个问题的，使用普通的两触点电阻即可。</p><p>按照采样电阻放置位置不同，电阻采样方案可分为两大类——高端采样(High-Side Sensing)与低端采样(Low-Side Sensing)，其区别见下图<sup>[4]</sup>：<br><img src="https://pic.gaomf.store/Motor20151231204133.png" alt=""><br>正如图中所示，高端采样中，采样电阻位于负载高端，即一端与电源连接；低端采样中，采样电阻位于负载低端，即一端与地平面连接。下面先介绍高端采样方案，再介绍低端采样方案。</p><h3 id="高端采样"><a href="#高端采样" class="headerlink" title="高端采样"></a><strong>高端采样</strong></h3><p>对于三相逆变器电路，采样电阻直接置于相电流桥臂上即可，如图所示<sup>[5]</sup>：<br><img src="https://pic.gaomf.store/Motor20151231224917.png" alt=""><br>根据基尔霍夫电流定律，只需要测量两相的电流即可，另一相电流可通过计算得到。高端采样的优势在于：</p><ol><li>采样得到的电流值在任何时刻都等于相电流值，对于采样时刻无需特别考虑；</li><li>因为使用类似差分输入的形式，可以很好的避免地平面噪声的干扰，检测精度会更高。</li></ol><p>高端采样最大的缺陷在于其对后级处理电路的要求很高，后级运放要能承受很高的且急剧变化的共模电压，这样的运放选择起来并不是很容易。<br>不过目前不少半导体厂商均有专门针对高端电流检测的运放芯片，比如TI有专门的Current Sense Amplifiers系列运放，最大共模电压为80V；ADI的AD8479能承受600V的共模电压；IR的IR2277更是能承受高达1200V的共模电压，其共模抑制比CMRR也达到了100dB。</p><h3 id="低端采样"><a href="#低端采样" class="headerlink" title="低端采样"></a><strong>低端采样</strong></h3><p>一般来说，高端采样是一种较为昂贵的解决方案，考虑到成本问题，更为普遍使用的是低端采样方案。常用的低端采样方案根据使用电阻数量的不同可分为三种——三电阻采样、双电阻采样与单电阻采样，其电路结构见下图<sup>[6]</sup>：</p><ul><li>三电阻采样：</li></ul><p><img src="https://pic.gaomf.store/Motor20160101001534.png" alt=""></p><ul><li>双电阻采样：</li></ul><p><img src="https://pic.gaomf.store/Motor20160101001552.png" alt=""></p><ul><li>单电阻采样：</li></ul><p><img src="https://pic.gaomf.store/Motor20160101001611.png" alt=""></p><p>其中，最为常用的是双电阻采样方案，在某些成本敏感的应用中，也会选用单电阻采样方案。</p><p>低端采样的优势在于：</p><ol><li>对运放没有特殊要求，选用常规通用运放即可；</li><li>成本低廉，特别是单电阻采样方案，具有较大的价格优势。</li></ol><p>其缺点在于：</p><ol><li>由于开关管的存在，流经采样电阻的电流并不随时等于相电流，对采样时刻有严格的要求；</li><li>地平面噪声会影响采样的准确性。</li></ol><p>采样时刻问题是使用低端采样时需要重点考虑的问题，下面将具体分析此问题。开关管的调制方式以SVPWM为例。</p><hr><p>从原理图中可以看到，当下桥臂的开关管断开的时候，采样电阻上显然是不会有电流流过的；只有当下桥臂开关管导通的时候，由于负载是感性负载，此时才会有续流电流从下桥臂流过，这个续流电流就等于相电流。<br>以SVPWM调试波形为例，使用Simulink对此过程进行仿真，结果见下图：<br><img src="https://pic.gaomf.store/Motor%E7%94%B5%E6%B5%81%E9%87%87%E6%A0%B7.png" alt=""><br>从图中可以看到，相电流是基本连续的，然而下桥臂电流并不连续，当且仅当下桥臂导通时流过下桥臂采样电阻的电流才等于相电流。</p><hr><p>所以对于双电阻及三电阻采样方案而言，只需要在SVPWM的零矢量（000）中央处进行采样即可获得正确的相电流。采样时刻示意图见下面这两张图<sup>[7, 8]</sup>：<br><img src="https://pic.gaomf.store/Motor20160101223135.png" alt=""><br><img src="https://pic.gaomf.store/Motor20160101223610.png" alt=""></p><p>双电阻采样的情况下，可以通过电流平衡条件推算出第三相的电流,不过此方案有一个问题，在某些情况下（如SVPWM几个扇区的交界处），采样窗口时间会变得很短。三电阻采样则不存在此问题，任何时刻都可丢弃采样窗口时间较短采样电阻的结果，用其他两相的电流值来推出此相的电流，其原理说明见下图<sup>[9]</sup>：<br><img src="https://pic.gaomf.store/Motor20160101225405.png" alt=""></p><hr><p>单电阻采样方案中，是通过在一个PWM周期内进行两次AD采样实现相电流检测的，其采样时刻见以下三张图<sup>[6, 7, 8]</sup>：<br><img src="https://pic.gaomf.store/Motor20160101230119.png" alt=""><br><img src="https://pic.gaomf.store/Motor20160101230250.png" alt=""><br><img src="https://pic.gaomf.store/Motor20160101231108.png" alt=""><br>图中T1与T2阶段就是采样时刻。</p><p>采样得到的电流值与相电流的对应关系见下表<sup>[6]</sup>：<br><img src="https://pic.gaomf.store/Motor20160101230736.png" alt=""></p><p>与双电阻采样方案一样，单电阻采样方案也存在一些不允许单分流三相重构的特殊情形。在SVPWM中，有些时候会输出两路占空比相等的PWM信号，如下图所示<sup>[6]</sup>，此时T2=0，不能重构得到三相电流信息。除此之外，死区时间等因素也会影响采样窗口，具体可参考文献[6]中的说明。<br><img src="https://pic.gaomf.store/Motor20160101231128.png" alt=""></p><p>解决此问题有几种不同的方案，详见文献[6, 10]中的分析。其中最常用的一种方法是：在相邻边界的时候插入固定时间的有效矢量，而在低调制区域的时候，采用轮流插入有效矢量的方法。插入有效矢量会给电流波形带来失真，这种情况下需要通过软件来进行补偿<sup>[10]</sup>。<br>文献[10]中还比较了双电阻采样与单电阻采样的优劣，可供参考。</p><p>最后还有个值得注意的问题，运放的选型与电路的设计也会影响电阻采样的效果，这方面的内容可参考文献[6, 8]中的说明。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>对于三相逆变器而言，进行电流检测最稳定方便且精度也较高的检测方法是使用集成霍尔传感器，不过其成本也较高。在大部分情况下，使用采样电阻进行低端检测是最为常用的方法。其中以两电阻检测最为普遍，如需进一步降低成本，可考虑使用单电阻检测的方案。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><blockquote><p>[1]    设备设计者为何应考虑将霍尔效应传感器芯片用于电机控制[R].Allegro MicroSystems LLC.<br>[2]    Wang Y, Liu J, Zhao J, et al. Split core closed loop hall effect current sensors and applications: PCIM EUROPE International Exhibition and Conference for Power, Electronics, Nuremberg, 2012[C].<br>[3]    百度百科. 电流互感器[EB/OL]. <a href="http://baike.baidu.com/view/427702.htm" target="_blank" rel="noopener">http://baike.baidu.com/view/427702.htm</a>.<br>[4]    Current Shunt Monitors, SLYB194A[R].Texas Instruments Incorporated, 2014.<br>[5]    Sino Henri. 高端电流检测:差动放大器 VS 电流检测放大器[J]. Analog Dialogue, 2008.<br>[6]    Torres Daniel, Zambada Jorge. PMSM无传感器FOC的单分流三相电流重构算法, AN1299[R].Microchip Technology Inc, 2009.<br>[7]    李飞飞. 基于PSoC4的矢量控制方案：电流采样[R].Cypress.<br>[8]    马达控制三相变频器中相电流Shunt检测电路设计, ZHCA598[R].Texas Instruments Incorporated, 2014.<br>[9]    TMS320F28026F, TMS320F28027F InstaSPIN™-FOC Software Technical Reference Manual, SPRUHP4[R].Texas Instruments Incorporated, 2013.<br>[10]    孙桂喜, 唐华标, 张建新, 等. 永磁同步电机矢量控制方案在变频空调风机中的运用[R].STMicroelectronics.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Motor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C2000 DSP基本数据类型</title>
      <link href="/2015/12/27/C2000%20DSP%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2015/12/27/C2000%20DSP%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>一般情况下，在大部分平台上，一个字节(byte)是指8bit，char占用8bit的空间，int占用32bit的空间。<strong>然而，在TI C2000 DSP上，情况确不是这样的。</strong>在C2000系列DSP上，<strong>byte = 16 bits，char = short = int = 16 bits，long = 32 bit，long long = 64bit</strong>。</p><a id="more"></a><p><img src="https://pic.gaomf.store/DSP20151227220552.png" alt=""></p><p>上图截自”<a href="http://www.ti.com/lit/spru514" target="_blank" rel="noopener">TMS320C28x Optimizing C/C++ Compiler User’s Guide</a>“</p><p>不过仔细看C语言标准，的确<strong>没有规定char是几位的，也只规定了long≥int≥short≥char</strong>。这也提醒我们，不要太依赖于所谓的经验，不要想当然……</p>]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C2000 ePWM模块</title>
      <link href="/2015/12/24/C2000%20ePWM%E6%A8%A1%E5%9D%97/"/>
      <url>/2015/12/24/C2000%20ePWM%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p><em>以TMS320F28030为例，其它型号可能有差异，不过大同小异。</em></p><p>在TI C2000 DSP中，PWM模块是一个独立的模块，并没有算作通用定时器的一部分，这也充分体现了C2000系列用于控制系统的定位。整个ePWM模块可以视为由若干个独立的ePWM子模块组成，每个ePWM子模块对应2个互补输出的通道——EPWMxA及EPWMxB。这样的设计减少了各PWM通道间的耦合关系，使用起来更为方便灵活。</p><a id="more"></a><p>在TI的参考手册中是这样说的：</p><blockquote><p>Cross coupling or sharing of resources has been avoided; instead, the ePWM is built up from smaller single channel modules with separate resources that can operate together as required to form a system. This modular approach results in an orthogonal architecture and provides a more transparent view of the peripheral structure, helping users to understand its operation quickly.</p></blockquote><p>各独立的ePWM模块可以单独工作，也可以通过时钟同步策略来连接为一个整体，除此之外，时钟同步还可用于同步ePWM模块与eCAP模块。下文所说的ePWM模块都是指每个独立的子模块。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ePWM模块的简要结构框图如下：<br><img src="https://pic.gaomf.store/DSP20151224151306.png-width600" alt=""></p><ul><li>输出信号：</li></ul><p>** EPWMxA &amp; EPWMxB ：**<br>PWM信号输出。</p><p>** EPWMxTZINT &amp; EPWMxINT ：**<br>中断信号输出，连接至PIE模块。</p><p>** EPWMxSOCA &amp; EPWMxSOCB ：**<br>ADC SOC信号输出，用于控制ADC开始进行数据转换的时间。</p><blockquote><p>Each ePWM module has two ADC start of conversion signals . Any ePWM module can trigger a start of conversion . Which event triggers the start of conversion is configured in the Event-Trigger submodule of the ePWM.</p></blockquote><ul><li>输入信号：</li></ul><p>** TZ1 ~ TZ6 ：**<br>错误信号输入，ePWM模块内部可以选择性的处理这些错误信号，具体含义：</p><blockquote><p>These input signals alert the ePWM module of fault conditions external to the ePWM module. *<em>Each module on a device can be configured to either use or ignore any of the trip-zone signals. The TZ1 to TZ3 trip-zone signals can be configured as asynchronous inputs through the GPIO peripheral. TZ4 is connected to an inverted EQEP1 error signal (EQEP1ERR) from the EQEP1 module (for those devices with an EQEP1 module). TZ5 is connected to the system clock fail logic, and TZ6 is connected to the EMUSTOP output from the CPU. *</em>This allows you to configure a trip action when the clock fails or the CPU halts.</p></blockquote><p>** COMPxOUT ：**<br>比较器模块的输出信号。</p><ul><li>时钟同步信号：</li></ul><p>** EPWMxSYNCI &amp; EPWMxSYNCO ：**<br>菊花链结构的时钟同步信号，EPWMxSYNCI是输入，EPWMxSYNCO是输出.</p><hr><p>各模块的连接关系见下图：<br><img src="https://pic.gaomf.store/DSP20151224183244.png-width600" alt=""></p><p>下面简要总结下各模块的核心内容，具体参考TI的Reference manual.</p><h2 id="Time-Base"><a href="#Time-Base" class="headerlink" title="Time-Base"></a>Time-Base</h2><p><strong>主时基模块。</strong></p><p>一共有3种计数方式，示意图及频率计算方法如下：<br><img src="https://pic.gaomf.store/DSP20151224184122.png-width600" alt=""></p><p>模式选择通过TBCTL[CTRMODE]位，预分频可通过TBCTL[HSPCLKDIV]位。</p><p>产生CTR = PRD及CTR = Zero这两个信号。</p><p>TBPDR寄存器有一个影子寄存器(Shadow Register)，通过TBCTL[PRDLD]位来控制是否使用此功能。</p><blockquote><p>The TBPRD shadow register is enabled when TBCTL[PRDLD] = 0. Reads from and writes to the TBPRD memory address go to the shadow register. The shadow register contents are transferred to the active register (TBPRD (Active) ← TBPRD (shadow)) when the time-base counter equals zero (TBCTR = 0x0000). By default the TBPRD shadow register is enabled.</p></blockquote><hr><p>时钟同步的结构见下图：<br><img src="https://pic.gaomf.store/DSP20151224185250.png-width600" alt=""></p><p>使能时钟同步的步骤如下：</p><blockquote><p>The proper procedure for enabling ePWM clocks is as follows:</p><ol><li>Enable ePWM module clocks in the PCLKCRx register</li><li>Set TBCLKSYNC= 0</li><li>Configure ePWM modules</li><li>Set TBCLKSYNC=1</li></ol></blockquote><p>注：TBCLKSYNC位位于PCLKCR0寄存器中，属于”System Control and Interrupts”的一部分。</p><blockquote><p>When TBCLKSYNC = 1, all ePWM time-base clocks are started with the rising edge of TBCLK aligned. For perfectly synchronized TBCLKs, the prescaler bits in the TBCTL register of each ePWM module must be set identically</p></blockquote><p>收到同步信号后：</p><blockquote><p>The value of the phase register is loaded into the counter register when an input synchronization pulse is detected (<strong>TBPHS → TBCTR</strong>).<br><strong>In up-down-count mode, the TBCTL[PSHDIR] bit configures the direction of the time-base counter immediately after a synchronization event.</strong> The new direction is independent of the direction prior to the synchronization event.</p></blockquote><hr><p>多个ePWM模块之间可以存在一个精确的相位差，在一些特殊的电力电子拓扑结构中特别有用。例如在大功率的应用中，对于移相变压器、多绕组变压器等，其输入有多个整流单元，相位互差特定的角度，此时就可以使用TBPHS寄存器来调整它们之间载波的相位差；而且因为是相对于同一个时间基准来计数，其精度也较高。在这种使用情况下，一般将一相ePWM做为主模块，其时钟信号作为同步源，其余几相ePWM做为从模块，其时钟信号使用同步源与TBPHS的和或者差。</p><h2 id="Counter-Compare"><a href="#Counter-Compare" class="headerlink" title="Counter-Compare"></a>Counter-Compare</h2><p><strong>计数器比较模块。</strong></p><p>产生CTR = CMPA及CTR = CMPB这两个信号：<br><img src="https://pic.gaomf.store/DSP20151224192906.png-width600" alt=""><br><img src="https://pic.gaomf.store/DSP20151224193010.png-width600" alt=""></p><p>同样，CMPA与CMPB寄存器也有其影子寄存器，分别通过CMPCTL[SHDWAMODE]与CMPCTL[SHDWBMODE]来进行控制。</p><blockquote><p>If the shadow register is enabled then the content of the shadow register is transferred to the active register on one of the following events as specified by the <strong>CMPCTL[LOADAMODE]</strong> and <strong>CMPCTL[LOADBMODE]</strong> register bits:</p><ul><li>CTR = PRD: Time-base counter equal to the period (TBCTR = TBPRD).</li><li>CTR = Zero: Time-base counter equal to zero (TBCTR = 0x0000)</li><li>Both CTR = PRD and CTR = Zero</li></ul></blockquote><h2 id="Action-Qualifier"><a href="#Action-Qualifier" class="headerlink" title="Action-Qualifier"></a>Action-Qualifier</h2><p><strong>输出波形产生及控制模块。</strong></p><p>模块原理框图：<br><img src="https://pic.gaomf.store/DSP20151224194023.png-width600" alt=""></p><p>一共有4种可选操作：</p><ul><li><strong>Set</strong> High : Set output EPWMxA or EPWMxB to a high level.</li><li><strong>Clear</strong> Low : Set output EPWMxA or EPWMxB to a low level.</li><li><strong>Toggle</strong> : If EPWMxA or EPWMxB is currently pulled high, then pull the output low. If EPWMxA or EPWMxB is currently pulled low, then pull the output high.</li><li><strong>Do Nothing</strong> : Keep outputs EPWMxA and EPWMxB at same level as currently set. Although the “Do Nothing” option prevents an event from causing an action on the EPWMxA and EPWMxB outputs, this event can still trigger interrupts and ADC start of conversion.</li></ul><p>在寄存器AQCTLA及AQCTLB中进行配置，各种常用配置的示例代码在参考手册中有详细说明。</p><h2 id="Dead-Band-Generator"><a href="#Dead-Band-Generator" class="headerlink" title="Dead-Band Generator"></a>Dead-Band Generator</h2><p><strong>互补PWM产生及死区控制模块。</strong></p><p>只使用Action Qualifier模块，通过灵活配置CMPA与CMPB寄存器，一样可以实现死区控制功能，然而这样做较为麻烦，更常规的做法是使用Dead Band Generator来生成互补PWM信号及控制死区时间。</p><p>模块原理框图如下：<br><img src="https://pic.gaomf.store/DSP20151224200802.png-width600" alt=""></p><p>常用的配置如表，其中Mode 2 &amp; Mode 3为最为常用的互补输出模式。（表中均为S4 = 0， S5 = 0）<br><img src="https://pic.gaomf.store/DSP20151224201210.png-width600" alt=""></p><p><strong>从中可以看到，在使用Dead Band Generator来生成互补PWM信号时，只使用了Action Qualifier产生的一路PWM信号，即EPWMxA，另一路信号EPWMxB并没有使用，而是根据EPWMxA来产生的。</strong></p><p>最终生成的互补PWM信号波形如图所示：<br><img src="https://pic.gaomf.store/DSP20151224201951.png-width600" alt=""></p><p>RED及FED时间由DBRED及DBFED寄存器决定，计算方法及一些常用值见参考手册中的说明。</p><h2 id="PWM-Chopper"><a href="#PWM-Chopper" class="headerlink" title="PWM-Chopper"></a>PWM-Chopper</h2><p><strong>斩波模块，用于在PWM输出中加入一个高频载波信号。</strong></p><p>这个模块是可选的，其作用是用一个高频信号（最高为系统时钟的8分频）来调制PWM信号。经过调制后的输出波形效果如下：<br><img src="https://pic.gaomf.store/DSP20151224204718.png-width600" alt=""></p><p>如此调制一般是用于高频开关电源中，当PWM的周期较长，用高频变压器作驱动器，就会达不到目的，并有可能烧坏器件。使用PWM-Chopper模块可以将PWM波经过“再调制”后的高频波作驱动就可以解决这个问题。</p><h2 id="Trip-Zone"><a href="#Trip-Zone" class="headerlink" title="Trip-Zone"></a>Trip-Zone</h2><p><strong>错误信号控制模块。</strong></p><p>TZSEL寄存器选择启用哪些错误信号(TZ1~TZ6)，TZCTL寄存器选择相应的操作，有4种可选操作：</p><ul><li>强制拉低</li><li>强制拉高</li><li>高阻输出</li><li>保持原状态(Do nothing)</li></ul><p>错误输入一共有两种模式：One-Shot(OSHT)及Cycle-by-Cycle(CBC)模式，其区别在于：</p><blockquote><p>The one-shot trip condition remains latched until the user clears the condition via the TZCLR register.<br>A cycle-by-cycle trip condition is automatically cleared when the time-base counter reaches zero.</p></blockquote><p>简而言之，就是One-Shot模式需要手动复位，而Cycle-by-Cycle模式会自动复位。</p><p>同时，Trip-Zone模块也可以产生中断，通过TZEINT寄存器来配置。</p><h2 id="Event-Trigger"><a href="#Event-Trigger" class="headerlink" title="Event-Trigger"></a>Event-Trigger</h2><p><strong>中断及外部事件触发模块。</strong></p><p>原理框图如下：<br><img src="https://pic.gaomf.store/DSP20151224212634.png-width600" alt=""></p><p>输入信号可通过ETPS[INTCNT]位配置为不产生中断、每次都产生中断、每2次产生中断、每3次产生中断。</p><p>除了中断外，还可以产生ADC模块的SOC信号。</p><h2 id="Digital-Compare"><a href="#Digital-Compare" class="headerlink" title="Digital Compare"></a>Digital Compare</h2><p><strong>数字比较模块</strong></p><p>原理框图如下：<br><img src="https://pic.gaomf.store/DSP20151224213527.png-width600" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Simulink仿真模式</title>
      <link href="/2015/12/23/Simulink%E4%BB%BF%E7%9C%9F%E6%A8%A1%E5%BC%8F/"/>
      <url>/2015/12/23/Simulink%E4%BB%BF%E7%9C%9F%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在Simulink中，一共有6种仿真模式可供选择，如图：<br><img src="https://pic.gaomf.store/Matlab20151223135602.png" alt=""></p><ul><li><strong>Normal模式为一般正常的仿真模式</strong></li><li><strong>Accelerator及Rapid Accelerator模式用于加快代码的执行速度</strong></li><li><strong>SIL及PIL模式用于自动代码生成时进行测试仿真</strong></li><li><strong>External模式用于连接外部系统实现基于客户端/服务器模式的实时系统仿真</strong></li></ul><p>正常模式(Normal)不需要进行特殊设置，这是Simulink默认的仿真模式。下面简要介绍一下其他几种仿真模式。</p><a id="more"></a><h2 id="加速模式-Accelerator"><a href="#加速模式-Accelerator" class="headerlink" title="加速模式(Accelerator)"></a><strong>加速模式(Accelerator)</strong></h2><p>Normal、Accelerator、Rapid Accelerator模式的比较如下：<br><img src="https://pic.gaomf.store/Matlabaccel_perform12c.png" alt=""><br>简而言之，就是Normal模式执行速度最慢，不过支持的功能最多；Rapid Accelerator模式执行速度最快，不过支持的功能最少，对于使用的模块也有限制(需要模块有C代码以可以编译为可执行文件)；Accelerator模块介于二者之间。<br>这三种模式的具体功能比较可参阅帮助文档中”<a href="http://cn.mathworks.com/help/simulink/ug/choosing-a-simulation-mode.html" target="_blank" rel="noopener">Choosing a Simulation Mode</a>“小节，执行方式比较详见”<a href="http://cn.mathworks.com/help/simulink/ug/how-the-acceleration-modes-work.html" target="_blank" rel="noopener">How Acceleration Modes Work</a>“小节。</p><h2 id="SIL与PIL模式"><a href="#SIL与PIL模式" class="headerlink" title="SIL与PIL模式"></a><strong>SIL与PIL模式</strong></h2><p>这两种模式用于在使用Embedded Coder™、HDL Coder™或Simulink PLC Coder™从模型生成代码的过程中进行测试分析，属于Simulink Verification and Validation的一部分。<br>关于各种”In-the-Loop”测试的含义，可参阅”<a href="http://www.matlabsky.com/thread-38774-1-1.html" target="_blank" rel="noopener">有关基于模型的设计（MBD）一些概念和理解</a>“这篇文章，这里把SIL与PIL的相关部分摘录如下：</p><blockquote><p>2）SIL，软件在环测试，软件在环测试，应该说是从模型在环测试引申过来的，区别只是把控制器的模型换成了由控制器模型生成的C代码编译成的S-function，SIL的目的是为了验证生成的代码和模型在功能上是否一致，或者说验证生成的代码和模型在功能上是否等效。</p><p>验证等效性，是否一定需要被控对象模型？不必要，既然验证生成的代码和模型的一致性，那只需要给生成代码和用于代码生成的模型相同的输入，比较它们在相同的输入条件下，输出是否一致即可。</p><p>3）PIL，PIL有两个目的，一是为了等效性验证，二是为了测量模型生成的代码在目标处理器上的运行时间。有关运行时间的测量，如果你选择的处理器足够强大，或者你非常把握目标代码的运行不会超限，那么PIL的意义就要打折扣了。</p></blockquote><h2 id="外部模式-External"><a href="#外部模式-External" class="headerlink" title="外部模式(External)"></a><strong>外部模式(External)</strong></h2><p>外部模式(External)是MATLAB Real Time Workshop(RTW)提供的一种仿真模式，可实现两个独立系统（宿主机与目标机）之间的通信。宿主机是指运行MATLAB和Simulink的计算机，而目标机是指运行RTW所生成的可执行程序的设备。在外部模式下，使用Simulink中的控制面板工具，可以通过网络连接控制模型的启动、停止、数据回传，调整模型运行参数等。</p><p>External模式主要用于实现数据的实时采集与处理，此处的外部设备可以也是本机上另一个进程，也可以是另一台计算机，还可以配置为诸如Rasberry Pi等嵌入式硬件平台。</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM8外设引脚重映射</title>
      <link href="/2015/12/21/STM8%E5%A4%96%E8%AE%BE%E5%BC%95%E8%84%9A%E9%87%8D%E6%98%A0%E5%B0%84/"/>
      <url>/2015/12/21/STM8%E5%A4%96%E8%AE%BE%E5%BC%95%E8%84%9A%E9%87%8D%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>在STM8中，外设对应引脚可能会有几种不同的选择，可根据实际情况来选择合适的引脚。下面总结下STM8S与STM8L系列中进行外设引脚重映射(Remap)的方法。</p><a id="more"></a><h2 id="STM8S"><a href="#STM8S" class="headerlink" title="STM8S"></a>STM8S</h2><p>在STM8S中，默认情况下一个外设功能只会对应一个引脚，只有少数外设引脚可以改变位置。<strong>进行引脚重映射通过修改”Option bytes”完成</strong>，具体修改内容可参考器件的数据手册。需要注意的是，修改”Option bytes”并不像读写其他一般寄存器那样直接，其修改方式在数据手册中有如下说明：</p><blockquote><p>Option bytes can be modified in ICP mode (via SWIM) by accessing the EEPROM address shown in the table below.<br>Option bytes can also be modified “on the fly” by the application in IAP mode, except the ROP option that can only be modified in ICP mode (via SWIM).</p></blockquote><p>一般情况下可直接在IDE中设置”Option bytes”，如在IAR中：<br><img src="https://pic.gaomf.store/STM820151221155326.png" alt=""></p><h2 id="STM8L"><a href="#STM8L" class="headerlink" title="STM8L"></a>STM8L</h2><p>在STM8L中，同样可以通过修改”Option bytes”来完成一些引脚的重映射，不过除此之外，有些外设功能本身就对应到了多个引脚上，此时<strong>可以通过SYSCFG寄存器来选择需要使用的引脚</strong>。</p><p>以STM8L051F3为例：<br><img src="https://pic.gaomf.store/STM820151221160054.png" alt=""><br>此图中使用”[]”括起来的功能就是只能通过上文修改”Option bytes”的方法来进行重映射的功能，而其余功能的选择则可通过修改SYSCFG寄存器来完成，如Timer 2-channel 1可以选择PB0或PC5。</p><p>SYSCFG寄存器的主要作用是进行引脚功能选择，其操作较为简单，直接根据参考手册中的说明设置所需的位即可。<br>如果使用库函数的话，可通过调用<code>SYSCFG_REMAPPinConfig()</code>函数完成。如下面两句代码将STM8L051中TIM2_CH1与TIM2_CH2由默认的PB0、PB2重映射至PC5、PC6。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SYSCFG_REMAPPinConfig(REMAP_Pin_TIM2Channel1, ENABLE);</span><br><span class="line">SYSCFG_REMAPPinConfig(REMAP_Pin_TIM2Channel2, ENABLE);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM8系列单片机</title>
      <link href="/2015/12/21/STM8%E7%B3%BB%E5%88%97%E5%8D%95%E7%89%87%E6%9C%BA/"/>
      <url>/2015/12/21/STM8%E7%B3%BB%E5%88%97%E5%8D%95%E7%89%87%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.st.com/web/en/catalog/mmc/FM141/SC1244" target="_blank" rel="noopener">STM8</a>系列单片机基于STM8专有8位内核，具有很高的性价比，其下一共有5个系列:<a href="http://www.st.com/st-web-ui/active/en/home/catalog/mmc/SC1244/SS1010" target="_blank" rel="noopener">STM8S</a>、<a href="http://www.st.com/st-web-ui/active/en/home/catalog/mmc/SC1244/SS1336" target="_blank" rel="noopener">STM8L</a>、<a href="http://www.st.com/st-web-ui/active/en/home/catalog/mmc/SC1244/SS1583" target="_blank" rel="noopener">STM8AF</a>、<a href="http://www.st.com/st-web-ui/active/en/home/catalog/mmc/SC1244/SS1584" target="_blank" rel="noopener">STM8AL</a>及<a href="http://www.st.com/st-web-ui/active/en/home/catalog/mmc/FM141/SC1244/SS1598" target="_blank" rel="noopener">STM8T</a>，<a href="http://www.eccn.com/theme/2015/smarthome/ArticleShow.html?pid=2014100910359313" target="_blank" rel="noopener">这篇文章</a>中比较分析了这几个系列，下面简要总结一下。</p><p><strong>STM8S是STM8中的主流系列；STM8L侧重于低功耗；STM8AF与STM8AL则是STM8S及STM8L用于汽车应用的增强型，其使用温度更广，具有更高的可靠性；STM8T未在上图中出现，此系列在STM8L系列的基础上增加了ProxSense电荷转移电容采集技术，用于触控检测。</strong></p><a id="more"></a><p><img src="https://pic.gaomf.store/STM8STM8_SC1244.jpg" alt=""></p><p>各系列下又细分为诸多产品线：</p><h2 id="STM8S系列"><a href="#STM8S系列" class="headerlink" title="STM8S系列"></a><strong>STM8S系列</strong></h2><p><img src="https://pic.gaomf.store/STM8STM8S003005007%20Value%20Line_LN2.jpg" alt=""><br><img src="https://pic.gaomf.store/STM8STM8S_series_SS1010.jpg" alt=""></p><h2 id="STM8L系列"><a href="#STM8L系列" class="headerlink" title="STM8L系列"></a><strong>STM8L系列</strong></h2><p><img src="https://pic.gaomf.store/STM8STM8L051052_Value_Line_LN1798.jpg" alt=""><br><img src="https://pic.gaomf.store/STM8STM8L_series_SS1336.jpg" alt=""></p><h2 id="STM8AF系列"><a href="#STM8AF系列" class="headerlink" title="STM8AF系列"></a><strong>STM8AF系列</strong></h2><p><img src="https://pic.gaomf.store/STM8STM8AF52_line_LN1543.jpg" alt=""><br><img src="https://pic.gaomf.store/STM8STM8AF_series_SS1583.jpg" alt=""></p><h2 id="STM8AL系列"><a href="#STM8AL系列" class="headerlink" title="STM8AL系列"></a><strong>STM8AL系列</strong></h2><p><img src="https://pic.gaomf.store/STM8STM8AL31_line_LN3.jpg" alt=""><br><img src="https://pic.gaomf.store/STM8STM8AL_series_SS1584.jpg" alt=""></p><h2 id="STM8T系列"><a href="#STM8T系列" class="headerlink" title="STM8T系列"></a><strong>STM8T系列</strong></h2><p><img src="https://pic.gaomf.store/STM8STM8T_series_SS1598.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻抗测量方法</title>
      <link href="/2015/12/19/%E9%98%BB%E6%8A%97%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95/"/>
      <url>/2015/12/19/%E9%98%BB%E6%8A%97%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>阻抗测量在不少领域都有着广泛的应用，这几天做项目用到了LCR数字电桥来测量电机参数，正好来总结下阻抗测量的基本方法及技术。</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>所谓的阻抗测量，就是通过仪器来得到待测元件的电阻(R)、电容(C)、电感(L)、品质因数(Q)、损耗因数(D)等信息，可以用一张图把这些关系简明的表示出来：<br><img src="https://pic.gaomf.store/Circuit20151219222741.png" alt=""></p><h2 id="测量技术"><a href="#测量技术" class="headerlink" title="测量技术"></a>测量技术</h2><p>阻抗测量有几种不同的技术和方法，是德科技在其文档“<a href="http://literature.cdn.keysight.com/litweb/pdf/5968-1947CHCN.pdf" target="_blank" rel="noopener">成功测量阻抗的8点提示</a>”中简要介绍了各种方法及技术。</p><p>简而言之，从原理上来看，阻抗测量有三种方法：</p><ul><li>自动平衡电桥技术</li><li>IV和RF-IV技术</li><li>传输/反射技术</li></ul><p>从仪器种类上来看，阻抗测量可以通过三大类仪器来完成：</p><ul><li><strong>LCR表</strong></li><li><strong>阻抗分析仪</strong></li><li><strong>网络分析仪</strong></li></ul><p><strong>LCR表与阻抗分析仪采用RF-IV/IV或自动平衡电桥技术；网络分析仪则是基于传输/反射技术。</strong>LCR表和阻抗分析仪的主要区别之一是它们对测量结果的显示方式。LCR表用数字显示测量结果，而阻抗分析仪既可以用数字也可以用图形显示测量结果。<strong>使用自动平衡电桥技术的LCR表又称为LCR数字电桥，这也是最便宜和简单的阻抗测试仪器。</strong>网络分析仪主要用于通信领域，其价格也是最为昂贵的。</p><p>关于网络分析仪，可参考NI的文档“<a href="http://www.ni.com/white-paper/11640/zhs/" target="_blank" rel="noopener">网络分析基础</a>”，下面主要讨论下LCR数字电桥的相关问题。</p><h2 id="LCR数字电桥"><a href="#LCR数字电桥" class="headerlink" title="LCR数字电桥"></a>LCR数字电桥</h2><p>LCR数字电桥的相关知识可以阅读IET Labs的”<a href="http://www.ietlabs.com/pdf/application_notes/030122%20IET%20LCR%20PRIMER%201st%20Edition.pdf" target="_blank" rel="noopener">LCR Measurement Primer</a>“，这份文档较为详细的介绍了LCR电桥各方面的知识，本文仅从使用的角度简要介绍下LCR数字电桥的基础知识。</p><p>LCR数字电桥的基本原理框图如图：<br><img src="https://pic.gaomf.store/Circuit20151219223740.png" alt=""><br>一言以蔽之，就是<strong>通过测量待测元件两端的电流与电压（同时记录相位信息），根据矢量形式的欧姆定律就可以计算得到各种所需参数。</strong></p><p>绝大部分LCR数字电桥均有四个被测端，其名字不同厂家的仪器有所区别，国内厂家的仪器一般称之为HD、LD、HS、LS。这四个端口的含义为：</p><ul><li><strong>HD: 输出激励源正极</strong></li><li><strong>LD：输出激励源负极</strong></li><li><strong>HS: 检测信号输入正极</strong></li><li><strong>LS: 检测信号输入负极</strong></li></ul><p>大部分测量单个元件的时候，将HS与HS短接后接到元件正极上；LD与LS短接后接到元件负极上。如图所示：<br><img src="https://pic.gaomf.store/Circuit20151219225036.png" alt=""><br>图中IH即上文HD，IL即LD，PH即HS，PL即LS。</p><p>不过在某些情况下，需要使用其他的连接方式，比如是德科技在其文档“<a href="http://literature.cdn.keysight.com/litweb/pdf/5967-5377CHCN.pdf" target="_blank" rel="noopener">高效变压器/低频线圈测试</a>”中就介绍了使用LCR数字电桥测量变压器互感的方法，如图所示：<br><img src="https://pic.gaomf.store/Circuit20151219230811.png" alt=""><br>此图是基于其4263B LCR表的，不过对于其他型号的LCR数字电桥应该也可以使用。</p><p>除此之外，还有所谓的三端连接法，如图所示：<br><img src="https://pic.gaomf.store/Circuit20151219231304.png" alt=""><br>关于此电路的分析，见”<a href="http://www.ietlabs.com/pdf/application_notes/030122%20IET%20LCR%20PRIMER%201st%20Edition.pdf" target="_blank" rel="noopener">LCR Measurement Primer</a>“第24页。</p><p>在测量前，一般需要将测试夹短接后执行清零操作，以去除测试夹本身的阻抗。</p><h2 id="阻抗模型"><a href="#阻抗模型" class="headerlink" title="阻抗模型"></a>阻抗模型</h2><p>最后，简要介绍一下串联模型与并联模型，如图所示：<br><img src="https://pic.gaomf.store/Circuit20151219232013.png" alt=""><br>图中等效模型是以电容为例，不过对于电感同样存在串联模型与并联模型。</p>]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用OpenMP进行多线程计算</title>
      <link href="/2015/12/11/%E4%BD%BF%E7%94%A8OpenMP%E8%BF%9B%E8%A1%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97/"/>
      <url>/2015/12/11/%E4%BD%BF%E7%94%A8OpenMP%E8%BF%9B%E8%A1%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p><a href="http://openmp.org/" target="_blank" rel="noopener">OpenMP</a>是一套支持跨平台共享内存方式的多线程并发的编程API，关于其详细介绍，可浏览其官方主页与<a href="https://zh.wikipedia.org/wiki/OpenMP" target="_blank" rel="noopener">Wiki页面</a>。</p><p>多线程并行计算是一个值得深入研究的问题，不过很多时候，我们仅仅是需要实现一些很基础的多线程计算。例如程序中需要依次处理100张图片，它们之间又没有什么关联，这时如果使用多线程，可以极大的提升程序的执行效率。使用OpenMP就可以很方便的实现上述要求而不必了解多线程的底层技术。</p><a id="more"></a><p>Microsoft VS编译器与GCC均支持OpenMP，需要通过编译选项来启用。</p><ul><li>GCC中添加<code>-fopenmp</code>编译选项</li><li>VS中在项目属性中启用<code>OpenMP支持</code>，如下图所示：</li></ul><p><img src="https://pic.gaomf.store/C20151211153251.png" alt=""></p><hr><p>大多数情况下，需要进行多线程优化的代码段是一个for循环，此时，只要在for循环前面加上<strong><code>#pragma omp parallel for</code></strong>即可。示例代码段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Another for, this loop won't be paralleled</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码段中的第一个for循环会自动使用多线程进行并行计算，而第二个for循环不受影响。简而言之，<code>#pragma omp parallel for</code>仅对之后的一个for循环起作用。</p><hr><p>for循环中有一些代码位于所谓的临界区段（Critical Section），这部分代码不能同时被两个线程访问，否则会发生错误。使用<strong><code>#pragma omp critical</code></strong>来指定临界区段代码，用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp critical</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Critical section</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>{}</code>将临界区段代码包围起来，然后在前面添加<code>#pragma omp critical</code>即可。</p><hr><p>只需要简单的添加这两句编译指令，OpenMP就会自动实现多线程运行了。当然，OpenMP还支持更多高级用法，此处给出的仅是最简单实用的用法。</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrent </tag>
            
            <tag> OpenMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STC单片机不断电下载程序</title>
      <link href="/2015/12/10/STC%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8D%E6%96%AD%E7%94%B5%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/"/>
      <url>/2015/12/10/STC%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8D%E6%96%AD%E7%94%B5%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>在使用STC-ISP为STC单片机下载程序的过程中，需要手动对单片机进行复位，之后才能正确下载程序。这样不是很方便，我们可以采用一些方法来简化这一过程。</p><p>基本思路：在程序中加入一段监控代码，监测UART接收到的数据，当接收到STC-ISP程序发送的下载开始的数据后，软件复位单片机从系统ISP监控程序区启动。</p><a id="more"></a><p>首先要获取STC-ISP软件发送的数据，最简单的方法是通过虚拟串口软件配合串口助手即可看到所需的数据，结果如图所示：<br><img src="https://pic.gaomf.store/51MCU20151210163116.png" alt=""><br>从中可以看到，STC-ISP会持续发送<code>0x7F</code>，直至单片机给出正确的响应，故程序中只需要接收到若干个连续的<code>0x7F</code>后进行软件复位即可。</p><p>软件复位通过写IAP_CONTR寄存器实现，其定义如下：<br><img src="https://pic.gaomf.store/51MCU20151210164210.png" alt=""><br>将第5、6两位置1即可实现软件复位且从系统ISP监控程序区启动的目的。</p><p>下面给出具体实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UART_ISR_Handle</span><span class="params">()</span> interrupt 4 <span class="keyword">using</span> 3</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> isp_cnt = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 串口中断处理 */</span></span><br><span class="line">  <span class="keyword">if</span>(RI)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* 此处必须要手动清标志位 */</span></span><br><span class="line">    RI=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* ISP Reset */</span></span><br><span class="line">    <span class="keyword">if</span>(SBUF==<span class="number">0x7F</span>)</span><br><span class="line">      isp_cnt++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      isp_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(isp_cnt &gt; <span class="number">50</span>)</span><br><span class="line">      IAP_CONTR |= <span class="number">0x60</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是，STC-ISP软件中的最低波特率与最高波特率必须设置为相同的，且等于程序中配置好的波特率，不能使用自适应波特率。</strong>比如下图中就将波特率固定为115200bps。<br><img src="https://pic.gaomf.store/51MCU20151210165012.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCS-51 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV 3.0安装</title>
      <link href="/2015/12/08/OpenCV%203.0%E5%AE%89%E8%A3%85/"/>
      <url>/2015/12/08/OpenCV%203.0%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>主要参考以下文章：</p><blockquote><p><a href="http://blog.csdn.net/poem_qianmo/article/details/19809337" target="_blank" rel="noopener">【OpenCV入门教程之一】 安装OpenCV</a><br><a href="http://blog.csdn.net/desti5/article/details/39012343" target="_blank" rel="noopener">64位系统vs2013配置opencv3.0</a><br><a href="http://www.bubuko.com/infodetail-793518.html" target="_blank" rel="noopener">VS2013+openCV3.0无脑配置方法+解决警告问题【windows平台】</a></p></blockquote><p>目前OpenCV的最新版本为3.0.0，正式版发布于2015年6月4日。本文记录一下安装OpenCV 3.0及新建工程的步骤。相关环境：Windows 8.1 64bit；Visual Studio 2013。</p><a id="more"></a><h2 id="下载OpenCV-SDK"><a href="#下载OpenCV-SDK" class="headerlink" title="下载OpenCV SDK"></a><strong>下载OpenCV SDK</strong></h2><p>在<a href="http://opencv.org/" target="_blank" rel="noopener">官网</a>上找到OpenCV for Windows下载下来即可，大概有300MB不到。这是一个自解压压缩包，下载完后直接双击运行即可。<strong>因为OpenCV项目文件打包的时候，根目录就是opencv，所以我们不需要额外的新建一个名为opencv的文件夹，然后再解压</strong>。解压后的文件有接近3G。</p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a><strong>配置环境变量</strong></h2><p>在PATH路径中增加以下两项即可：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">\o</span>pencv<span class="symbol">\b</span>uild<span class="symbol">\x</span>86<span class="symbol">\v</span>c12<span class="symbol">\b</span>in;</span><br><span class="line"><span class="symbol">\o</span>pencv<span class="symbol">\b</span>uild<span class="symbol">\x</span>64<span class="symbol">\v</span>c12<span class="symbol">\b</span>in;</span><br></pre></td></tr></table></figure><p>其中的<code>vc12</code>对应VS2013，<code>vc11</code>对应VS2012。在之前版本的OpenCV中，还存在<code>vc10</code>文件夹对应VS2010，不过在OpenCV 3.0中，去掉了<code>vc10</code>文件夹。<br>这里可以只保留需要用到的VS版本，删掉其余版本以节省空间。</p><h2 id="编写OpenCV的VS工程属性表"><a href="#编写OpenCV的VS工程属性表" class="headerlink" title="编写OpenCV的VS工程属性表"></a><strong>编写OpenCV的VS工程属性表</strong></h2><p>VS中配置OpenCV的包含路径、库文件路径等通常是通过项目属性对话框完成的，这样操作较为繁琐，故这里采用工程属性表的方式来进行配置。工程属性表是一个后缀为<code>.props</code>的文本文件，其中记录了工程属性配置情况，新建工程后可以直接导入此文件即可。</p><p>在OpenCV根目录下新建一个<code>.props</code>文件，比如<code>OpenCV.props</code>，文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">ToolsVersion</span>=<span class="string">"4.0"</span> <span class="attr">xmlns</span>=<span class="string">"http://schemas.microsoft.com/developer/msbuild/2003"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ImportGroup</span> <span class="attr">Label</span>=<span class="string">"PropertySheets"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Label</span>=<span class="string">"UserMacros"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">IncludePath</span>&gt;</span>D:\opencv\build\include;$(IncludePath)<span class="tag">&lt;/<span class="name">IncludePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LibraryPath</span> <span class="attr">Condition</span>=<span class="string">"'$(Platform)'=='Win32'"</span>&gt;</span>D:\opencv\build\x86\vc12\lib;$(LibraryPath)<span class="tag">&lt;/<span class="name">LibraryPath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LibraryPath</span> <span class="attr">Condition</span>=<span class="string">"'$(Platform)'=='X64'"</span>&gt;</span>D:\opencv\build\x64\vc12\lib;$(LibraryPath)<span class="tag">&lt;/<span class="name">LibraryPath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemDefinitionGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Link</span> <span class="attr">Condition</span>=<span class="string">"'$(Configuration)'=='Debug'"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AdditionalDependencies</span>&gt;</span>opencv_ts300d.lib;opencv_world300d.lib;%(AdditionalDependencies)</span><br><span class="line">      <span class="tag">&lt;/<span class="name">AdditionalDependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Link</span> <span class="attr">Condition</span>=<span class="string">"'$(Configuration)'=='Release'"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AdditionalDependencies</span>&gt;</span>opencv_ts300.lib;opencv_world300.lib;%(AdditionalDependencies)</span><br><span class="line">      <span class="tag">&lt;/<span class="name">AdditionalDependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemDefinitionGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，其中具体路径要根据之前安装OpenCV的路径来确定。</p><p>第6行用于配置包含目录；第7行与第8行分别是Win32和X64情况下的库目录；第12行与第16行分别是Debug与Release情况下的附加依赖项。</p><p>OpenCV 3.0与之前的版本不同，库文件目录下同时有两个文件夹，<code>/lib/</code>与<code>/staticlib/</code>，并不需要同时添加这两个文件夹与其中的库文件，选择一个即可。如果选择<code>/staticlib/</code>的话与之前的版本一样，有一大堆的依赖项要添加；如果选择了<code>/lib/</code>的话，就只需要加入两个依赖项。故此处选择使用<code>/lib/</code>文件夹。</p><h2 id="创建新工程"><a href="#创建新工程" class="headerlink" title="创建新工程"></a><strong>创建新工程</strong></h2><p>正常新建一个VC++空项目，然后打开属性管理器，如果没有属性管理器的话可以从<code>视图</code>-&gt;<code>其他窗口</code>-&gt;<code>属性管理器</code>中打开。打开后在工程名上点击右键，选择添加现有属性表，找到之前新建的项目属性表文件添加进来即可。</p><p>新建一个<code>main.cpp</code>文件进行测试，使用如下测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2\opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Mat img = imread(<span class="string">"pic.jpg"</span>);</span><br><span class="line">  imshow(<span class="string">"Picture"</span>, img);</span><br><span class="line">  waitKey();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>pic.jpg</code>图片放置于工程目录下编译运行程序，如果之前配置正确的话就可以显示出图片了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM8 SWIM接口</title>
      <link href="/2015/12/06/STM8%20SWIM%E6%8E%A5%E5%8F%A3/"/>
      <url>/2015/12/06/STM8%20SWIM%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>STM8系列单片机通过SWIM接口进行程序下载与Debug，这是一个单线接口，仅有一条数据线，即SWIM。SWIM引脚为开漏(OD)结构，以此实现双向通信。关于SWIM协议的详细说明，可参考ST的文档”<a href="http://www.st.com/st-web-ui/static/active/cn/resource/technical/document/user_manual/CD00173911.pdf" target="_blank" rel="noopener">STM8 SWIM communication protocol and debug module</a>“，此文档介绍了SWIM协议的通信过程与物理层时序等内容，如果需要自行设计制作SWIM下载器需要参考此文档。</p><p>当然，如果仅是为了给STM8单片机下载程序，并不需要了解SWIM协议的具体实现方法，仅需要在板子上设计好下载接口，然后和<a href="http://www.st.com/web/catalog/tools/FM146/CL1984/SC724/SS1677/PF251168?sc=internet/evalboard/product/251168.jsp" target="_blank" rel="noopener">ST-Link</a>仿真器连接起来即可。</p><a id="more"></a><p>ST-Link/V2中SWIM接口的定义如下：<br><img src="https://pic.gaomf.store/CircuitST-LINK-V2-Interface_SWIM_200.jpg" alt=""></p><p>其中的VDD可以不接，从STM8L-Discovery开发板上提供的ST-Link上来看，VDD直接通过一个10k的电阻接地了：<br><img src="https://pic.gaomf.store/Circuit20151206133333.png-height2" alt=""></p><p>另外，从中可以看到，仿真器部分已经在SWIM上加上了上拉电阻，故目标板上并不需要加上拉电阻，直接和单片机SWIM口连接即可。</p>]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BLDC六步换相法基本原理及驱动波形</title>
      <link href="/2015/12/03/BLDC%E5%85%AD%E6%AD%A5%E6%8D%A2%E7%9B%B8%E6%B3%95%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E9%A9%B1%E5%8A%A8%E6%B3%A2%E5%BD%A2/"/>
      <url>/2015/12/03/BLDC%E5%85%AD%E6%AD%A5%E6%8D%A2%E7%9B%B8%E6%B3%95%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E9%A9%B1%E5%8A%A8%E6%B3%A2%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p>直流无刷电机（BLDC）最经典的驱动方法就是三相六步换相法，这几天调试时顺便用示波器捕捉了下6个MOS管的栅极驱动波形。</p><p>基本驱动电路如图所示：<br><img src="https://pic.gaomf.store/CircuitBLDC_MOS_Driver.png-width300" alt=""></p><p>所谓的六步换相法即是按如下的顺序通电：<strong>AB-&gt;AC-&gt;BC-&gt;BA-&gt;CA-&gt;CB</strong>。当然，除此之外还可以使用其他的通电顺序，只需要保证磁场的变化方向能构成一个旋转磁场即可。</p><a id="more"></a><p>一般情况下，还要使用PWM进行调速。最简单的方法是只对上桥臂MOS管（Q1、Q3、Q5）进行调制，下桥臂（Q2、Q4、Q6）使用GPIO控制。这样的优点是控制方式简单；缺点在于上桥臂截止时，只能通过下桥臂MOS管的体二极管进行续流，而体二极管压降较大，这会造成下桥臂MOS管发热更为严重。使用这种驱动方法的驱动波形如图所示：</p><p><img src="https://pic.gaomf.store/Motor173259mvu6y4vc646ye7cn.jpg" alt=""></p><p>图中红色框内为一个周期，可以看到，只有上桥臂使用了PWM进行调制。</p><p>更好的方法是使用互补的PWM信号进行控制，上下管交替导通。这种方式的驱动波形如图所示：</p><p><img src="https://pic.gaomf.store/Motor6-step.png-height" alt=""></p><p>图中红色框内为一个周期，可以看到，上下桥臂同时使用了PWM信号进行控制。互补PWM信号展开放大后的波形如图所示：</p><p><img src="https://pic.gaomf.store/Motorscope_20151203_32.png-width600" alt=""></p><p>上桥臂导通时下桥臂截止，上桥臂截止时下桥臂导通。</p>]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C2000 CSM使用方法</title>
      <link href="/2015/11/30/C2000%20CSM%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2015/11/30/C2000%20CSM%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>在TI C2000系列DSP中，CSM模块用于对给芯片进行加密，以防止未经授权的代码逆向等行为，TI在其文档中对此模块的说明如下：</p><blockquote><p>The code security module (CSM) is a security feature incorporated in 28x devices. It prevents access/visibility to on-chip memory to unauthorized persons—that is, it prevents duplication/reverse engineering of proprietary code.<br>The word secure means access to on-chip memory is protected. The word unsecure means access to onchip secure memory is not protected — that is, the contents of the memory could be read by any means (through a debugging tool such as Code Composer Studio™, for example).</p></blockquote><p>关于DSP中具体哪些部分受到CSM模块的保护，以及此模块的详细信息可参阅TI的相关文档，此处仅从使用的角度来讨论下如何对DSP芯片进行加密与解密。<em>本文基于CCS 6.0。</em></p><a id="more"></a><h2 id="密码设定"><a href="#密码设定" class="headerlink" title="密码设定"></a><strong>密码设定</strong></h2><p>最简单的方法是直接使用<a href="http://www.ti.com.cn/tool/cn/controlsuite" target="_blank" rel="noopener">controlSUITE</a>中提供的<code>DSP28***_CSMPasswords.asm</code>文件，将此文件加入工程中，修改其中的密码即可。此文件的内容如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.sect</span> <span class="string">"csmpasswds"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">.int</span><span class="number">0xFFFF</span><span class="comment">;PWL0 (LSW of 128-bit password)</span></span><br><span class="line"><span class="meta">.int</span><span class="number">0xFFFF</span><span class="comment">;PWL1</span></span><br><span class="line"><span class="meta">.int</span><span class="number">0xFFFF</span><span class="comment">;PWL2</span></span><br><span class="line"><span class="meta">.int</span><span class="number">0xFFFF</span><span class="comment">;PWL3</span></span><br><span class="line"><span class="meta">.int</span><span class="number">0xFFFF</span><span class="comment">;PWL4</span></span><br><span class="line"><span class="meta">.int</span><span class="number">0xFFFF</span><span class="comment">;PWL5</span></span><br><span class="line"><span class="meta">.int</span><span class="number">0xFFFF</span><span class="comment">;PWL6</span></span><br><span class="line"><span class="meta">.int</span><span class="number">0xFFFF</span><span class="comment">;PWL7 (MSW of 128-bit password)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">.sect</span> <span class="string">"csm_rsvd"</span></span><br><span class="line"><span class="meta">.loop</span> (<span class="number">3F7FF5h</span> - <span class="number">3F7F80h</span> + <span class="number">1</span>)</span><br><span class="line"><span class="meta">      .int</span> <span class="number">0x0000</span></span><br><span class="line"><span class="meta">.endloop</span></span><br></pre></td></tr></table></figure><p>对应的CMD文件中地址分配情况：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">PAGE <span class="number">0</span>:    /* Program Memory */</span><br><span class="line">   CSM_RSVD    : <span class="type">origin</span> = <span class="number">0</span>x3F7F80, length = <span class="number">0</span>x000076     /* Part <span class="keyword">of</span> FLASHA.  Program <span class="keyword">with</span> <span class="keyword">all</span> <span class="number">0</span>x0000 <span class="keyword">when</span> CSM <span class="keyword">is</span> <span class="keyword">in</span> <span class="keyword">use</span>. */</span><br><span class="line">   CSM_PWL_P0  : <span class="type">origin</span> = <span class="number">0</span>x3F7FF8, length = <span class="number">0</span>x000008     /* Part <span class="keyword">of</span> FLASHA.  CSM password locations <span class="keyword">in</span> FLASHA */</span><br><span class="line">&#125;</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">   csmpasswds          : &gt; <span class="type">CSM_PWL_P0</span>  PAGE = <span class="number">0</span></span><br><span class="line">   csm_rsvd            : &gt; <span class="type">CSM_RSVD</span>    PAGE = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置密码时有一些关键点需要注意：</p><ol><li>将128-bit全部设为<code>1</code>意味着不加密，即所谓的”unsecure”。</li><li><strong>将128-bit全部设为<code>0</code>意味着永久加密，此时芯片不可被解密，即无法再进行编程，也无法读取其中的程序和数据。一般情况下，不要进行此设置。</strong></li><li>如果设置了128-bit中的低64-bit（即不为全<code>1</code>），会触发所谓的ECSL(Emulation Code Security Logic)功能，这时如需使用仿真器下载程序，需要进行些特殊设置，下文会对此进行详细讨论。</li></ol><h2 id="加密后使用仿真器下载程序"><a href="#加密后使用仿真器下载程序" class="headerlink" title="加密后使用仿真器下载程序"></a><strong>加密后使用仿真器下载程序</strong></h2><p>如果芯片没有被加密，自然可以直接使用仿真器通过JATG正常下载程序；但如果芯片设置了密码被加密了，就需要在仿真器设置中正确填入密码才能下载程序和Debug。具体来看，分为两种情况：没有设置低64位密码与设置了低64位密码。</p><h3 id="没有设置低64位密码"><a href="#没有设置低64位密码" class="headerlink" title="没有设置低64位密码"></a><strong>没有设置低64位密码</strong></h3><p>此时ECSL功能没有被触发，只要在仿真器设置中正确填入密码即可正常下载程序。以CCS v6.0及XDS100V3仿真器为例，设置界面如图所示：<br><img src="https://pic.gaomf.store/DSP20151130163640.png" alt=""><br>图中设置的CSM密码为<code>0xAAAABBBBCCCCDDDDFFFFFFFFFFFFFFFF</code>。<br>设置好后，就可以正常Debug了。</p><h3 id="设置了低64位密码"><a href="#设置了低64位密码" class="headerlink" title="设置了低64位密码"></a><strong>设置了低64位密码</strong></h3><p>此时情况要复杂一些，当设置了低64位密码时，DSP中的ECSL功能会被触发，关于此功能，TI文档中的说明如下：</p><blockquote><p>In addition to the CSM, the emulation code security logic (ECSL) has been implemented to prevent unauthorized users from stepping through secure code. Any code or data access to flash, user OTP, L0 memory while the emulator is connected will trip the ECSL and break the emulation connection.</p><p><strong>When initially debugging a device with the password locations in flash programmed (that is, secured), the emulator takes some time to take control of the CPU. During this time, the CPU will start running and may execute an instruction that performs an access to a protected ECSL area. If this happens, the ECSL will trip and cause the emulator connection to be cut.</strong></p></blockquote><p><strong>简而言之，当ECSL功能有效时，会强制切断仿真器与器件间的JTAG连接，导致连接失败。此时，就算是按之前的步骤正确设置了密码也是无法下载程序的。</strong>点击Debug按钮后会出现如下错误提示：</p><blockquote><p>C28xx: Error connecting to the target: (Error -1015 @ 0x0) Device is not responding to the request.  Device may be locked, or the emulator connection may be unreliable. Unlock the device if possible (e.g. use wait in reset mode, and power-cycle the board). If error persists, confirm configuration and/or try more reliable JTAG settings (e.g. lower TCLK). (Emulation package 5.1.450.0) </p></blockquote><p><em>此错误提示与密码错误时的提示是不一样的，密码错误时的提示如下：</em></p><blockquote><p>C28xx: Flash Programmer: Device is locked or not connected. Operation cancelled.<br>C28xx: Error Writing Flash @ Address 0x003F74C6 of Length 0x00000016 (page 0)<br>C28xx: GEL: File: D:\Forklift\MS8000V10\Project\Release\MS8000V10.out: Load failed.</p></blockquote><p><em>同时会有一个对话框提示：</em><br><img src="https://pic.gaomf.store/DSP20151130165534.png" alt=""></p><p>TI的文档中也给出了此问题的解决办法：</p><blockquote><ol><li>The first is to use the Wait-In-Reset emulation mode, which will hold the device in reset until the emulator takes control. The emulator must support this mode for this option.</li><li>The second option is to use the “Branch to check boot mode” boot option. This will sit in a loop and continuously poll the boot mode select pins. You can select this boot mode and then exit this mode once the emulator is connected by re-mapping the PC to another address or by changing the boot mode selection pin to the desired boot mode.</li></ol></blockquote><p><strong>简而言之，第一种方法是保持器件处于复位状态直至仿真器接管器件，这需要仿真器与器件的支持；第二种方法是通过BOOT引脚的配置，使得DSP进入一个所谓的”Branch to check boot mode”，然后再连接仿真器。</strong><br>我使用的XDS100v3仿真器并不支持第一种方法，在仿真器设置中”Halt the target on a connect”一项是不可选的，如图所示：<br><img src="https://pic.gaomf.store/DSP20151130170550.png" alt=""><br>此时只能采用第二种方法，然而第二种方法中的”Branch to check boot mode”具体指什么文档中并没有很明确的指出来。不过TI的<a href="http://processors.wiki.ti.com/index.php/Code_Security_Module_FAQ_for_C2000?keyMatch=code#Q:_Is_there_anyway_to_erase_the_password.3F" target="_blank" rel="noopener">Wiki Page</a>上给出了正确的操作方法：</p><blockquote><p>Q: Why does Code Composer Studio give me an emulator error when I try to connect to my locked device?</p></blockquote><p>On devices with ECSL protection which do not support hardware wait-in-reset mode (such as the Piccolo devices), if the device is locked:<br>When the device is powered up, the CPU will start running and may execute an instruction that performs an access to an ECSL protected area. If this happens, the ECSL will trip and cause the emulator connection to be cut. To resolve this:</p><ol><li><strong>Disconnect your emulator.</strong></li><li><strong>Set your boot pins for “WAIT” boot mode. Note: on 2833x/2823x this is documented as the “loop to check” boot mode.</strong></li><li><strong>Reset your device.</strong></li><li><strong>Reconnect your emulator.</strong><blockquote></blockquote>At this point you should be able to proceed and unlock your device.</li></ol><p>简而言之，对于2803x系列单片机来说，<strong>需要使DSP先复位进入Wait模式后再连接仿真器就可以顺利下载程序了</strong>。至于如何进入Wait模式，在器件参考手册中可以查到，以28031为例，上电时将GPIO34拉低即可（GPIO34默认情况下有内部上拉）：<br><img src="https://pic.gaomf.store/DSP20151130171526.png" alt=""></p><p>实际测试表明，这样设置后就可以通过仿真器正常下载程序并进行Debug了。</p>]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C2000 DSP新建工程基本步骤</title>
      <link href="/2015/11/28/TMS320%20DSP%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/"/>
      <url>/2015/11/28/TMS320%20DSP%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<p>本文以TMS320F28031为例，介绍如何新建一个完整的CCS工程文件。其他型号的C2000系列微处理器的操作方法大同小异。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h2><p>需要安装好<a href="http://www.ti.com.cn/tool/cn/ccstudio" target="_blank" rel="noopener">CCS</a>及<a href="http://www.ti.com.cn/tool/cn/controlsuite" target="_blank" rel="noopener">controlSUITE</a>。下文使用的CCS版本为v6.0.0，controlSUITE版本为v3.3.3。</p><h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a><strong>新建工程</strong></h2><p>打开CCS，菜单栏上找到<code>Project</code>-&gt;<code>New CCS Project...</code>。在弹出的对话框中选好DSP的型号及仿真器的型号，填入工程名称及工程位置，其余选项保持默认值即可。<br><img src="https://pic.gaomf.store/DSP20151128135049.png" alt=""><br>点击<code>Finish</code>后在Project Explorer中可以看到新建的工程<br><img src="https://pic.gaomf.store/DSP20151128135556.png" alt=""></p><h2 id="添加CMD文件"><a href="#添加CMD文件" class="headerlink" title="添加CMD文件"></a><strong>添加CMD文件</strong></h2><p>新建好工程后自动加入了一个CMD文件，<code>28031_RAM_lnk.cmd</code>，此CMD文件用于配置DSP从RAM启动。一般情况下，程序调试过程中在RAM中进行测试，正式发布时肯定要从Flash中启动，故需要为这两种情况分别添加CMD文件。</p><p>首先，<strong>将工程目录中已有的那个CMD文件删掉</strong>；之后在菜单栏上找到<code>Project</code>-&gt;<code>Properties</code>进入工程属性设置界面。默认情况下，CCS已经为我们建立了两个Configuration，分别为Debug和Release，所以可以将Debug用于调试，程序下载至RAM中；Release用于发布，程序下载至Flash中。<br>首先配置Debug，Configuration选择Debug，下方的Linker command file选择<code>****_RAM_lnk.cmd</code>，<code>****</code>是使用的DSP型号，如图所示：<br><img src="https://pic.gaomf.store/DSP20151128143648.png" alt=""><br>之后配置Release，Configuration选择Release，下方的Linker command file选择<code>F****.cmd</code>，<code>****</code>是使用的DSP型号，如图所示：<br><img src="https://pic.gaomf.store/DSP20151128143850.png" alt=""><br>配置完成后，选择Debug模式进行编译时<code>F****.cmd</code>文件会被排除掉；同理，选择Release模式进行编译时<code>****_RAM_lnk.cmd</code>文件会被排除掉。效果见下图：<br><img src="https://pic.gaomf.store/DSP20151128144431.png" alt=""></p><hr><p>上面添加的CMD文件用于分配RAM、Flash等区域的存储空间，除此之外，还需要添加一个CMD文件用于为外设寄存器结构体分配正确的空间。这个CMD文件的名字为<code>****_Headers_nonBIOS.cmd</code>或<code>****_Headers_BIOS.cmd</code>。文件开头的注释对此文件的用途做了简要的说明：</p><blockquote><p>FILE:    F2802x_Headers_nonBIOS.cmd<br>TITLE:   F2802x Peripheral registers linker command file<br>DESCRIPTION:<br>This file is for use in Non-BIOS applications.<br>Linker command file to place the peripheral structures used within the F2802x headerfiles into the correct memory mapped locations.<br>This version of the file includes the PieVectorTable structure.<br>For BIOS applications, please use the F2802x_Headers_BIOS.cmd file which does not include the PieVectorTable structure.</p></blockquote><p>从中可以看到<code>****_Headers_nonBIOS.cmd</code>与<code>****_Headers_BIOS.cmd</code>的区别在于是否包含PIE中断向量表，一般的，在有RTOS的情况下选用<code>****_Headers_BIOS.cmd</code>，其余情况下均选择<code>****_Headers_nonBIOS.cmd</code>。</p><p>关于此文件的详细说明，可以参考TI的Application Report “<a href="http://www.ti.com/lit/an/spraa85d/spraa85d.pdf" target="_blank" rel="noopener">Programming TMS320x28xx and 28xxx Peripherals in C/C++</a>“。</p><p>此文件可以从controlSUITE中找到，位于<code>\controlSUITE\device_support\f****\v***\DSP****_headers\cmd</code>路径下，其中<code>v***</code>代表固件库的版本，一般选用最新版。以本文使用的28031为例，具体路径就是<code>\controlSUITE\device_support\f2803x\v130\DSP2803x_headers\cmd</code>。</p><p>需要注意的是，在添加文件的时候一般选择<code>Copy files</code>而不是<code>Link to files</code>，如图所示：<br><img src="https://pic.gaomf.store/DSP20151128145950.png" alt=""></p><h2 id="添加寄存器头文件"><a href="#添加寄存器头文件" class="headerlink" title="添加寄存器头文件"></a><strong>添加寄存器头文件</strong></h2><p>将<code>\controlSUITE\device_support\f****\v***\DSP****_headers\</code>中的<code>source\</code>与<code>include\</code>文件夹复制到工程目录下，将<code>include\</code>文件夹添加到包含路径中。<strong>注意不要选择绝对路径</strong>，而是使用<code>Workspace...</code>选择相对路径，如下图所示：<br><img src="https://pic.gaomf.store/DSP20151128152726.png" alt=""></p><p>刚刚添加的<code>include\</code>文件夹中包含的内容是对所有外设寄存器的结构体定义，这种方式TI称之为“Bit Field and Register-File Structure Approach”，与传统的“Traditional #define Approach”有所区别，使用起来会更为方便。关于这两种方式的具体说明与比较，TI在其应用报告”<a href="http://www.ti.com/lit/an/spraa85d/spraa85d.pdf" target="_blank" rel="noopener">Programming TMS320x28xx and 28xxx Peripherals in C/C++</a>“中有详细的论述。</p><p><strong>需要修改</strong><code>DSP****_Device.h</code><strong>文件以指定使用的DSP型号</strong>，以下例子中选择了<code>DSP28_28031PN</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   TARGET   1</span></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// User To Select Target Device:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   DSP28_28030PAG   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   DSP28_28030PN    0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   DSP28_28031PAG   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   DSP28_28031PN    TARGET</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   DSP28_28032PAG   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   DSP28_28032PN    0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   DSP28_28033PAG   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   DSP28_28033PN    0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   DSP28_28034PAG   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   DSP28_28034PN    0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   DSP28_28035PAG   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   DSP28_28035PN    0</span></span><br></pre></td></tr></table></figure><p><code>source\</code>文件夹下只有一个文件，就是<code>DSP****_GlobalVariableDefs.c</code>，这个文件中实例化了所有的外设结构体，并且通过通过<code>#pragma DATA_SECTION()</code>将其放置在地址映射中的正确位置，以此实现对外设寄存器的正确访问。TI文档中对此文件的说明如下：</p><blockquote><ul><li>Declarations for the variables that are used to access the peripheral registers.</li><li>Data section #pragma assignments that are used by the linker to place the variables in the proper locations in memory.</li></ul></blockquote><h2 id="添加标准外设库"><a href="#添加标准外设库" class="headerlink" title="添加标准外设库"></a><strong>添加标准外设库</strong></h2><p>使用标准外设库可以更方便的控制外设而不需要具体了解寄存器的配置方法，这在进行初始化的过程中尤为有用，标准外设库的使用及controlSUITE中例程的说明文档位于<code>\controlSUITE\device_support\f****\v***\doc\</code>文件夹中。需要注意的是，并不是所有型号的C2000 DSP均提供了标准外设库，目前仅有2802x，2807x等几个系列提供了标准外设库文件。</p><p>如需使用标准外设库文件，将库文件（即driverlib.lib）添加至工程中，并且包含<code>\controlSUITE\device_support\f****\v***\DSP****_common\include\</code>目录即可。</p><h2 id="添加TI提供的一些例程文件"><a href="#添加TI提供的一些例程文件" class="headerlink" title="添加TI提供的一些例程文件"></a><strong>添加TI提供的一些例程文件</strong></h2><p>将<code>\controlSUITE\device_support\f****\v***\DSP****_common\</code>中的<code>source\</code>、<code>include\</code>与<code>lib\</code>文件夹复制到工程目录下，将<code>include\</code>文件夹添加到包含路径中。<br>这些文件的具体作用参考<code>\controlSUITE\device_support\f****\v***\doc\</code>中的文档，可根据实际去除不需要的文件。在本项目中，最终的目录结构如图所示：<br><img src="https://pic.gaomf.store/DSP20151128190022.png" alt=""></p><h2 id="设置程序入口点"><a href="#设置程序入口点" class="headerlink" title="设置程序入口点"></a><strong>设置程序入口点</strong></h2><p>根据TI文档的说明，依次找到菜单栏的<code>Project</code>-&gt;<code>Properties</code>-&gt;<code>C2000 Linker</code>-&gt;<code>Symbol Management</code>，在<code>Program Entry Point -e</code>中输入程序入口点即可。TI文档中对此设置的说明如下：</p><blockquote><p>Defines a global symbol that specifies the primary entry point for the output module. For the DSP2803x examples, this is the symbol “code_start”. This symbol is defined in the DSP2803x_common\source\DSP2803x_CodeStartBranch.asm file. When you load the code in Code Composer Studio, the debugger will set the PC to the address of this symbol. If you do not define a entry point using the -e option, then the linker will use <em>c</em>int00 by default.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——循环队列</title>
      <link href="/2015/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
      <url>/2015/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>可参考<a href="http://c.biancheng.net/cpp/html/2706.html" target="_blank" rel="noopener">这篇文章</a>，循环队列一般用静态数组实现，称之为队列的顺序存储类型。可使用如下结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Queue_EleType Buffer[Queue_Buffer_Size + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">uint8_t</span> front;    <span class="comment">/*!&lt;数据头 */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> rear;     <span class="comment">/*!&lt;数据尾 */</span></span><br><span class="line">&#125; CircularQueue;</span><br></pre></td></tr></table></figure><a id="more"></a><p>循环队列入队及出队示意图见下图：<br><img src="https://pic.gaomf.store/Algorithm1-140G32234251B.jpg" alt=""></p><p><strong>循环队列实现的核心问题在于队满情况的判断。</strong>最普遍的做法是牺牲一个单元来区分队空和队满，入队时少用一个队列单元，即图中(d2)的情况。约定以“<strong>队头指针在队尾指针的下一位置</strong>“作为队满的标志，故在上述循环队列结构体定义中，<code>Buffer</code>的大小为<code>Queue_Buffer_Size + 1</code>。</p><p>下面给出循环队列具体实现：</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> CircularInit(CircularQueue * Q)</span><br><span class="line">&#123;</span><br><span class="line">  Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">  Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断队列是否为空"><a href="#判断队列是否为空" class="headerlink" title="判断队列是否为空"></a>判断队列是否为空</h3><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> CircularIsEmpty(CircularQueue * Q)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">TRUE</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">FALSE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ErrorStatus CircularEnQueue(CircularQueue * Q, Queue_EleType x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % (Queue_Buffer_Size + <span class="number">1</span>) == Q-&gt;front)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  Q-&gt;Buffer[Q-&gt;rear] = x;</span><br><span class="line">  Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % (Queue_Buffer_Size + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ErrorStatus CircularDeQueue(CircularQueue * Q, Queue_EleType * x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span> (Q-&gt;</span><span class="function"><span class="title">front</span> == Q-&gt;</span>rear)</span><br><span class="line">    return ERROR;</span><br><span class="line">  *<span class="function"><span class="title">x</span> = Q-&gt;</span>B<span class="function"><span class="title">uffer</span>[Q-&gt;</span>front];</span><br><span class="line">  Q-&gt;<span class="function"><span class="title">front</span> = (Q-&gt;</span>front + <span class="number">1</span>) % (Queue_Buffer_Size + <span class="number">1</span>);</span><br><span class="line">  return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/g199209/MCUSnippet/tree/master/Structure/Queue" target="_blank" rel="noopener">完整代码</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSI模型总结</title>
      <link href="/2015/11/23/OSI%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2015/11/23/OSI%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>OSI模型是最为常用的网络分层模型，其全称为“<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">开放式系统互联通信参考模型</a>”，Open System Interconnection Reference Model。 此模型由国际标准化组织(ISO)提出，是一个试图使各种计算机在世界范围内互连为网络的标准框架，对应标准为ISO/IEC 7498-1。<br>此模型已成为计算机间和网络间进行通信的主要结构模型，目前使用的大多数网络通信协议的结构都是基于OSI模型的。 </p><p>OSI模型中将网络通信的工作分为七层，这就是通常说的OSI七层模型，具体层次划分见下图及下表：</p><a id="more"></a><p><img src="https://pic.gaomf.store/Web20160304200750.jpg" alt=""></p><table><thead><tr><th>层</th><th>数据单元</th><th>典型设备</th><th>功能</th></tr></thead><tbody><tr><td>应用层</td><td>数据</td><td>计算机：应用程序</td><td>直接和应用程序连接并提供常见的网络应用服务</td></tr><tr><td>表示层</td><td>数据</td><td>计算机：编码方式</td><td>将数据按照网络能理解的方案进行格式化</td></tr><tr><td>会话层</td><td>数据</td><td>计算机：建立会话</td><td>负责在网络中的两节点之间建立、维持和终止通信</td></tr><tr><td>传输层</td><td>数据段</td><td>计算机：进程和端口</td><td>提供端到端的交换数据的机制，检查分组编号与次序</td></tr><tr><td>网络层</td><td>数据包</td><td>网络：路由器</td><td>将网络地址转化为对应的物理地址，并且决定如何将数据从发送方传到接收方</td></tr><tr><td>数据链路层</td><td>数据帧</td><td>网络：交换机、网桥</td><td>控制物理层和网络层之间的通讯</td></tr><tr><td>物理层</td><td>比特</td><td>网络：集线器、网线</td><td>产生并检测电压，以便发送和接收携带数据的信号，提供为建立、维护和拆除物理链路所需要的机械的、电气的、功能的和规程的特性</td></tr></tbody></table><p>OSI七层模型的每一层都具有清晰的特征。基本来说，第七至第四层处理数据源和数据目的地之间的端到端通信，而第三至第一层处理网络设备间的通信。另外，OSI模型的七层也可以划分为两组：主机层（7、6、5、4层）和媒介层（3、2、1层）。主机层处理应用程序问题，并且通常只应用在软件上，最高层，即应用层是与终端用户最接近的；媒介层是处理数据传输的，物理层和数据链路层应用在硬件和软件上，最底层，即物理层是与物理网络媒介最接近的，并且负责在媒介上发送数据。 </p><p>下面从最底层开始，具体说明各层的作用：</p><h2 id="物理层-Physical-Layer"><a href="#物理层-Physical-Layer" class="headerlink" title="物理层(Physical Layer)"></a><strong>物理层(Physical Layer)</strong></h2><p>物理层位于OSI参考模型的最底层，它直接面向原始比特流的传输。为了实现原始比特流的物理传输，物理层必须解决好包括传输介质、信道类型、数据与信号之间的转换、信号传输中的衰减和噪声等在内的一系列问题。另外，物理层标准要给出关于物理接口的机械、电器功能和规程特性，以便于不同的制造厂家既能够根据公认的标准各自独立地制造设备，又能使各个厂家的产品互相兼容。<br>简而言之，物理层规定了通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接。<br>具体地讲，机械特性规定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等；电气特性规定了在物理连接上传输比特流时线路上信号电平的大小、阻抗匹配、传输速率、距离限制等；功能特性是指对各个信号先分配确切的信号含义，即定义了DTE和DCE之间各个线路的功能；规程特性定义了利用信号线进行bit流传输的一组 操作规程，是指在物理连接的建立、维护、交换信息是，DTE和DCE双放在各电路上的动作系列。<br>在这一层，数据的单位称为比特（bit）。<br><strong>属于物理层定义的典型规范包括：<a href="https://zh.wikipedia.org/wiki/RS-232" target="_blank" rel="noopener">EIA-RS-232</a>、<a href="https://zh.wikipedia.org/wiki/EIA-422" target="_blank" rel="noopener">EIA-RS-422</a>、<a href="http://baike.baidu.com/view/14873387.htm" target="_blank" rel="noopener">V.35</a>、<a href="https://zh.wikipedia.org/wiki/8P8C" target="_blank" rel="noopener">RJ-45</a>等。</strong></p><h2 id="数据链路层-Data-Link-Layer"><a href="#数据链路层-Data-Link-Layer" class="headerlink" title="数据链路层(Data Link Layer)"></a><strong>数据链路层(Data Link Layer)</strong></h2><p>数据链路层涉及相邻节点时间的可靠数据传输，数据链路层通过加强物理层传输原始比特的功能，使之对网络层表现为一条无错线路。为了能够实现相邻节点之间无差错的数据传输，数据链路层在数据传输过程中提供了确认、差错控制和流量控制等机制。在数据链路层的设备有二层交换机和网桥，我们可以把数据链路层看做是承上启下的一层。<br>数据链路层在不可靠的物理介质上提供了可靠的传输。在这一层，数据的单位称为帧（frame）。<br><strong>数据链路层典型协议包括：<a href="https://zh.wikipedia.org/wiki/IEEE_802.11" target="_blank" rel="noopener">IEEE 802.11</a>、<a href="https://zh.wikipedia.org/wiki/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">PPP</a>、<a href="https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%BA%8C%E5%B1%82%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">L2TP</a>、<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">STP</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">ATM</a>、<br><a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91" target="_blank" rel="noopener">Ethernet</a>、<a href="https://zh.wikipedia.org/wiki/GPRS" target="_blank" rel="noopener">GPRS</a>、<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9F%E5%B0%81%E5%8C%85%E5%AD%98%E5%8F%96" target="_blank" rel="noopener">HSPA</a>、<a href="https://zh.wikipedia.org/wiki/PPPoE" target="_blank" rel="noopener">PPPoE</a>等。</strong></p><h2 id="网络层-Network-Layer"><a href="#网络层-Network-Layer" class="headerlink" title="网络层(Network Layer)"></a><strong>网络层(Network Layer)</strong></h2><p>网络中的两台计算机进行通信时，中间可能要经过许多中间节点甚至不同的通信子网。网络层的任务就是在通信子网中选择一条合适的路径，使发送端传输层所传下来的数据能够通过所选择的路径到达目的端。网络层提供了路由及其相关的功能，可以将众多的数据链路结合成一个互连的网络，这是通过设备的逻辑寻址来实现的。<br>有关路由的一切事情都在这第一层处理，地址解析和路由是网络层的重要目的，网络层还可以实现拥塞控制、网际互连等功能。在这一层，数据的单位称为数据包（packet）。<br><strong>网络层的典型协议包括：<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">IP</a>、<a href="https://zh.wikipedia.org/wiki/IPsec" target="_blank" rel="noopener">IPsec</a>、<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">RIP</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E5%BC%8F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88" target="_blank" rel="noopener">OSPF</a>、<a href="https://zh.wikipedia.org/wiki/%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">BGP</a>、<a href="https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%BB%84%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">IGMP</a>等。</strong></p><h2 id="传输层-Transport-Layer"><a href="#传输层-Transport-Layer" class="headerlink" title="传输层(Transport Layer)"></a><strong>传输层(Transport Layer)</strong></h2><p>传输层是OSI参考模型中唯一负责端到端节点间数据传输和控制功能的一层。传输层也是具有承上启下功能的一层，它下面的三层主要面向网络通信，以确保信息被准确有效地传输，它上面的三层则面向用户主机，为用户提供各种服务，传输层通过弥补网络层服务质量的不足，为会话层提供端到端的可靠数据传输服务。<br>传输层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的数据包和其它在传输过程中可能发生的危险。传输层为上层提供端到端的透明的、可靠的数据传输服务。所为透明的传输是指在通信过程中传输层对上层屏蔽了通信传输系统的具体细节。<br>在这一层，数据的单也称作数据包（packets）。不过，在谈论TCP等具体的协议时又有特殊的叫法，TCP的数据单元称为段（segments），而UDP协议的数据单元称为报文（datagrams）。<br><strong>传输层的典型协议包括：<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">TCP</a>、<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">UDP</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97%E5%88%86%E7%B5%84%E4%BA%A4%E6%8F%9B" target="_blank" rel="noopener">SPX</a>、<a href="https://zh.wikipedia.org/wiki/%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%9A%A7%E9%81%93%E5%8D%94%E8%AD%B0" target="_blank" rel="noopener">PPTP</a>、<a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E5%8D%94%E8%AD%B0" target="_blank" rel="noopener">TLS/SSL</a>、<a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E6%8E%A7%E5%88%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">SCTP</a>、<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">DCCP</a>等。</strong></p><h2 id="会话层-Session-Layer"><a href="#会话层-Session-Layer" class="headerlink" title="会话层(Session Layer)"></a><strong>会话层(Session Layer)</strong></h2><p>会话层的主要功能是在两个节点之间建立、维护和释放面向用户的连接，并对会话进行管理和控制，保证会话数据可靠传输。会话层是建立在传输层之上，由于利用传输层提供的服务，使得两个会话实体之间不考虑他们之间相隔多远，使用了什么样的通信子网等网络通信细节，从而进行透明的、可靠的数据传输。<br>会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制，如服务器验证用户登录便是由会话层完成的。在会话层及以上的高层次中，数据传送的单位不再另外命名。<br><strong>会话层没有协议，应用层的HTTP、RPC、SDP、RTCP等协议有类似的功能。</strong></p><h2 id="表示层-Presentation-Layer"><a href="#表示层-Presentation-Layer" class="headerlink" title="表示层(Presentation Layer)"></a><strong>表示层(Presentation Layer)</strong></h2><p>表示层的主要作用是为通信双方的应用层实体提供共同的表达手段，使双方能正确地理解所传送的信息。表示层为应用层提供了各种编码和数据转换功能。这些功能可以确保发自某个系统的应用层信息可以被另一个系统的应用层解读出来。<br>这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法，即提供格式化的表示和转换数据服务。数据的压缩和解压缩、加密和解密等工作都由表示层负责。<br><strong>表示层没有协议，应用层的HTTP、FTP、Telnet等协议有类似的功能，传输层的TLS/SSL也有类似功能。</strong></p><h2 id="应用层-Application-Layer"><a href="#应用层-Application-Layer" class="headerlink" title="应用层(Application Layer)"></a><strong>应用层(Application Layer)</strong></h2><p>应用层是OSI参考模型中最靠近用户的一层，负责为用户的应用程序提供网络服务。与OSI参考模型其它层不同的是，它不为任何其他OSI层提供服务，而只是为OSI模型以外的应用程序提供服务，具体来说就是为操作系统或网络应用程序提供访问网络服务的接口。<br><strong>应用层的协议最为丰富，典型协议包括：<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">HTTP</a>、<a href="https://zh.wikipedia.org/wiki/%E9%83%B5%E5%B1%80%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">POP3</a>、<a href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">SMTP</a>、<a href="https://zh.wikipedia.org/wiki/IMAP" target="_blank" rel="noopener">IMAP</a>、<a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">DNS</a>、<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">DHCP</a>、<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">FTP</a>、<br><a href="https://zh.wikipedia.org/wiki/Telnet" target="_blank" rel="noopener">Telnet</a>、<a href="https://zh.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">SSH</a>、<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E6%96%B0%E8%81%9E%E5%82%B3%E8%BC%B8%E5%8D%94%E8%AD%B0" target="_blank" rel="noopener">NNTP</a>、<a href="https://zh.wikipedia.org/wiki/XMPP" target="_blank" rel="noopener">XMPP</a>、<a href="https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D%E5%8F%91%E8%B5%B7%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">SIP</a>、<a href="https://zh.wikipedia.org/wiki/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">RPC</a>、<a href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">RTCP</a>、<a href="https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D%E6%8F%8F%E8%BF%B0%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">SDP</a>、<br><a href="https://zh.wikipedia.org/wiki/MMS_(%E5%8D%8F%E8%AE%AE)、[SOAP](https://zh.wikipedia.org/wiki/SOAP)、[SSDP](https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">MMS</a>等。<br>关于<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">HTTPS</a>协议，有些文章将其算作应用层的一个协议，不过严格地讲，HTTPS并不是一个单独的协议，而是对工作在一加密连接（TLS或SSL）上的常规HTTP协议的称呼。</strong></p><hr><p>最后，对OSI七层模型结构做一个概括性的总结：</p><p><strong>应用层：触及到应用程序的网络业务<br>表示层：数据表达<br>会话层：主机间通信<br>传输层：端到端的可靠连接<br>网络层：逻辑寻址和最佳路径<br>数据链路层：访问介质<br>物理层：数据二进制的传输</strong></p><p>知乎上有个通俗的例子可供参考：<br><a href="http://www.zhihu.com/question/24002080" target="_blank" rel="noopener">生动形象，切中要点的讲解osi七层模型和两主机传输过程。</a></p><hr><p><em>参考资料：</em></p><blockquote><p><a href="http://www.abuve.com/article/14/" target="_blank" rel="noopener">网络工作中应该知道的OSI七层模型 - 阿布的博客</a><br><a href="http://www.cnblogs.com/cutepig/archive/2007/10/11/921427.html" target="_blank" rel="noopener">OSI网络结构的七层模型 TCP/IP层次模型 - cutepig’s blog</a><br><a href="http://www.jianshu.com/p/ef5703f65369" target="_blank" rel="noopener">OSI七层模型笔记 - 简书</a><br><a href="http://www.ha97.com/3215.html" target="_blank" rel="noopener">OSI七层与TCP/IP五层网络架构详解 -  服务器运维与架构</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安规电容总结</title>
      <link href="/2015/11/23/%E5%AE%89%E8%A7%84%E7%94%B5%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2015/11/23/%E5%AE%89%E8%A7%84%E7%94%B5%E5%AE%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>所谓安规电容，是指用于这样的场合，即电容器失效后，不会导致电击，不危及人身安全。<br>具体来说，安规电容是一种与普通电容相比符合安全认证的电容，故称为安规电容。一般的电容失效后，会造成电击穿，通常表现为短路，这样就会引入大电流，对人或设备将造成危害；而安规电容失效后，则呈现开路状态，不会引入其它危险。</p><a id="more"></a><p>除此之外，安规电容的放电特性与普通电容不同。普通电容在外部电源断开后电荷会保留很长时间，如果用手触摸就会被电到，而安规电容的放电时间相对较短。在实际使用时，一般还加上额外的放电电路进行放电。</p><p>安规电容通常只用于抗干扰电路中的电源滤波上。出于安全及EMC考虑，一般在交流电源的入口处加上若干个安规电容，用于抑制EMI传导干扰。</p><h2 id="X电容与Y电容"><a href="#X电容与Y电容" class="headerlink" title="X电容与Y电容"></a><strong>X电容与Y电容</strong></h2><p>根据IEC 60384-14标准，安规电容包括X电容与Y电容两大类。</p><ul><li>X 电容是指跨接于 L-N 之间的电容器；</li><li>Y 电容是指跨接于 L-G/N-G 之间的电容器。 </li></ul><p><em>其中，L=Line(火线), N=Neutral(零线), G=Ground(地线)</em></p><p>示意图：<br><img src="https://pic.gaomf.store/Circuit20151122153327.png" alt=""></p><p>火线与零线之间接个电容就像是“X”,故称X电容；而火线与地线之间接个电容像个“Y”，故称Y电容。通常Y电容成对使用，X电容可使用一个或多个。</p><p>对于X电容与Y电容的技术规范在IEC 664标准中规定，中国国家标准GB/T 16935.1-1997与之等同。</p><hr><p>X电容跨接于火线与零线间，受电压峰值的影响，为避免短路，比较注重的参数是耐压等级，故按照允许的峰值脉冲电压过电压等级将其分为X1、X2、X3三种电容，具体定义如下：</p><table><thead><tr><th>分类</th><th>峰值脉冲电压过电压等级</th></tr></thead><tbody><tr><td>X1</td><td>&gt;2.5kV &amp; ≤4.0kV</td></tr><tr><td>X2</td><td>&gt;1.2kV &amp; ≤2.5kV</td></tr><tr><td>X3</td><td>≤1.2kV</td></tr><tr><td><img src="https://pic.gaomf.store/Circuit20151122163346.png" alt=""></td><td></td></tr></tbody></table><p>其中，X2安规电容最为常用。</p><hr><p>Y电容跨接于火线与地线间，涉及到漏电安全的问题，因此它注重的参数就是绝缘等级，故按照绝缘等级将其分为Y1、Y2、Y3、Y4四种电容，具体定义如下：</p><table><thead><tr><th>分类</th><th>绝缘等级</th><th>额定电压</th><th>交流耐压</th><th>脉冲电压</th></tr></thead><tbody><tr><td>Y1</td><td>双重绝缘或加强绝缘</td><td>≥250VAC</td><td>4000VAC</td><td>8.0kV</td></tr><tr><td>Y2</td><td>基本绝缘或附加绝缘</td><td>≥150VAC &amp; &lt;250VAC</td><td>1500VAC</td><td>5.0kV</td></tr><tr><td>Y3</td><td>基本绝缘或附加绝缘</td><td>≥150VAC &amp; &lt;250VAC</td><td>1500VAC</td><td>无</td></tr><tr><td>Y4</td><td>双重绝缘或加强绝缘</td><td>&lt;150VAC</td><td>900VAC</td><td>2.5kV</td></tr><tr><td><img src="https://pic.gaomf.store/Circuit20151122170021.png" alt=""></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>其中，Y1与Y2安规电容最为常用，Y3与Y4安规电容因为其耐压过低，基本没有使用。</p><h2 id="型号及应用"><a href="#型号及应用" class="headerlink" title="型号及应用"></a><strong>型号及应用</strong></h2><p>安规电容通常使用金属化薄膜为介质，常用的材料有聚酯膜CL及聚丙烯膜CBB两种。所谓金属化，是指电容引出线是从喷了金属的端面引出，从而使电流通路很短，所以也称为无感电容。<br>CL电容与CBB电容的最大优点就是其绝缘性能特别好，优于其他材质的电容器，这正好符合安规电容的需求。<br>除了CL电容与CBB电容外，Y电容有时也会使用陶瓷电容。</p><hr><p>X电容大部分均为CBB电容，X2与X1电容最为常用，X3电容基本不使用。其外形通常是这样的：<br><img src="https://pic.gaomf.store/Circuit1346475056467.jpg" alt=""></p><p>一般X安规电容都使用图中这样的黄色环氧树脂外壳，体积较大，外壳上注明了其电容值、安规等级、各种安规认证等。图中这个电容就是一个0.47uF的X2安规电容。</p><p><strong>一般X1电容的额定电压为300VAC，X2电容的额定电压为275VAC。电容值从10nF<del>4.7uF之间都有，大部分电路中使用1</del>2个0.47uF的X电容就可以了。</strong></p><hr><p>Y电容通常使用Y2或Y1电容，Y3和Y4电容基本不使用。Y电容也有使用CBB电容的，其外形与X电容相同，比如下面这个Y2电容：<br><img src="https://pic.gaomf.store/Circuit1350548721366.jpg" alt=""></p><p>不过，Y电容更常用的是陶瓷电容，这主要是因为陶瓷电容更为便宜，在成本上有很大的优势。其外壳通常是蓝色的，比如下面这个Y电容：<br><img src="https://pic.gaomf.store/Circuit1320893846683.jpg" alt=""></p><p>陶瓷电容有时候并不严格区分Y1、Y2电容，外壳上会同时写上“Y1 400VAC / Y2 250VAC”的字样。</p><p>Y电容的容量大小不能太大，一般情况下，工作在亚热带的机器，要求对地漏电电流不能超过0.7mA；工作在温带机器，要求对地漏电电流不能超过0.35mA。<strong>因此，Y电容的总容量一般都不超过4700pF。大部分电路中使用2个2200pF的Y电容就可以了。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HW Component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言生成随机数</title>
      <link href="/2015/11/16/C%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/2015/11/16/C%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在C语言中，使用<code>rand()</code>函数生成随机数，<code>srand()</code>函数初始化随机数种子。</p><p><code>rand()</code>函数原型为<code>int rand(void)</code>，在头文件<code>stdlib.h</code>中声明。此函数返回一个0~<code>RAND_MAX</code> 间的伪随机整数。</p><a id="more"></a><p><code>RAND_MAX</code>是头文件<code>stdlib.h</code>中定义的一个宏，其值在不同平台下有所区别。根据C语言标准，<code>RAND_MAX</code>最小为32767。在Microsoft VS提供的标准库文件中，<code>RAND_MAX</code>被定义为32767。</p><p><code>srand()</code>函数原型为<code>void srand(unsigned int seed)</code>，同样在头文件<code>stdlib.h</code>中声明。此函数将<code>seed</code>设置为伪随机数生成的初始种子。确定了初始种子后，每次调用<code>rand()</code>函数时，就会使用递推公式给出一个伪随机数。所以显而易见，若<code>seed</code>相同，之后得到的伪随机数序列也会完全相同。<br>如果不显式调用<code>srand()</code>函数，在第一次调用<code>rand()</code>函数之前，会自动将<code>seed</code>设置为1。</p><p>通常做法是使用当前时间来作为<code>seed</code>，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure><p>其中，<code>time()</code>函数的原型为<code>time_t time(time_t *timer)</code>，在头文件<code>time.h</code>中声明。此处给出的函数原型是基于Microsoft VS提供的标准库文件的，在其它平台下可能会有所区别。关于此函数的参数与返回值，可参考MSDN中的说明：</p><blockquote><p>The time function returns the number of seconds elapsed since midnight (00:00:00), January 1, 1970, Coordinated Universal Time (UTC), according to the system clock. The return value is stored in the location given by timer. This parameter may be NULL, in which case the return value is not stored.</p><p>time is a wrapper for _time64 and time_t is, by default, equivalent to __time64_t. If you need to force the compiler to interpret time_t as the old 32-bit time_t, you can define _USE_32BIT_TIME_T. This is not recommended because your application may fail after January 18, 2038; the use of this macro is not allowed on 64-bit platforms.</p></blockquote><p>简而言之，使用<code>time(NULL)</code>会返回从1970年1月1日0:0:0至今的秒数，每次运行程序时此值都不相同，故可以用此值作为<code>seed</code>。<br>需要注意的是，<code>time()</code>的最小分辨率为1s，所以在1s内多次调用此函数的返回值是相同的。</p><hr><p>直接调用<code>rand()</code>函数仅能得到0~<code>RAND_MAX</code>间的整数，如需得到其它范围的整数或小数，则需要在此基础上再进行一些处理。</p><h3 id="生成任意范围的整数"><a href="#生成任意范围的整数" class="headerlink" title="生成任意范围的整数"></a><strong>生成任意范围的整数</strong></h3><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">random_int</span><span class="params">(<span class="keyword">int</span> minNum, <span class="keyword">int</span> maxNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> delt = maxNum - minNum;</span><br><span class="line">  <span class="keyword">if</span> (delt &lt;= RAND_MAX)</span><br><span class="line">    <span class="keyword">return</span> rand() % (delt + <span class="number">1</span>) + minNum;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> rand()*delt / RAND_MAX + minNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是网上广为流传的代码，然而，从理论上仔细进行分析，这个方法并不能严格保证生成的伪随机数符合均匀分布。故此方法仅适合于粗略的生成一些随机数。</p><h3 id="生成0-1区间的小数"><a href="#生成0-1区间的小数" class="headerlink" title="生成0~1区间的小数"></a><strong>生成0~1区间的小数</strong></h3><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">random_float</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">float</span>)rand()/(RAND_MAX + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h3><p>前面提到，<code>rand()</code>函数是使用某个递推公式来生成一个伪随机数序列的，事实上，这里使用的算法是<a href="http://en.wikipedia.org/wiki/Linear_congruential_generator" target="_blank" rel="noopener">线性同余法</a> （LCG，Linear Congruential Generator）。</p><p>LCG的基本公式为：</p><blockquote><p>x(n+1) = (A * x(n) + C) % M</p></blockquote><p>所谓初始种子<code>seed</code>即为x(0)的值。</p><p>不同编译器附带的标准库文件中A、C、M这三个参数的取值并不相同，具体可参考 <a href="http://en.wikipedia.org/wiki/Linear_congruential_generator" target="_blank" rel="noopener">Wikipedia</a> 中的说明<br>对于Microsoft VS来说，在<code>rand.c</code>文件中可以找到如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">rand</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _ptiddata ptd = _getptd();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>( ((ptd-&gt;_holdrand = ptd-&gt;_holdrand * <span class="number">214013L</span></span><br><span class="line">      + <span class="number">2531011L</span>) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x7fff</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __<span class="function">cdecl <span class="title">srand</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _getptd()-&gt;_holdrand = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，A = 214013, B = 2531011, m = 2^32。</p><p>线性同余法的优势在计算速度快，内存消耗少。但是生成的随机数质量不高，因为其相邻的随机数并不独立，序列关联性较大。<br>除了线性同余法外，还有多种生成伪随机数的方法，如生成均匀分布伪随机数使用的梅森旋转算法、Multiply-With-Carry算法，生成高斯分布伪随机数使用的中心极限定理法、Box-Muller算法等。具体可以参考 <a href="http://blog.skyoung.org/2013/08/27/generate-random-number/" target="_blank" rel="noopener">这篇文章</a> 的说明。</p><blockquote><p>C++中生成随机数可以使用更好的方法，详见：<a href="/2017/03/22/C++_Random/">C++生成随机数</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Number Theory </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Doxygen处理条件编译</title>
      <link href="/2015/11/13/Doxygen%E5%A4%84%E7%90%86%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/"/>
      <url>/2015/11/13/Doxygen%E5%A4%84%E7%90%86%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>在使用Doxygen生成文档的时候，发现有些内容没有生成。仔细研究程序源代码，发现这部分代码使用了条件编译进行控制，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAL_ADC_MODULE_ENABLED</span></span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAL_ADC_MODULE_ENABLED */</span></span></span><br></pre></td></tr></table></figure><p>而Doxygen是会对宏进行处理的，这样就会跳过这部分代码。<br>解决方式：在<code>Expert</code>的<code>Preprocessor</code>选项中，找到<code>PREDEFINED</code>，添加需要预定义的宏即可。</p><a id="more"></a><p>截图如下：<br><img src="https://pic.gaomf.store/Doxygen20151113230829.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Doxygen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Doxygen生成高质量代码参考文档</title>
      <link href="/2015/11/12/%E4%BD%BF%E7%94%A8Doxygen%E7%94%9F%E6%88%90%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/"/>
      <url>/2015/11/12/%E4%BD%BF%E7%94%A8Doxygen%E7%94%9F%E6%88%90%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>注释和文档是程序的重要组成部分，使用 <a href="http://www.stack.nl/~dimitri/doxygen/index.html" target="_blank" rel="noopener">Doxygen</a> 可以自动将程序中特定格式的注释提取出来，生成一份很漂亮的参考文档。这样只要在编程的时候遵循特定的格式书写注释，程序编好后文档也就自动完成了，不需要专门花时间来写文档，这无疑减少了很多的工作量。</p><p>Doxygen支持的语言有很多，常用的有C/C++、Java、Python等；可以生成的文档格式也很丰富，其中以HTML格式和Latex格式最为常用。</p><p>关于Doxygen的安装和使用，可参考其官方 <a href="http://www.stack.nl/~dimitri/doxygen/manual/index.html" target="_blank" rel="noopener">参考手册</a>， 这个参考手册本身也是使用Doxygen生成的。网上也可找到很多基础教程，在此不再累述。本文主要介绍在使用C语言编程时该如何写注释，以便使用Doxygen自动生成高质量的文档。</p><a id="more"></a><p>下面以STM32F0系列单片机的标准库（Standard Peripheral Library）中的ADC模块为例进行分析，这是ST公司为其F0系列单片机提供的驱动库文件，注释的书写十分标准，很适合进行学习模仿。</p><h2 id="定义功能模块"><a href="#定义功能模块" class="headerlink" title="定义功能模块"></a><strong>定义功能模块</strong></h2><p>STM32F0xx_StdPeriph_Driver是按照功能模块进行组织的，每个功能模块有其对应的头文件与源文件。功能模块列表如下：<br><img src="https://pic.gaomf.store/Doxygen20151112222545.png" alt=""><br>为了让Doxygen能正确提取模块定义，需添加模块定义注释。在文件中加入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @addtogroup ADC </span></span><br><span class="line"><span class="comment">  * @brief ADC driver modules</span></span><br><span class="line"><span class="comment">  * @&#123;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//程序代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p>使用<code>@brief</code>对本模块的主要功能进行说明，如需进行更详细的说明，可使用<code>@details</code>。</p><h2 id="定义宏定义子模块"><a href="#定义宏定义子模块" class="headerlink" title="定义宏定义子模块"></a><strong>定义宏定义子模块</strong></h2><p>定义了功能模块后，一般还将宏定义单独定义为一个子模块，宏定义一般放在头文件中，加入以下注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @defgroup ADC_Exported_Constants</span></span><br><span class="line"><span class="comment">  * @&#123;</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** @defgroup ADC_JitterOff</span></span><br><span class="line"><span class="comment">  * @&#123;</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADC_JitterOff_PCLKDiv2                    ADC_CFGR2_JITOFFDIV2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADC_JitterOff_PCLKDiv4                    ADC_CFGR2_JITOFFDIV4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_ADC_JITTEROFF(JITTEROFF) (((JITTEROFF) &amp; 0x3FFFFFFF) == (uint32_t)RESET)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @&#125;</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** @defgroup ADC_Resolution</span></span><br><span class="line"><span class="comment">  * @&#123;</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADC_Resolution_12b                         ((uint32_t)0x00000000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADC_Resolution_10b                         ADC_CFGR1_RES_0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADC_Resolution_8b                          ADC_CFGR1_RES_1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADC_Resolution_6b                          ADC_CFGR1_RES</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_ADC_RESOLUTION(RESOLUTION) (((RESOLUTION) == ADC_Resolution_12b) || \</span></span><br><span class="line">                                       ((RESOLUTION) == ADC_Resolution_10b) || \</span><br><span class="line">                                       ((RESOLUTION) == ADC_Resolution_8b) || \</span><br><span class="line">                                       ((RESOLUTION) == ADC_Resolution_6b))</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @&#125;</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p>以上代码段中定义了一个名为<code>ADC_Exported_Constants</code>的模块，此模块包含了ADC模块中所有的宏定义。在<code>ADC_Exported_Constants</code>模块中，又有若干个子模块，如<code>ADC_JitterOff</code>，<code>ADC_Resolution</code>等。它们的关系可以参考下图：<br><img src="https://pic.gaomf.store/Doxygengroup___a_d_c___exported___constants.png" alt=""><br>这样组织代码可以让大的量宏定义结构更为清晰，而且有利于在其它地方进行交叉引用。</p><h2 id="定义函数子模块"><a href="#定义函数子模块" class="headerlink" title="定义函数子模块"></a><strong>定义函数子模块</strong></h2><p>与宏定义子模块类似，也可以将函数定义为一个子模块，并且按功能进行进一步分组归类。函数的定义与注释说明一般都全部放在源文件中，头文件中仅简单的进行函数声明。在源文件中加入以下注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @defgroup ADC_Private_Functions</span></span><br><span class="line"><span class="comment">  * @&#123;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** @defgroup ADC_Group1 Initialization and Configuration functions</span></span><br><span class="line"><span class="comment">  * @brief   Initialization and Configuration functions </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @&#123;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_DeInit</span><span class="params">(ADC_TypeDef* ADCx)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_Init</span><span class="params">(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_StructInit</span><span class="params">(ADC_InitTypeDef* ADC_InitStruct)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/** @defgroup ADC_Group2 Power saving functions</span></span><br><span class="line"><span class="comment">  * @brief   Power saving functions </span></span><br><span class="line"><span class="comment">  * @&#123;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_AutoPowerOffCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_WaitModeCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p>以上代码在实际代码的基础上进行了精简，仅保留了进行模块定义的基本结构。代码段中定义了一个名为<code>ADC_Private_Functions</code>的模块，此模块中包含了所有的函数定义，并且各函数按用途进行了分组，分为了若干个子模块，如<code>Initialization and Configuration functions</code>，<code>Power saving functions</code>等。关系示意图如下：<br><img src="https://pic.gaomf.store/Doxygengroup___a_d_c___private___functions.png" alt=""></p><h2 id="结构体注释说明"><a href="#结构体注释说明" class="headerlink" title="结构体注释说明"></a><strong>结构体注释说明</strong></h2><p>对于结构体，一般使用如下形式的注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * @brief  ADC Init structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> ADC_Resolution;                  <span class="comment">/*!&lt; Selects the resolution of the conversion.</span></span><br><span class="line"><span class="comment">                                                 This parameter can be a value of @ref ADC_Resolution */</span></span><br><span class="line"></span><br><span class="line">  FunctionalState ADC_ContinuousConvMode;   <span class="comment">/*!&lt; Specifies whether the conversion is performed in</span></span><br><span class="line"><span class="comment">                                                 Continuous or Single mode.</span></span><br><span class="line"><span class="comment">                                                 This parameter can be set to ENABLE or DISABLE. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> ADC_ExternalTrigConvEdge;        <span class="comment">/*!&lt; Selects the external trigger Edge and enables the</span></span><br><span class="line"><span class="comment">                                                 trigger of a regular group. This parameter can be a value</span></span><br><span class="line"><span class="comment">                                                 of @ref ADC_external_trigger_edge_conversion */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> ADC_ExternalTrigConv;            <span class="comment">/*!&lt; Defines the external trigger used to start the analog</span></span><br><span class="line"><span class="comment">                                                 to digital conversion of regular channels. This parameter</span></span><br><span class="line"><span class="comment">                                                 can be a value of @ref ADC_external_trigger_sources_for_channels_conversion */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> ADC_DataAlign;                   <span class="comment">/*!&lt; Specifies whether the ADC data alignment is left or right.</span></span><br><span class="line"><span class="comment">                                                 This parameter can be a value of @ref ADC_data_align */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span>  ADC_ScanDirection;              <span class="comment">/*!&lt; Specifies in which direction the channels will be scanned</span></span><br><span class="line"><span class="comment">                                                 in the sequence. </span></span><br><span class="line"><span class="comment">                                                 This parameter can be a value of @ref ADC_Scan_Direction */</span></span><br><span class="line">&#125;ADC_InitTypeDef;</span><br></pre></td></tr></table></figure><p>此代码段中对<code>ADC_InitTypeDef</code>这个结构体进行了较为详尽的注释，开头使用<code>@brief</code>说明此结构体的主要功能，之后对结构体中每个成员的意义进行了注释。使用<code>/*!&lt; Comment */</code>这样的语法表示此注释对应的是注释前面的语句，这样可以使代码的排版更为美观。</p><p>另外，注意到其中<code>@ref</code>标签的使用，这代表交叉引用。如<code>@ref ADC_Resolution</code>，实际会生成一个超链接指向之前定义的<code>ADC_Resolution</code>模块。这里的交叉引用可以为模块名、函数名、结构体等。</p><p>以上代码段提取出的文档效果见下图：<br><img src="https://pic.gaomf.store/Doxygen20151113211950.png" alt=""></p><p>枚举的注释形式与结构体完全相同，可参照以上示例进行注释。</p><h2 id="函数注释说明"><a href="#函数注释说明" class="headerlink" title="函数注释说明"></a><strong>函数注释说明</strong></h2><p>函数的注释说明一般放在源文件中，头文件和源文件中最好不要重复添加注释，否则生成的文档会有重复。函数注释一般使用以下的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Enables or disables the ADC DMA request after last transfer (Single-ADC mode)</span></span><br><span class="line"><span class="comment">  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.</span></span><br><span class="line"><span class="comment">  * @param  ADC_DMARequestMode: the ADC channel to configure. </span></span><br><span class="line"><span class="comment">  *          This parameter can be one of the following values:</span></span><br><span class="line"><span class="comment">  *            @arg ADC_DMAMode_OneShot: DMA One Shot Mode </span></span><br><span class="line"><span class="comment">  *            @arg ADC_DMAMode_Circular: DMA Circular Mode  </span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ADC_DMARequestModeConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="keyword">uint32_t</span> ADC_DMARequestMode)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Active the Calibration operation for the selected ADC.</span></span><br><span class="line"><span class="comment">  * @note   The Calibration can be initiated only when ADC is still in the </span></span><br><span class="line"><span class="comment">  *         reset configuration (ADEN must be equal to 0).</span></span><br><span class="line"><span class="comment">  * @param  ADCx: where x can be 1 to select the ADC1 peripheral.</span></span><br><span class="line"><span class="comment">  * @retval ADC Calibration factor </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">uint32_t</span> ADC_GetCalibrationFactor(ADC_TypeDef* ADCx)&#123;&#125;</span><br></pre></td></tr></table></figure><p>使用<code>@brief</code>简要说明函数的作用；使用<code>@param</code>说明输入参数，若输入参数是有限的几个值，可用<code>@arg</code>进行列举；使用<code>@retval</code>说明函数的返回值。另外，一些需要特别注意的地方可以使用<code>@note</code>，<code>@warning</code>进行说明。</p><p>以上代码段提取出的文档效果见下图：<br><img src="https://pic.gaomf.store/Doxygen20151113212310.png" alt=""></p><h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a><strong>文件头</strong></h2><p>每个文件的开头部分一般都需要添加一个对此文件的说明，可使用如下格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  **************************************************************</span></span><br><span class="line"><span class="comment">  * @file Example.c</span></span><br><span class="line"><span class="comment">  * @author 高明飞</span></span><br><span class="line"><span class="comment">  * @version V1.0</span></span><br><span class="line"><span class="comment">  * @date 2015-11-13</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @brief 程序的简要说明</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @details </span></span><br><span class="line"><span class="comment">  * @verbatim</span></span><br><span class="line"><span class="comment">  * 程序的详细说明。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 修改记录：</span></span><br><span class="line"><span class="comment">  * 2015-11-13 :</span></span><br><span class="line"><span class="comment">  *   - 修改记录</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * @endverbatim</span></span><br><span class="line"><span class="comment">  ***************************************************************</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a><strong>杂项</strong></h2><ul><li><p>使用<code>@todo</code>和<code>@bug</code>标签列出待办事项与Bug，Doxygen会自动汇总Todo与Bug列表。</p></li><li><p>可使用<code>@verbatim</code>与<code>@endverbatim</code>包含一段文本，这段文本就会按原样输出。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Doxygen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客优化加载速度</title>
      <link href="/2015/11/01/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/"/>
      <url>/2015/11/01/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>前几天根据 <a href="http://caoyudong.com/" target="_blank" rel="noopener">小A同学</a> 的方法在Github Pages上使用Hexo搭建了这个博客，然而之后发现访问速度实在是太慢了，而且有些时候还会直接无法打开。当然要想个办法来解决这个问题，于是又开始了折腾……写篇文章来记录下折腾的过程。</p><a id="more"></a><h2 id="Github-amp-Gitcafe-同时部署"><a href="#Github-amp-Gitcafe-同时部署" class="headerlink" title="Github &amp; Gitcafe 同时部署"></a>Github &amp; Gitcafe 同时部署</h2><blockquote><p>目前Gitcafe已被Coding.net收购，其业务也并入Coding.net中，以下方法也适用于Coding.net</p></blockquote><p><a href="https://gitcafe.com/" target="_blank" rel="noopener">Gitcafe</a> 可以视为中国版的Github，Github有Github Pages， Gitcafe就有Gitcafe Pages。二者的使用方法也如出一辙，具体可以参考 <a href="http://blog.devtang.com/blog/2014/06/02/use-gitcafe-to-host-blog/" target="_blank" rel="noopener">这篇文章</a>。<br>本来可以直接把博客全部迁移到Gitcafe上，不过在网上看到，可以同时在Github和Gitcafe上进行部署，并且让国内用户访问Gitcafe，国外用户访问Github。实现过程也不复杂，可以参考 <a href="http://blog.yuanbin.me/posts/2014/05/multi-deployment-with-hexo.html" target="_blank" rel="noopener">这篇文章</a> 的做法。</p><p>主要就是在建立好Gitcafe Pages后，通过修改<code>_config.yml</code>文件的配置，让每次使用<code>hexo d</code>命令进行部署时，能同时部署至Github和Gitcafe上。相关代码如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repository</span>: </span><br><span class="line">    <span class="attribute">gitcafe</span>: git<span class="variable">@gitcafe</span>.<span class="attribute">com</span>:username/username.git,gitcafe-pages</span><br><span class="line">    <span class="attribute">github</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:username/username.github.io.git,master</span><br></pre></td></tr></table></figure><p>Github与Gitcafe使用的SSH RSA公钥必须相同。</p><p>部署完成后，需要配置DNS多线路解析，以DNSPod为例，添加如下主机记录即可：<br><img src="https://pic.gaomf.store/web20151101141232.png" alt=""><br>Github与Gitcafe均使用了官方推荐的CNAME方式进行解析。</p><h2 id="优化Mathjax"><a href="#优化Mathjax" class="headerlink" title="优化Mathjax"></a>优化Mathjax</h2><h3 id="选择性加载"><a href="#选择性加载" class="headerlink" title="选择性加载"></a>选择性加载</h3><p>加载Mathjax的过程很费时间，根据 <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">Yilia</a> 主题的默认写法，即使在网页中并没有生成公式时, 也会加载最基本 MathJax.js。为解决此问题，可根据 <a href="http://lukang.me/2014/mathjax-for-hexo.html" target="_blank" rel="noopener">这篇文章</a> 的做法，只有在用到公式的页面才加载 Mathjax。<br>修改<code>after-footer.ejs</code>文件，将原来的</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">%</span> <span class="keyword">if</span> <span class="comment">(theme.mathjax)</span>&#123; <span class="meta">%</span>&gt;</span><br><span class="line">&lt;<span class="meta">%</span>- partial<span class="comment">('mathjax')</span> <span class="meta">%</span>&gt;</span><br><span class="line">&lt;<span class="meta">%</span> &#125; <span class="meta">%</span>&gt;</span><br></pre></td></tr></table></figure><p>替换为</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">%</span> <span class="keyword">if</span> <span class="comment">(page.mathjax)</span>&#123; <span class="meta">%</span>&gt;</span><br><span class="line">&lt;<span class="meta">%</span>- partial<span class="comment">('mathjax')</span> <span class="meta">%</span>&gt;</span><br><span class="line">&lt;<span class="meta">%</span> &#125; <span class="meta">%</span>&gt;</span><br></pre></td></tr></table></figure><p>在需要使用公式的文章开头加上<code>mathjax: true</code>即可，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Markdown常用格式</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2015</span><span class="bullet">-10</span><span class="bullet">-30</span> <span class="number">14</span><span class="string">:34:23</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">Web</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="替换Mathjax镜像"><a href="#替换Mathjax镜像" class="headerlink" title="替换Mathjax镜像"></a>替换Mathjax镜像</h3><p>Mathjax的CDN服务器全部位于海外，故访问速度都很慢，可以参考 <a href="http://blog.josephjctang.com/2015/03/github/" target="_blank" rel="noopener">这篇文章</a> 的做法，将其替换为一个中国镜像。<br>找到<code>mathjax.ejs</code>文件，将</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>替换为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://mathjax.josephjctang.com/MathJax.js?config=TeX-MML-AM_HTMLorMML"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用百度CDN加速静态资源库"><a href="#使用百度CDN加速静态资源库" class="headerlink" title="使用百度CDN加速静态资源库"></a>使用百度CDN加速静态资源库</h2><ul><li><strong>Fancybox</strong><br><code>after-footer.ejs</code>中，将<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">%</span> <span class="keyword">if</span> <span class="comment">(theme.fancybox)</span>&#123; <span class="meta">%</span>&gt;</span><br><span class="line">  &lt;<span class="meta">%</span>- css<span class="comment">('fancybox/jquery.fancybox')</span> <span class="meta">%</span>&gt;</span><br><span class="line">&lt;<span class="meta">%</span> &#125; <span class="meta">%</span>&gt;</span><br></pre></td></tr></table></figure>改为<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">%</span> <span class="keyword">if</span> <span class="comment">(theme.fancybox)</span>&#123; <span class="meta">%</span>&gt;</span><br><span class="line">  &lt;<span class="meta">%</span>- css<span class="comment">('http://apps.bdimg.com/libs/fancybox/2.1.5/jquery.fancybox')</span> <span class="meta">%</span>&gt;</span><br><span class="line">&lt;<span class="meta">%</span> &#125; <span class="meta">%</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><hr><p><code>main.js</code>中，将</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(yiliaConfig.fancybox === <span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'/fancybox/jquery.fancybox.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">pc</span>)</span>&#123;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(yiliaConfig.fancybox === <span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'http://apps.bdimg.com/libs/fancybox/2.1.5/jquery.fancybox.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">pc</span>)</span>&#123;</span><br></pre></td></tr></table></figure><hr><p>同时，可以直接删掉<code>\yilia\source\fancybox\</code>文件夹。</p><ul><li><strong>Lazyload</strong><br><code>main.js</code>中，将<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(yiliaConfig.animate === <span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'/js/jquery.lazyload.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br></pre></td></tr></table></figure>改为<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(yiliaConfig.animate === true)&#123;</span><br><span class="line">  <span class="attribute">require(['http</span>://apps<span class="variable">.bdimg</span><span class="variable">.com</span>/libs/jquery-lazyload/1.9.5/jquery<span class="variable">.lazyload</span><span class="variable">.js</span>'],</span><br></pre></td></tr></table></figure></li></ul><hr><p>同时，可以直接删掉<code>\yilia\source\js\jquery.lazyload.js</code>文件。此文件并不是官方版本的Lazyload，主题作者Litten对它进行了一些更改，不过测试表明，使用官方的Lazyload来替代此文件没有什么问题。</p><h2 id="使用七牛加速静态资源文件"><a href="#使用七牛加速静态资源文件" class="headerlink" title="使用七牛加速静态资源文件"></a>使用七牛加速静态资源文件</h2><ul><li><strong>Jquery</strong><br><del>将<code>http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js</code>下载下来，上传到七牛上，之后修改<code>after-footer.ejs</code>，将</del><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">%</span>- js<span class="comment">('http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min')</span> <span class="meta">%</span>&gt;</span><br></pre></td></tr></table></figure><del>改为七牛提供的地址。</del></li></ul><blockquote><p>7.url.cn的访问速度和稳定性均好于七牛，故没必要画蛇添足。</p></blockquote><ul><li><p>*<em>mobile.js &amp; pc.js *</em><br>将<code>\yilia\source\js\mobile.js</code>和将<code>\yilia\source\js\pc.js</code>上传至七牛，之后修改<code>\yilia\source\js\main.js</code>，将</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'/js/mobile.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">mobile</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'/js/pc.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">pc</span>)</span>&#123;</span><br></pre></td></tr></table></figure><p>改为七牛提供的地址。</p></li><li><p><strong>main.js</strong><br>将<code>\yilia\source\js\main.js</code>上传至七牛，之后修改<code>after-footer.ejs</code>，将</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="meta">%</span>- js<span class="comment">('js/main')</span> <span class="meta">%</span>&gt;</span><br></pre></td></tr></table></figure><p>改为七牛提供的地址。</p></li><li><p><strong>字体文件</strong><br>将<code>\yilia\source\css\fonts\</code>目录中全部文件上传至七牛，之后修改以下这些文件：<br><code>_variables.styl</code>中，将</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">font-icon-path</span> = <span class="string">"fonts/fontawesome-webfont"</span></span><br></pre></td></tr></table></figure><p>改为七牛提供的地址。</p></li></ul><hr><p><code>style.styl</code>中，修改以下代码段</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>:<span class="string">'FontAwesome'</span>;</span><br><span class="line">  <span class="attribute">src</span>:<span class="built_in">url</span>(<span class="string">"fonts/fontawesome-webfont.eot"</span>);</span><br><span class="line">  <span class="attribute">src</span>:<span class="built_in">url</span>(<span class="string">"fonts/fontawesome-webfont.eot?#iefix"</span>) <span class="built_in">format</span>(<span class="string">"embedded-opentype"</span>),<span class="built_in">url</span>(<span class="string">"fonts/fontawesome-webfont.woff"</span>) <span class="built_in">format</span>(<span class="string">"woff"</span>),<span class="built_in">url</span>(<span class="string">"fonts/fontawesome-webfont.ttf"</span>) <span class="built_in">format</span>(<span class="string">"truetype"</span>),<span class="built_in">url</span>(<span class="string">"fonts/fontawesome-webfont.svgz#FontAwesomeRegular"</span>) <span class="built_in">format</span>(<span class="string">"svg"</span>),<span class="built_in">url</span>(<span class="string">"fonts/fontawesome-webfont.svg#FontAwesomeRegular"</span>) <span class="built_in">format</span>(<span class="string">"svg"</span>);</span><br><span class="line">  <span class="attribute">font-weight</span>:normal;</span><br><span class="line">  <span class="attribute">font-style</span>:normal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用JLink为2440 NOR Flash下载程序</title>
      <link href="/2015/10/31/%E4%BD%BF%E7%94%A8JLink%E4%B8%BA2440%20NOR%20Flash%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/"/>
      <url>/2015/10/31/%E4%BD%BF%E7%94%A8JLink%E4%B8%BA2440%20NOR%20Flash%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>以Mini2440开发板为例，通过Jlink将程序下载至NOR Flash中运行。因为CPU可对NOR Flash直接寻址，程序可在NOR Flash中直接运行，故将裸机程序下载至NOR Flash中调试运行较为简单。</p><p>使用J-Link Commander和J-Flash ARM均可实现程序下载，不过J-Flash ARM使用起来更为简单直观。</p><p>下面总结一下使用J-Flash ARM下载程序的方法。 *<em>需要先安装好J-Link驱动，连接好JTAG，并且给目标板上电。2440 OM[1:0]配置为从NOR Flash启动。 *</em></p><a id="more"></a><h2 id="新建工程-Optional"><a href="#新建工程-Optional" class="headerlink" title="新建工程(Optional)"></a>新建工程(Optional)</h2><p><code>File</code> -&gt; <code>New project</code></p><h2 id="检查连接情况-Optional"><a href="#检查连接情况-Optional" class="headerlink" title="检查连接情况(Optional)"></a>检查连接情况(Optional)</h2><p><code>Target</code> -&gt; <code>Connect</code></p><p>如果连接正常的话，LOG窗口中会有类似下面这样的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Connecting ...</span><br><span class="line"> - Connecting via USB to J-Link device 0</span><br><span class="line"> - J-Link firmware: V1.20 (J-Link ARM V8 compiled Sep  2 2011 17:54:36)</span><br><span class="line"> - JTAG speed: 5 kHz (Fixed)</span><br><span class="line"> - Initializing CPU core (Init sequence) ...</span><br><span class="line">   - Initialized successfully</span><br><span class="line"> - JTAG speed: 8000 kHz (Auto)</span><br><span class="line"> - J-Link found 1 JTAG device. Core ID: 0x0032409D (ARM9)</span><br><span class="line"> - Reading CFI info ...</span><br><span class="line">   - CFI info read successfully</span><br><span class="line"> - Connected successfully</span><br></pre></td></tr></table></figure><p>其中<code>Core ID: 0x0032409D (ARM9)</code>就是检测到的CPU核心。</p><h2 id="设置工程-Optional"><a href="#设置工程-Optional" class="headerlink" title="设置工程(Optional)"></a>设置工程(Optional)</h2><p><code>Options</code> -&gt; <code>Project settings</code></p><p>实际测试表明，不进行设置全部使用默认值（大部分选项的默认值均是Auto）可以成功下载程序，不过也有可能会发生一些 <a href="http://m.blog.csdn.net/blog/zhoujiaxq/7750933" target="_blank" rel="noopener">问题</a> 。另外，默认情况下不使用目标RAM，下载速度会很慢。所以还是建议进行下设置。</p><p><code>General</code>一般不需要更改。</p><p><code>Target Interface</code>可保持默认值，也可修改下JTAG speed。</p><p><code>CPU</code>中，<code>Core</code>可以选择<code>Auto</code>，也可按实际情况选为<code>ARM9</code>。<br><code>Use traget RAM (faster)</code>建议选上，否则下载速度会很慢。RAM Address根据实际情况填写，对于S3C2440来说，可以使用内部4K的SRAM，其地址为0x40000000。<br>在使用了目标RAM后，有时候下载会提示错误：<code>PC of target system has unexpected value after programming</code>,若出现此错误，可参考 <a href="http://www.crifan.com/resolved_j-flash_arm_nor_flash_programming_error_pc_of_target_system_has_unexpected_value_after_programming/" target="_blank" rel="noopener">这篇文章</a> 的做法，将<code>Use following init sequence:</code>中Reset的Delay时间改为2ms。<br>配置完成后的设置如图：<br><img src="https://pic.gaomf.store/arm20151031162234.png" alt=""></p><p><code>Flash</code>中，可不勾选<code>Automatically detect flash memory</code>，改为手动指定Flash型号。<br>点击<code>Select flash device</code>后，选择正确的Falsh型号即可。Mini2440开发板上使用的NOR Flash为AM29LV160DB。<br>如果没有实际使用的型号，可以选择一个兼容型号，然后去掉<code>Check manufacturer flash Id</code>和<code>Check product flash Id</code>即可。<br>配置完成后的设置如图：<br><img src="https://pic.gaomf.store/arm20151031163621.png" alt=""></p><p><code>Production</code>保持默认。</p><p>全部设置完成后，工程设置如图：<br><img src="https://pic.gaomf.store/arm20151031163909.png" alt=""></p><p>可将设置文件保存为<code>.jfalsh</code>文件，下次直接打开即可。</p><h2 id="测试下载速度-Optional"><a href="#测试下载速度-Optional" class="headerlink" title="测试下载速度(Optional)"></a>测试下载速度(Optional)</h2><p><code>Target</code> -&gt; <code>Test</code> -&gt; <code>Test speed</code></p><p>可以通过测试下载速度来检查之前的配置是否正确，如果能正常下载测试数据，说明配置正确。</p><p>如果测试通过的话，会自动弹出测试结果：<br><img src="https://pic.gaomf.store/arm20151031153629.png" alt=""></p><h2 id="选择程序文件"><a href="#选择程序文件" class="headerlink" title="选择程序文件"></a>选择程序文件</h2><p><code>File</code> -&gt; <code>Open data file</code></p><p>一般选择<code>.bin</code>格式的程序文件，不支持<code>.axf</code>文件，可通过<code>fromelf.exe</code>将<code>.axf</code>文件转为<code>.bin</code>文件。</p><h2 id="下载编程"><a href="#下载编程" class="headerlink" title="下载编程"></a>下载编程</h2><p><code>Target</code> -&gt; <code>Program</code><br>之后选择确定擦除和复写编程区域。</p><p>如果下载成功的话，LOG窗口中会有类似下面这样的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Programming target (1324 bytes, 1 range) ...</span><br><span class="line"> - RAM tested O.K.</span><br><span class="line"> - Erasing affected sectors ...</span><br><span class="line">    - Erasing sector 0</span><br><span class="line">    - Erase operation completed successfully</span><br><span class="line"> - Target programmed successfully - Completed after 2.146 sec</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JTAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用格式</title>
      <link href="/2015/10/30/Markdown%E5%B8%B8%E7%94%A8%E6%A0%BC%E5%BC%8F/"/>
      <url>/2015/10/30/Markdown%E5%B8%B8%E7%94%A8%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>根据以下文章整理得到：</p><blockquote><p><a href="http://ibruce.info/2013/11/26/markdown/" target="_blank" rel="noopener">markdown简明语法</a><br><a href="http://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">献给写作者的 Markdown 新手指南</a><br><a href="http://www.ituring.com.cn/article/504" target="_blank" rel="noopener">Markdown语法说明（详解版）</a><br><a href="http://caoyudong.com/2015/07/15/MacDown/" target="_blank" rel="noopener">BAZINGA的博客</a></p></blockquote><p>不同Markdown解析器的行为可能会有所区别，支持的标签也不完全相同，本文根据Hexo所附带的解析器进行讨论。</p><a id="more"></a><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>一个段落是由一个以上相连接的行句组成，而一个以上的空行则会切分出不同的段落（空行的定义是显示上看起来像是空行，便会被视为空行。比如，若某一行只包含空白和 tab，则该行也会被视为空行）。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用1到6个<code>#</code>，对应1至6级标题。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>使用3个以上<code>_</code>表示。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span><span class="strong">_____</span>__</span><br></pre></td></tr></table></figure><p>下面是一条分割线</p><hr><p>上面是一条分割线</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用<code>-</code>，注意，<code>-</code>后有一个空格，不能省略。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>列表项1</span><br><span class="line"><span class="bullet">- </span>列表项2</span><br><span class="line"><span class="bullet">- </span>列表项3</span><br></pre></td></tr></table></figure><ul><li>列表项1</li><li>列表项2</li><li>列表项3</li></ul><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><p>交替使用<code>-</code> <code>+</code>，并使用空格进行缩进。<br><em>注：Hexo似乎只支持两级嵌套。</em></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>嵌套列表1</span><br><span class="line"><span class="bullet"> + </span>嵌套列表11</span><br><span class="line"><span class="bullet"> + </span>嵌套列表12</span><br><span class="line"><span class="bullet">- </span>嵌套列表2</span><br></pre></td></tr></table></figure><ul><li>嵌套列表1<ul><li>嵌套列表11</li><li>嵌套列表12</li></ul></li><li>嵌套列表2</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>使用<code>1.</code> <code>2.</code> <code>3.</code>，注意，之后要有一个空格。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>列表项1</span><br><span class="line"><span class="bullet">2. </span>列表项2</span><br><span class="line"><span class="bullet">3. </span>列表项3</span><br></pre></td></tr></table></figure><ol><li>列表项1</li><li>列表项2</li><li>列表项3</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>使用<code>&gt;</code>表示。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一条引用。</span></span><br></pre></td></tr></table></figure><blockquote><p>这是一条引用。</p></blockquote><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>使用<code>[显示文本](链接地址)</code>这样的语法即可。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">浙江大学</span>](<span class="link">http://www.zju.edu.cn</span>)</span><br><span class="line">[<span class="string">上海交通大学</span>](<span class="link">http://www.sjtu.edu.cn</span>)</span><br></pre></td></tr></table></figure><p><a href="http://www.zju.edu.cn" target="_blank" rel="noopener">浙江大学</a><br><a href="http://www.sjtu.edu.cn" target="_blank" rel="noopener">上海交通大学</a></p><hr><p>也可使用尖括号，会自动处理链接形式。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">http:</span>//<span class="attr">gaomingfei.xyz</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">g199209@163.com</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><a href="http://gaomingfei.xyz" target="_blank" rel="noopener">http://gaomingfei.xyz</a><br><a href="mailto:&#103;&#49;&#x39;&#x39;&#50;&#x30;&#57;&#64;&#x31;&#54;&#51;&#46;&#x63;&#111;&#x6d;">&#103;&#49;&#x39;&#x39;&#50;&#x30;&#57;&#64;&#x31;&#54;&#51;&#46;&#x63;&#111;&#x6d;</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>使用<code>![](图片链接地址)</code>这样的语法即可。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://pic.gaomf.store/Octocat.png)</span><br></pre></td></tr></table></figure><p><img src="https://pic.gaomf.store/Octocat.png-width300" alt=""></p><h2 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h2><p>使用2个<code>*</code>包含一段文本代表粗体，使用1个<code>*</code>包含一段文本代表斜体。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是正常文本，<span class="strong">**这是粗体文本**</span>，<span class="emphasis">*这是斜体文本*</span>。</span><br></pre></td></tr></table></figure><p>这是正常文本， <strong>这是粗体文本</strong>， <em>这是斜体文本</em>。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>参见以下代码段，使用<code>:</code>来确定对齐方式。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned | $1600 |</span><br><span class="line">| col 2 is      | centered      |   $12 |</span><br><span class="line">| zebra stripes | are neat      |    $1 |</span><br></pre></td></tr></table></figure><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><p>使用<code>`</code>包含代码片段即可。</p><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>使用<code>```</code>包含代码片段即可，第一行的<code>```</code>后面可以指定使用的编程语言，一般建议手动指定，常用语言列表如下：</p><table><thead><tr><th>Language Name</th><th>Alias</th><th>Language Name</th><th>Alias</th></tr></thead><tbody><tr><td>ARM assembler</td><td>armasm, arm</td><td>AVR assembler</td><td>avrasm</td></tr><tr><td>Awk</td><td>awk, mawk, nawk, gawk</td><td>Bash</td><td>bash, sh, zsh</td></tr><tr><td>Basic</td><td>basic</td><td>C#</td><td>cs, csharp</td></tr><tr><td>C, C++</td><td>cpp, c, cc, c++</td><td>CMake</td><td>cmake</td></tr><tr><td>CSS</td><td>css</td><td>DOS</td><td>dos, bat, cmd</td></tr><tr><td>Delphi, Pacal</td><td>delphi, pascal</td><td>Diff</td><td>diff</td></tr><tr><td>Django</td><td>django</td><td>DTS (Device Tree)</td><td>dts</td></tr><tr><td>Excel</td><td>excel</td><td>Fortran</td><td>fortran</td></tr><tr><td>Go</td><td>go</td><td>Gradle</td><td>gradle</td></tr><tr><td>Groovy</td><td>groovy</td><td>HTML, XML</td><td>xml, html, xhtml, rss</td></tr><tr><td>HTTP</td><td>http</td><td>JSON</td><td>json</td></tr><tr><td>Java</td><td>java</td><td>JavaScript</td><td>javascript, js</td></tr><tr><td>Lisp</td><td>lisp</td><td>Lua</td><td>lua</td></tr><tr><td>Makefile</td><td>makefile, mk, mak</td><td>Markdown</td><td>markdown, md</td></tr><tr><td>Matlab</td><td>matlab</td><td>PHP</td><td>php</td></tr><tr><td>Perl</td><td>perl</td><td>Processing</td><td>processing</td></tr><tr><td>Prolog</td><td>prolog</td><td>Python</td><td>python, py</td></tr><tr><td>R</td><td>r</td><td>Ruby</td><td>ruby</td></tr><tr><td>SQL</td><td>sql</td><td>Swift</td><td>swift</td></tr><tr><td>Tcl</td><td>tcl</td><td>TeX</td><td>tex</td></tr><tr><td>VB.Net</td><td>vbnet, vb</td><td>VBScript</td><td>vbscript, vbs</td></tr><tr><td>VHDL</td><td>vhdl</td><td>Verilog</td><td>verilog, v</td></tr><tr><td>Vim Script</td><td>vim</td><td>x86 Assembly</td><td>x86asm</td></tr></tbody></table><p>完整的帮助见：<a href="http://highlightjs.readthedocs.io/en/latest/css-classes-reference.html" target="_blank" rel="noopener">CSS classes reference</a>。如果不需要高亮，使用<code>no-highlight</code></p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>需要<a href="https://www.mathjax.org/" target="_blank" rel="noopener">Mathjax</a>支持，详细说明可参考其<a href="http://mathjax.readthedocs.org/en/latest/" target="_blank" rel="noopener">文档</a>。<br>Hexo本身不直接支持Mathjax，不过本博客系统使用的<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">Yilia</a>主题添加了Mathjax支持，故不需要做其它配置即可直接使用。Mathjax公式常用语法可参考:</p><blockquote><p><a href="http://3iter.com/2015/10/14/Mathjax%E4%B8%8ELaTex%E5%85%AC%E5%BC%8F%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">Mathjax与LaTex公式简介</a></p></blockquote><p>使用<code>$</code>表示行内公式，使用<code>$$</code>表示整行公式，其中使用Latex格式来编辑公式，推荐一个比较好用的在线Latex公式可视化编辑器：<a href="https://www.codecogs.com/latex/eqneditor.php?lang=zh-cn" target="_blank" rel="noopener">CodeCogs</a>。下面是一些公式的示例效果。</p><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">著名的质能守恒方程为：$E=mc^2$。其中$E$代表能量，$m$代表质量，$c$代表光速</span><br></pre></td></tr></table></figure><p>著名的质能守恒方程为：$E=mc^2$。其中$E$代表能量，$m$代表质量，$c$代表光速</p><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">同样很著名的麦克斯韦方程组为</span><br><span class="line">$$\nabla\cdot\vec&#123;B&#125;=0$$</span><br><span class="line">$$\nabla\cdot\vec&#123;D&#125;=\rho$$</span><br><span class="line">$$\nabla\times\vec&#123;H&#125;=\vec&#123;J&#125; + \frac&#123;\partial \vec&#123;D&#125;&#125;&#123;\partial t&#125;$$</span><br><span class="line">$$\nabla\times\vec&#123;E&#125;=- \frac&#123;\partial \vec&#123;B&#125;&#125;&#123;\partial t&#125;$$</span><br><span class="line">此方程组由两个散度方程和两个旋度方程组成，是麦克斯韦方程组的微分形式，可转化为对应的积分形式：</span><br><span class="line">$$\oint\_&#123;S&#125; \vec&#123;B&#125;\cdot\mathrm&#123;d&#125;\vec&#123;S&#125;=0$$</span><br><span class="line">$$\oint\<span class="emphasis">_&#123;S&#125; \vec&#123;B&#125;\cdot\mathrm&#123;d&#125;\vec&#123;S&#125;=\int\_</span>&#123;V&#125;\rho \mathrm&#123;d&#125;V$$</span><br><span class="line">$$\oint\<span class="emphasis">_&#123;l&#125; \vec&#123;H&#125;\cdot \mathrm&#123;d&#125;\vec&#123;l&#125;=\int\_</span>&#123;S&#125;(\vec&#123;J&#125;+\frac&#123;\partial \vec&#123;D&#125;&#125;&#123;\partial t&#125;)\cdot\mathrm&#123;d&#125;\vec&#123;S&#125;$$</span><br><span class="line">$$\oint\<span class="emphasis">_&#123;l&#125; \vec&#123;E&#125;\cdot \mathrm&#123;d&#125;\vec&#123;l&#125;=-\int\_</span>&#123;S&#125;\frac&#123;\partial \vec&#123;B&#125;&#125;&#123;\partial t&#125;\cdot\mathrm&#123;d&#125;\vec&#123;S&#125;$$</span><br></pre></td></tr></table></figure><p>同样很著名的麦克斯韦方程组为<br>$$\nabla\cdot\vec{B}=0$$<br>$$\nabla\cdot\vec{D}=\rho$$<br>$$\nabla\times\vec{H}=\vec{J} + \frac{\partial \vec{D}}{\partial t}$$<br>$$\nabla\times\vec{E}=- \frac{\partial \vec{B}}{\partial t}$$</p><p>以上4个方程由两个散度方程和两个旋度方程组成，是麦克斯韦方程组的微分形式，可转化为对应的积分形式:</p><p>$$\oint_{S} \vec{B}\cdot\mathrm{d}\vec{S}=0$$<br>$$\oint_{S} \vec{B}\cdot\mathrm{d}\vec{S}=\int_{V}\rho \mathrm{d}V$$<br>$$\oint_{l} \vec{H}\cdot \mathrm{d}\vec{l}=\int_{S}(\vec{J}+\frac{\partial \vec{D}}{\partial t})\cdot\mathrm{d}\vec{S}$$<br>$$\oint_{l} \vec{E}\cdot \mathrm{d}\vec{l}=-\int_{S}\frac{\partial \vec{B}}{\partial t}\cdot\mathrm{d}\vec{S}$$</p><hr><p>需要注意的是，正如<a href="http://hijiangtao.github.io/2014/09/08/MathJaxinHexo/" target="_blank" rel="noopener">这篇文章</a>所说，在书写MathJax公式的时候有时候会出现一些问题，主要是因为Markdown会将一些标记给编译掉，所以<code>_</code>、<code>{}</code>和<code>\\</code>等符号有时会出现问题，解决方式是在前面加上\进行转义。</p><h2 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h2><p>文本中可直接用html标签，不需要额外标注这是 HTML 或是 Markdown，只要直接加标签就可以了。<br>只有区块元素──比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必需在前后加上空白，以利与内容相区分。<br>比如以下代码段，可以居中放置一张图片，其中url代表图片地址。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align: center"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"url"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Html标签另外一个比较有用的作用是可以方便的直接插入一些符号，避免被Markdown解释器错误的解释。</p>]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

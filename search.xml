<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【读读论文】RocksDB 发展回顾及展望</title>
      <link href="/2021/11/28/Paper_RocksDB_Developemnt/"/>
      <url>/2021/11/28/Paper_RocksDB_Developemnt/</url>
      
        <content type="html"><![CDATA[Evolution of Development Priorities in Key-value Stores Serving Large-scale Applications: The RocksDB Experience此论文为 Facebook 发表在 FAST’21 上的论文，回顾了 RocksDB 在过去 8 年的演进中设计上核心关注点的变化及相应的优化措施，以及在性能，功能，易用性上所做的探索工作；此外还总结了将 RocksDB 应用于大规模分布式系统及系统错误处理上需要考虑的一些问题及经验教训。论文中没有论述具体的技术细节，更多的是从宏观的面上讨论了核心设计思想及工程实现上的各种权衡。下面就来看下此论文具体讲了些什么，引用部分为我自己的笔记。1 引言RocksDB 是 Facebook 基于 Google 的 LevelDB 于 2012 年开发的一款高性能 KV 存储引擎，在设计之初 RocksDB 就是针对 SSD 来进行设计及优化的，且 RocksDB 的定位一直都很清晰——只做一个核心存储引擎而不是完整的应用，作为一个嵌入式的库集成到更大的系统中去。RocksDB 是高度可定制的，因此它作为一个核心 KV 存储引擎能适应各种工作负载，用户可以根据自己的需要对它进行针对性调优，如为读性能优化，为写性能优化，为空间使用率优化，或它们之间的某个平衡点。正是因为如此灵活的可配置性，RocksDB 可以作为很多不同数据库的存储引擎使用，如 MySQL，CockroachDB，MongoDB，TiDB 等，也可以满足流式计算（Stream processing），日志服务（Logging/queuing services），索引服务（Index services），缓存服务（Caching on SSD）等多种特性完全不同的业务需求。这些不同业务场景特性总结如下：这么多不同应用共用一个相同的存储引擎与每个应用都去搭一套自己的存储子系统相比有很多优势：无论是多简单的存储相关应用都要处理数据损坏，异常恢复，文件系统错误处理等问题，一个统一的存储引擎可以把这些都处理了，避免重复造轮子；由于使用了同一套存储引擎，不同系统间可以共用一套统一的基础设施，如一致的监控系统，运维工具，调试工具等；由于底层都是一样的，各种调试经验等在不同应用间都是可以复用的。文中说这些基本就是用一个统一轮子的好处了，其实对于个人来说还有些其他额外好处，由于不同公司不同 Team 都选用了同样的底层引擎，人员流动就会变得更方便了：）引言最后照例介绍了下文章结构：第 2 章主要介绍了 RocksDB 之所以选择 LSM-tree 作为其核心数据结构的考虑。作者认为 LSM-tree 至今都很好，选用 LSM-tree 也是 RocksDB 能适应各种不同工作负载的关键所在；第 3 章主要介绍了 RosksDB 的核心优化目标的变化，由最小化写放大到最小化空间放大；由性能优化到效率优化；第 4 章主要介绍了使用 RocksDB 搭建大规模分布式系统时的一些经验教训；第 5 章主要介绍了 RocksDB 在错误处理方面的一些考虑；第 6 章主要介绍了 RocksDB 对于 KV 接口演化的一些思考；第 7，8，9 章则分别是相关工作介绍，未来发展方向展望及结论。2 背景2.1 基于 SSD 的嵌入式存储引擎RocksDB 设计之初就是为 SSD 及现代硬件优化的。SSD 的 IOPS 及读写带宽都大幅优于传统机械硬盘，不过其寿命有限，且写入性能会由于擦除而恶化，因此设计一款针对 SSD 的嵌入式 KV 存储引擎就变得更有必要了，这就是 RocksDB 的设计初衷——设计一款极具灵活性可用于各类应用的，使用本地 SSD 并为其优化的 KV 存储引擎。2.2 RocksDB 架构RosksDB 的核心数据结构是 LSM-tree，其基本结构如下：几种基本操作的流程简述如下：写入（Writes）先写 Memtable 及 WAL 文件（Write Ahead Log），Memtable 通常使用跳表（Skip List）作为其数据结构。Memtable 写满后转换为不可变的 Memtable（immutable Memtable），并同时生成一个新的 Memtable 供写入；随后 immutable Memtable 会被写入到磁盘上变成 SST 文件（Sorted String Table）。压缩（Compaction）Compaction 有多种不同算法，RocksDB 最古老的 Compaction 算法是源于 LevelDB 的 Leveled compaction。其基本原理如上图所示，Memtable dump 生成的 SST 文件位于 Level-0，当某个 Level 中所有 SST 大小超过阈值后选择其中的一部分文件 Merge 到下一个 Level 中。除 Level-0 外，其他 Level 内不同 SST 文件间 key 的范围没有重合。读取（Reads）读取时从小到大遍历所有 Level，直到读到为止。可使用布隆过滤器（Bloom filters）来避免不需要的 IO。Scan 时需要扫描所有 Level。RocksDB 支持多种不同的 Compaction 算法：Leveled compaction。源自 LevelDB，上文已经介绍了其原理，每一层的阈值是指数形式增加的。Tiered compaction，RocksDB 中又叫 Universal Compaction，类似 Apache Cassandra 或 Hbase 中使用的方法，简单的把多个小的 SSTable 合并成一个大的 SSTable。FIFO compaction，达到大小限制后直接把最老的 SSTable 丢掉，这种策略只适用于一些纯内存的 Cache 应用等。Tiered compaction 与 Leveled compaction 的核心区别在于每个 Level 中不同 SSTable 间 Key 的范围是否有重叠（overlap），leveled compaction 策略下同一 Level 内 SSTable 间 Key 是不会有重叠的，因此读的时候只会读一个 SSTable，IO 放大是可控的。Tiered compaction 则没有此性质，不同 SSTable 间 Key 范围是有重叠的。这两种 compation 策略的选择其实也是读放大与写放大间的权衡。可以进一步参考下此文：LSM Tree的Leveling 和 Tiering Compaction可以使用多种不同的 Compaction 策略使得 RocksDB 可以适用于广泛的应用场景，通过配置 RocksDB 可以变成为读优化，为写优化或极度为写优化（用于 Cache 等应用中）。不同的配置其实是读写放大间的平衡问题，一些实际的测试结果如下： 3 资源优化目标的演进RocksDB 的优化目标最初是减少写放大，之后过渡到减少空间放大，目前重点则是优化 CPU 使用率。写放大这是刚开始开发 RocksDB 时的重点优化目标，一个重要原因是为了减少 SSD 的写入量以延长其寿命，这对某些写入很多的应用来说至今仍然是首要优化目标。Leveled compaction 的写放大系数一般在 10～30 左右，这在大部分情况下是优于 B-tree 的，与 MySQL 中使用的 InnoDB 引擎相比，RocksDB 的写数量仅为其的 5% 左右。然而对于某些写入量很大的应用来说，10～30 的写放大系数还是太大了，所以 RocksDB 引入了 Tiered compaction，其放大倍数通常在 4～10 左右。空间放大在经过若干年开发后，RocksDB 的开发者们观察到对于绝大多数应用来说，空间使用率比写放大要重要得多，此时 SSD 的寿命和写入开销都不是系统的瓶颈所在。实际上由于 SSD 的性能越来越好，基本没有应用能用满本地 SSD，因此 RocksDB 开发者们将其优化重心迁移到了减少磁盘使用率上。RocksDB 开发者们引入了所谓的 Dynamic Leveled Compaction 策略，此策略下，每一层的大小是根据最后一层的大小来动态调整的。Tiered compaction 的空间放大和 Level compaction 根本没法比，极端情况下需要预留一半空间才能顺利进行完整的 compaction，因此这里就直接不讨论了。Dynamic Leveled Compaction 的具体介绍可参考：Dynamic Level Size for Level-Based Compaction核心思想就是让稳态情况下更多的做一些 compaction。此策略的效果如下：CPU 使用率随着 SSD 的速度越来越快，一种普遍的担心是，系统的瓶颈会不会由磁盘 IO 转移到 CPU 上呢？然而作者认为无需担心此问题，原因如下：真实场景中，只有极少数应用会受限于 SSD 能提供的 IOPS，绝大部分应用是受限于 SSD 的存储空间；目前高端服务器 CPU 有足够多的计算资源来满足一块高端 SSD 的需求，当然如果一台机器上有多块 SSD，则 CPU 是有可能会成为瓶颈的，然而作者认为这是系统配置问题，完全可以通过调整 CPU 和 SSD 配比来解决此问题……就算某些应用 CPU 真成瓶颈了，这意味着此时存在大量 SSD 写入，这也意味着这块 SSD 命不久矣……为了证明此观点是正确的，作者给出了若干个 ZippyDB &amp;amp; MyRocks 的实际测试结果用以论证空间才是瓶颈所在：虽然说了这么多无需太担心 CPU 成为瓶颈，作者认为我们还是要去优化 CPU 使用率，为什么呢？因为其他更重要的优化，如空间放大优化都做完了没有可做的了……（这段真不是我瞎写的，原文就是这么说的：Nevertheless, reducing CPU overheads has become an important optimization target, given that the low hanging fruit of reducing space amplification has been harvested.）此外，CPU 和内存还越来越贵了，优化 CPU 使用可以让我们用一些更便宜的 CPU……一些有助于优化 CPU 使用率的早期尝试包括：前缀布隆过滤器（Prefix bloom filters），在查找索引前就先通过 bloom filter 进行过滤，还有其他一些 bloom filter 的优化。对于上述论述不甚赞同……作者这是假设这台机器上只跑 RocksDB，上层应用是很轻量级的，把全部 CPU 资源都给 RocksDB 用才没有瓶颈，这显然是很有问题的，有可能上层应用本身就需要很多 CPU 啊，而且作为一个 KV Engine 就把大部分 CPU 资源用完了不太合理吧。这还不要说在共有云等场景下大规模混部的情况了，此时所有空余的 CPU 都是可以用来干其他事的。不知作者为什么认为一台机器上只配一块 SSD 才是最优搭配，根据我的经验这分明是不太好的搭配吧，正因为 SSD 少了存储空间才成瓶颈的，一台机器上使用 2～4 块 NVME SSD 才是目前更主流且合理的方案吧，要是机器上还有多个 RocksDB 实例在同时工作，此时 CPU 显然很容易成为瓶颈吧。适配新技术作者列举了一些存储领域的新技术，如 open-channel SSD，mulit-stream SSD，ZNS（Zone namespace，类似抽象得更好的 open-channel SSD），这些都能降低 IO 延迟，然而作者又抛出了绝大部分应用都是受空间制约的这一论据，认为这些技术并没有什么实际用处……此外如果要让 RocksDB 这一层直接用上这些技术会破坏 RocksDB 统一一致的体验，因此更值得尝试的方向是下层文件系统去适配这些新技术，RocksDB 专注于 KV 引擎层该做的工作，而不是去做底层 FS 存储层该做的事。前面空间制约这一说法不敢苟同……后面的说法倒是的确很有道理，每一层就专注做这一层该做的事吧。存算一体（In-storage computing）也是个很有潜力的技术，然而尚不确定 RocksDB 要如何用它，以及能从中获得多大的收益，后续会继续关注研究此技术。远端存储（Disaggregated/remote storage）是目前阶段更有意义的优化目标，上文也提到了 CPU 和本地 SSD 盘很难都同时用满，然而若用的是存算分离的架构则不存在此问题了。对于 RocksDB 来说，对远端存储的优化主要集中在聚合 IO 及并行化 IO 上，此外还有对瞬时网络错误的处理，将 QoS 需求下传至底层系统，提供 Profiling 信息等。资源使用率优化是存算分离架构最大的优点之一。持久性内存（Persistent Memory, PMem，又称 Storage Class Memor, SCM）是另一个极有前途的技术，对于 RocksDB 来说有以下这些值得尝试的方向：将 PMem 作为内存的扩展。这个尝试的挑战是在 DRAM 与 PMem 并存时如何优化内存数据结构（Block cache 及 Memtable），并且在尝试利用其非易失性时会有什么额外开销；将 PMem 直接用作系统的主存储介质。SSD 性能作者都认为过剩了当然不会认为这是很好的优化方向；使用 PMem 来保存 WAL 文件。这个想法的问题在于，数据只会在 WAL 文件中停留很短时间，用 PMem 来做是否值得，毕竟 PMem 还是比 SSD 贵很多的。主要数据结构选择回顾经过了这么多年的发展，LSM-tree 这一基本数据结构是否还合适呢？作者给出的答案是，Yes！LSM-tree 至今还很适合 RocksDB 使用。主要原因是 SSD 的价格还没有降到足够低的程度，即可以让大部分应用都不在意其寿命损耗的程度，此类应用只是很少一部分应用。然而，当 Value 很大时，分离 KV （如 WiscKey）可以显著降低系统写入放大，所以此功能也被加入到了 RocksDB 中（被称为 BlobDB）。4 应用于大规模系统中的经验教训资源管理在大规模分布式数据存储系统中，通常都会将数据分为若干个 Shard，再把不同 Shard 分配到不同存储节点上。单个 Shard 的大小通常是有上限的，原因是 Shard 是负载均衡和多副本的基本单位，需要能在不同节点间自动拷贝。每个服务节点上通常都会有数十个或数百个 Shard。在使用 RocksDB 的通常实践中，一个 RocksDB 实例只用于管理一个 Shard，因此一个服务节点上也就会有很多 RocksDB 实例在同时运行，这些实例可以运行在同一地址空间下，也可运行在不同地址空间下。这里分别就是多线程和多进程模型吧。一台 Host 上会运行多个 RocksDB 实例的事实让资源管理变得更为复杂，因为资源需要同时在全局（整个 Host）和局部（单个 RocksDB 实例）两个维度上进行管理。当不同实例运行在同一个进程内时资源管理相对较为简单，只要限制好各种全局资源，如内存，磁盘带宽等的使用即可。RocksDB 支持对每类资源都创建一个资源控制器（resources controller），并将其传递个各实例，以实现实例内的局部资源管理，这个资源管理还是支持优先级的，可以灵活的在不同实例间分配资源。然而若不同实例时运行在不同进程上时，资源管理就会变得更有挑战性。解决此问题有两个思路：每个实例配置成保守的使用资源的模式，即先设置一个较低的限额，当出现瓶颈后再尝试去用更多的资源。此方案的缺点很明显，全局的资源使用率不是最优的。实例间通过 ICP 或其他机制共享资源分配信息，以此实现一个更优的局部资源分配。这条路上 RocksDB 还有很多工作需要做。此外，另一个经验教训是，随意使用独立的线程会导致很多问题，这会使得总的线程数变得很多且不可控，进而导致线程切换开销增大及很痛苦的 debug 过程。一个更好的选择是使用线程池，这可以根据实际情况去控制总的线程数量。WAL 文件的处理传统的数据库都是使用 WAL 文件来保证数据持久性的，然而大规模分布式存储系统更多的是依赖于不同节点上的多副本来保证这一点的，单节点的数据损坏可以通过其他节点来进行修复，对于这类系统来说，RocksDB 的 WAL 文件就没那么重要了。进一步，很多一致性协议（如 Paxos，Raft 等）有其自己的 Log，这种情况下 RocksDB 的 WAL 文件就完全没用了。因此 RocksDB 提供了三种不同的 WAL 策略可供选择：同步 WAL 文件写入；缓冲（buffered）WAL 文件写入，即在后台以低优先级异步刷 WAL 文件；没有 WAL 文件。删除文件限速RocksDB 底层的文件系统通常是选用 SSD-aware 的文件系统，如 XFS，此类文件系统在删除文件时可能会显式的向底层 SSD 固件发送 TRIM 命令。此行为通常有助于提高 SSD 的性能及寿命，然而某些时候也会导致一些性能问题。TRIM 命令其实是没那么轻量级的，SSD 固件在收到 TRIM 命令后会更新其地址映射关系，此行为有可能需要写入 FTL 日志（journal），而 FTL journal 是位于 Flash 上的，这又有可能会触发 SSD 内部的 GC，进而导致大量的数据迁移，此行为会干扰前台写入造成写入延迟的上升。为解决此问题，RocksDB 引入了一个速率限制器来限制 compaction 后并发删除的速度。数据格式兼容性大规模的分布式系统之所以叫大规模了，当然是因为整个系统中的机器数很多喽，此时升级肯定是增量式进行的，没有任何实际生产系统会对所有节点做同步升级。因此需要保证两种基本兼容性：新老版本间数据的兼容性，因为要考虑到回滚，向前兼容性和向后兼容性都是需要的；不同版本运行在同一集群下数据的兼容性，因为分布式系统会在节点间搬移数据，要考虑二者并存的时候整个系统是正常的。如果不保证这些兼容性就会给运维带来极大的困难。对于向后兼容性（backward compatibility）来说，RocksDB 要能识别之前版本的数据，这的代价通常是软件复杂度；而向前兼容性（forward compatibility）通常是更难保证的，这要求老版本要能识别新版本的数据，RocksDB 通过 Protocol Buffer 等技术来一定程度的保证了至少一年的向前兼容。backward compatibility 相对比较好做，顶多就是代码写得复杂点；然而 forward compatibility 要困难的多，甚至是在很多时候根本就是不可行的，一个系统的 forward compatibility 如何很大程度上是取决于设计之初设计者的远见与前瞻性的。配置方式管理RocksDB 的一大特色就是其高度可配置性，这也是它能用于满足各种工作负载需求的原因所在，然而此时配置管理也就变得很有挑战性了。最初 RocksDB 的配置方式类似于 LevelDB，有哪些配置项及其默认值等都是写死在代码中的，这种方式有两个问题：某些配置项是和磁盘上的数据密切相关的，如果数据是根据 A 配置生成的，而另一个实例使用 B 配置去读取就会发生问题；RocksDB 版本升级有可能会修改代码中的默认值，这在某些时候会造成一些非预期的结果。为解决此问题，RocksDB 支持针对每个数据库使用不同的配置文件，而非一个 RocksDB 实例只能用一个统一的配置文件。此外还提供了一些辅助工具：检查配置文件和实际数据库数据间的兼容性工具；数据库数据迁移工具，可以根据期望的配置文件来进行数据重写迁移。另一个更严峻的问题是 RocksDB 的配置项实在是太多了，这是 RocksDB 早期之所以能得到广泛应用的一个原因，然而过多的配置项也让配置的复杂性和混乱程度变得很高，要弄清楚每个配置项是干嘛的基本是不可能的。这些配置项如何配置才是最优的不仅取决于 RocksDB 的运行环境，还取决于其上层应用，还有上层应用更上层的负载情况等等，这些都会让调参变得极为困难。 这些真实世界中遇到的问题让 RocksDB 的开发者们重新检视了其最初的配置支持策略，开始努力提高 RocksDB 开箱即用性能及简化配置项。目前开发的重点是在保持高度可配置性的基础上提供更强大的自适应性（automatic adaptivity），要同时做到这两点会显著增加代码维护的负担，然而开发者们认为这是值得的～多副本及数据备份支持RocksDB 本身是一个单节点的库，使用 RocksDB 的应用需要自己处理多副本及备份问题，不同应用的处理方法不尽相同，因此 RocksDB 需要对此提供恰当的支持。在新节点上重新拉起一个副本有两种策略：逻辑拷贝（Logical copying），从源副本读数据再写到目标副本去。对于这种方式，RocksDB 提供了 Scan 接口支持，且提供了让这类 scan 尽量少影响在线服务的能力，如这类操作读到的数据不加到 Cache 里面；目标端提供 bulk loading 支持。物理拷贝（Physical copying），直接把 SSTable 及其他文件拷贝过去。RocksDB 对这种方式的支持在于，可以提供当前数据库用到的 SSTable 及其他文件不会被删除或修改的能力。支持物理拷贝也是 RocksDB 选择将底层架在一个文件系统而非裸盘上的重要原因，这可以方便使用文件系统自己提供的工具来实现这一 Copy，开发者们认为，直接使用裸盘带来的性能收益并不比上述优势的收益更大。备份也是很多数据库或其他应用所需的一个重要功能。备份与多副本一样也有逻辑和物理两种方式，然而与多副本不同的是，应用通常需要管理多个版本的备份数据。尽管大部分应用都实现了其自己的备份策略，RocksDB 也提供了一个简单基本的备份引擎。5 错误处理的经验教训静默错误出现概率由于性能原因，RocksDB 一般不使用 DIF/DIX 等 SSD 提供的数据保护功能，而是使用最为通用的校验和策略。根据作者的观测，RocksDB 层面的错误在 100PB 规模下大概每 3 个月就会出现一次，更糟糕的是，大约 40% 的情况下，错误已经被扩散到多个副本里去了。多层次的数据保护数据损坏越早被检出系统的可用性及可靠性就会越好，大部分基于 RocksDB 的应用都使用不同机器上的多副本策略，此时检测到一个副本校验和错误后可以根据其他副本进行修复，前提是正确的副本还存在。目前的 RocksDB 校验和保护机制可分为 4 层（含计划中的应用层校验和）：Block checksum。源于 LevelDB，SSTable 中 Block 级别的校验，会在每次读取时进行检查，用于防止由于底层文件系统导致的数据损坏；File checksum。在 2020 年加入，整个 SSTable 的校验，保存在 SSTable 的 meta 字段中，用于防止在传输整个 SSTable 过程中发生的数据损坏；Handoff checksum。用于保护 WAL 文件的机制，核心思想是在写入时将数据及其对应的校验码一起发给底层文件系统，底层文件系统对每次的增量写入进行校验，以此避免写入 WAL 这一过程中发生的错误。然而不幸的是，绝大部分本地文件系统是不支持此类 API 接口的。不过对于远端文件系统来说，可以通过修改 API 接口来支持此类端到端的保护功能。K/V checksum。计划中的功能，需要修改 RocksDB 的 API 接口并要上层应用配合实现，为每个 kv 都加入校验，这是最彻底的端到端的数据保护措施。分级错误处理RocksDB 遇到的大部分错误都是底层文件系统返回的错误，最初 RocksDB 处理这些错误的方式就是不处理，即直接将这些错误抛给上层应用或永久停止写入。目前开发者们更倾向仅在 RocksDB 自身无法处理或恢复时才中断 RocksDB 的正常流程，实现这的基本方法就是对某些暂时性错误在 RocksDB 层面就进行重试。上层收到 RocksDB 的错误后一般处理方法都是进行实例迁移，RocksDB 自身进行了重试后上层因此造成的实例迁移就会少很多。6 KV 接口设计的经验教训版本及时间戳核心的 KV 接口是如此的通用，以至于基本所有的存储负载都可以被 KV 接口所满足，这就是 KV 存储这么流行的原因了。然而对某些应用来说，这么简单的接口可能会制约其性能。比如要想基于 KV 接口做 MVCC（Multiversion concurrency control，多版本并发控制）的开销就会很大。RocksDB 内部是有一个 56-bit 的序列号用于区分不同版本的 KV 对的，也支持快照（Snapshot）功能，生成了一个 Snapshot 后此时的所有 KV 对都是不会被删除的，直到显式的释放了此快照，因此同一个 Key 是可以有多个序列号不同的 Value 的。然而此种简单的多版本机制是没法完全满足很多应用需求的，原因在于此机制存在一些局限性：要读到历史数据的必要条件是历史数据的 Snapshot 已经存在了，RocksDB 是不支持对过去时间再进行快照的；上述序列号是单个 RocksDB 实例自己生成并维护的，只保证其是一个递增的序列号，用户写入时也不能指定此序列号，因此基本是没法建立一个全局跨 Shard 的一致性读（由于不同实例间的序列号没有可比性）。应用想要绕开这些限制只能在 Key 或 Vaule 中自行编码加入时间戳，然而这会导致性能下降：在 Key 中编码时间戳会让查询变得低效，原因是之前的单次 Query 变成了范围 Scan；在 Value 中编码时间戳会让写入变得低效，因为要更新 Vaule 必须要进行 RMW（Read-Modify-Write） 操作。因此在 KV 接口层面就支持指定时间戳会是一个更好的解决方案，目前 RocksDB 对此已经提供了基本的支持。以应用自行在 Key 中编码时间戳的性能为基准，原生带时间戳的 KV 接口性能如下：可以看到至少有 1.2 倍性能提升，原因在于查询操作可以使用正常 Query 接口而非 Scan 接口了，此时 Bloom Filter 等就都可以起作用了。此外 SSTable 包含的时间戳范围可以加入到其元信息中了，这就有助于在读的时候直接跳过不符合要求的 SSTable 文件。开发者们认为，此功能有助于上层应用实现 MVCC 或其他分布式事务功能，然而并不考虑开发更复杂的多版本功能，原因是更复杂的多版本功能使用起来并不那么直观，也可能会被误用；且为了保存时间戳需要更多的磁盘空间，也使得接口上与其他 KV 系统间的可移植性变差。7 相关工作这部分主要就是介绍在存储引擎库，基于 SSD 的 KV 存储系统，LSM-tree 优化，大规模存储系统这几方面上还有些什么研究，感兴趣的可以去看看原文。8 未来的工作及一些开放问题除了上文提及的支持远端存储，KV 分离，多层次校验和，应用指定时间戳外，还计划统一 Leveled 及 Tiered compaction 策略和增强自适应性，此外还有些开放问题：如何使用 SSD/HDD 混合存储来优化系统效率；当存在很多删除时如何尽量保证此时的读性能；如何优化写入限流算法；如何高效的比较两个副本，以确定其包含相同的数据；如何最好的使用 PMEM，此时还该继续使用 LSM-Tree 么？如何支持多存储层级；附录 A. RocksDB 发展路线图很不错的图～可以看到 RocksDB 性能上的优化主要聚焦于 Compaction 及 Bloom Filter 展开～附录 B. 重要结论总结一个存储引擎能通过调参来适应不同工作负载是很重要的；对于使用 SSD 的大部分应用来说，系统瓶颈是在 SSD 容量上；降低 CPU 开销也变得越来越重要；如果一台机器上运行了多个 RocksDB 实例，那全局的资源管理就会变得很必要；提供不同的 WAL 文件处理方式可以给上层应用带来性能提升；SSD TRIM 是个好命令，然而需要对文件删除操作进行限速以避免偶发性的性能问题；RocksDB 需要同时具有向前及向后兼容性；配置的自适应性对于简化配置管理来说很有帮助；需要恰当的支持多副本及数据备份；数据损坏发现的越早越好，而非最后用到时才发现；CPU 及内存导致的数据损坏很罕见，然而是有可能发生的，此类数据损坏有时是不能被多副本所修复的；数据完整性保护需要覆盖全系统；用户通常是期望 RocksDB 能从暂时 IO 错误中自动恢复过来的；错误需要根据其原因及后果不同而采用不同处理方式；KV 接口是通用的，然而会有些性能局限性，增加一个时间戳可以很好的平衡性能和简单易用性。 附录 C. 设计之初一些不太合适的观点对用户来说可自定义的程度越高越好；RocksDB 无法处理类似 CPU 位反转这类错误；一旦发生 IO 错误就直接停止工作是可以接受的。参考资料：论文原文及 Presentation]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Storage </tag>
            
            <tag> RocksDB </tag>
            
            <tag> Distributed System </tag>
            
            <tag> System Design </tag>
            
            <tag> KV </tag>
            
            <tag> Paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TLA+ 形式化验证入门指南</title>
      <link href="/2021/08/01/TLA_Tutorial/"/>
      <url>/2021/08/01/TLA_Tutorial/</url>
      
        <content type="html"><![CDATA[形式化验证（Formal Verification）指一类使用数理逻辑方法来证明软件设计是正确的技术，据称是由 Edsger Dijkstra 于 1972 年最早提出，此方法一直是一种比较小众冷门的技术。形式化验证技术想要解决的核心问题是：软件总是可能存在 Bug 的，而测试始终无法涵盖所有可能性，特别是对于并发系统及分布式系统来说，就算单元测试达到了 100% 分支覆盖率，也不能肯定的说这个系统在线程安全，一致性等方面不会出问题。那如何更好的来验证我们的程序是否符合预期呢？形式化验证就旨在使用严谨的数学证明方法来证明某一算法是正确的。这样我们就可以拍着胸脯说，我的算法肯定是正确的，都证明过了:)听上去是不是很牛逼啊，感觉我们马上就要能写出 bug free 的程序来了呢～然而理想很丰满，现实很骨感，实际问题远远不会是这么简单的，要是形式化验证真这么好用那它就不至于至今还这么小众了，事实上形式化验证存在着很多局限性与不 work 的时候的，这个后面再来细说。关于形式化方法的实际应用及其强大之处可以进一步读读下面这篇布道文：Don’t Test, Verify —— 哪个故事真正符合你对形式化验证的想象？当初也是因为偶然看了此文章知道了形式化验证这个东西，后面也陆续去深入了解学习了下，最近也用它解决了一些实际工作中的问题。本文就打算分享下入门学习的一些心得体会。TLA+ &amp;amp; PlusCal 简介及一些基本概念进行形式化验证的具体工具有很多，目前实际软件开发中最为常用的是由 Leslie Lamport 开发的 TLA+，这是一种用于形式化验证的语言，主要用于验证并行及分布式系统的正确性。由于 TLA+ 写的代码并不是用来实际运行的，故一般将其代码称为模型（Model）而非程序（Program）。TLA+ 是基于数理逻辑而非经典的软件开发思想设计出来的，故其代码与其他编程语言有着显著区别，其中的基本元素是集合，逻辑运算，映射等东西，来个例子感受下：这段代码看上去完全不像在编程，实际上写 TLA+ 代码的确也不是在编程而是在用数理逻辑定义一些东西。这学习曲线对于大部分码农来说实在是太过于陡峭了，Programer 并不是数学家，Lamport 大神也知道这一点，于是他又搞了个叫 PlusCal 的东西出来。PlusCal 是一种类似 C/Pascal 的高级语言，其目的同样不是为了生成机器代码来运行，而是依靠 TLA+ 解释器来生成对应的 TLA+ 模型代码。来一段实际的 PlusCal 代码感受下：这看上去就很像经典编程语言了，因此对于程序员来说，可以使用 PlusCal 来快速进行形式化验证。不过 PlusCal 毕竟是 TLA+ 的上层高级语言，其能实现的功能只是 TLA+ 的一个子集，不过一般来说此问题不大，这个子集对于简单应用来说足够用了。有了代码后如何运行 TLA+ 或 PlusCal 模型呢，Lamport 为此开发了一个 IDE，即 TLA Toolbox. 然而此 IDE UI 界面并不是很好用，更建议使用 VSCode 中的 TLA 插件 来进行开发。入门学习路径及资料入门学习建议从下面这个教程开始：Learn TLA+此教程完全从实用角度出发，立足点是如何用 PlusCal 来解决日常编程中需要关注的并发，一致性等问题，因此十分简单易学，也比较短，看完后基本就能实际上手做些事情了。在实际写 PlusCal 代码的时候需要参考下其语法手册，PlusCal 有两种语法风格，类似 Pascal 的 P-Syntax 及类似 C 语言的 C-Syntax，语法手册分别如下：A PlusCal User’s Manual C-Syntax Version 1.8A PlusCal User’s Manual P-Syntax Version 1.8网上的例子中使用 P-Syntax 的居多，不过我个人更喜欢 C-Syntax 一些。如果看完上述简单教程后还想进一步系统的学习一下，那建议从 Lamport 的 TLA+ 项目主页开始：The TLA+ Home Page此外 Lamport 还有一本系统的讲形式化验证的书：Specifying Systems观千剑而后识器，看看其他人是如何写代码的对于入门来说也是很有用的，下面这两个 Github 项目中收集整理了很多 TLA+ 模型，如果想要提高水平可以仔细学习揣摩下：TLA+ ExamplesDr. TLA+ Series一些关键点及 TLA+ 的局限性定义什么是正确形式化验证是用来验证算法是正确的，那什么叫“正确”呢？如何定义“正确”是形式化验证中最重要的问题之一。比较符合程序员习惯的方法是在 PlusCal 中加入 assert 来检查是否满足某些条件。不过更好的方法是使用不变量（Invariants）检查，如何正确的定义算法中需要检查的 Invariant 是十分重要的，如果检查条件的定义本身就是不完备的，那形式化验证的结果自然也是不完备的。合理定义原子操作PlusCal 中使用 Label 来定义原子操作，一个 Label 下若干条语句会被视为是一个原子操作，如果把本来不是原子操作的行为错误的定义为了原子操作，那最终得到的结果显然就会是不完备的。如果把本来可以视为一个原子操作的行为定义为若干条原子操作，则会让验证的计算量大幅增加，导致验证所需时间变长。PlusCal 翻译成 TLA+ 后验证原理是穷举不同进程间执行时序的所有可能性，若原子操作或分支过多，会造成解空间的急剧膨胀。局限性TLA+ 并不是直接去验证算法的实现，而是验证算法实现抽象出来的 PlusCal 或 TLA+ 模型，这一步抽象的正确性只能由人工自行保证，没有任何方法可以证明二者是等价的。事实上二者绝大多数时候也是不等价的，比如程序中的数字都是会溢出的，而数学模型中的数字则不会。妄图对程序所有实现细节都去建模验证的尝试也是不可行的，因为这会导致验证的解空间变得极为巨大，基本上都是没有实际意义的。估计这也就是 Lamport 为什么不设计一个 C / Java 等语言直接翻译为 PlusCal 模型解释器的原因。如前文所述，算法正确性的定义也是需要人工完成的，这一步某些时候也是比较困难的，精确的定义什么是正确的本身就很有挑战性。需要人工建模也带来了软件开发过程中成倍的工作量增加，特别是在软件需要快速迭代开发时形式化验证方法基本是不可用的，因此实际上形式化验证手段一般也只用于一些变化很小，且开发周期很长的项目中。]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrent </tag>
            
            <tag> TLA+ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何学习一个新东西</title>
      <link href="/2021/06/12/How_to_Learn_a_New_Thing/"/>
      <url>/2021/06/12/How_to_Learn_a_New_Thing/</url>
      
        <content type="html"><![CDATA[我们从小到大都在学习各种新东西，学的东西多了自然会对“如何学新东西”这一问题本身有一些方法论层面的思考，本文就来分享总结下自己的一些经验。对于学习各种人为创造的东西基本都可以按相同的方法进行，不过对于学习自然科学的概念方法会有所不同，本文就不去讨论了。学习一个新东西基本可以分为三个阶段：初步理解，即会用；深入理解，即懂原理；融会贯通。初步理解这一阶段的目的是学会如何使用这个新东西，即学习如何用轮子的阶段，对于只需要应用的情况来说达到这一阶段就够了。此阶段的核心就是搞清楚三个问题：是什么（What），为什么（Why），怎么用（How），这十分类似于 3W 法则，因为这本来就是人类自然思维过程的抽象总结。是什么最基本的第一步，搞清楚这是一个什么东西。这一步说简单也简单，说复杂也复杂。简单在于只要随便看看介绍就会对这是什么有个初步感觉了；复杂在于要想给一个东西下一个精确的定义来描述它是什么会是极为复杂的。要理解一个东西是什么往往伴随着理解它不是什么同步进行。在学习新东西时一开始只需要对它是什么有个基本认识就好了，后续随着学习过程的深入自然会对此问题有越来越深入精确的认识。作用搞清楚为什么要创造出这么一个东西？这个东西的作用是什么？它可以用来解决什么问题？对于某些东西来说要搞清楚此问题并不简单，特别是一些源于数学的抽象概念和方法。使用方法学会如何用这个东西。一些基础小东西会相对较为单纯，其使用方法也自然很简单。然而很多时候一个东西会提供若干不同功能来满足不同需求与解决不同问题，各功能都会有自己不同的使用方法。且达到同样目的也可以选择不同优劣有异的功能组合。一般而言一个东西的复杂度很大程度上取决于其提供功能的多样性。相对比较简单纯粹的东西就只有会用和不会用两种状态，而更多复杂的东西则存在连续的中间状态。这一步通常会是一个逐步深化、逐步探索的过程，开始只会用其最基本的功能，随着使用的深入会发掘出越来越多的使用方法及功能来。深入理解即学习其内部实现原理，这一阶段也就是学习如何造轮子的阶段，由浅到深可以继续分为三步：理解这个东西是如何设计及实现出来的，它是如何工作的？理解为什么这样做是正确及可行的？理解为什么要这样设计，不这样做还可以怎么做？一般而言，一个相对较复杂的技术及概念都是基于一系列更基础的技术及概念组合而成的，要充分理解其实现原理就要先理解其用到的各种底层技术或概念。实现原理与此东西的功能及使用方法是密切相关的，内部实现是为了支撑其外部功能，在不知道其功能与使用方法时是很难理解其实现原理的。在这一点上是很容易走弯路的，就像大学的很多课程为什么会感觉无用和难学就是因为这些课程的设计不是从应用出发自顶向下而是从原理出发自底向上的。根据我个人的经验，自底向上的学习方式并不是完全不可行，然而学习过程会很痛苦和迷茫，往往也会事倍功半。从应用出发自顶向下的学习路线相对会自然很多，先会用，再去研究它是怎么工作的，这更加的符合人类认识事物的规律。当然也不是说非要精通其使用方法后再去研究其实现原理，二者其实是一个相辅相成相互促进的关系，会用了再去研究其内部实现会自然很多；理解了其内部实现后会有助于更好的去应用。融会贯通这一阶段主要是在一个更大的框架下来思考理解这个东西，以达到融会贯通的目的。可以从两个维度来入手。同类比较一般来说解决一个问题的方法都不止一个，因此可以进一步深入思考下这些问题：为了实现同样的目的及作用，还有什么其他方法？这些方法间有什么优劣？什么时候改选择什么方法？造成它们各自优劣的原因是什么？实现原理又有何共同点及区别？发展脉络人类发展至今基本所有东西都是渐进式发展的，没有太多东西是全新发展出来的，因此可以从时间的维度上来进行下思考：为了达到同样的目的，历史上有过什么其他的方法？它们是如何一步步演化到当前这个样子的？未来又会向什么方向演化？]]></content>
      
      
      <categories>
          
          <category> 人生之思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Methodology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chia 技术架构简述</title>
      <link href="/2021/05/16/Chia_Architecture_Brief/"/>
      <url>/2021/05/16/Chia_Architecture_Brief/</url>
      
        <content type="html"><![CDATA[Chia（起亚） 是最近极为火热的数字货币项目，对应的货币叫做 Chia Coin，简称 XCH。其核心算法为 PoST（Proof of Space and Time），以替代比特币中的 PoW（Proof of Work）。使用 PoSpace 空间证明而非 PoW 工作量证明是 Chia 项目宣称的最大优点。据他们的开发者宣称，PoW 耗费太多能源了，不环保，我们来搞点更环保的东西吧，不用 PoW 了，改用 PoSpace，即谁有的硬盘空间多谁的投票权就更大。因此他们还把通常称为白皮书（White Paper）的文档改名叫做绿皮书（Green Paper）。然而仔细想想这哪里环保了，把一堆硬盘搞来塞满毫无意义的数据比比特币矿机还要更邪恶吧……Chia 的官网上还可笑的宣称硬盘更不容易被垄断，因此个人还有小玩家可以更好的入场，简直是更荒谬的说法，哪个个人会去囤积一堆存不了有用数据的硬盘？IPFS 好歹还可以存一些实际有用的数据，看起来还真能促进下社会发展，至于 Chia 简直是除了圈钱和泡沫看不到任何其他意义。不过抛开实际意义，由于最近也研究了下 Chia 的文档和代码，就单纯的来和大家分享下 Chia 的技术实现吧。软件架构Chia 的整体架构图如下：整个系统中主要有 3 种类型的参与者：Farmer，农民TimeLord，时间领主Full Node，全能节点（中文翻译不确定）Farmer绝大部分参与者都是农民 Farmer，如何成为农民也很简单，直接去下载个打包好的客户端运行就好了。至于为什么叫 Farmer 呢？当然是为了凸显 Chia 的绿色环保喽，我们不是在浪费能源的挖矿，我们是在环保的种田！Farmer 的工作也很简单，基本就是两步：Plotting，播种Farming，摸奖Farmer 生成的 Plots file（P 盘文件） 可能会分布在很多台机器上，因此需要在这些机器上都部署上用来支持摸奖的服务，这个服务就被称为 Harvester 收割机。Farmer 接收到来自 TimeLord 的 Challenge（质询） 后，会将此 Challenge 转发到所连接的所有 Harvester 上。PlottingPlotting 的目的是在磁盘上生成一大堆 Plots file，根据其实现代码，这一过程可分为 4 步： Phase 1, forward propagation. 计算出所需的 7 张表及 f 函数集合，这一步实际上就已经生成了 PoSpace 所需的所有数据了，只是生成的临时文件还太大，需要后续来压缩下。f 函数的计算过程中会用到 Plot ID，Plot ID 直接决定了 Plots file 的内容； Phase 2, backprogagation. 主要目的在于消除表中的无意义项（Dead entries），以减少磁盘空间占用； Phase 3, compresses. 进一步压缩生成的临时文件 1，生成临时文件 2，临时文件 2 其实就是最终的 Plots file 了；这一步做了重排序，会使得生成的表中各项的顺序发生变化，不是按 PoSpace 要求的某种顺序。 Phase 4, write checkpoint table. 写入检查点表，其意义在于加快查找表的过程。最后，若最终路径（--final_dir）与临时文件 2 的路径（--tmp2_dir）是一样的，简单的把临时文件 2 做个 Rename 重命名即可；否则做一次数据拷贝生成最终 Plots file。此处之所以要 Copy 或 Rename 一下而不是直接把临时文件 2 作为最终文件的主要原因是为了分离临时文件及最终文件的存储位置。根据 Chia 的设计，Plots file 越多越好，因此显然要把它们存放在廉价的大容量存储系统，如本地机械盘或云端的低价存储中。然而此类系统通常随机读写能力不佳，甚至是直接不支持随机写入。可在生成临时文件 2 时是需要随机写入的，且写入的 IOPS 对生成文件的速度有显著影响，因此在通常实践中，会把临时文件写到 SSD 上。Plotting 的逻辑是由 DiskPlotter 这个类来实现的。FarmingFarming 的过程就是对一系列 Challenges 的证明响应，每一轮证明过程都是以一个 256 bit 的 Challenge 为输入，输出是一个 PoSpace 结构，其中包括 Plots file 的公钥，Pool 的公钥， Proof 结果等。其中最重要的就是 Proof 结果。生成一个区块的过程中会产生 64 次 Challenges，这一过程在客户端 Farming 的界面中可以看到：每一个这样的点被称为一个 Signage Point。为减少 IO 次数及所需网络带宽，目前的实现中采用了一种类似于预筛选的方法，先用较少次数的读计算出一个 Quality 值，并根据特定算法评估此 Quality 对于当前 Signage Point 来说够不够好，如果够好的话再去获取完整 Proof 结果。获取 Proof &amp;amp; Quality 的过程是由 Harvester 完成的，评估 Quality 质量则是 Farmer 的工作。HarvesterHarvester 负责管理某台机器上的所有 Plots file，并接收来自 Farmer 的 Challenge，返回每个 Plots file 的 PoSpace 及 PoSpace Quality。这部分代码是由 DiskProver 类实现的。Challenge 的高 $k$ bit 表示 f7 要满足的一些性质，通过对 C1, C2, C3 表的一通查询最终可以确定 Table 7 中有几项满足要求，可能有若干项满足要求，也可能一项都没有，平均期望是存在 1 项满足要求。这里有几项满足要求就意味着这个 Plots file 中存在多少个最终的 Proof 证明结果。之后的查找过程示意如下：不过要注意的是，从 Table 7 中的一项表项只能找到 Table 6 中对应的一项，这样依次找下去就可以得到 Table 1 中的 32 项，每项是由 2 个 $k$ bit 的整数构成的，因此最终结果就有 $k*64$ bit。对这 64 个数进行重新排序（排序规则是由 PoST 算法决定的），最终就可以生成一个长长的字符串，这就是 PoSpace 的证明结果。至于 Quality 是怎么来的呢？Challenge 最低 5 bit 的含义是 Table 6 ～ Table 2 在生成 Quality 时应该选择左边的值还是右边的值，按此规则进行选取后 Table 7 中的一项就会对应得到 Table 1 中的一项，即 2 个整数。将 Challenge 与这两个整数简单的二进制连起来，并计算 SHA-256，得到的结果就是 Quality 值。TimelordTimelord 一般被翻译为时间领主，它负责向 Farmer 发起质询（Challenge）并计算 VDF，计算完成后打包成新的区块，实际上整个 Chia 链中的区块都是由 TimeLord 计算生成的。TimeLord 最终决定了哪个 Farmer 的某个 Plots file 赢得了当前区块，即摸中奖了可以获得 XCH 奖励。那如何保证 TimeLord 是公平的而不是邪恶的始终选取自己的 plots file 呢？这就是由 Chia 的 PoST 算法决定的了。离 Challenge 越近（越优）的 PoSpace 会使得 TimeLord 计算 VDF 的速度越快。系统中不止有一个 TimeLord，而是有很多 TimeLord 在互相竞争，哪个 TimeLoad 先计算完成 VDF 成功打包区块，那整个链就会沿此区块继续延伸，其他在计算同一高度区块的 TimeLord 就会失败。此过程与传统 Bitcoin 的运行模式基本一模一样，可以猜想，对于分支情况的处理也应该和比特币基本相同。然而一个显著区别是，Bitcoin 奖励的是矿工，即最终成功生成新区块的参与者，而在 Chia 中，TimeLord 是没有任何奖励的，完全是自愿劳动:) 被奖励的是 Farmer。那无偿劳动为啥有人来干呢？根据某个 Chia 核心开发人员的说法是，当 TimeLord 好处多多，大家都会争着来干的，最显著的好处是，自己部署一个 TimeLord 与自己的 Harvester 离得近网络延迟小，避免自己由于网络延迟太大而成为炮灰。即由于网络延迟导致自己的 PoSpace 很久之后才被送到某个遥远的 TimeLord 上，导致根本没有机会被打包到区块中，即使自己的 PoSpace 比其他人更优。TimeLord 是 CPU 密集型任务，目前的开源实现强制要求运行平台支持 AVX512-IFMA 指令集。如果某个 TimeLord 的运行速度能压倒性的快于其他 TimeLord，那它理论上是可以凭借算力而非磁盘空间来控制整个链的，因此按照 Chia 开发者的说法，要把运行得最快的 TimeLord 算法开源出来，而且使得 ASIC 的运算速度没法超过通用 CPU，这样才能避免邪恶 TimeLord 的出现。Full NodeFull Node 的作用是广播中转各种消息，创建区块，保存和维护历史区块，与系统的其他参与者通信等。不同参与者之间的通信就是靠 Full Node 来完成的。Full Node 间的一致性使用的是与比特币一样的 Gossip 协议。一些重要算法算法部分没有仔细研究，此处更多的是给出一些深入研究的链接。PoST 算法Chia 最重要的算法当然要数 PoST 算法了，PoST 算法是由两部分构成的，PoSpace + VDF。PoSpace 的文档VDF 的文档为什么只有 PoSpace 是不够的还需要 VDF 呢？因为整个区块链网络是个 P2P 网络，产生一个 Challenge 后需要去收集所有 Farmer 的 Proof，区块链设计的核心哲学就是没有邪恶的中心节点，那怎么确定哪个 Proof 是最优的呢？如果这个判断进行得很快，比如简单的比比差值，那所有的 TimeLoad 都可以马上宣称某个 Proof 为最优，此时区块如何增长就完全不可控了，所以 PoT 也是必不可少的。需要通过计算 VDF 的过程让全网能够就哪个 Proof 是最优的达成共识。一致性协议一致性协议中主要介绍的是链的延伸过程，在 Chia 的绿皮书中对此有说明，不过目前有一份更新的 Google Doc:Chia Consensus Algorithm签名算法所有区块链技术的最底层基石都是密码学，特别是各种数字签名技术。Chia 中签名用的算法是 BLS12-381。BLS 算法是 2003 年由斯坦福大学的 Dan Boneh，Ben Lynn 以及 Hovav Shacham 提出的一种基于 ECC 的数字签名算法，和 ECDSA 的用处是一样的。该方案是一个基于双线性映射且具有唯一确定性的签名方案。BLS的主要思想是待签名的消息散列到一个椭圆曲线上的一个点，并利用双线性映射 e 函数的交换性质，在不泄露私钥的情况下，验证签名。BLS的算法在签名合并，多签，m/n 多签有丰富的应用。而 BLS12-381 则一种具体的 BLS 签名算法，此算法由 Sean Bowe 于 2017 年提出，最早被用于一个叫 Zcash 的数字货币项目中，现在不少其他区块链项目也用了此算法。在 Chia 的实现中需要用到不止一对密钥，比如钱包的密钥，Farmer 用的农民密钥等。这些密钥不是独立的，而是由一个主私钥通过私钥派生算法得到的，对于 BLS12-381 算法来说怎么生成这些密钥可以参考这个：EIP-2333: BLS12-381 Key Generation至于主私钥怎么来的呢，第一次启动 Chia 客户端时会创建一个由 24 个单词组成的助记词，这些助记词就是用来生成主私钥的。Plotting 时会生成一个随机主私钥，通过它可以派生出一个本地私钥，这个本地私钥又可以导出一个本地公钥，最终，本地公钥与农民公钥（Farmer Public Key）融合，生成了绘图公钥（Plot Public Key），最后矿池公钥（Pool Public Key）和绘图公钥（Plot Public Key）会被组合到一起，并进行一次哈希，哈希的结果被称为绘图 ID（Plot ID）。上述提及的绘图 ID，随机主私钥，农民公钥与矿池公钥均会被记录到 Plots file 的 Header 中。生成区块时，需要用与 Plot file 匹配的矿池私钥（Pool Private Key）进行一次签名。开源项目代码结构Chia 的业务逻辑，网络，一致性算法等是用 Python 写的，即 chia-blockchain 这个项目。这个项目也被视为 Chia 的主项目在 GitHub 上获得了最多的 Star。最终各平台上能运行的完整的程序也是在这个项目中发布 Release 版本的。至于 GUI 部分是基于 Electron 开发的，对应项目为 chia-blockchain-gui。核心的 PoST 算法则是 C++ 写的，分为两个项目：chiapos，PoSpace 相关代码，包括 Plots file 的生成及验证；chiavdf，TimeLord 上运行的 VDF 算法。Chia 中使用的 BLS12-381 数字签名算法的实现为：bls-signatures此外 Chia 还开发了一个叫 Chialisp 的智能合约语言，相关项目有：clvm，用 Python 写的 Chialisp 虚拟机；clvm-rs，用 Rust 写的 Chialisp 虚拟机；clvm_tools，一些支持工具。参考资料：硬盘危机——Chia 挖矿背后的原理与技术细节（一）Chia Green PaperChia挖矿：深入浅出聊P盘（绘图 Plots）]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Blockchain </tag>
            
            <tag> P2P </tag>
            
            <tag> Cryptography </tag>
            
            <tag> Consensus </tag>
            
            <tag> Storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 中的 volatile，atomic 及 memory barrier</title>
      <link href="/2020/09/11/Cpp_Volatile_Atomic_Memory_barrier/"/>
      <url>/2020/09/11/Cpp_Volatile_Atomic_Memory_barrier/</url>
      
        <content type="html"><![CDATA[C++ 中的 volatile 关键字，std::atomic 变量及手动插入内存屏障指令（Memory Barrier）均是为了避免内存访问过程中出现一些不符合预期的行为。这三者的作用有些相似之处，不过显然它们并不相同，本文就将对这三者的应用场景做一总结。这三者应用场景的区别可以用一张表来概括：volatileMemory Barrieratomic抑制编译器重排YesYesYes抑制编译器优化YesNoYes抑制 CPU 乱序NoYesYes保证访问原子性NoNoYes下面来具体看一下每一条。抑制编译器重排所谓编译器重排，这里是指编译器在生成目标代码的过程中交换没有依赖关系的内存访问顺序的行为。比如以下代码：编译器不保证在最终生成的汇编代码中对 p_a 内存的写入在对 p_b 内存的读取之前。如果这个顺序是有意义的，就需要用一些手段来保证编译器不会进行错误的优化。具体来说可以通过以下三种方式来实现：把对应的变量声明为 volatile 的，C++ 标准保证对 volatile 变量间的访问编译器不会进行重排，不过仅仅是 volatile 变量之间， volatile 变量和其他变量间还是有可能会重排的；在需要的地方手动添加合适的 Memory Barrier 指令，Memory Barrier 指令的语义保证了编译器不会进行错误的重排操作；把对应变量声明为 atomic 的， 与 volatile 类似，C++ 标准也保证 atomic 变量间的访问编译器不会进行重排。不过 C++ 中不存在所谓的 “atomic pointer” 这种东西，如果需要对某个确定的地址进行 atomic 操作，需要靠一些技巧性的手段来实现，比如在那个地址上进行 placement new 操作强制生成一个 atomic 等；抑制编译器优化此处的编译器优化特指编译器不生成其认为无意义的内存访问代码的优化行为，比如如下代码：在较高优化级别下对变量 a 的内存访问基本都会被优化掉，f() 生成的汇编代码和一个空函数基本差不多。然而如果对 a 循环若干次的内存访问是有意义的，则需要做一些修改来抑制编译器的此优化行为。可以把对应变量声明为 volatile 或 atomic 的来实现此目的，C++ 标准保证对 volatile 或 atomic 内存的访问肯定会发生，不会被优化掉。不过需要注意的是，这时候手动添加内存屏障指令是没有意义的，在上述代码的 for 循环中加入 mfence 指令后，仅仅是让循环没有被优化掉，然而每次循环中对变量 a 的赋值依然会被优化掉，结果就是连续执行了 1000 次 mfence。抑制 CPU 乱序上面说到了编译器重排，那没有了编译器重排内存访问就会严格按照我们代码中的顺序执行了么？非也！现代 CPU 中的诸多特性均会影响这一行为。对于不同架构的 CPU 来说，其保证的内存存储模型是不一样的，比如 x86_64 就是所谓的 TSO（完全存储定序）模型，而很多 ARM 则是 RMO（宽松存储模型）。再加上多核间 Cache 一致性问题，多线程编程时会面临更多的挑战。为了解决这些问题，从根本上来说只有通过插入所谓的 Memory Barrier 内存屏障指令来解决，这些指令会使得 CPU 保证特定的内存访问序及内存写入操作在多核间的可见性。然而由于不同处理器架构间的内存模型和具体 Memory Barrier 指令均不相同，需要在什么位置添加哪条指令并不具有通用性，因此 C++ 11 在此基础上做了一层抽象，引入了 atomic 类型及 Memory Order 的概念，有助于写出更通用的代码。从本质上看就是靠编译器来根据代码中指定的高层次 Memory Order 来自动选择是否需要插入特定处理器架构上低层次的内存屏障指令。关于 Memory Order，内存模型，内存屏障等东西的原理和具体使用方法网上已经有很多写得不错的文章了，可以参考文末的几篇参考资料。保证访问原子性所谓访问原子性就是 Read，Write 操作是否存在中间状态，具体如何实现原子性的访问与处理器指令集有很大关系，如果处理器本身就支持某些原子操作指令，如 Atomic Store， Atomic Load，Atomic Fetch Add，Atomic Compare And Swap（CAS）等，那只需要在代码生成时选择合适的指令即可，否则需要依赖锁来实现。C++ 中提供的可移植通用方法就是 std::atomic，volatile 及 Memory Barrier 均与此完全无关。总结从上面的比较中可以看出，volatile，atomic 及 Memory Barrier 的适用范围还是比较好区分的。如果需要原子性的访问支持，只能选择 atomic；如果仅仅只是需要保证内存访问不会被编译器优化掉，优先考虑 volatile；如果需要保证 Memory Order，也优先考虑 atomic，只有当不需要保证原子性，而且很明确要在哪插入内存屏障时才考虑手动插入 Memory Barrier。参考资料：内存模型与c++中的memory ordervolatile与内存屏障总结X86/GCC memory fence的一些见解]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
            <tag> Concurrent </tag>
            
            <tag> C++ </tag>
            
            <tag> Compiler </tag>
            
            <tag> x86 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态库全局符号覆盖的大坑</title>
      <link href="/2020/06/03/shared_library_global_symbol_override/"/>
      <url>/2020/06/03/shared_library_global_symbol_override/</url>
      
        <content type="html"><![CDATA[今天在调试时发现了一个奇怪的core：double free or corruption (fasttop)，从堆栈看是由于 _dl_fini 函数多次重复释放了某些 STL 容器导致的，此时就算在 main 函数中只保留个简单 return 0 也会出错，因此猜想肯定和某些全局变量有关。后面经过各种修改尝试，终于发现这是由于引用的 .so 动态库和主程序中定义了同名的全局 STL 容器导致的，此时的行为简直就是一个神坑，很有必要记录一下……先说最终结论吧：多个动态库或者是动态库与主程序间可以有同名全局符号，包括全局变量和函数等，此时链接过程是不会出错的。这些同名全局符号的地址是相同的！链接过程中会从前往后依次查找符号，对于 .so 及 .a 来说，如果遇到相同的全局变量是不会报错的，此时 GCC 会默默的选择第一个，这种情况连 Warning 都不会有。这与多个 .o 是不同的，在多个 .o 中定义相同的全局变量无法正常链接。以上行为的问题在于，绝大部分情况下各模块期望的行为都是调用自己的全局变量及函数，而不是调用其他模块的，因此大概率会造成运行时的各种异常。尤有甚者，若全局变量并不是基本类型而是 class，那虽然此变量只有一个内存地址，然而其构造与析构函数会被调用多次，若其中有动态分配的内存，多次 delete 就会导致 double free 异常。以上构造与析构行为是通过编译时向 _init() 及 _fini() 中添加 hook 函数实现的，构造顺序是链接顺序，析构顺序是其逆序。前文提到的 _dl_fini() 函数应该是 _fini() 的动态库版本。上面这些行为看上去已经很坑了吧，然而这并不是全部……以上行为仅适用于编译时直接指定需要链接库的情况，若是在程序运行过程中使用 dlopen 动态加载 .so 时行为不太一样；若通过 LD_PRELOAD 指定动态库那行为又不一样了……使用 dlopen 加载时的行为可以简要归纳如下：主程序中的全局符号是永远都不会被加载进来的动态库给覆盖的，无论是变量还是函数。这与很多文章中说的不太一样，然而实际使用 GCC 9.3 测试的结果就是如此，估计是较新的 GCC 版本做了什么修改导致的。多次调用 dlopen 加载多个动态库，若这些动态库间存在相同的全局符号，则它们之间是有可能相互覆盖的，这取决于 dlopen 的 flag。若使用 RTLD_GLOBAL，则后面加载进来的动态库会使用已有的全局符号；若使用 RTLD_LOCAL，则每个动态库间的符号是独立的。上述行为中，对应全局变量的构造及析构每次都会进行，也就是后面加载进来的动态库会在之前内存的基础上再来构造一次，退出的时候也会析构多次。以上很多行为显然应该都不是预期行为的，那如何解决这些问题呢，大概有这些方法：创建 .so 时加上编译选项 -Wl,-Bsymbolic，这会强制采用本地的全局变量定义。可以通过 __attribute__ ((visibility(&amp;quot;xxx&amp;quot;))) 来控制符号可见性，并通过编译选项 -fvisibility=xxx 来控制默认符号可见性。将不需要导出的全局变量声明为 static 的。最根本的做法，通过 namespace 等手段从根本上避免同名变量及函数的存在！最后给出几个简单测试程序，可以对照着理解上面的各种行为。my_calss.h:my_lib1.cc:my_lib2.cc:app1.cc:app2.cc:app3.cc:Makefile:测试程序运行结果为：app1：app2：app3：本文只是一个简单的总结，关于此问题的更多深入讨论可以参考以下文章：控制共享库的符号可见性 第 1 部分 - 符号可见性简介浅谈动态库符号的私有化与全局化linux动态库的种种要点Linux动态链接库so版本兼容浅析静态库链接原理全局符号Linux下全局符号覆盖问题What exactly does -Bsymblic do?]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> C++ </tag>
            
            <tag> Compiler </tag>
            
            <tag> Linux </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何从 coredump 文件中获取被优化掉的局部变量真实值</title>
      <link href="/2019/12/24/coredump_optimized_value/"/>
      <url>/2019/12/24/coredump_optimized_value/</url>
      
        <content type="html"><![CDATA[在 GCC -O3 优化级别下，很多局部变量是会被优化掉的，此时只能通过人工分析反汇编代码来获取所需信息，而这么做的前提是保存下来的寄存器中的值是准确的。绝大部分情况下 coredump 是由于 segment fault 或 assert 触发的，segment fault 情况下 Kernel 保存下来的 registers 信息是准确的，GDB 中直接用 info registers 就可以看到。然而若是由 assert 触发，由于 assert 会进行多层函数调用后最终执行 raise()，错误现场的寄存器信息是不准确的，这时候就需要一些其他手段来解决此问题。下面用一个具体例子来说明此问题。测试程序代码：运行此程序肯定会发生 assert failed，我们用 gdb 来看下调用栈：切换到 fun() 的栈帧：可以看到 a 与 b 都被优化掉了，到底是哪个值触发了 assert 就不能直接确定了。当然并不是就彻底没办法知道了，来看下 fun() 函数的反汇编：在 -O3 优化下 fun() 直接被内联到 main() 里面了，不过这不影响基本分析，重点关注 &amp;lt;+16&amp;gt; ~ &amp;lt;+32&amp;gt; 这几行，这就对应 fun() 的前几行逻辑，if (b &amp;gt; 0) 是通过 test + jg 来实现的，b 的值此时就是 %esi 寄存器中的值。看下 gdb 分析出来的当前栈帧的寄存器值：是不是其中 %rsi 的值就是我们需要的 b 了呢？非也！注意到 &amp;lt;+68&amp;gt; 行，在调用 __assert_fail() 前 %esi 又被重新赋值用于传递参数了，且由于 %esi 属于 caller save 的寄存器，在 __assert_fail() 内有可能会被再次改写。因此 使用 GDB 分析 coredump 文件不同栈帧的 register 信息时，只有为数不多的几个 callee save 寄存器的值是可靠的，其他的都是不可靠的。 那如何才能得到可靠的寄存器值呢？一般来说只有靠我们自己保存了，一个简单思路是只要在调用 __assert_fail() 前把所有寄存器的值保存到一个全局数组中就可以了。在 assert() 前添加如下一段内联汇编代码即可实现此目的：再来看下此时的反汇编代码：&amp;lt;+59&amp;gt; ~ &amp;lt;+180&amp;gt; 行就是我们新加的逻辑，可以看到这段代码紧接在 &amp;lt;+32&amp;gt; 行之后，理论上分析的确是可以保存准确的寄存器信息。来看下实际效果：registers_data[4] 与 final 的值完全相同，而从源代码和反汇编 &amp;lt;+26&amp;gt; 行可以看到，final 中保存的就是 b 的真实值。参考资料：Value optimized out. Reverse debugging to the rescue!]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> x86 </tag>
            
            <tag> Linux </tag>
            
            <tag> Debug </tag>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 perf 进行性能分析时如何获取准确的调用栈</title>
      <link href="/2019/10/30/perf_stack_traceback/"/>
      <url>/2019/10/30/perf_stack_traceback/</url>
      
        <content type="html"><![CDATA[perf 是 Linux 下重要的性能分析工具，perf 可以通过采样获取很多性能指标，其中最常用的是获取 CPU Cycles，即程序各部分代码运行所需的时间，进而确定性能瓶颈在哪。不过在实际使用过程中发现，简单的使用perf record -g 获取到的调用栈是有问题的，存在大量 [Unknown] 函数，从 perf report 的结果来看这些部分对应地址大部分都是非法地址，且生成的火焰图中存在很多明显与代码矛盾的调用关系。最初怀疑是优化级别的问题，然而尝试使用 Og 或 O0 优化依然存在此问题，仔细阅读 perf record 的手册后发现，perf 同时支持 3 种栈回溯方式：fp, dwarf, lbr，可以通过 --call-graph 参数指定，而 -g 就相当于 --call-graph fp.栈回溯方式 fp 就是 Frame Pointer，即 x86 中的 EBP 寄存器，fp 指向当前栈帧栈底地址，此地址保存着上一栈帧的 EBP 值，具体可参考此文章的介绍，根据 fp 就可以逐级回溯调用栈。然而这一特性是会被优化掉的，而且这还是 GCC 的默认行为，在不手动指定 -fno-omit-frame-pointer 时默认都会进行此优化，此时 EBP 被当作一般的通用寄存器使用，以此为依据进行栈回溯显然是错误的。不过尝试指定 -fno-omit-frame-pointer 后依然没法获取到正确的调用栈，根据 GCC 手册的说明，指定了此选项后也并不保证所有函数调用都会使用 fp…… 看来只有放弃使用 fp 进行回溯了。dwarf 是一种调试文件格式，GCC 编译时附加的 -g 参数生成的就是 dwarf 格式的调试信息，其中包括了栈回溯所需的全部信息，使用 libunwind 即可展开这些信息。dwarf 的进一步介绍可参考 “关于DWARF”，值得一提的是，GDB 进行栈回溯时使用的正是 dwarf 调试信息。实际测试表明使用 dwarf 可以很好的获取到准确的调用栈。最后 perf 还支持通过 lbr 获取调用栈，lbr 即 Last Branch Records，是较新的 Intel CPU 中提供的一组硬件寄存器，其作用是记录之前若干次分支跳转的地址，主要目的就是用来支持 perf 这类性能分析工具，其详细说明可参考 “An introduction to last branch records” &amp;amp; “Advanced usage of last branch records”。此方法是性能与准确性最高的手段，然而它存在一个很大的局限性，由于硬件 Ring Buffer 寄存器的大小是有限的，lbr 能记录的栈深度也是有限的，具体值取决于特定 CPU 实现，一般就是 32 层，若超过此限制会得到错误的调用栈。测试实际测试下以上 3 种栈回溯方式得到的结果，测试程序是一个调用深度为 50 的简单程序，从 f0() 依次调用至 f50()。**--call-graph fp**：**--call-graph lbr**：**--call-graph dwarf**：可以看到，的确只有 dwarf 获取到了正确的调用栈。总结优点缺点fpNone1. 默认 fp 被优化掉了根本不可用。lbr1. 高效准确1. 需要较新的 Intel CPU 才有此功能；2. 能记录的调用栈深度有限。dwarf1. 准确1. 开销相对较大；2. 需要编译时附加了调试信息。参考资料：perf Examples]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> x86 </tag>
            
            <tag> Linux </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PVE上部署OpenWRT发生网络中断的解决方法</title>
      <link href="/2019/07/28/PVE_OpenWRT_Network_Broken/"/>
      <url>/2019/07/28/PVE_OpenWRT_Network_Broken/</url>
      
        <content type="html"><![CDATA[在旧笔记本上使用Proxmox搭建了一个OpenWRT软路由，正常使用都很稳定，然而当PC使用百度网盘，迅雷等工具进行全速率下载时偶尔会出现网络中断问题，此时Proxmox宿主机的网络会全部断掉，即PVE自己的Web管理界面也无法登录。查看终端，此时会不断打印Detected Hardware Unit Hang的错误提示。Google一下这个错误提示，还是有不少类似问题的：Proxmox: enp0s31f6: Detected Hardware Unit Hang解决FreeNAS under KVM使用Virtio网卡导致宿主机网卡Hang的问题e1000e Reset adapter unexpectedly / Detected Hardware Unit HangHow to fix “eth0: Detected Hardware Unit Hang” in Debian 9?Proxmox Node freezes基本所有文章都提到此问题与TCP checksum offload特性有关，解决方案就是关掉checksum offload。具体方法是使用ethtool工具：如果要重启后永久生效的话将此命令写入/etc/network/if-up.d/ethtool2文件中并为此文件加上x权限即可：除此之外上述第2篇文章的情况和我遇到的很像，里面提到这与Virtio虚拟化有很大关系，而我使用的也正是Vritio，根据作者的说法，更应该在OpenWRT而不是Proxmox中关闭checksum offload。然而实际试了下却发现一个蛋疼的问题，OpenWRT中是无法把tx checksum offload给关掉的……此外作者还提到，将网卡的虚拟化方式从Virtio改为E1000也可以解决此问题，不过会有CPU占用率上升的副作用。综合以上几种方法，我最后采用的解决办法是：禁用Proxmox宿主机上的TCP checksum offload，并将OpenWRT使用的网卡虚拟化方式改为E1000。实际测试下来没有再发生网卡hang的问题，满速率下载（250Mbps左右）时CPU占用率50%左右，比之前使用Virtio时CPU占用率要高10%左右，还是可以接受的。问题算是解决了，最后顺带去进一步学习了下相关的知识，首先是TCP checksum offload，此技术的作用是将计算TCP checksum的工作由CPU软件实现改为由NIC设备（即网卡等）硬件实现，以此达到节约CPU资源的目的。Checksum OffloadingTCP checksum offloadUDP的checksum计算与硬件Offload另外就是Virtio与E1000，这是两种不同的网络虚拟化技术，Virtio是半虚拟化而E1000是全虚拟化。对于全虚拟化方案来说，虚拟机是完全感知不到自己是运行在一个虚拟环境中的；而半虚拟化则是虚拟机知道自己就是运行在一个虚拟环境中，此时IO驱动就可以做一些针对性的修改优化，以此降低虚拟化层进行转换带来的开销及性能损失。显而易见，半虚拟化技术的隔离度是没有全虚拟化好的，而且要是虚拟机驱动有问题会导致宿主机也出问题。这就是为什么在使用Virtio时，OpenWRT网络出现问题会导致整个Proxmox的网络都不能用了的原因。除了这两种虚拟化方式外，还有些更为先进的虚拟化技术，如SR-IVO等，有兴趣的话可以看看下面这篇文章的总结：KVM虚拟化网络优化技术总结]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Virtualization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用于嵌入式车载安全预警的交通标志检测若干关键技术研究与验证</title>
      <link href="/2019/02/24/Thesis_of_Master/"/>
      <url>/2019/02/24/Thesis_of_Master/</url>
      
        <content type="html"><![CDATA[转眼间毕业已经要一年了，今天在整理电脑文件的时候翻出了当初写的硕士毕业论文，在知网上搜搜也找得到了。想想硕士期间做过的东西也太杂了，电机控制、Android 开发、嵌入式。。。最后确定了这个毕业论文的题目后只有1年不到的时间可以做了，这期间还要复习准备找工作，不过最后做出来的东西还算是自己基本满意的，这估计也是我在学术上的顶峰了……为纪念下我离Academy最近的时刻，这里把我这篇论文的摘要及pdf版本的全文贴一下吧。全文下载链接：用于嵌入式车载安全预警的交通标志检测若干关键技术研究与验证论文摘要：车载安全预警系统可及时为驾驶员提供必要的行车安全预警信息以提高驾驶安全性,其包含若干子系统,如交通标志识别、超速预警等,而交通标志检测则是支撑诸多子系统的重要基础技术之一;本文就针对交通标志检测中基于颜色分割的定位算法及多线程任务调度策略这两项关键技术进行了研究,提出了适用于性能有限嵌入式系统的混合颜色分割策略及混合切换任务调度策略,并通过搭建嵌入式原型样机在实际道路环境中验证了方法的有效性。此外为更好的验证及评估交通标志检测算法的效果,本文建立了中国道路交通标志视频数据集,并将此数据集公开发布以供其他研究人员使用,这也是此领域目前唯一的中国公开数据集。目前主流成熟的交通标志检测定位方法基本均是基于颜色及几何形状局部特征的,本文在此框架下对用于车载安全预警的交通标志检测中最为重要的红色及黄色分割方法展开了深入研究,针对已有主流颜色分割方法的不足提出了混合颜色分割策略,此策略通过若干线性分类器的组合实现了对红色及黄色准确高效的分割,分割效果优于目前常用的各方法且其算法执行速度与最简单的RGB阈值法相似,可保证安全预警算法在性能有限的小型嵌入式车载设备上依然有较好的实时性;在颜色分割基础上本文采用经典的Hough变换实现了对红色圆形交通标志的检测定位并在数据集上评估了算法的效果。本文通过对交通标志检测识别问题进行建模分析提出可用采样间隔时间作为定量衡量此类系统实时性的指标,进而针对目前广泛使用的多核CPU提出了理论最优的理想多线程任务调度算法,此算法可显著降低采样间隔时间以提高系统实时性;不过理想任务调度算法实际无法实现,因此本文进一步提出了实际可实现的混合切换任务调度策略及动态更新参数估计策略;通过控制系统模型数值仿真及实际嵌入式原型样机上的测试验证均表明本文提出的方法可有效优化采样间隔时间分布以此提高系统实时性。本文同时开发了基于Qt的算法验证平台软件及基于Intel Joule模块的嵌入式原型样机,并在其上验证了上述各方法的有效性,最后在校园环境及城市道路上分别进行了静态及动态系统集成测试;测试结果表明本文提出的方法可在小型嵌入式设备上满足系统实时性要求,在天气光照条件较好时检出率也相对较高,不过算法鲁棒性依然需要加强。]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrent </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入分析Docker hello-world镜像</title>
      <link href="/2019/02/15/Deep_Into_Dokcer_Helloworld/"/>
      <url>/2019/02/15/Deep_Into_Dokcer_Helloworld/</url>
      
        <content type="html"><![CDATA[学习Docker时一般刚开始接触的第一个docker image就是hello-world，这个image运行起来的效果也很简单直接，仅仅是在屏幕上输出一段Docker的使用说明就结束了。这个镜像虽然简单，然而仔细分析下还是涉及不少底层机制的。我之所以会对这个镜像感兴趣，是发现它的大小仅仅只有1.84kB，这实在是太小了，写一个printf(&amp;quot;Hello Wolrd\n&amp;quot;);的程序编译出来大小就远超1.84kB了，所以很好奇这个镜像是如何构建出来的。DockerfileDocker的镜像构建过程是由其镜像描述文件Dockerfile决定的，所以就先找到其Dockerfile来看看。hello-world用于AMD64架构的Dockerfile可以在Github上找到，只有简单的3行：第1行导入了一个名为scratch的东西，这并不是一个真正的image，可以把它视为是所有image的最底层虚拟镜像，类似于一个基本抽象类，Docker官方对其的说明如下：This image is most useful in the context of building base images (such as debian and busybox) or super minimal images (that contain only a single binary and whatever it requires, such as hello-world).As of Docker 1.5.0 (specifically, docker/docker#8827), FROM scratch is a no-op in the Dockerfile, and will not create an extra layer in your image (so a previously 2-layer image will be a 1-layer image instead).……You can use Docker’s reserved, minimal image, scratch, as a starting point for building containers. Using the scratch “image” signals to the build process that you want the next command in the Dockerfile to be the first filesystem layer in your image.后面两行的含义也很直接，把一个名为hello的程序copy到根目录下，在运行image的时候运行此程序。下面就来看下这个如此小的hello world程序是如何实现的。主程序hello.c文件的源码也在同一个Github仓库中，省略掉过长的字符串常量后很简单：这个最简版本的Hello World和C语言教科书中第一个Hello World是有不小差别的。首先是程序入口点上，众所周知正常C/C++程序的入口点是main()，然而这里使用的是_start()。我们的程序是运行在Linux系统上的，程序的加载与运行必然是由OS发起的，对于Linux来说，OS层面的程序入口点就是_start()而不是main() 函数，一个程序要能正常运行在main()之前是有一些准备工作要做的，比如建立程序运行环境（初始化.bss全局变量等）；在main()返回之后也有些收尾工作要处理，比如调用exit()通知系统等。这些工作正常情况下是由语言标准库来完成的，也就是所谓的Runtime运行环境，对于C语言来说就是crt0.o。大部分程序的_start()就位于其中，在建立好运行环境后_start()会调用main()跳转到用户定义的入口点处。当main()返回后程序又将回到ctr0.o中，最终调用exit()通知OS回收进程资源。这里为了缩小程序体积和简单起见，没有使用标准的ctr0.o Runtime，事实上这一个简单的程序也不需要什么Runtime。程序最后直接通过syscall函数调用了SYS_exit系统调用结束了自身的运行。将字符串输出到屏幕上也没有使用标准库中的printf()，同样是直接调用了SYS_write这个系统调用，其第一个参数显式的写为了1，其实就是STDOUT_FILENO，Linux系统在unistd.h中定义了stdin, stdout, stderr这几个标准文件描述符。可以看到，这样一个程序是可以不依赖于任何其他的库在Linux上独立运行的，为了实现不链接C标准库的目的，需要使用一些特殊的编译选项。从编译这个hello-world程序使用的Makefile中可以找到使用的编译选项为：-static表示静态链接，虽然对这个程序来说无所谓动态链接还是静态链接……-Os表示为空间进行-O2级别的优化，专门用于减少目标文件大小；-nostartfiles是关键编译选项，此选项表示不使用标准C语言运行库（即crt0.o），也不链接C标准库；-fno-asynchronous-unwind-tables选项也是用于减少代码空间的，其大概含义是不产生C++异常处理机制中使用的.eh_frame段，关于什么是unwind-tables和.eh_frame是个比这篇文章复杂多了的问题，文末有几篇参考资料，之后有空可以深入学习下C++的底层机制……进行了以上诸多特殊优化处理后，终于可以得到一个只有1k多的可以正常运行于Linux上的Hello World程序了。参考资料：What is the use of _start() in C?When is the gcc flag -nostartfiles used?GCC x86 code size optimizationsc++ 异常处理（2）]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compiler </tag>
            
            <tag> C </tag>
            
            <tag> Runtime </tag>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sudo不需要输入密码的方法</title>
      <link href="/2018/11/17/Sudo_No_Passwd/"/>
      <url>/2018/11/17/Sudo_No_Passwd/</url>
      
        <content type="html"><![CDATA[正常情况下，使用sudo命令是需要输入密码的，连续输入多条sudo只用输一次密码就行，不过若干分钟后又需要输入密码了。对于自己使用的本地桌面环境来说，其实是可以配置成sudo免输入密码的，这样可以减少一些麻烦。以Ubuntu 18.04为例说明设置方法，其他发行版可能会有区别。Ubuntu Desktop默认已经将安装系统时配置的用户加入了admin用户组，且admin用户组中的用户都是有sudo权限的，因此无需修改sudo用户组。若需要将某用户添加到sudo用户组中，可参考文末链接。输入su -命令切换到root下，修改/etc/sudoers文件，找到：修改为：即可。这样就可以允许sudo用户组中的用户免密码执行sudo命令了。参考资料：免密码使用sudo和su]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为Hexo博客Yelee主题添加Gitment评论系统</title>
      <link href="/2018/11/04/Hexo_Yelee_Gitment/"/>
      <url>/2018/11/04/Hexo_Yelee_Gitment/</url>
      
        <content type="html"><![CDATA[本来博客使用的是多说作为评论系统，前两年多说停止服务了换成了友言，用了没多久友言又要求备案不能用了……后面由于工作繁忙也就没管这个了。前段时间发现Gitment这个基于Github Issue的评论系统不错，这两天终于有空把它给加上了。我使用的主题是基于Yelee做了些修改得到的，Yelee又是基于Yilia的，添加Gitment的过程可以参考这篇文章：Hexo 添加 Gitment 评论Yiila主题也添加了Gitment支持，其Commit也是很有参考价值的。与以上教程有区别的是，无需安装Gitment npm插件，添加修改的代码我也改了下，有兴趣的话可以看这个Commit。其中Gitment的CSS &amp;amp; JS文件改为了本地压缩后的版本，评论框的显示效果也调整了下。终于评论系统又可以用啦，之后就该静心学学技术提高下自己的水平了……Update:2021-06-12: Gitment 的 Github OAuth 是依赖于外部服务器的，目前公共的挂得差不多了，需要自己搭一个，参考下文：gitment修复[object ProgressEvent]]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sizeof 获取 extern 数组长度</title>
      <link href="/2018/06/30/sizeof_extern_array/"/>
      <url>/2018/06/30/sizeof_extern_array/</url>
      
        <content type="html"><![CDATA[sizeof是获取数组元素个数的常用运算符，然而前几天使用时发现，对于extern类型的数组，sizeof的使用上是有些需要考虑的问题的。假设系统中有3个文件：file1.c:header1.h:main.c:在main.c中期望通过sizeof运算符获取array中元素个数，然而这么做是错误的，编译时无法通过，错误提示类似incomplete type not allowed这类。造成这一问题的原因在于，**sizeof是在编译时计算的，而C/C++的编译是以文件为基本单位的**。在编译main.c文件时，编译器是不可能知道定义在file1.c文件中array数组具体信息的，只根据header1.h文件中的声明是无法确定array的具体大小的，因此，就算某些编译器编译时不报错，得到的结果也是不正确的。分析清楚原因后来看下解决方案，基本解决方法有4种：避免使用匿名长度的数组声明，使用宏定义预先确定数组大小；定义一个辅助变量用于保存数组大小信息，将其定义赋值放在定义array数组的同一个文件中；使用特殊元素表示数组结束，就像字符串结尾的&amp;#39;\0&amp;#39;一样，这样就可以在运行阶段动态确定数组大小；将数组的定义放到使用它的源文件中。这几种方法都有其缺点：使用sizeof就是不想固定数组长度，因为使用宏定义固定数组长度不够灵活，要是想添加数组元素也要同时修改宏定义，否则尽管编译不会报错，然而运行时新添加的元素其实是无效的，这会导致将来维护时一些潜在Bug发生的可能性增加；需要一个额外的存储空间，且由于这是一个变量，每次使用数组长度时都需要访问内存，编译器也无法对数组长度作出任何假设，进而影响编译优化，理论上说这可能会导致运行时一些微小的效率损失；需要修改上层逻辑，缺乏通用性；大部分情况下，使用非static全局变量的原因就是多个源文件需要使用这个变量，这时显然无法做到这一点，多次重复定义链接时会出错的。实际使用中，需要根据具体问题具体分析采用哪种方法最恰当，一般而言不经常变化的数组就使用宏定义确定其大小，会经常变化的第2种方法最常用，此时还可以用一些宏定义简化编程，以上代码可修改为：file1.c:header1.h:main.c:参考资料：comp.lang.c FAQ list · Question 1.24C: How to determine sizeof(array) / sizeof(struct) for external array?sizeof extern数组]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多歧路，今安在？</title>
      <link href="/2018/06/03/The_Road/"/>
      <url>/2018/06/03/The_Road/</url>
      
        <content type="html"><![CDATA[好久没写博客了，翻看自己的博客，上次更新已是半年多前了，这大半年来忙于找工作，毕业设计，毕业答辩、入职……入职前两个月也是各种忙碌，现在对手头的工作也熟悉一些了，于是乎在低头做事的空暇时也需要抬起头来看看路了。自从找工作拿到几个Offer可以选择时就开始各种纠结与困惑了，大疆、阿里、Intel、华为、拼多多、乐鑫、网易……有幸能拿到这么些优秀公司的Offer，然而每一家公司都同时有吸引我和令我踌躇的地方，鱼和熊掌终不可兼得，选择也变得十分困难。虽然最终选择了大疆，然而这一选择并不是那么顺理成章，当时在犹豫，本以为选了之后就不会困惑了，现在才发觉，困惑的东西并不会随着时间推移而自然而然的变得清晰起来。人生有很多选择，选择和努力哪个更重要呢？这个问题的标准答案在准备面试时都背得滚瓜烂熟了，选择与努力互为因果，选择是为了决定之后努力的方向，努力是为了将来能有更多选择。然而，记住了所谓的标准答案并无济于事，该困惑的时候还是一样困惑。其实想想，所有困惑的根源都来自于两点：不知道自己真正想要的是什么；不知道未来会是怎样。与其说是不知道自己想要什么，不如说是不知道自己愿意放弃什么，选择之所以困难，是因为选择与放弃总是如影相随的，选择了此就注定要放弃彼。人总是什么都想要的，但事实是我们注定要放弃大多数东西的，人生在不断的做出选择，同时也是在不断放弃。然而，我究竟愿意放弃什么呢？愿意选择什么呢？这并不是那么确定的啊……什么都不想放弃，也就注定什么都无法得到。上面那点也许还能随着年岁与阅历的增长思考得越来越清楚，那对未来不可知的迷茫更是让人觉得无能为力。生命的精彩源于不可知，生命的痛苦也源于不可知。时代的洪流滚滚前进，顺之者昌逆之者亡，然而时代的车轮碾向何方又有谁知？可供选的路总是越来越少的，我们都终有一日会无路可选，到那时，认命也罢，不认也罢，是非成败转头空，唯余夕阳照青山。在我们还有得可选的时候，还是多想想吧，就算是一条咸鱼也还是要挣扎下看看的。虽然路最终总是越走越窄的，还是要努力下让它窄得不要那么快吧，毕竟啊，谁又能说自己走的一定是那条自己想要同时又不会被时代湮没的道路呢？瞎扯了这么多似乎还是多想清楚了那么一丝东西吧，脚踏实地亦要仰望星空，不要让天天加班和生活琐事的忙碌成为一种错觉蒙蔽了双眼。自己的未来何在，尽管想不清还是要去找的吧，在坚信自己找到之前，努力让未来的路宽广一些，努力让自己不要失去有选择的能力，虽然选择是困难和纠结的，然而没选择的走投无路是更大的悲哀。然而，要维持像学校里那样站在四通八达的十字路口近乎是不可能完成的事，两条路经常是越来越远的，刚开始时尚有可能跳过去，越到后面越难跳过去了吧。所以啊，还是要尽快想清楚自己想去哪条路上才行啊，然而，谁知道哪时候能想清楚呢……不过在想清楚自己要跳去哪条路上之前，还是要多练练自己跳跃的能力，培养些通用的技能，让自己还是有路可跳有路可选吧。]]></content>
      
      
      <categories>
          
          <category> 人生之思 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH反向穿透访问内网主机</title>
      <link href="/2017/11/04/SSH_Forwarding/"/>
      <url>/2017/11/04/SSH_Forwarding/</url>
      
        <content type="html"><![CDATA[学校的网络位于无数重NAT内网中，而且还有各种VPN，所以想要从外网访问十分困难，之前试过各种方法都没成功。今天偶然看到了SSH反向穿透的方法，因为我访问内网服务器主要也是需要SSH连接功能，故此方法可以很好的满足我的需求。此处记录下配置方法。SSH反向穿透需要有一台有公网IP的服务器作为桥梁，此处将位于多重NAT网络中需要访问的主机称为Target，而将有固定IP的中转服务器称为Server。SSH反向穿透的原理是，Target主动建立与Server间的SSH连接，利用SSH的端口转发功能，将访问Server某端口的数据包转发到Target SSH端口（22端口）上，以此实现间接登陆Target的目的。假设Server上的转发端口为6766，使用如下命令在Target上建立与Server间的反向隧道：-R用于定义反向隧道，-fN用于在建立SSH连接后SSH进入后台运行。之后需要在Server上打开sshd的GatewayPorts功能，这样才能实现只登录一次即可连接上Target。修改/etc/ssh/sshd_config文件，添加下面这行：重启sshd服务：此时就可以在任意一个终端上使用ssh -p 6766 userTarget@Server登录到Target上了，需要注意的是，此时使用的用户名、密码、秘钥都应该是Target而不是Server的，只有IP地址或者是域名是Server的。最后一个问题是，如何保持这个SSH反向隧道的稳定存在，并且实现若Target意外重启后能自动再次建立此反向隧道。解决方法是使用autossh，并且把它作为一个服务自动启动。先安装autossh，之后在/etc/init.d下建立一个名为autossh的文件：（以下操作以Ubuntu为例，其他发行版可能会有区别）-M参数指定了一个监控端口，和端口转发无关，使用一个无用的端口即可；-i指定了一个密钥，此处用RSA密钥的方式登陆Server。保存此文件，并添加执行权限：chmod +x autossh；注册服务：update-rc.d autossh enable；最后启动服务：service autossh start。可使用sysv-rc-conf工具查看autossh服务的开机自启动情况。这样将其作为服务配置好后，就可以实现稳定的SSH反向穿透了，终于可以实现从任何地方自由访问内网主机的目的了~~最后顺便提一下，SSH转发其实可以承载其他更多的网络服务，这个之后有空再来研究~参考资料：如何通过SSH反向隧道，访问NAT后面的Linux服务器?使用SSH反向隧道进行内网穿透使用autossh实现反向SSH隧道ubuntu service的添加和删除How to use systemctl in Ubuntu 14.04]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言关键词restrict的应用</title>
      <link href="/2017/10/25/C_restrict/"/>
      <url>/2017/10/25/C_restrict/</url>
      
        <content type="html"><![CDATA[restrict是C99标准中新增的关键词，只能用于修饰指针（函数指针除外），其含义为：此指针是访问其指向对象的唯一初始方法。使用此关键词的意义在于：有助于编译器进行代码优化。restrict是一个类型限定词，在C99标准(ISO/IEC 9899:1999)的”6.7.3.1 Formal definition of restrict”中给出其定义，基本语法为xxx * restrict var，其中xxx是指针指向的变量类型。需要注意的是，只有指向所谓”object types”的指针才能用restrict修饰，而”object types”的定义应该是除了函数指针外所有类型的指针。另外，对于函数参数来说，由于数组和指针的等价性，函数参数为数组时也可以用restrict修饰，此时restrict放在[]中，如：void fun(int par[restrict])。上面也说到，使用restrict的意义在于便于编译器优化，此处使用restrict最常用的一个例子进行说明：对于foo函数，编译器是不能假设a和b指向的区域是不同的，它们有可能指向同一内存区域，故此时编译得到的汇编代码为：可以看到，在进行最后一步加法运算前，需要再读一遍*a的值，以保证结果的正确性，因为若a==b的话，此时*a == 6而不是*a == 5；此时这段程序返回的是12而不是11。然而，我们如果能确保a != b，那以上代码是可以进一步优化的，restrict关键词就用于把这一信息提供给编译器，此时的rfoo函数编译结果如下：这段代码中直接返回了编译器预先计算出来的结果11，与foo相比减少了一次加法运算，且不需要进行movl (%eax), %eax这一步骤。（虽然由于Cache的存在，这一指令也不一定会进行内存访问）以上汇编代码使用GCC 4.9.3编译得到，编译参数为：-O3 -S -std=gnu11，结果和参考资料中给出的汇编代码稍有区别，不知为何参数传递使用的是栈而不是寄存器……从以上例子中可以看到，若一个指针是访问某内存区域的唯一方法，那可以为其加上restrict限定符，这有利于编译器进行代码优化生成效率更高的程序。参考资料：restrict type qualifier如何理解C语言关键字restrict？C99中的restrict关键字]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux kernel中的min和max宏</title>
      <link href="/2017/10/08/Kernel_min_max_macro/"/>
      <url>/2017/10/08/Kernel_min_max_macro/</url>
      
        <content type="html"><![CDATA[min和max是两个很常用的操作，一般都是用宏实现的，不过想要写出一个很完善的宏定义还是要考虑很多问题的，本文就来分析下Linux Kernel中的实现方法。文中仅考虑min，max的结构与其完全相同，只要修改下大于小于号即可。宏定义中要将整体和变量都加上括号的意义此处就不多说了，据此我们可以写出一个最基本的形式：然而这种写法是有副作用的，考虑min(a++, b)这样的用法，其展开后的形式为：当a&amp;lt;b时，a++会被执行两次，这显然不是我们所希望的，为了解决这一问题，我们可以使用下面这个稍显复杂的宏定义：这里用到了GCC的一个扩展特性，形如(&amp;#123; ... &amp;#125;)这样的代码块会被视为一条语句，其计算结果是&amp;#123; ... &amp;#125;中最后一条语句的计算结果。故上述宏定义展开后的结果就是第5行返回的结果。注意，这个扩展特性不是所有编译器都有的，如果用VS编译上述代码，是无法通过编译的。这个宏定义中，先根据a, b的类型生成了两个局部变量__min1__和__min2__，之后比较其大小，返回较小的一个，这样就保证了宏参数只会被执行一次，避免了上述副作用。另外，第4行代码其实是没有实际作用的，其意义在于，若__min1__和__min2__的类型不同，比较其地址时编译器会给出一个Warning，这样可以避免一些潜在的错误发生。以上宏定义就是网上普遍流传的Linux Kernel中的实现方法，然而，我实际阅读了当前4.12.7版本的Kernel源代码，发现实际的实现方法要更复杂一些。在引入实际的实现方法前，我们先思考一下以上宏定义还存在什么漏洞。考虑以下代码段：期望得到的结果应该是__min1__ = 9, __min2__ = 21, min_val = 10。然而实际情况是，__min1__ = 10, __min2__ = 20，min_val的值则是不确定的。造成这一结果的原因在于输入参数和宏定义内部使用的局部变量重名了，这样就会导致在宏定义的语句块内，外层同名变量的作用域被内层局部变量的作用域所屏蔽，展开后的代码就成了这样：这就类似于int a = a这样的语句，执行完后a的值是不确定的，且因为展开后__min1__成了宏体内的局部变量，__min1__--的自减操作对于外层变量来说也是无效的。知道问题的原因后解决方法就很清晰了，只要避免重名就可以了，其实上述宏定义中使用__min1__这样的名字也是为了避免重名，然而，靠起特殊的名字这种方法不是那么的优雅，故实际新版的Linux Kernel中使用了编译器产生的唯一名称来解决这一问题：可以看到这是一个多重的宏嵌套结构，主要区别就在于__UNIQUE_ID(min1_)上，__UNIQUE_ID可以生成一个唯一的名字。唯一性是由编译器提供的__COUNTER__宏保证的，这也是GCC的一个扩展，GCC文档中对其的说明如下：This macro expands to sequential integral values starting from 0. In conjunction with the ## operator, this provides a convenient means to generate unique identifiers.简而言之，__COUNTER__会被展开为一个从0开始的整数，且每次调用后其值都会加一，这也就保证了其唯一性。至于__PASTE宏这是用来实现两个token连接的，之所以要两重宏定义和宏的嵌套展开规则有关，可以参考我之前写的总结文章。调用__UNIQUE_ID(min1_)后产生的就是形如__UNIQUE_ID_min1_0这样的变量名，这就确保了此名称不会和传入变量的名称重复了。当然，我们还是可以通过刻意构造这样一个特殊名称来实现冲突的，只是程序是程序员自己写的，相信也没有程序员这么无聊……故我们只需要保证正常情况下不会发生冲突即可。]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言中typeof的使用</title>
      <link href="/2017/10/07/C_typeof/"/>
      <url>/2017/10/07/C_typeof/</url>
      
        <content type="html"><![CDATA[typeof不是C语言本身的关键词或运算符（sizeof是C标准定义的运算符），它是GCC的一个扩展，作用正如其字面意思，用某种已有东西（变量、函数等）的类型去定义新的变量类型。typeof通常用于宏定义中，一些示例用法如下：可以看到，typeof()中可以是任何有类型的东西，变量就是其本身的类型，函数是它返回值的类型。typeof一般用于声明变量，如：不过，这也不是绝对的，从语法上来说，所有可以出现基本类型关键词的地方都可以使用typeof，比如sizeof(typeof(a))这样的用法，虽然这里的typeof是多余的，不过它是符合语法的。再来看一些高级用法：可以看到，typeof还可以用来定义函数指针等，且typeof(int *)a, b是定义了两个指针变量。最后指出一些需要注意的问题。typeof()是在编译时处理的，故其中的表达式在运行时是不会被执行的，比如typeof(fun())，fun()函数是不会被执行的，typeof只是在编译时分析得到了fun()的返回值而已。typeof还有一些局限性，其中的变量是不能包含存储类说明符的，如static、extern这类都是不行的。参考资料：6.6 Referring to a Type with typeofGCC扩展关键字typeof学习笔记]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解C语言中宏定义</title>
      <link href="/2017/10/06/C_Macro/"/>
      <url>/2017/10/06/C_Macro/</url>
      
        <content type="html"><![CDATA[从本质上看，C语言中的宏定义实现的是一个文本替换的功能，似乎很简单的样子，然而这几天去看了下Linux Kernel源码中的各种宏定义，才发现一个宏定义竟然也可以有如此多的奇技淫巧……于是花了一天时间仔细研究了下宏的相关知识，此处整理总结下。关于宏，网上有一组写得极好的文章，基本上看完这几篇文章就可以对宏有一个深入的理解了：宏定义黑魔法-从入门到奇技淫巧 (1) —— 基本概念宏定义黑魔法-从入门到奇技淫巧 (2) —— object-like宏的展开宏定义黑魔法-从入门到奇技淫巧 (3) —— function-like宏的展开宏定义黑魔法-从入门到奇技淫巧 (4) —— 一些宏的高级用法宏定义黑魔法-从入门到奇技淫巧 (5) —— 图灵完备宏定义黑魔法-从入门到奇技淫巧 (6) —— 宏的一些坑作者的知乎上也有一份相同的备份。相同的内容此处就不再重复了，此处列出一些要点。带参数的宏中可以使用两个特殊运算符，#(Stringification Operator)和##(Token Pasting Operator)，作用分别是把宏参数变为字符串字面量和连接两个token。且遇到这两个运算符时，宏参数不会展开。宏的嵌套展开过程中，已展开过的宏不会重复展开。宏展开后，会进一步检查是否构成了新的宏，若构成了会进一步展开。宏定义中也可以使用...代表可变参数，用__VA_ARGS__获取可变参数列表。宏参数会先展开，之后再进行替换，这也被称为”prescan”.宏基本上是图灵完备的，所以可以只靠宏实现各种东西……宏的展开过程遵循以下流程图：这个流程图是我根据自己的理解和实验画出来的，并不确定完全正确……图中的“已展开宏记录”就是文章中说的“蓝色列表”。使用gcc编译时，可以通过附加-E参数，让gcc只进行预处理，这样就可以看到各种宏实际展开出来的结果是什么了，如gcc -E -o test.i test.c命令对test.c文件进行预处理，生成test.i文件。关于宏的展开流程，有一些不太明确的地方，此处用例子说明下，结果都经过gcc预处理验证过。遇到#或##时，其相连的宏参数不会展开，然而这不意味着这个宏参数本身不会展开，其他部分用到这个宏参数的地方还是会展开的。另外，#运算符后必须是一个宏参数，不能是其他东西，不过##两端则无这一要求，来看个例子：可以看到，##两端可以是任意token，其作用就是把这两个token合成一个。另外，还可以看到，##是在最开始就进行处理的，所以P(a)这个宏是没有用到的。另外，由##操作符组合产生的新宏是会继续展开的，并不像某些文章说的那样会停止展开。关于多次扫描展开的问题，有些文章中说的是展开完成后会重新扫描一遍当前字符串，若有可以继续展开的则继续展开，然而实际测试下来并不是这样的。还是来看个例子：可以看到，第1、3个例子中，展开到FOO () 之后就没有继续展开下去了，这说明并没有重新扫描字符串这一步，已经处理过的部分不会再次处理的。而第2个例子则说明的确是会再展开合并出新的宏来的，故上面的流程图中使用了”向后扫描一个token，形成一个新的字符串”这样的说法。考虑到token是以空白为界划分的，后面组合出来的新宏只可能是function-like的宏，所以这样的展开方式是不存在歧义的，不会出现原来的宏被组合成其他宏的情况。如果要继续展开上面未能展开的那两个宏，可以再封装一层：这里利用的原理是：宏参数会先尽可能展开后再进行替换。将宏定义的各种奇技淫巧应用得巅峰造极、神鬼莫测之作就是The Boost Preprocessing library，这是Boost库的一部分，不过和其他部分完全独立，这部分包含了各种数据结构和算法等，而且只有头文件，全部都是宏定义……简直可谓是丧心病狂……Github上有人将这部分独立的代码提取出来了，有兴趣的读者可以去进一步揣摩瞻仰：boost-preprocessor参考资料：代码自动生成-宏带来的奇技淫巧《C标准库》—之&amp;lt;assert.h&amp;gt;实现C preprocessor]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言中的字符串字面量连接</title>
      <link href="/2017/10/05/string_literal_concatenate/"/>
      <url>/2017/10/05/string_literal_concatenate/</url>
      
        <content type="html"><![CDATA[字符串字面量(string literal)就是程序代码中出现的&amp;quot;包围的字符串，比如&amp;quot;hello&amp;quot;, &amp;quot;I Love C Language!&amp;quot;这类的。在C语言中，有一个奇技淫巧：两个相邻的字符串字面量会自动被合并连接为一个。这里的相邻可以是直接连在一起，也可以是间隔着若干个空白字符。需要指出的是，这个特性是C语言标准所要求的，并不是某个编译器的扩展功能。一个例子：以上代码完全等同于：参考资料：How does concatenation of two string literals work?]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用代码判断栈的增长方向</title>
      <link href="/2017/09/28/Detect_Stack_Direction/"/>
      <url>/2017/09/28/Detect_Stack_Direction/</url>
      
        <content type="html"><![CDATA[对于大部分CPU架构和编译器来说，程序的栈空间增长方向都是向下递减的，然而这也不是一定的。我们可以用一小段简单的C语言代码来判断下栈的增长方向。栈基本都是用于保存局部变量和传递参数，故要判断栈的增长方向就要从这两个方面入手。第一篇参考资料中给出了各种思路及其可行性分析，很值得看看，此处直接给出结论：一个函数中的局部变量在栈中的顺序是不定的，或者说是由编译器决定的，故不能通过直接比较两个局部变量的地址来判断栈的增长方向；函数参数压栈的顺序也是不确定的，虽然一般编译器都是从后向前压栈，然而从前向后也不是绝对不可能；连续嵌套调用两个函数时，第一个函数的相关数据会先入栈，之后才是它调用的第二个函数，这一点应该是一个通用成立的结论。综上，要判断栈的增长方向，可以通过函数的嵌套调用来进行判断，更优雅一点的方案是使用递归，得到的代码如下：在绝大多数平台上，我们得到的结果应该都是Stack Growth Downward!。参考资料：判断栈和堆的生长方向栈增长方向与大端/小端问题]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compiler </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>printf格式化字符串漏洞攻击</title>
      <link href="/2017/09/20/printf_format_string_attack/"/>
      <url>/2017/09/20/printf_format_string_attack/</url>
      
        <content type="html"><![CDATA[前几天去Intel面试时，遇到了一个问题：printf(&amp;quot;%s&amp;quot;, s)与printf(s)有何区别？面试官还提示我从安全的角度回答这个问题，然而当时并没有想出答案来……:( 回来后仔细研究了下这个问题，才发现pritnf(s)这种写法是存在严重安全漏洞的，这被称为printf格式化字符串漏洞攻击。printf函数支持不定参数的原理在此不多说，可参考stdarg.h头文件的相关介绍。核心就是，函数使用栈传递参数，且根据cdecl函数调用约定，压栈顺序是从最后一个参数开始逆序进行的，而printf函数的第一个参数是确定的字符串，故可以从这个字符串中判断出栈中还有多少个数据，每个数据的类型是什么，进而依次取出各个数据。正常情况下，格式化字符串中格式化字符%是和之后的参数一一对应的，然而我们可以考虑一种情况，若格式化字符%比参数多会怎么样呢，答案是，会取到栈中其他的数据。这就是printf(s)这种写法有问题的原因了，这里使用s而不是一个字符串字面常量，而s传入什么内容其实是不可控的，若传入字符中存在%，就会输出栈中其他一些内容。要是s还是可以由外部输入的，那就可以通过巧妙的构造s的形式来实现访问栈中本来没有权限访问的内容，这就是所谓的格式化字符串漏洞攻击。下面来看一个实际的例子：这段程序中由用户输入一个整数，存放在security这个变量中，之后再输入一个字符串str，并使用printf(str)这样的形式将其打印出来。针对这个例子，我们可以构造一个特定的输入字符串将security的内容给打印出来。使用GCC 4.9.3编译以上程序，优化等级-O2，得到的程序用objdump反汇编一下，可以找出对应的汇编代码为：40835040835a部分为GCC自动生成的main函数入口处代码，此处不用管它；40835f408372为第一个scanf函数，读入security；408377408382为第二个scanf函数，读入str；40838740838a调用printf输出str。根据反汇编结果，我们可以画出408372行时栈的结构：scanf函数反向压栈，故%esp指针指向的元素$0x40a0c0应该就是字符串字面量&amp;quot;%d&amp;quot;的首地址，而%esp+0x04就是栈中的下一个元素，这就是security变量的地址，从汇编代码中可以看到，这个地址是一个%esp的偏移量，%esp+0x18。由此，我们可以分析出security在栈中的位置，而之后%esp指针没有改变，故我们可以构造以下这个特殊的字符串：%d%d%d%d%d_____security_is:%d，这个字符串会连续取出栈中的前6个int，第6个int的地址就是%esp+0x18，这正是security变量的地址。实际运行程序测试一下：可以看到，我们成功读到了security的内容。为了预防这个问题，我们需要确保在使用printf函数时第一个参数必须是一个字符串字面量。其实，以上写法编译器也会产生warning：format string is not a string literal (potentially insecure).最后，其实配合一个比较少用的printf参数%n还可以利用此漏洞实现对栈中内容的修改，在此就不展开了，可参考第三篇参考资料。参考资料：printf(string) vs. printf(“%s”, string)What is the underlying difference between printf(s) and printf(“%s”, s)?格式化字符串漏洞简介]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> C </tag>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atom编辑器配置</title>
      <link href="/2017/09/16/Atom_Configure/"/>
      <url>/2017/09/16/Atom_Configure/</url>
      
        <content type="html"><![CDATA[之前使用过各种文本编辑器，Notepad++、Sublime Text、VIM等，使用下来觉得各有千秋，都有些不太满意的地方。前段时间体验了下Atom，感觉很不错~作为一个所谓的”A hackable text editor for the 21st Century”，还是有很多可以折腾配置的东西，此处总结整理下。基本使用Atom是Github社区推出的开源编辑器，即可以开箱即用无需配置，也可以充分的去定制折腾：Atom is a text editor that’s modern, approachable, yet hackable to the core—a tool you can customize to do anything but also use productively without ever touching a config file.Atom官方的使用手册见文末第一个参考资料链接。下载安装一般从其主页上下载编译好的二进制程序文件即可，Windows下一般使用exe安装包。安装过程完全不需要用户参与，也无法参与……安装包会将Atom自动安装到C盘的某个位置，且这是无法更改的。命令面板（Command Palette）Windows下，使用ctrl-shift-p键即可打开命令面板，在这个命令面板中可以使用模糊搜索快速查找所需的命令，而无需像传统方式那样在层层菜单中寻找。如设置界面，可从菜单中的File-&amp;gt;Setting打开，更快的方式是在命令面板中搜索setting，即可看到所需命令及其快捷键：主题与字体在设置界面中，Themes一项用于设置界面及语法高亮主题，尝试下来One这个主题最好看，还提供了One Light及One Dark两套亮色及暗色主题。如果对自带的几个主题配色不满意的话，可以去官方的几千个主题中挑选自己喜欢的，或者干脆自己自定义一个~不过自带的这两个主题已经可以完全满足我的需求了，就不再去折腾了……至于编辑器界面的字体与字号，可在Editor选项卡中配置，一般选择等宽字体，如我选择的YaHei Consolas Hybrid。查找文件Atom中，通过文件夹的方式来组织管理项目，界面左侧就是Project面板。若要查找项目中的文件，可使用ctrl-p快捷键；使用ctrl-b查找已打开的文件。编辑&amp;amp;移动Atom中本身就有一些光标移动的快捷键，不过更方便的是使用下文将要提到的Vim扩展插件，此处仅列举一些比Vim更好用的功能：跳转到某行：ctrl-g，之后输入行号跳转到标签：ctrl-r，如要在工程内搜索，使用ctrl-shift-r将当前行（或选中的几行）上下移动：ctrl-↑/↓，此功能在调整代码时会很有用Atom中还有个很强大的多光标功能，按住ctrl键的同时用鼠标在多个位置点击或选取，即可启用多光标编辑模式。也可以选中一个词后，按ctrl-d键即可选择下一个相同的词。另外，Atom中的括号等不仅会自动配对，而且选中某一个部分后输入单边括号，编辑器会自动用此括号把选中内容包围起来。书签使用alt-ctrl-F2键来添加或删除书签，使用F2键可以调到下一个书签，ctrl-F2打开书签列表。搜索和替换与大部分软件一样，ctrl-f打开搜索替换面板，ctrl-shift-f在整个工程中执行搜索替换。也可以使用正则表达式，在替换时若需反向引用，使用$1, $2…各种高级功能Atom内置了很多高级编辑功能，此处列出一些常用的，详见Atom Flight Manual中的帮助说明。Snippets常用代码片段，输入响应关键词后，会自动弹出提示，此时按Tab键即可自动输入。不同文件类型有不同的默认代码片段，各种package也会添加自己的snippets扩展，可在命令面板中输入Snippets:Available查看当前可用的snippets。如果要自定义snippets，可参考官方文档的说明：Creating Your Own SnippetsGit集成Atom是Github发布的编辑器，自然内置了很好的Git支持，界面右下角即可看到当前状态，点击后即可打开Git面板。不过和大部分IDE中集成的Git一样，此处的Git只适合日常工作时commit新代码，若要查看之前的提交记录或进行一些更复杂的操作，还是使用专门的软件更好，比如GitKraken。值得一提的是，编辑器左侧使用不同颜色直接标出了此文件的修改情况，十分的直观~使用快捷键alt-g-↑/↓可以快速切换到下一个修改过的地方。插件Atom本身是一个很轻量级的编辑器框架，它的各种功能都是由不同插件实现的，称为Packages，这也就是配置Atom中最好玩的部分了~插件的安装有几种不同的方法，最简单的方法是，在Settings-&amp;gt;Install中直接搜索安装即可。此处记录下我安装的插件。配置备份Atom的所有配置文件其实都位于.atom文件夹下，理论上可通过自行备份这个文件夹来实现配置备份，不过此处我们有一个更优雅的解决方案：Sync-setttings插件。此插件基于Github gist进行备份，所以还需要进行一些额外的配置，详见下面两篇文章：Sync-setttings(插件-备份神器)Atom 编辑器配置sync-settingVim扩展Vim最好用的地方应该是其移动方式，在Atom中也可以通过安装vim-mode-plus这个插件实现基础的Vim功能，这个插件是对官方Vim插件的升级加强，功能还是很完善的。这个插件还有一个Wiki页面，里面有各种帮助文档，其中Advanced Topic Tutorial部分介绍了各种高级编辑技巧，很值得一读。vim-mode-plus插件默认绑定了很多快捷键，如果需要自定义的话，可以修改keymap.cson文件。比如我就根据自己的需求加入了以下一些配置：Vim中还有个很好用的插件叫EasyMotion，可以实现快速移动定位，同样在Atom中，也可以通过安装Jumpy这个插件来实现这一目的。此插件默认绑定的快捷键是shift-Enter，可以将vim-mode-plus中的f键替换为这个插件：Markdown扩展Atom本身就支持Markdown语法高亮的，再配合一些插件就可以很完美的作为一个Markdown编辑器使用了：markdown-preview-enhanced : Markdown预览增强版，提供了各种高级功能，详见其文档。安装好后可以把Atom自带的markdown-preview给禁用掉Markdown-Writer : 各种辅助增强功能，功能介绍见其文档Markdown-Writer有一个很方便的功能就是自动生成草稿文件(draft)和发布(publish)完成的草稿文件，这需要先在其设置中配置一下，相应的config.cson文件如下：最后三个选项是为了实现自动管理标签和分类用的，这需要另一个Hexo插件hexo-generator-atom-markdown-writer-meta配合，这个插件有些小Bug，在Hexo 3上无法正常使用，不过有人给出了解决方案，打上这个补丁即可。这样配置好后，再配合内置Terminal，就可以实现在Atom内完成博客写作的全过程了~minimapSublime Text中有一个很好用的文档缩略图功能，在滚动时屏幕右侧会显示此文档的缩略图。在Atom中也可以通过插件实现这一功能，这就是minimap插件，除了这个基础插件外，还有几个扩展插件用于增强其功能：minimap-autohider : 在不滚动鼠标时自动隐藏minimap缩略图；minimap-bookmarks : 在缩略图中高亮显示书签；minimap-find-and-replace : 在缩略图中高亮显示搜索结果；minimap-git-diff : 在缩略图中高亮显示当前文档修改情况；minimap-highlight-selected : 在缩略图中高亮显示选中的单词；minimap-split-diff : 在缩略图中显示split-diff插件的比较结果；Terminal集成Atom中的terminal插件有很多，使用下来最好用的是platformio-ide-terminal，在Windows下默认调用的是powershell。安装好此插件后，点击界面左下角的加号即可新建一个terminal，其显示风格也可以自定义，用起来极为方便。编程辅助最常用的两个功能就是自动补全和代码检查，通过插件autocomplete-plus和linter实现，这两个插件都只是一个框架，针对不同语言有不同语言的扩展。针对C/C++，可安装autocomplete-clang和linter-clang，这两个插件都依赖于clang，所以要先装好clang。clang是LLVM的一部分，下载链接在这里，在Windows下就是一个exe安装包，直接安装即可，不过需要注意的是，安装时一定要选择添加到环境变量，否则无法正常使用。安装好后，在命令行中输入clang -v，若有输出说明安装正确。关于这两个插件的详细使用和配置可参考其文档。另外，linter的显示似乎还需要一个名为Linter-UI-Default的插件支持，也要一起安装上。其他一些推荐插件还有：atom-ctags : 为当前工程生成tag索引，以便实现跳转，默认跳转快捷键为F12，shift-F12返回；symbols-tree-view : 与atom-ctags配合使用，以列表的形式列出tag；最后一个待解决的问题就是调试器，要是能把GDB等集成到Atom里面就完美了，这个之后再来折腾……Update 2017-10-05:对于Python来说，可以安装autocomplete-python和linter-pylama，Python的语法补全和错误检查比C语言用起来感觉更好~关于调试器，可以使用dbg-gdb插件其它插件highlight-selected : 高亮当前选中的单词file-icons : 添加一些文件类型的图标，更为美观split-diff : 可以对比两个文件的差异杂项使用过程中也遇到了一些零散的问题，此处记录一下。Q: 无法通过拖拽打开文件，即将文件拖入一个已经打开的Atom窗口界面时，显示红色的禁止标志。A: 不要使用管理员身份运行Atom即可。Q: 界面字体发虚。A: Win10下软件界面显示模糊问题解决办法 Atom禁用GPU启动的方法Q: 安装Package时网络连接错误。A: 这是由于GFW把相关网站墙掉了的缘故……开VPN或者是系统代理即可，使用代理的话，在Settings-&amp;gt;Core中找到Use Proxy Settings When Calling APM，勾选上此选项即可。最后，使用了一段时间后觉得，Atom有各种好，不过它也有个最大的缺点，就是慢，真的好慢啊…………参考资料：Atom Flight ManualAtom编辑器入门到精通(一) 安装及使用基础atom在vim模式下设置快捷复制按键Windows 软件系列-atom插件]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atom禁用GPU启动的方法</title>
      <link href="/2017/09/06/Atom_Disable_GPU/"/>
      <url>/2017/09/06/Atom_Disable_GPU/</url>
      
        <content type="html"><![CDATA[正如在之前的文章中提到，Atom在Win10下若不禁用GPU加速的话，界面字体会模糊，启动时可以通过附加--disable-gpu选项来禁用GPU，然而在打开关联文件等时候，是无法直接设置命令行参数的，此时就需要做些配置来实现这一目的。修改快捷方式若要直接打开一个程序，较常用的方法就是通过桌面或开始菜单中的快捷方式，此时可以在快捷方式属性中指定命令行参数即可，如图所示：修改右键菜单默认情况下，Atom会自动新建一个Open with Atom的右键菜单项，这个功能还是很实用的，要实现此处打开的Atom也能附加命令行参数，需要通过修改注册表实现。在regedit中，找到\HKEY_CLASSES_ROOT\*\shell\Atom项，这就对应右键菜单中那个命令，其默认项为菜单项的名称，Icon项指向一个exe文件，对应缩略图图标，不要去修改它。继续展开其command子目录，其默认项就是调用的命令，在最后添加一个--disable-gpu即可，例如：&amp;quot;C:\Users\g1992\AppData\Local\atom\atom.exe&amp;quot; &amp;quot;%1&amp;quot; --disable-gpu。最先为Atom的目录，之后的&amp;quot;%1&amp;quot;应该就是系统传入的待打开的文件，最后为我们加上的附加参数。注意，disable-gpu必须加在&amp;quot;%1&amp;quot;之后，加在前面Atom无法正常打开文件。修改文件关联要修改文件关联调用的程序，也要通过修改注册表实现。系统的打开方式中列出的程序其实是由注册表中\HKEY_CLASSES_ROOT\Applications\目录决定的，每一个子项对应一个程序。找到\HKEY_CLASSES_ROOT\Applications\atom.exe项，这就对应打开方式中Atom项。\HKEY_CLASSES_ROOT\Applications\atom.exe\shell\open目录下的FriendlyAppName项就是打开方式中程序的名称，而其下的command目录的默认项就对应调用的命令行。同理在最后添加一个--disable-gpu即可。通过以上配置，基本可以实现无论通过哪种方式打开Atom均可以完全禁用GPU加速的效果了~参考资料：修改注册表实现文件默认打开方式]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10下软件界面显示模糊问题解决办法</title>
      <link href="/2017/08/30/Win10_Software_Font_Blur/"/>
      <url>/2017/08/30/Win10_Software_Font_Blur/</url>
      
        <content type="html"><![CDATA[某些软件在使用过程中会出现显示显示模糊的问题，鼠标动一下或者点一下菜单显示又清晰起来。使用的系统是Win 10，笔记本显卡为GT 730M，开启了系统DPI缩放。遇到此问题的软件有：Visual Studio 2015AtomMarkdownPad我遇到的问题与这两个问题基本完全一样：atom，vs2017、vscode 在 win10 下界面显示模糊怎么办？Visual Studio 2015字体发虚、模糊解决方案解决方法正如其中所说，关掉GPU硬件加速即可。不过对于Atom来说，使用配置useHardwareAcceleration: false是无效的，必须在启动时附加命令行参数--disable-gpu才行。此问题显然应该是某个Bug造成的，但具体是什么原因导致的并没有查到……]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>memcpy中的内存读写优化问题</title>
      <link href="/2017/08/15/Memcpy_Optimization/"/>
      <url>/2017/08/15/Memcpy_Optimization/</url>
      
        <content type="html"><![CDATA[memcpy作为一个很简单的库函数，实现了内存的拷贝。不过这个函数功能虽然简单，要实现一个高效的memcpy函数还是很有难度的，这里对其优化问题做一简单讨论。基本实现最简单的memcpy函数实现如下：memcpy1函数对应的汇编代码如下：（使用gcc 4.8.4 -O1优化级别得到，-O2优化级别得到的代码差不多，-O3优化级别得到的代码会复杂很多，极为难以理解……）从中可以看到，在.L3主循环中，每次使用零扩展传送（MOVZ）从源地址读取一个字节的内容，然后将其写入目的地址。内存读写优化memcpy1实现的功能是完全正确的，然而，这段代码效率也是很低效的，其中一个重要原因就是没考虑到实际内存读写过程。目前大部分主流CPU架构中，数据总线的位宽是确定的（大部分是32位或64位），在进行数据传输时，只能以此为基本单位进行传输，且每次读写数据的地址也最好是按照总线位宽对齐的（可能会有其他更严格的对其要求，如x86平台上SSE寄存器要求128位对齐），如果需要的数据不满足此要求时，读写效率会降低，如会进行多次读写等。根据以上分析，我们可以每次都以数据总线位宽为单位进行读写，以此优化上述代码：需要注意的是，以上代码假设n是8的整数倍。对应的汇编代码如下：对比两段反汇编代码可以看到，理论上说后一段代码的执行速度会是前一段的8倍，实际测试表明后一段的确快很多，数据长度不同时加速比不一样，不过没有达到8倍，其原因应该和Cache有关，现代主流CPU中均有Cache，所以第一段代码也不是每次都会去读取内存的，之前读到的数据会存在于Cache中，后续访问的速度会比读取内存快很多。memcpy2为了说明主要问题，假设n是8的整数倍，然而对于实际使用的函数而言，显然不能做这个假设，此时的处理方法是最后来复制n % 8个字节，代码如下：此时的汇编代码类似memcpy1与memcpy2的混合体，此处从略。另一个问题是，之前也提到，内存的读写最好以对齐的方式进行，不过我实际测试了下对于memcpy3来说，src与dest是不是对齐的影响并不大，特别是数据量比较大的时候。这个应该也与Cache机制有关。当然，这是对于x86架构来说的，对于ARM架构而言，地址是强制要求对齐的，好像不对齐的话会出现错误。更多优化实际的标准库memcpy函数的实现要复杂的多，主要还要考虑以下一些问题：使用SIMD指令集，如SSE2，SSSE3，AVX2等；考虑缓存预取问题（Cache Prefetch）；考虑地址对齐问题；相关讨论可以参考这个知乎帖子：怎样写出一个更快的 memset/memcpy？关于预取（Prefetch）技术的优化技巧，可参考ARM公司的这篇文章：Using Block Prefetch for Optimized Memory Performance最后，实际最新版的Glibc 2.26中memcpy的代码是用汇编写的，对于x86_64架构使用了SSSE3指令集优化，代码长达3000余行……列在最后以表达下对技术大佬的膜拜……memcpy-ssse3.S]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找数组中出现次数超过一半的元素</title>
      <link href="/2017/07/31/Array_Find_Half/"/>
      <url>/2017/07/31/Array_Find_Half/</url>
      
        <content type="html"><![CDATA[一个数组中，有某个元素的出现次数超过数组中元素个数的一半，找出这个元素。这题有一些较容易想到的常规做法：先排序，中间元素即为所需元素。时间复杂度O(lonN)。利用散列，统计每个元素出现的次数，超过一半即输出。此算法需要额外空间，约为O(n)。不过这两种方法都未能在时间和空间上同时达到最优，在牛客网上做到这题时，评论区中有个给出了一个来源于《编程之美》中的巧妙算法，可以做到只循环一遍，且不需要额外空间。算法基本思路是：在数组中任选两个不同元素消去，最终剩下的元素一定是出现次数超过一半的元素（在保证此元素存在的情况下）。具体编程时，可以重头开始扫描，记录当前元素出现次数times，遇到不同的元素则times--，若times==0，换一个元素继续。代码如下：此算法需要预先保证输入元素中肯定存在解时返回结果才正确，若不确定是否有元素出现次数大于一半，需要在最后再循环检查一遍：]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++中std::string的COW及SSO实现</title>
      <link href="/2017/07/26/Cpp_string_COW_SSO/"/>
      <url>/2017/07/26/Cpp_string_COW_SSO/</url>
      
        <content type="html"><![CDATA[在牛客网上看到一题字符串拷贝相关的题目，深入挖掘了下才发现原来C++中string的实现还是有好几种优化方法的，这里简单记录一下。原始题目是这样的：关于代码输出正确的结果是()（Linux g++ 环境下编译运行）这段程序的输出结果和编译器有关，在老版本(5.x之前)的GCC上，输出是true true false，而在VS上输出是false false false。这是由于不同STL标准库对string的实现方法不同导致的。简而言之，目前各种STL实现中，对string的实现有两种不同的优化策略，即COW(Copy On Write)和SSO(Small String Optimization)。string也是一个类，类的拷贝操作有两种策略——深拷贝及浅拷贝。我们自己写的类默认情况下都是浅拷贝的，可以理解为指针的复制，要实现深拷贝需要重载赋值操作符或拷贝构造函数。不过对于string来说，大部分情况下我们用赋值操作是想实现深拷贝的，故所有实现中string的拷贝均为深拷贝。最简单的深拷贝就是直接new一个对象，然后把数据复制一遍，不过这样做效率很低，STL中对此进行了优化，基本策略就是上面提到的COW和SSO。COW所谓COW就是指，复制的时候不立即申请新的空间，而是把这一过程延迟到写操作的时候，因为在这之前，二者的数据是完全相同的，无需复制。这其实是一种广泛采用的通用优化策略，它的核心思想是懒惰处理多个实体的资源请求，在多个实体之间共享某些资源，直到有实体需要对资源进行修改时，才真正为该实体分配私有的资源。COW的实现依赖于引用计数（reference count, rc），初始时rc=1，每次赋值复制时rc++，当修改时，如果rc&amp;gt;1，需要申请新的空间并复制一份原来的数据，并且rc--，当rc==0时，释放原内存。不过，实际的stringCOW实现中，对于什么是”写操作”的认定和我们的直觉是不同的，考虑以下代码：以上代码显然没有修改string b的内容，此时似乎a和b是可以共享一块内存的，然而由于string的operator[]和at()会返回某个字符的引用，此时无法准确的判断程序是否修改了string的内容，为了保证COW实现的正确性，string只得统统认定operator[]和at()具有修改的“语义”。这就导致string的COW实现存在诸多弊端（除了上述原因外，还有线程安全的问题，可进一步阅读文末参考资料），因此只有老版本的GCC编译器和少数一些其他编译器使用了此方式，VS、Clang++、GCC 5.x等编译器均放弃了COW策略，转为使用SSO策略。SSOSSO策略中，拷贝均使用立即复制内存的方法，也就是深拷贝的基本定义，其优化在于，当字符串较短时，直接将其数据存在栈中，而不去堆中动态申请空间，这就避免了申请堆空间所需的开销。使用以下代码来验证一下：某次运行的输出结果为：可以看到，a.c_str()的地址与a、b本身的地址较为接近，他们都位于函数的栈空间中，而b.c_str()则离得较远，其位于堆中。SSO是目前大部分主流STL库的实现方式，其优点就在于，对程序中经常用到的短字符串来说，运行效率较高。参考资料：std::string的Copy-on-Write：不如想象中美好C++ 工程实践(10)：再探std::stringWhy is COW std::string optimization still enabled in GCC 5.1? C++ string的COW和SSO]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> C++ </tag>
            
            <tag> Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LDO应用总结</title>
      <link href="/2017/06/12/LDO/"/>
      <url>/2017/06/12/LDO/</url>
      
        <content type="html"><![CDATA[LOD(Low Dropout Regulator, 低压差线性稳压器)是目前最常用的线性稳压元件，本文对其特性进行一总结。基本原理LDO的本质可以视为一个带反馈的可变电阻，其降压的基本原理就是电阻分压。其基本原理框图如下：其中虚线框内的调整元件(Pass Element)可以有很多实现方式，比如NPN、PNP、NMOS、PMOS、达灵顿管等。目前比较先进的LDO使用的都是MOS，这是由于MOS管可以获得比三极管更低的导通电阻，进而获得更低的压差(Drop Voltage)。最常用的1117 LDO使用的调整元件就是NPN三极管：而TI的TPS737xx(130mV @ 1A)使用的则是NMOS：误差比较器也是LDO的一个核心器件，它将输出反馈电压分压与REFERENCE基准源提供的基准电压进行比较，之后通过改变调整元件的栅极电压（或基极电流），进而改变其电阻，以实现将输出电压稳定在某一个特定值处的目的。REFERENCE基准源一般都是使用带隙基准电路(Bandgap voltage reference)来实现的，所以其电压一般为1.25V左右。特性LDO在稳态工作时的特性与一个电阻完全相同，也就是说，可以直接用一个电阻来替代稳态工作时的LDO。LDO名称中的Low Dropout低压差是与传统三端串联稳压元件（如78xx系列）相比来说的，这类串联稳压元件之所以有一个最小压差，本质原因就是其调整元件的电阻不能降为0，这也就是上面的原理框图中将调整元件电阻拆分为两部分——$R_{DS(on)}$及一个可变电阻的原因。下面就来具体分析下此问题，需要注意的是，下面的分析仅在调整元件为MOS时成立，对于1117这类调整元件为三极管的LDO是不适用的。首先来看一下LDO的工作区域：图中Saturation Line饱和线右下方的区域即为LDO可能的工作区域，这张图其实就是MOS管的输出特性曲线，正常情况下LDO是工作在MOS的恒流区的，图中A、B、C三点即是三个可能的工作点。当输出电流发生改变时，误差放大器就会通过调节$V_{GS}$保证$V_{DS}$不变，就像A-&amp;gt;B点的变化过程。任意一点与原点连线斜率的倒数就是这一工作点下LDO的等效电阻，可以看到，由于MOS管的$I_{DS}$会饱和，LDO的工作区域中存在最小的导通电阻，即饱和线上对应的电阻，而饱和线近似为一条直线，故这个最小电阻近似为一固定值，即$R_{DS(on)}$。一般数据手册中给出的最小压降是LDO在最大工作电流时对应的最小压降，即上图饱和线左上角那一点。从图中可以很容易看出：当工作电流降低时，对应的最小压降成比例的降低，也就是说LDO的最小导通电阻基本为一常量，最小压降与工作电流存在线性关系。几个实际LDO芯片的最小压降特性：TPS737xx:ISL80510:ADM7172:不过需要注意的是，以上特性仅在导通元件为MOS的情况下存在，对于导通元件为三极管时，以上特性不成立。比如对于BL1117来说，其最小压降为：1.3V@1A; &amp;#x31;&amp;#46;&amp;#50;&amp;#x33;&amp;#x56;&amp;#x40;&amp;#x30;&amp;#46;&amp;#49;&amp;#65;。输出电流的减小并没有让最小压降显著减小。当LDO工作于饱和区时（即实际压差小于最小压差时），LDO特性相当于一个固定电阻，失去了稳压调节能力。核心参数指标极限参数各种极限参数，比较重要的是最高输入电压，也就是器件的最高耐压；除此之外还有器件的极限温度，需要保证晶元温度不能超过此值。输出电压LDO有固定输出和可变输出两种，固定输出反馈回路集成在器件内部，其电压是厂家出厂前调整过的，精度较高，数据手册中一般会给出典型输出电压及其最大最小范围。输出电压的精度与很多因素有关，如温度、噪声等，详细分析可以参考文末第二篇参考资料。最大输出电流需要注意的是，设计过程中不仅要考虑最大输出电流，而且要考虑散热，就算电流小于最大输出电流，然而散热不能保证，导致器件温度超过其极限温度时，LDO一样会损坏的。最小压差(Dropout Voltage)本文前面一节分析过这一问题，最小压差与输出电流有关，除此之外，最小压差还可能会与输入电压有关，如：需要指出的是，当器件工作于最小压差的临界状态时，数据手册中的很多指标都无法保证，比如PSRR会下降等。线性调整率(Line Regulation)其定义为，在某个固定负载电流条件下，当输入电压变化时，对应输出电压的变化量，即：$$Line\ Regulation=\frac{\Delta V_{out}}{\Delta V_{in}}$$最小输入电压是指满足最小压差情况下的最小输入电压。线性调整率是一个DC直流参数，反映了直流情况下输入电压对输出电压的影响，其值越小越好。负载调整率(Load Regulation)与线性调整率类似，其定义为，在某个固定输入电压条件下，当输出电流变化时，对应输出电压的变化量，即：$$Load\ Regulation=\frac{\Delta V_{out}}{\Delta I_{out}}$$这也是一个DC直流参数，反映了直流情况下输出电流对输入电压的影响，其值也是越小越好。电源抑制比(Power Supply Rejection Ratio, PSRR)表征LDO性能好坏的核心参数，其定义也是输入电压对输出电压的影响，与线性调整率类似，一般用分贝表示：$$PSRR=20\log(\frac{ v_{in} } { v_{out} } )$$与线性调整率不同的是，PSRR是一个频域交流参数，其表征的是，LDO对于输入电压不同频率噪声（纹波）的动态抑制能力。TPS737xx的PSRR和频率的关系：其值越大代表对输入纹波的抑制效果越好，故PSRR又称Ripple Rejection Ratio。LDO在10k~1M这个范围内的PSRR尤为重要，这是因为LDO一般是接在开关电源后的，而开关电源的开关频率一般是上述范围，这也导致开关电源的输出纹波频率集中在上述范围内。PSRR与频率的大致关系如下：图中区域1的PSRR主要与带隙基准滤波器有关，不深入分析；区域2的PSRR主要取决于误差放大器的闭环增益特性，这个区域曲线的形状与运放的频率响应特性基本相同，极小值点就是放大器增益降低为单位增益时的频率；达到区域3后，误差放大器对于抑制PSRR帮助已经不大了，此时的PSRR主要取决于输出滤波电容，也就是说高频部分（100k以上）的电源纹波抑制只有靠电容来完成了，LDO的响应速度是没有这么快的，这与电源完整性中的结论异曲同工~。除了频率外，LDO的PSRR还与很多因素有关，如输出电流、压差、负载电容等，在此不详细分析了，可以参考文末第二篇参考资料。瞬态响应包括负载电流与输入电压突变时的瞬态响应，一般数据手册中会给出实际实验测试得到的波形图。瞬态响应与PSRR有密切关系，因为通过傅里叶变换，阶跃信号也可以分解成很多正弦信号的叠加。TPS73733瞬态响应：接地电流(Ground Current)即GND脚上流出的电流，如果只给出一个值的话，一般是输出电流为0时的接地电流。接地电流与输出电流关系最大，如：TPS737xx的接地电流与输出电流的关系：噪声LDO的噪声主要来自带隙基准电路及误差放大器，手册中一般会给出其噪声电压频谱密度，如：TPS737xx系列：稳定性LDO内部有误差放大器，自然就存在稳定性问题，其稳定性主要取决于外部负载电容及其ESR，数据手册中一般会对负载电容的容值范围进行说明，也可能会给出确保系统稳定性要求的ESR。对此问题的详细分析可参考以下技术资料：ESR, Stability, and the LDO RegulatorLDO Regulator Stability Using Ceramic Output CapacitorsUnderstanding the stable range of equivalent series resistance of an LDO regulatorStability analysis of low-dropout linear regulators with a PMOS pass element新技术PSRR是LDO的重要参数，为了提高PSRR，研究人员设计出了各种新型电路结构，比如在以下文章中，作者将输入端电压也加入控制回路中，这相当于引入了前馈，作者将其称为“Feed‐Forward Ripple Cancellation Technique”：Low Drop-Out (LDO) Linear Regulators: Design Considerations and Trends for High Power Supply Rejection (PSR)参考资料：Understanding Low Drop Out (LDO) RegulatorsUnderstand Low-Dropout Regulator (LDO) Concepts to Achieve Optimal DesignsUnderstanding Linear Regulators and Their Key Performance ParametersUnderstanding power supply ripple rejection in linear regulators]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HW Component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TL431自激振荡消除方法</title>
      <link href="/2017/06/09/TL431_Self_OScillation/"/>
      <url>/2017/06/09/TL431_Self_OScillation/</url>
      
        <content type="html"><![CDATA[项目中使用TL431作为电流采样放大电路的基准源，然而之后调试过程中发现，采样电流有很大噪声，会影响控制效果。进一步分析表明，这是因为TL431输出的基准电压不稳造成的，输出纹波有几百毫伏，初步猜测是发生了自激振荡。下面对此问题进行下总结。TL431部分电路原理图如下：TL431作为基准源使用，输出2.5V基准电压，RL为后级等效负载，CL则是一个负载电容，设计电路时增加此电容是为了起到滤波作用，期望使得基准电压更平稳。系统供电是反激开关电源产生的+5V，实际使用示波器测试过，+5V的纹波和毛刺都很小，50mV不到，所以可以排除是电源导致的输出振荡。再来看一下TL431的内部原理框图：TL431内部有一个误差比较器，用于比较REF管脚的电压与内部2.5VVref间的差异，进而控制后级晶体管的基极电流，这个三极管应该是工作在放大区的，通过调整其基极电流，可以控制ICE，对于后级负载来说，这就相当于一个分流器，进而实现了对Cathode阴极输出电压的控制。这只是对其基本工作原理的一个定性理解，若对其内部电路实现有兴趣，可以进一步参考此分析文章：TL431内部结构TL431应用电路极为广泛，不同的外电路接法可以实现不同的功能，就像数据手册中说的这样：This standard device has proven ubiquity and versatility across a wide range of applications, ranging from power to signal path. This is due to it’s key components containing an accurate voltage reference &amp;amp; opamp, which are very fundamental analog building blocks. TL43xx is used in conjunction with it’s key components to behave as a single voltage reference, error amplifier, voltage clamp or comparator with integrated reference.当用作电压基准源时，从上面的工作原理分析中很容易想到，此时该引入负反馈闭环使得阴极输出电压稳定，这就是最经典的所谓的“Shunt Regulator”电路：输出电压可以由电阻分压很简单的求出来，在我们的应用电路中，省去了反馈的两个分压电阻，直接将阴极输出与反馈端连接了起来，这样输出电压期望就是2.5V。RSup电阻用于提供直流偏置，保证整个系统在开环时就工作于合适的线性放大区，这个偏置电流在数据手册中用IKA表示，其范围很宽，1mA~100mA均可保证TL431正常工作，典型值是10mA。不过较大的驱动电流可以获得更好的响应特性及稳定性，所以在我们的电路中，IKA设置为了100mA。分析了电路的内部原理就会发现，这其实就是一个运放负反馈电路，自然就存在系统稳定性问题，关于这个问题，TL431的数据手册中是这样说的：Unlike many linear regulators, TL43xx is internally compensated to be stable without an output capacitor between the cathode and anode. However, if it is desired to use an output capacitor Figure 24 can be used as a guide to assist in choosing the correct capacitor to maintain stability.Figure 24是TL431内部晶体管的详细原理图，我的水平并不能从中分析出稳定区域来……不过仔细阅读数据手册后发现，其中给了这么一张稳定性区域图：仔细看这张图，当IKA为100mA时，A曲线的不稳定区域对应的负载电容在0.3uF~4uF之间，而我们选择的2.2uF正好在这个区域中，所以此时整个闭环系统是处于不稳定区域的，发生自激振荡也就很正常了。这张图是通过实际实验测试得到的，考虑到元器件参数的离散性，特别是电容公差较大，我们选择的2.2uF离临界值相差不远，所以其实可以理解成，这个设计其实是处于临界稳定状态的。这也就进一步解释了，实际调试时，为何大部分板子都会振荡，但是也有几块板子不振荡。TI文档SLVA482A对此问题做了进一步的分析：Understanding stability boundary conditions charts in TL431, TL432 Data sheet其中指出，负载电容的加入相当于为系统引入了一个极点，当此极点位于S平面右半边时，系统即会发生振荡。数据手册中给出的稳定性区域图是临界条件，也就是相位裕度为0的情况，实际设计时还要预留30度以上的相位裕度，以保证系统的可靠性。粗略来看，可以使用左右两侧临界区域1/10或10倍的值作为设计参考。文档中还给出了一张30度相位裕度参考图：至此问题已经明确了，将板子上的2.2uF的电容改为1nF的，自激振荡即消失，电机控制效果好了很多。最后还要补充一点，除了调整负载电容容量外，TI文档中还给出了另一种解决方法，在电容上人为串联一个电阻，相当于增加电容的ESR。此方法的原理是为系统增加一个零点，用这个零点来抵消相位延迟：The output capacitor pole greatly limits the capacitors that can be used. However, any capacitor could be used if a series resistor was added that created an output zero at a low enough frequency. The zero can cancel most of phase lag of the output pole at the unity gain bandwidth frequency of the loop.不过我没有能很好的理解此方法的内在原理，最后列在这里，之后可以再思考一下。参考资料：TL431 Datasheet]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> HW Component </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数独求解程序</title>
      <link href="/2017/06/07/Sudoku/"/>
      <url>/2017/06/07/Sudoku/</url>
      
        <content type="html"><![CDATA[今晚上帮同学写了个求解数独的小程序，发出来记录下。标准数独是9*9的，规则是行、列、每个小九宫都填入不重复的19，我们可以把这个经典游戏扩展到N阶，行和列的规则不变，可以加入对角线限制，即对角线也需要唯一的填入1N。对于N为完全平方的情况，可以加入分块，即类似经典数独那样，每一个小块也要唯一的填入1~N。程序逻辑很简单，就是基本的回溯算法，和N皇后问题基本完全一样，下面给出求解程序的核心框架：CheckValid()是与规则有关的判断填入数字合法性的函数，FindNextBlank()和FindPreviousBlank()两个函数用于寻找下一个及上一个空位置，参数使用引用的方式传递，返回结果直接修改了传入值。程序中先从第一个空位置开始，依次尝试所有取值，找到一个合法值后，开始填下一个空位置；若达到最后一个空位置，则说明找到了一个解，输出后继续循环；若当前位置尝试完所有取值后，依然没有合法值，说明之前填的有误，需要回溯，清除当前位置的值后会退到上一个空位置继续循环即可。完整的程序代码见GitHub。参考资料：SudokuPuzzle总共有多少个数独？]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV与GTK+结合使用</title>
      <link href="/2017/06/01/OpenCV_and_GTK/"/>
      <url>/2017/06/01/OpenCV_and_GTK/</url>
      
        <content type="html"><![CDATA[之前研究过OpenCV与Qt结合使用，毕设要用的Intel Joule开发板上安装Qt较为困难，不过它自带了GTK+3.0 GUI框架，于是研究了下是否可以在GTK+中显示OpenCV的图片，折腾了一下发现是可行的，记录一下方法。OpenCV默认的imshow似乎使用的就是GTK+框架，在GTK中显示图片的方法参考以下这篇教程：GTK常用控件之图片控件(GtkImage)可以看到，GTK中的图片是使用GdkPixbuf结构体来保存的，而OpenCV 3.x中使用Mat类来保存图片，所以只要实现Mat到GdkPixbuf的转换即可在GTK中显示图片了，实现代码如下：关于gdk_pixbuf_new_from_data()及GdkPixbuf的详细说明参见：Gdk-pixbuf参考资料：How can I display an OpenCV IplImage in Gtk+/Gtkmm?Converting cv::Mat to IplImage*]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cadence Allegro 调整界面字体字号</title>
      <link href="/2017/05/14/Allegro_Font/"/>
      <url>/2017/05/14/Allegro_Font/</url>
      
        <content type="html"><![CDATA[在使用高分屏时，会发现系统设置的dpi缩放对Allegro无效，这就导致对话框中的文本会显得很小，极不方便使用。不过研究发现，Allegro中是有设置可以调整字体和字号的。打开Setup-&amp;gt;User Preference...，在左侧Categories中展开Ui-&amp;gt;Fonts。右侧的设置中，fontsize代表字号，这是个负数，值越小字号越大，默认值是-12；fontface是字体；fontweight是用来控制加粗的，500代表粗体，300是不加粗字体，默认的400介于二者之间。确定保存后重启程序即可生效。最后附上官方帮助文档中的说明以供参考：Changing FontsThe layout editor lets you customize the look of the graphical user interface by changing the size and type of the fonts in the console, status, and Options windows, and in the Find window pane. This can be convenient if you find it difficult to read information presented in the default size and type.To change fonts in the user interface:Exit the layout editor, if you have it running.Set the font variables in your environment file.These variables can also be set in the System dialog box in the Control Panel.fontSize = -12where -12 represents the default font size. A larger negative number (for example -20) makes the font larger. Do not use positive numbers in this value.fontFace = helveticawhere helvetica represents the default font type. Fonts available to you depend on your platform and any user-installed fonts. The value is always a font name.fontWeight = 500where 500 represents bolded type. Change the value to 300 to produce unbolded type.Restart the tool.Resize the window, if necessary, to display all information in the larger font size.You can also change font variables in the User Preferences Editor dialog box by running the enved command. Note that you must restart the tool to see the change.]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带软启动的分立负载开关电路</title>
      <link href="/2017/05/05/Discrete_Load_Switch/"/>
      <url>/2017/05/05/Discrete_Load_Switch/</url>
      
        <content type="html"><![CDATA[负载开关用于控制后级电路的供电，可以采用分立元件，也可用专用的芯片，此处总结一下最常用的分立元件方案。电路原理图：图中C1及R5代表后级负载电路。U5断开时，Q1截止，进而U4也为截止状态；U5导通时，Q1也导通，此时V1、C2、R2、Q1构成RC充电回路，U4 Vgs逐渐上升，当Vgs上升超过其阈值后，U4导通，不过刚开始导通时其导通电阻较大，故尽管负载电容很大，此时的电流并不会很大，这也就是所谓的软启动功能。随着Vgs进一步上升，U4导通电阻降低，系统正常为后级负载供电。PSpice仿真结果如下：若去掉C2，此时就没有软启动了，PSpice仿真结果为：可以看到，在导通的瞬间有一个很大的脉冲浪涌电流，这很有可能导致MOS管的损坏。不过也要看到，软启动功能也带来了一些弊端，比如电路延时变长。更为可靠的方法是使用集成式负载开关，可参考之前写的这篇文章：集成式负载开关]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PSpice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PSpice教程及帮助文档</title>
      <link href="/2017/05/05/PSpice_Tutorial_Help/"/>
      <url>/2017/05/05/PSpice_Tutorial_Help/</url>
      
        <content type="html"><![CDATA[PSpice的教程在网上随便一搜就有一大堆，不过其实还是Cadence自带的帮助文档最好，这里就来总结下有哪些比较有用的PSpice帮助文档。基础教程打开OrCAD Capture CIS，选择Help-&amp;gt;Learning PSpice即可打开一个交互式的Tutorial，这个比各种教程好多了，从最简单的元器件基础内容到各种高级分析方法都介绍到了：Cadence OrCAD Solution’s “Learning PSpice” is made available to all, for learning various concepts related to Electrical and Electronics engineering. This complete material covers several diverse topics, ranging from basic theorems to very advanced topics in the field of Electrical &amp;amp; Electronics Engineering and electronic design automation etc. 帮助文档打开Cadence帮助（按F1），在左侧导航栏中可以找到PSpice文件夹，这些就是PSpice相关帮助文档，可以在当前帮助浏览器中直接查看，也可通过菜单栏上的pdf按钮打开对应的pdf文件查看：下面列举几份比较有用的文档。SPICE帮助PSpice A/D Reference Guide在导航菜单中的名字叫做PSpice Reference Guide，这份文档其实是对SPICE本身的介绍，包括各种基本元件、分析方法、基本函数、SPICE语法等。实际上使用SPICE分析模拟电路的情况更多一些，故在需要时可以通过其中Analog devices部分查阅各种基础元件的模型：Detailed descriptions of the simulation controls and analysis specifications, start-up option definitions, and a list of device types in the analog and digital model libraries. User interface commands are provided to instruct you on each of the screen commands.PSpice基础文档PSpice User GuidePSpice HelpPSpice软件相关的文档，Guide相当于一份十分详尽的软件教程，而Help则是用于查阅的帮助文档。在PSpice Help中有一部分叫做Index of PSpice symbol and part properties，其中包含了所有仿真模型和仿真参数的说明，可以在这里查到每个参数的意思，还有这个元件是包含在那个库文件中的。PSpice高级文档PSpice Advanced Analysis User GuidePSpice Advanced Analysis Help与上面的PSpice基础文档类似，只是介绍的是PSpice中的各种高级功能，比如蒙特卡洛分析、灵敏度分析、优化器等等。]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PSpice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PSpice中的延时开关</title>
      <link href="/2017/05/05/PSpice_Swt/"/>
      <url>/2017/05/05/PSpice_Swt/</url>
      
        <content type="html"><![CDATA[延时开关用于仿真某一时刻闭合或断开的元件特性，这不是SPICE的基本元件，PSpice中使用了两个子电路模块来实现这一功能：初始时刻闭合，某一时刻断开的Sw_tOpen；初始时刻断开，某一时刻闭合的Sw_tClose。这两个元件原理图符号位于eval.olb库中，SPICE实现位于anl_misc.lib库中，下面对其参数及实现做一总结。Sw_tOpenSPICE实现：可以看到，Sw_tOpen是由一个压控开关和一个脉冲电压源组成的，tOpen前电阻为Rclosed，之后ttran时间内电阻以指数形式变化至Ropen，并保持10k秒。参数含义默认值TOPEN断开切换时间0TTRAN过渡时间1uRCLOSED导通电阻0.01ROPEN开路电阻1MegSw_tCloseSPICE实现：与Sw_tOpen基本完全相同，只是开始时是断开的，tClose后导通。参数含义默认值TCLOSE导通切换时间0TTRAN过渡时间1uRCLOSED导通电阻0.01ROPEN开路电阻1Meg需要注意的是，默认的RCLOSED和ROPEN的值不一定合适，需要根据实际电路进行修改，而且根据注释说明，这两个值之间的差距还不能太大，也就是说其实这两个元件是无法很好的模拟仿真理想开关的性质的。]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PSpice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux软路由——基础配置</title>
      <link href="/2017/04/25/Linux_SoftRouter_Basic/"/>
      <url>/2017/04/25/Linux_SoftRouter_Basic/</url>
      
        <content type="html"><![CDATA[之前买了台二手服务器，总觉得应该让它发挥点什么作用，正好针对学校蛋疼的网络，先试试能不能把它当做一台超级智能路由器吧~:)系统：Ubuntu Server 14.04 64bit设置无线AP使用的设备是TP-Link TL-WDN4800，配合hostapd实现软AP功能，实现方法参考以下几篇文章：linux软AP－－hostapd+dhcpdMy Wi-Fi access point revisitedSetting up a Wireless Access Point with Ubuntu Raring Ringtail我使用的hostapd的配置文件如下：完整的hostapd配置文件说明可以参考：hostapd configuration file配置好后使用service hostapd restart启动服务即可。不过以上配置应该并不是最优配置，TL-WDN4800最高传输速率450Mbps，然而之后实际测试得到的速率只有30Mbps左右。配置DHCP服务器为无线AP添加DHCP服务。安装DHCP服务配置DHCP网卡修改/etc/default/isc-dhcp-server文件，根据注释说明添加对应网卡即可，可以添加不止一个，此处以wlan0为例：修改DHCP配置文件修改/etc/dhcp/dhcpd.conf文件，根据注释修改即可：以上是最基本的配置方法，各种高级配置可参考注释说明。配置本机IPDHCP服务器本身显然是不能再配置为动态获取IP的，需要配置为静态IP的形式。修改/etc/network/interfaces文件，如：重启DHCP服务此时客户端配置为自动获取IP即可。通过VPN拨号连接校园网根据学校网络中心的说明文件配置即可。配置静态IP修改/etc/network/interfaces文件：安装xl2tpd修改配置文件配置/etc/xl2tpd/xl2tpd.conf文件，在最后加入以下代码：创建/etc/ppp/options.xl2tpd.zju文件：保存用户名与密码，修改/etc/ppp/chap-secrets文件，在最后添加：其中00000000替换为真实的密码。启动服务与停止服务连接：连接成功后，使用ifconfig命令可以看到ppp0接口：其中的inet addr就是虚拟局域网IP地址。断开连接：修改路由表添加两条记录即可，首先将发往VPN服务器的流量通过本地网关发送：默认流量都通过ppp0发送：此处的网关就是之前看到的ppp0的IP地址。需要将矛盾的路由记录删除掉，比如只要保留一条默认记录就可以了。使用手机USB共享提供4G网络连接本来想买个4G USB网卡的，然而价格都太贵……之前一直用一个闲置的Nexus手机做无线AP的，其实可以使用USB网络共享（USB Tethering）功能，把手机当成一个4G网卡用的。将手机与电脑连起来，在手机上开启USB网络共享功能，使用lsusb命令可以查看手机是否正常连接上了，若成功连接的话，会有显示：显示tether的话就说明共享成功了，使用ifconfig -a命令可以看到一个名为usb0的网络设备：不过可以看到，此时还没有正确分配IP地址，使用dhcpcd usb0命令从手机DHCP服务器上获取一下IP地址即可，再使用ifconfig命令即可看到usb0已经获得正确的IP地址了。使用route -n命令可以看到此时也自动添加了路由表。添加路由转发路由器最重要的功能就是路由转发啦，Linux内核本身就支持这一功能，这在之前写的Ubuntu虚拟机中设置NAT使树莓派开发板可以联网一文中介绍了实现方法，大概就是在/etc/sysctl.conf文件中开启IP转发功能，之后在iptables中添加一条MASQUERADE规则即可，文末参考资料中鸟哥的文章里对此有详细介绍。如果要使用有线网上网：如果要使用4G网络上网：自动连接脚本以上操作可以写成一个脚本文件，方便在校园网和4G网络间切换。连接至校园网连接至4G网络使用以上方法配置好后，笔记本通过无线连接，电脑即可正常上网了，此时服务器就相当于一台路由器，只是目前4G和校园网还是独立的，要更改连接需要自己手动输入命令，之后进一步研究下如何实现更高级的策略路由。参考资料：Ubuntu下DHCP服务器的配置Linux 的封包过滤软件： iptables第八章、路由观念与路由器设定linux 添加静态路由在多种系统下通过USB连接android手机上网USB Tethering on Linuxlinux 路由表设置 之 route 指令详解]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> TCP/IP </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>松弛振荡器原理</title>
      <link href="/2017/04/04/Relaxation_Oscillator/"/>
      <url>/2017/04/04/Relaxation_Oscillator/</url>
      
        <content type="html"><![CDATA[松弛振荡器 (Relaxation Oscillator, RO)是一种无稳态多谐振荡器，一般使用比较器或者施密特触发器构成，在电容检测中，很多情况下就是使用此电路检测电容大小。松弛振荡器的基本电路如下：当然，这是针对比较器是使用双电源供电的情况下才能使用的，输出波形及电容电压如下：若运放使用单电源供电，是不能使用此电路的。单电源供电时，简单分析即可知道，此电路有一个稳态，即所有点电压均为0的状态，故此系统无法稳定的振荡起来。单电源情况下，要引入一个直流偏置：简单的计算即可知道，此时 $V_{+}$ 的两个阈值为$\frac{2}{3}V_{cc}$及$\frac{1}{3}V_{cc}$，电容就在这两个阈值之间来回充放电，进而产生振荡。粗略的仿真波形如下：图中红线为$V_{out}$，绿线为$V_{+}$，蓝线为$V_{-}$。上图这种松弛振荡器输出波形占空比基本是50%，震荡周期为$2\ln2 R_{c}C$，这就是一个简单的电容充放电过程，根据“对电容充放电过程的理解”一文中的方法可以很快计算出振荡周期来。其实，上面那个电路就是一个反相施密特触发器加上一个电容和电阻，故也可以直接使用施密特触发器来构造松弛振荡器：这两个电路原理基本完全一样，其实所有的多谐振荡器原理都差不多，比如经典的555振荡电路，都是利用比较器的滞回特性，配合电容的周期性充放电实现振荡的。参考资料：Relaxation oscillatorThe Relaxation Oscillator]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对电容充放电过程的理解</title>
      <link href="/2017/04/04/Capacity_Charge/"/>
      <url>/2017/04/04/Capacity_Charge/</url>
      
        <content type="html"><![CDATA[很多年前就学过电容的性质了，之后也知道了如何快速写出时域上电容充放电过程的表达式，不过好长时间不用又忘了……今天又捡起来回忆了一下，在此总结记录一下。理想电容的基本性质很简单：$$i=C\frac{\mathrm{d} u}{\mathrm{dt}}$$从线性系统的角度来看，这就是一个一阶微分系统，所以对电容的分析其实可以直接用于其他类似系统的，比如电感等。一个基本的RC电路，如果在时域列微分方程，大概是这样的：$$C\frac{\mathrm{d} u}{\mathrm{dt}}+\frac{u}{R}=0$$最早学电路的时候，都是叫我们直接求解这个微分方程的，然后就结束了，这其实并没有理解到问题的实质，我们不可能也不需要在分析每个电路的时候都去解微分方程的。之后学到了信号与系统，还有线性系统理论，从s域的角度对此问题有了更好的理解，其实在s域中，可以把电容电感当成和电阻一样的东西进行分析的，串联并联都很简单，就比如RC电路的传递函数是这样的：$$\frac{1}{RCs+1}$$不过这依然不能直接得出时域性质，求解反拉普拉斯变换也很麻烦的，而且复杂点的还不一定求得出来……MIT的电路与电子学真的堪称基本电路课程中最好的，虽然从所谓的“深度”上看，远远不如国内的很多教材和课程，不过其中蕴含的思想极为深刻而实用，多少年前看完至今仍然受益匪浅啊……回到RC电路上来，在MIT的公开课中，Agarwal教授给出了一种很快捷的方法可以直接写出各种一阶系统的时域响应。我们知道，无论是通过求解微分方程还是进行反拉普拉斯变换，任何一阶系统在时域的表达式都是exp()形式的，即都有这么一项：$$\mathrm{e}^{-\frac{t}{\tau}}$$上式必然是负指数形式的，否则系统不收敛。$\tau$就是所谓的时间常数，从拉氏变换中可以很容易的找出这一项来。现在有意思的地方来了，任意一阶系统的时域响应其实都可以写成以下形式的：$$u(t)=A+B\mathrm{e}^{-\frac{t}{\tau}}$$其中$A$、$B$是两个待定系数，根据直觉，我们可以很容易的确定这两个系数，当$t\rightarrow+\infty$时，后一项趋于0，故$A$就是系统的稳态解，而当$t=0$时，指数项等于1，故$A+B$就是系统的初始状态。根据这两个状态就可以写出完整的表达式了这对于电容有初始电压时进行充电的过程尤为方便上面的做法也许不那么严谨，不过的确是行之有效的。我们也可以从另一个角度来严谨的看这一问题，在线性系统理论中我们知道，LTI系统的响应可以分解为两部分，零输入响应和零状态响应，系统的完整响应就是二者的叠加。对于一阶系统来说，零输入响应就类似电容的放电过程：$$u(t)=V\mathrm{e}^{-\frac{t}{\tau}}$$而零状态响应就对应电容的充电过程：$$u(t)=V(1-\mathrm{e}^{-\frac{t}{\tau}})$$二者的叠加，化简一下不就成上面那个简单的式子了么~上面是以电容充放电为例分析了以下，然而这显然不局限于电容的充放电，所有的一阶LTI系统都可以用这种方法快速确定其时域响应这就是Agarwal教授所谓的工程师的直觉]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>纽扣电池型号总结</title>
      <link href="/2017/04/03/Button_Cell/"/>
      <url>/2017/04/03/Button_Cell/</url>
      
        <content type="html"><![CDATA[纽扣电池型号很多，而且命名也不是特别规范，这里选择其中相对较有规律的一些总结一下。纽扣电池的型号可以分解成几个部分，逐部分介绍一下。串联节数如果第一位是数字，代表若干节电池串联，如4LR44表示内部是4节LR44串联。电池类型第一位字母代表电池的化学组成，这是型号中最统一的部分，也经常是最有价值的部分。代号通用名负极电解液正极标称电压截止电压C锂锰电池锂非水系有机电解液二氧化锰3.0V2.0VB锂氟化碳电池锂非水系有机电解液氟化碳3.0V2.0VG锂氧化铜电池锂非水系有机电解液氧化铜1.5V1.2VL碱性电池锌碱金属碳酸盐电解液二氧化锰1.5V1.0VS氧化银电池锌碱金属碳酸盐电解液氧化银1.55V1.2VP锌空气电池锌碱金属碳酸盐电解液氧气1.4V1.2V以上是一些最常用的电池，当然也还有其他的电池，可查阅文末参考资料。锂锰电池与锂氟化碳电池相比，锂锰电池的耐温性比较差，工作温度大概在-20℃70℃，而锂氟化碳电池大概在-30℃80℃，所以有时候又把锂氟化碳电池叫做所谓的高温电池。二者寿命和工作稳定性也不一样，一般认为锂锰电池的寿命和稳定性都要好一些，可以达到10年左右。电池形状第二位字母代表电池形状，一般纽扣电池都是圆的，用R表示。百度百科上也给出了个其他形状的代号，可供参考。电池尺寸最后几位数字表示尺寸，早期使用1~2位的流水号，如LR44，直径11.6mm，厚度5.4mm。新的编码方式是按照尺寸来编码，如CR2032表示直径20mm，厚度3.2mm。不过这只是粗略的大小，精确大小还需查阅具体标准。参考资料：钮扣电池Button cellCR2032]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HW Component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVN常用命令</title>
      <link href="/2017/03/30/SVN/"/>
      <url>/2017/03/30/SVN/</url>
      
        <content type="html"><![CDATA[本文总结一下常用的SVN命令，以便之后查阅。检出其中[URL]是服务器上的路径，如svn://xxxx.com/repo，此命令会把服务器上的内容在当前本地目录中检出，co是checkout的简写。使用--username参数附加用户名，之后会提示输入密码。更新使用远程版本库中的文件更新本地版本库及工作副本，可以使用[PATH]指定更新哪个路径，如不指定的话，递归的更新当前目录及其子目录。会输出更新条目的状态：A : 已将一个文件添加到工作副本中U : 已更新工作副本中的一个文件D : 已从工作副本中删除一个文件R : 已替换工作副本中的一个文件G : 已成功合并了一个文件C : 一个文件已合并了,但必须手动解决冲突上述svn update命令会直接更新当前工作副本，若需要先确定一下哪些文件有更改了，可使用svn list -v命令，会列出远程版本库[PATH]下各文件的版本号，修改人，修改日期等信息，若没有-v参数则只有文件名。查看状态查看工作副本的状态，如省略[PATH]的话，显示当前路径的状态。与版本库中相同则不显示，?代表不在版本库中，D代表删除，M代表有修改，A代表添加，C代表有冲突。如果附加上[-v]参数，会列出所有文件，第一列表示状态，第二列是版本号，第三和第四列是此文件最后一次修改的版本号及修改人。查看SVN仓库的相关信息，如URL、上次修改时间等。添加、删除及提交第一次在工作目录中创建并编辑新文件后，需要使用此命令将此文件添加到版本库中，[PATH]可以是一个文件也可以是一个目录，可配合*通配符使用。如果需要将版本库中的某个文件或目录删除，使用此命令，直接用rm删除那个文件是无效的，下次update的时候又会回来的。修改、添加、删除文件后，仅仅是影响了本地副本，还没有将其提交到版本库中，使用此命令提交更改。注意，附加参数-m是这次提交的说明，这是必须的，可以为空&amp;quot;&amp;quot;，但不能没有。另外，SVN与Git不同，不能只更新本地版本库而不将其上传到远程版本库上。撤销更改对本地副本进行了某些修改，但还没有使用svn ci提交之前，若想丢弃这些更改，可以使用此命令。filename可以是一个目录，此时需加上-R参数递归的进行处理。查看日志列出提交日志，使用-l [N]参数指定只列出最近N次的提交记录，否则列出全部记录；-v参数会列出每次提交的具体条目细节。比较差异比较两个版本间的差异，使用-r m:n参数比较版本m和版本n之间的差异，使用-r m参数比较当前工作副本的文件和版本m之间的差异，不附加此参数比较当前工作副本文件和版本库中最新版本间的差异。SVN默认的diff是没有颜色的，看起来很不方便，可以通过安装colordiff来解决这一问题：在ubuntu下，给 svn diff 一点颜色回滚实际使用时，先用svn log命令找出需要回滚到的版本，必要时使用svn diff进行比较确认；之后使用svn merge -r n命令将版本n合并到当前副本，此处的[PATH]可以是文件也可以是目录，若省略依然代表当前目录；最后，如果要确认这次回滚，还要使用svn commit将其重新提交到版本库中。加锁、解锁参考资料：使用命令行 Subversion 访问项目源文件SVN常用命令SVN：取消对代码的修改]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SVN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++生成随机数</title>
      <link href="/2017/03/22/C++_Random/"/>
      <url>/2017/03/22/C++_Random/</url>
      
        <content type="html"><![CDATA[之前写过一篇C语言生成随机数，其中生成随机数的方法自然也可用于C++中，不过C++ 11扩展了生成随机数的方法，我们可以有更多更好的选择了。随机数的相关类声明都位于&amp;lt;random&amp;gt;头文件中，完整说明可参考：random，此处选择一些常用的总结一下。文末参考文献中那两篇知乎讨论很有趣，介绍了各种关于随机数的知识，很值得一读。随机数生成器一共提供了3种算法的生成器：线性同余法（LCG）、梅森旋转法、Lagged Fibonacci generator（LFG），其中梅森旋转法据说是最好的伪随机数生成算法，在C++中的具体实现类为std::mt19937和std::mt19937_64，前者是32位的，后者是64位的。非确定性随机数生成设备上面几个随机数生成器的本质都是从一个种子开始，使用某个递推方法生成伪随机数序列，其实还有种随机数生成策略就是利用物理世界中的各种噪声，以此产生所谓的真随机数。std::random_device就是这样一种机制，具体实现方法Linux和Windows不相同，以Linux为例就是读取/dev/urandom设备的输出得到的。这个设备中有一个容纳来自各种设备驱动噪声数据的熵池，具体可参考：/dev/random/dev/urandom是/dev/random的非阻塞版本，会重复利用熵池，保证在熵池为空的时候也会有输出，这以降低随机数可靠性为代价提高了其生成速度。生成特定分布的随机数在C语言中，要生成特定分布的随机数并不容易，不过在C++中这就很简单了，C++中提供了各种常用分布的实现，直接调用就可以了。比如最常用的均匀分布的整数：std::uniform_int_distribution；均匀分布的小数：std::uniform_real_distribution；正态分布：std::normal_distribution等。使用示例最后举几个实际的例子来说明具体用法。直接使用random_device的输出作为随机数：此方法速度较慢，所以一般并不直接使用。以random_device的输出为初始种子，使用梅森旋转法生成[0,99]范围内的整数：使用std::bind()是为了让之后调用起来更方便些。此方法就是生成某个区间内均匀分布的整数随机数最常用的方法了，注意区间两端都是闭区间。以random_device的输出为初始种子，使用梅森旋转法生成[0.0, 1.0)范围内的小数：生成[0, 1)区间内任意小数最常用的方法，注意这里是左闭右开区间，不包含1.0的。参考资料：C++11带来的随机数生成器C++ 如何生成大随机数？电脑取随机数是什么原理，是真正的随机数吗？]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Number Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH证书登录总结</title>
      <link href="/2017/03/01/SSH_Authentication/"/>
      <url>/2017/03/01/SSH_Authentication/</url>
      
        <content type="html"><![CDATA[远程登录Linux服务器一般都是通过SSH方式，除此之外，像Git同步等其他一些操作也可通过SSH进行，默认情况下SSH是通过用户名和密码来进行用户身份验证的，这样密码太复杂自己输入不方便，太短了不安全，故更好的方式是通过证书进行身份验证和登录。证书生成使用ssh-keygen工具：直接使用ssh-keygen而不附加任何参数相当于ssh-keygen -t rsa -b 2048，即RSA类型2048字节的公钥/私钥对。ssh-keygen还可以附加很多参数，可以参考文末参考资料。Enter passphrase处可以输入一个秘钥文件的密码，如果设置了密码的话之后每次访问都要输入密码。服务器配置修改配置文件一般是/etc/ssh/sshd_config文件，只需要设置以下几项启用秘钥登录就可以了：Update 2019-07-13:在CentOS 7.4及以上版本中，没有RSAAuthentication这一项配置了，也不需要去配置这个，可参考：CentOS7.4配置SSH登录密码与密钥身份验证踩坑在保证可以用证书正常登录后，可以禁用密码登录以提高安全性：以上几项设置默认情况下都是注释，把开头的注释符号去掉即可。其余还有一些和安全性有关的设置，此处就省略了，可以根据文件中的注释说明进行修改，也可参考文末资料。添加用户公钥受信任的用户公钥记录在~/.ssh/authorized_keys文件中，服务器上每一个用户都有自己的authorized_keys文件，在使用SSH登录时，登录用户是哪一个就会去这个用户的用户目录中查找~/.ssh/authorized_keys文件，比如使用ssh root@192.168.1.1登录时，SSH服务器端就会使用/root/.ssh/authorized_keys文件中的公钥。所以我们要将之前生成的公钥添加到需要登录的用户目录下，如允许使用多个用户身份登录，需要分别添加公钥。添加方法有好几种，可以手动用vim打开此文件添加（如果不存在新建一个即可），也可先把之前生成的id_rsa.pub文件传到服务器上，使用以下命令添加：此外，似乎还可以直接使用ssh-copy-id工具上传：需要注意的是，~/.ssh目录及~/.ssh/authorized_keys文件必须是700及600权限的，如果不是的话要先修改一下，否则之后ssh客户端会出于安全因素拒绝使用此证书文件。重启sshd服务这时就可以在客户机上使用ssh user@host的方式登录了，默认会使用位于当前用户目录下的~/.ssh/id_rsa文件作为私钥。不过还可以在客户端上进行下配置简化这一命令。客户端配置修改~/.ssh/config文件（若不存在则新建），按以下格式添加Host配置：Port可以省略，此时使用默认的22端口。配置好后输入ssh myserver即等价于ssh -i &amp;lt;private_key_path&amp;gt; &amp;lt;user_name&amp;gt;@&amp;lt;server_name&amp;gt; -p &amp;lt;port&amp;gt;。这样用一条简单的命令就可以实现自动调用指定的私钥文件以特定的用户名和端口登录远程服务器的目的了，不同的服务器可以使用不同配置，十分方便灵活。参考资料：SSH 原理和基本使用：ssh 安全配置 以及ssh key 认证登录配置 SSH 服务以使用证书登录 Linux 服务器]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu减小swap分区大小的方法</title>
      <link href="/2017/02/28/Ubuntu_Reduce_Swap/"/>
      <url>/2017/02/28/Ubuntu_Reduce_Swap/</url>
      
        <content type="html"><![CDATA[这几天在新买的服务器上装上了Ubuntu Server 14.04，然而安装系统时没注意swap分区大小设置，导致swap分区占用了很大的磁盘空间，因为服务器本身的内存就很大，所以显然不需要分配这么多swap空间，在网上搜索一番找到了减小swap空间的方法，记录于此。定位swap分区首先要确定swap分区的位置才能进行之后的调整操作，可以简单的使用free -h命令查看当前内存及swap空间的使用情况：可以看到swap空间有1G，不过这是收缩了一次后的结果，最初的swap空间是16G……free命令只显示了swap分区的大小，为了找到swap分区所在位置，需要具体查看一下分区情况。因为Ubuntu Server 14.04安装时默认使用了GPT分区形式，所以应该使用parted -l而不是fdisk -l来查看分区情况：从上面的输出结果中可以看到，硬盘上只有3个物理分区，前两个是系统启动引导时用的，可以忽略，主分区就只有一个，并没有单独为swap创建一个分区。Ubuntu系统在这里采用了LVM逻辑卷管理机制（Logical Volume Manager）进行磁盘空间管理，关于LVM可进一步阅读以下文章：学习 Linux，101: 硬盘布局逻辑卷管理LVM Logical Volume使用pvdisplay命令列出所有物理卷（PVs）属性：可以看到，只有一个物理卷/dev/sda3，再使用vgdisplay命令列出卷组（VGs）属性：唯一一个卷组的名称叫做Xeon-vg（Xeon是主机名），最后用lvdisplay命令列出所有逻辑卷（LVs）属性：此处划分了两个逻辑卷，分别是/dev/Xeon-vg/root和/dev/Xeon-vg/swap_1，然而与parted -l的输出结果进行对比，会发现逻辑卷的名字并不相同，在parted -l的输出结果中使用的是/dev/mapper/Xeon--vg-root和/dev/mapper/Xeon--vg-swap_1，查看这几个文件：它们都通过符号链接指向了同一个地方：事实上这里用到的是Linux内核中的Device Mapper机制，设备名称dm就是Device Mapper之意。Device Mapper机制是LVM依赖的基础技术，用于实现物理设备到逻辑设备的映射，详细说明可进一步阅读以下文章：Linux 内核中的 Device Mapper 机制flashcache中应用device mapper机制DOCKER基础技术：DEVICEMAPPER另一个需要注意的问题是，尽管以上几个文件是通过符号链接联系起来的，不过它们并不等价，在使用lvm系列命令操作逻辑卷时，应该使用/dev/&amp;#123;VG&amp;#125;/&amp;#123;LV&amp;#125;这个路径，直接使用/dev/dm-*会出错。通过以上操作，我们已经找到swap文件对应的逻辑卷位置了，下面就来减小其大小。减小Swap分区先用swapoff命令关闭交换分区：检查下是否关闭成功了：可以看到swap分区的容量已经是0了，这时就可以通过lvreduce命令来收缩Swap_1这个逻辑卷的大小：-L 512M代表收缩至512M，更多用法可用man查询。之后要把新的逻辑卷重新设置为swap分区并用swapon命令开启之：最后检查下swap分区是否真的变小了：不过此时回收的空间成为了闲置的自由空间：注意其中的Free PE / Size，可以看到还有504M的未分配闲置空间，下一步就是要把这部分空间扩展到root逻辑卷中。扩展root分区对于Ext4文件系统，内核是支持在线扩容的，直接使用lvextend命令即可：-l +100%FREE表示扩展所有剩余空间，需要注意的是，-l与-L是不同的，-l的单位是所谓的logical extents，也就是上面vgdisplay命令显示出来的PE Size，这就是LVM中容量调整的一个基本单位；而-L的单位是传统的字节，-L选项不能搭配%100之类的形式使用。命令的详细用法还是参考man的说明。逻辑卷的容量和文件系统的容量并没有直接关系，故最后还需要对文件系统进行在线扩容，对于Ext文件系统可使用resize2fs命令：调整Swap分区交换策略Linux系统并不是在内存全部使用完之后再使用swap空间的，内核会自动判断是否该使用swap空间，可以通过很多参数控制这一行为，可参考以下文章：Tuning Virtual Memory其中最重要的一个参数叫做swappiness，取值在0~100之间，表示的是内核使用swap空间的频率策略，值越大内核越倾向于使用交换空间。目前内存很大而swap空间很小，故可以尽量不去使用swap空间。要实现这一目的，将swapiness设置为0即可，这代表内核仅在内存快要用完时使用swap空间，具体解释可参考：Swappiness设置方法也很简单，使用sysctl命令可以临时修改：要永久修改的话，在/etc/sysctl.conf文件中添加vm.swappiness=0即可：除了用sysctl命令外，还可用以下方法查看当前swappiness的值：参考资料：linux基础命令介绍十二：磁盘与文件系统]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Linux </tag>
            
            <tag> File System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于未来的迷茫</title>
      <link href="/2017/02/27/Future_Hesitate/"/>
      <url>/2017/02/27/Future_Hesitate/</url>
      
        <content type="html"><![CDATA[返乡半月有余，闲暇时反思过去一年半的研究生生活，不由感慨时光飞逝，如白驹过隙。昔时子于川上曰，逝者如斯，不舍昼夜，子诚不欺余。再想到半年后就要找工作了，而过去一年多似乎自己的水平并没有太大的提高，未免心中忐忑难安，唯恐所图甚大，所行甚小……古语有云，士为知己者死，这才有两表酬三顾，一对足千秋之美名；才有报君黄金台上意，提携玉龙为君死之意气。然古往今来更多的是怀才不遇，功名难就，冠盖满京华，斯人独憔悴的落寞……呜呼，不知未来在等待我的会是什么呢？月明星稀，乌鹊南飞，绕树三匝，何枝可依？]]></content>
      
      
      <categories>
          
          <category> 人生之思 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树算法</title>
      <link href="/2017/02/22/Minimum_Spanning_Tree/"/>
      <url>/2017/02/22/Minimum_Spanning_Tree/</url>
      
        <content type="html"><![CDATA[最小生成树是指在一个图中，由连接所有顶点的边构成的权值之和最小的树，求最小生成树的算法主要有Prim算法及Kruskal算法，此处介绍Prim算法的基本原理。Prim算法是一种贪心算法，不过可以证明，此算法得到的必定是全局最优解。Prim算法的基本思路如下：将图中的所有顶点分为两个集合，Known及Unknown，初始时任意选择一个顶点放置在Known中，其余顶点位于Unknown中，算法的目标是将Unknown中的所有顶点移至Known中；选择一条边，这条边连接的两个顶点一个位于Known中，另一个位于Unknown中，且这条边的权值是所有满足条件的边中最小的；将这条边添加到最小生成树中，并将其连接的那个位于Unknown集合中的顶点移至Known中；重复以上两步，直至Unknown集合为空；算法图示：Prim算法的过程与Dijkstra算法很相像，故二者的程序结构也很类似。在使用邻接表及二叉堆实现时，Prim算法的时间复杂度是O(|E|log|V|)，需要注意的是，无论对于稀疏图还是稠密图，这都是一个最优的算法复杂度。Kruskal算法的复杂度是O(|E|log|E|)，对于所有连通图来说都有|E|&amp;gt;=|V|-1，所以可以得出结论，Prim算法在时间复杂度上无论是对于稀疏图还是稠密图来说都是最优的，优于Kruskal算法。不过其最大缺点就是在使用二叉堆时空间复杂度会极大，对于超稠密图就很不合适了。具体定量比较可参考：Prim、Kruskal、Prim+Heap算法效率实测算法的实现代码有空再补上吧……参考资料：最小生成树(Minimum Spanning Trees)]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大流算法</title>
      <link href="/2017/02/20/Maximum_Flow_Algorithm/"/>
      <url>/2017/02/20/Maximum_Flow_Algorithm/</url>
      
        <content type="html"><![CDATA[最大流问题是指在一个有向图中，每条边的容量有限，求两点间能通过的最大流量。解决此问题常用Ford–Fulkerson方法，本文对此方法做一总结记录。在最大流问题中，涉及到很多术语，如残留网络、增广路径等，本文不打算使用和介绍这些名词，想深入了解此问题的话可进一步阅读文末的参考资料，这里仅从编程使用的角度介绍算法实现方法。Ford–Fulkerson方法的基本步骤很简单：在当前的图中寻找任意一条从源点到汇点的路径；为这条路径添加一条反向路径；重复以上两步，直至无法找到更多的路径为止。这个算法如此简单，很让人怀疑其正确性，不过，根据最大流与最小割定理，我们可以严格的证明：只要每一条边的容量都是有理数，Ford–Fulkerson方法肯定收敛于图的最大流，然而，若容量是无理数，算法不一定会收敛。证明步骤可以参考第二篇参考资料。算法的执行过程可以参考这个动画演示。此方法之所以称为Ford–Fulkerson方法而不是Ford–Fulkerson算法的原因在于，第一步寻找路径的过程可以使用很多不同的策略，这就可以衍生出各种不同的具体实现算法，其中最常用的一种是使用BFS广度优先搜索策略，这种算法称之为Edmonds-Karp算法。最后一篇参考资料中给出了一个实现代码，此处给出另一种封装更好一些的实现代码，实用邻接表实现。图的相关数据结构定义：FindPath()函数使用BFS搜索src至dst之间的一条路径，并计算此条路径的流量：AddFlow()函数更新流量信息（减去正向流量并添加反向流量），返回值即为当前路径流量：GClear()函数用于清除上一次BFS的中间数据，为下一次循环做好准备：最后是测试用的main()函数：参考资料：算法导论（Introduction to Algorithm）第26章 最大流6.854 高级算法 —— 网络流 最大流最大流（一）]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历算法</title>
      <link href="/2017/02/12/BinaryTree_Traversal/"/>
      <url>/2017/02/12/BinaryTree_Traversal/</url>
      
        <content type="html"><![CDATA[二叉树的遍历有两个基本问题：给定一颗树，输出其特定形式的遍历结果；给定一个或几个遍历，重建这棵树。第一个问题比较简单，而第二个问题则相对较复杂。本文就对这两个问题进行一个总结。二叉树的节点使用以下结构体定义：输出遍历结果前序遍历（Preorder Traversal）中序遍历（Inorder Traversal）后序遍历（Postorder Traversal）层序遍历（Levelorder Traversal）与其它遍历方法不同，层序遍历是一种广度优先搜索（BFS），一般需要使用队列实现，此处使用了STL中的&amp;lt;deque&amp;gt;结构。根据遍历结果重建树一般二叉树对于一般二叉树来说，只给定任何一种遍历都无法唯一的确定树的结构，需要且仅需要给定中序遍历+另一种其他遍历才能唯一的确定树的结构，下面给出树的重建方法。中序 + 前序通过前序遍历可以找出树的根节点，再根据中序遍历确定左右子树元素个数，之后就可以对遍历序列进行划分，迭代处理左右子树了。中序 + 后序与上一种情况算法基本相同，只是前序遍历根节点元素是第一个，后序遍历是最后一个，其余步骤完全相同。中序 + 层序层序遍历无法划分为左右子树进行迭代，故这里使用了一种不同的思路。在中序遍历的所有元素中，出现在层序遍历中最前面那个必定是根节点，也就是可以通过搜索来确定根节点，之后对中序遍历进行划分迭代求解左右子树即可。二叉查找树对于二叉查找树来说，因为它的元素是有序的，所以只需给定先序、层序及后序遍历中的任何一种即可唯一确定树的结构，不过只给定中序遍历是不能唯一确定的，下面给出树的重建方法。先序先序遍历中，根节点必定是第一个元素，又因为这是一棵二叉查找树，左子树所有元素必定小于根节点，右子树所有元素必定大于根节点，根据这一基本性质，可以很容易的将先序遍历序列划分为左子树和右子树部分，进而迭代求解。后序与先序遍历相同，只不过根节点对应元素是遍历结果中的最后一个。层序思路也是一样的，只是因为层序遍历中，左右子树的元素是混杂在一起的，直接划分并不方便，所以这里新建了两个vector，将对应的元素放入其中即可。总结根据遍历结果重建二叉树的算法虽然有很多变体，不过其核心思想都是一样的：先找出根节点，之后将遍历结果划分为左右子树对应的部分，最后递归求解。无法唯一确定二叉树的情况都是因为无法唯一确定根节点或无法划分左右子树。参考资料：根据前中后序和层序重建二叉树]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Data Struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——AVL树</title>
      <link href="/2017/02/11/Data_Structure_AVLTree/"/>
      <url>/2017/02/11/Data_Structure_AVLTree/</url>
      
        <content type="html"><![CDATA[AVL树是一种特殊的二叉查找树，其特征在于：对所有节点来说，其左子树和右子树间的高度差小于等于1。本文简要总结下AVL树的几种基本操作。节点结构体定义为了突出说明核心问题，节点数据类型使用最简单的int表示；height为树的高度，叶子节点高度为0，每向上一层加1，即每个节点的深度为其左右子树最大深度加1。可使用以下几个宏定义来计算及获取深度：AVL树的旋转旋转操作是AVL树特有的操作，也是学习AVL树的核心,旋转的目的在于解决插入、删除等操作造成的AVL树不平衡问题。AVL树的不平衡一共只有4种情况（以插入为例说明）：LL：在左子树左节点进行插入LR：在左子树右节点进行插入RR：在右子树右节点进行插入RL：在右子树左节点进行插入示意图：关于旋转的详细分析可参考第一篇参考资料，此处仅给出实现代码及简要思路。LL及RR单旋转二者是镜像操作，实现方法比较简单。调整完节点关系后，需要重新计算一下节点的高度。LR及RL双旋转二者也是镜像操作，可以视为两次单旋转的结合。因为单旋转操作已经正确的调整了节点高度，双旋转中无需再调整节点高度。常用操作插入一般使用递归形式，递归函数返回时，检查当前节点是否平衡，不平衡则执行旋转操作。查找元素根据二叉查找树的基本性质，可以很容易的写出查找最大元素、最小元素、任意元素的代码。删除删除是最复杂的操作，如果删除操作不多的话，可以考虑使用懒惰删除的策略，即增加一个标志位，表明当前节点是否被删除了。如果需要真实的删除元素，使用以下方法进行：基本策略和插入一样，依然是递归的进行删除，若待删除节点有两个儿子时，使用树的删除操作中的一般方法，即选择较高一侧子树中最大或最小元素代替当前元素，之后再删除那个最大或最小元素。最大或最小元素一定是叶子元素，这样之后的删除操作就会很简单，且这样的替代删除策略不会导致树的不平衡。遍历同样有前序、中序、后序及层序四种遍历策略，就是树的通用遍历策略，可参考二叉树的遍历算法。参考资料：AVL树(一)之 图文解析 和 C语言的实现]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径算法</title>
      <link href="/2017/02/03/Shortest_Path/"/>
      <url>/2017/02/03/Shortest_Path/</url>
      
        <content type="html"><![CDATA[图论中求解最短路径的算法主要有两种，Dijkstra算法及Floyd算法，其中Dijkstra算法用于求解单源最短路径问题，而Floyd算法则用于解决多源最短路径问题。本文对这两种算法做一总结。Dijkstra算法Dijkstra算法是最经典的最短路径算法，这是一种典型的贪心算法，不过可以证明，这种贪心策略得到的就是全局最优解。Dijkstra算法的详细描述可以参考数据结构的基础书籍，以下文章也可供参考：戴克斯特拉算法算法 7：Dijkstra 最短路算法Dijkstra算法的主要思想可以简要总结为：将所有顶点分为两类，即Known和Unknown两个集合，初始时所有顶点均位于Unknown集合中，算法的目标就是将Unknown集合中的所有顶点移至Known集合中；每一个顶点均有一个表示当前状态的属性表，其中一定要有一个变量记录此时距离源点的最短路径长度（不妨将其记为dr），除此之外根据需要还可以有一些附加信息，如最短路径来源顶点、经过的顶点数、所属的集合（Known还是Unknown）等；初始时，源点的dr为0，其余所有顶点的dr均为无穷大，这里的无穷大只是数学上的说法，实际编程中会用一个合适的值替代；**从Unknown集合中选出dr最小的一个顶点，将其移至Known集合中，并更新Unknown集合中剩余顶点的dr**；重复第4步，直至Unknown为空。算法的核心就是上述步骤中的第4步，这里所谓的更新是指：遍历与选出的顶点邻接的所有顶点，若其位于Unknown集合中，比较当前dr与经由选出顶点至其的距离，若新的距离小于dr，则使用新的距离替代dr。需要注意的是，这里只更新比较位于Unknown集合中的邻接顶点，不需要去更新Known集合中的顶点，否则这就不是贪心法了。用一张图可以很好的说明以上步骤：下面给出Dijkstra算法的核心伪代码：Dijkstra算法的结果一般使用一个一维表（即数组）来记录，每一项即是一个顶点对应的当前状态属性表。算法的复杂度取决于具体实现方式，一个较好的选择是使用斐波那契堆来实现，不过粗略的看，其复杂度大概是O(n^2)级别的。Floyd算法Floyd算法的实质是一种动态规划算法，最初不允许经由任何中间点，之后逐步添加允许的中间点，可以证明，最终允许的中间点为全部顶点时，算法得出的就是最优解。算法详细描述可见：算法 6：只有五行的 Floyd 最短路算法Floyd算法的核心伪代码如下：最外层的for循环逐渐添加允许途径的中间点，内层的两个循环遍历所有点之间的距离。Floyd算法的结果一般使用一个二维表（即二维数组）来记录，即上述代码中的D[N][N]，初始值即为当前图的邻接矩阵（Adjacency Matrix）表示。算法的复杂度是O(n^3)的。]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim配置及插件总结</title>
      <link href="/2017/02/02/Vim_Plugin/"/>
      <url>/2017/02/02/Vim_Plugin/</url>
      
        <content type="html"><![CDATA[Vim之所以强大很大程度上是源于其灵活的配置及丰富的插件，本文就对我的配置文件及用到的插件做一总结记录，插件用法主要给出参考链接，不做过多重复说明。配置文件如果不对Vim进行配置的话，其界面和功能都不是很好用，Vim的配置文件在Linux下是~/.vimrc文件，不过为了方便管理和使用Git进行备份同步，一般将其放在~/.vim/.vimrc处，并在~/和/root/路径下建立硬链接。Vim的配置文件中有一个被称为最强大的终极配置文件——spf13，这是一系列插件和配置文件的集合，不过我没有直接使用这个，只是参考了下它.vimrc文件的写法，我自己使用的配置文件在这里，其中的注释写得很详细，就不多做说明了。插件管理Vim的插件管理功能本身也是靠插件实现的，这类插件有很多：vim有哪些插件管理程序？都有些什么特点？我选用的是使用最广泛且最简单的Vundle。VundleVundle的Github页面上对其使用方法说得很清楚了，照着做就好。在.vimrc文件中配置好相关插件目录，常用命令就这几个：注：早期的Vundle使用Bundle的形式，不过这种用法已经被遗弃了，目前使用的是Plugin的形式。界面美化插件Solarized据说最受欢迎的配色方案，使用下来感觉的确不错。在Vundle中添加：Solarized标准的背景色是深蓝色的，在其Github页面上可以看到效果示意图，不过实际使用下来我却始终无法调出这种背景色来。后面仔细研究了其配色代码，发现蓝色背景色是其针对Gvim的配色，而我是在终端中直接使用Vim的，这时候使用的配色方案背景色是深灰色。当然也可以设置为透明的，即使用终端背景色，不过其实深灰色我看着更舒服，就没有去把它改成蓝色了，只是对部分颜色进行了一些调整，最终得到了一个定制版的Solarized主题。最终的显示效果如下：Airline状态栏增强美化插件，使用方法可参考：vim-airline配置VIM配置:vim-airline插件安装安装Vim插件vim-airlinevim-ariline的使用很简单，基本无需多少配置，且可以自动和诸多其他插件配合使用，十分方便。我使用bubblegum主题的显示效果如下：Startify为Vim添加一个开始界面，可以显示最近使用的文件等。功能增强插件NERDTree据说最受欢迎的Vim插件，可以在Vim中显示一个类似工程管理器的界面，用于方便的选择文件打开。一般同时配合以下两个插件一起使用：nerdtree-git-plugin：用于显示Git状态vim-nerdtree-tabs：在多Tab切换时保持NERDTree界面CtrlP用于快速查找文件的插件。Bookmarks用于增强书签功能的插件，可在左侧边栏显示书签，而且优化了快捷键。我觉得比Signature更简单好用些，按照Github说明配置即可。EasyGrep全局搜索插件。EasyMotion快速移动的神器，方便定位到所需位置。Fixtc.Vim在离开或重新进入插入模式时自动记录和恢复每个缓冲区各自的输入法状态，以便在普通模式下始终是英文输入模式，切换回插入模式时恢复离开前的输入法输入模式。编程相关插件YouCompleteMe代码补全插件，虽然效果还是比不过VS+VAssixtX，不过可以满足基本需求了。如果使用Makefile编译的话，可使用Bear生成索引数据库。Ultisnips快速插入代码片段，与YCM插件配合使用。AutoPair自动括号配对。TagList列出函数、宏定义等。NerdCommenter快速注释代码。ConqueGDB在Vim中集成GDB的插件，只是并不是很好用……参考资料：跟我一起学习VIM - The Life Changing Editor所需即所获：像 IDE 一样使用 vim]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Editor </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下Vim的编译安装</title>
      <link href="/2017/01/17/Linux_Vim_Compile/"/>
      <url>/2017/01/17/Linux_Vim_Compile/</url>
      
        <content type="html"><![CDATA[基本所有Linux发行版的软件仓库中都有现成的Vim，不过这个发布版包含的功能不全，且一般都不是最新版，故我们需要自己动手，从源码自行编译最新版的Vim。本文以Ubuntu 14.04 及 Debian 3.16为例，介绍编译最新Vim 8.0的过程。卸载老版本Vim虽然不卸载老版本的Vim也可以正常编译安装新版本的，不过既然用不到了，将其卸掉可以节省空间.下载所需依赖包首先是基本的编译系统，一般系统都是已经安装了的：其次是各种脚本语言的支持，如Python、Lua、Perl等，需要注意的是，并不是不写这些程序就不用安装了，很多Vim插件都是依赖于这些功能的，所有最好全部都装上以免之后出现奇怪的问题。PythonRubyLuaPerlTclTcl的最新版本是8.6，不过此处不能选择最新版本，要选8.5版本的。如果需要GUI支持，还需要安装GUI相关依赖包，因为我不准备使用GVim等，就无需安装这些了，如有需要可阅读参考资料中的网页。最后还需要安装一些杂项：获取源代码切换到src文件夹中，之后所有操作都在此文件夹中完成。配置使用./configure --help可查看帮助，我使用的设置是：编译安装这一步一般不会发生什么错误，编译时间也不是很长，几分钟就可以完成了。查看版本信息及清理打开Vim后使用:version查看版本信息：最后清理下编译中间文件：现在就可以尽情享受最新版的Vim了~Update 2018-03-03:以上编译选项编译出的vim可能会缺少clipboard支持，这会导致与系统剪贴板交互存在问题。同时为简化之后重复编译升级vim的过程，可编写一个脚本文件来自动执行上述操作，详见：https://github.com/g199209/vimrc参考资料：Debian下Vim的编译Linux中源码安装编译Vim源码编译Vim 8]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断终端色彩支持情况的方法</title>
      <link href="/2017/01/16/Terminal_Color/"/>
      <url>/2017/01/16/Terminal_Color/</url>
      
        <content type="html"><![CDATA[黑白的世界总没有彩色的世界精彩，最初的Linux或其他系统的Shell终端肯定只有黑白的，之后逐渐出现了支持8色、16色、256色及真彩色的终端。目前主流的终端一般都支持256色，未来的趋势是支持24位真彩色。那如何判断当前使用的是哪种模式，以及如何更改设置呢？本文就以Ubuntu下Gnome-Terminal为例介绍一下设置方法，理论上应该适用于所有Linux终端。终端类型及颜色支持使用tput colors命令即可查看当前终端支持几种颜色；使用以下命令即可列出系统所支持的所有终端类型，以及他们支持的颜色位数：示例输出如下：$TERM变量代表当前终端类型，可使用echo $TERM命令查看。256色支持运行以下命令，若输出了完整的256种颜色，就说明当前终端支持256色：若只有前8种颜色，说明当前配置是8色模式，默认情况下，Ubuntu中的Gnome-Terminal就只开启了8色支持。此时可通过修改~/.bashrc文件将其改为256色，在.bashrc文件中加入以下代码即可：真彩色支持很遗憾，Ubuntu下的终端目前尚没有支持真彩色的。可使用以下脚本代码进行检测：如果支持真彩色的话，输出效果如下：若不支持，是无法显示出连续的色彩的：Vim中256色设置要让Vim很好的支持256色需要在.vimrc文件中进行下设置，添加以下代码：如果使用了配色主题插件，也要在插件设置进行类似的设置，以最流行的Solarized主题为例，需要加上以下设置：参考资料：如何查看Linux终端是否支持256色icymind/NeoSolarized]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Git部署警告&quot;warning： LF will be replaced by CRLF&quot;的去除方法</title>
      <link href="/2017/01/13/Hexo_Git_CRLF/"/>
      <url>/2017/01/13/Hexo_Git_CRLF/</url>
      
        <content type="html"><![CDATA[Windows下在使用hexo d命令部署博客时，会出现下面这个警告：这个警告的意思很直接，就是Git会把LF替换为CRLF，不过这是无关紧要的，完全可以禁用此功能，这样还可以避免这个警告信息刷屏。设置方法也很简单，在MinGW窗口中输入以下命令即可：参考资料：Windows git “warning: LF will be replaced by CRLF”, is that warning tail backward?]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux彩色man page设置方法</title>
      <link href="/2017/01/13/Linux_Colourful_Man/"/>
      <url>/2017/01/13/Linux_Colourful_Man/</url>
      
        <content type="html"><![CDATA[Ubuntu中默认的man帮助页面是黑白的，如果将其改成彩色的会更方便阅读。实现方法主要有三种：使用most、使用terminfo、配置.bashrc文件。本文将介绍最简单的第三种方法。Linux下man page的显示默认是通过less来完成的，故在.bashrc文件中添加less的相关设置参数即可使man page变成彩色的:更改完.bashrc文件后要用source .bashrc命令重新载入一下配置，之后重启终端才会生效，以上配置显示效果如下：其中LESS_TERMCAP_xx的含义如下：termcap含义mbstart blinkmdstart boldmeturn off bold, blink and underlineusstart underlineuestop underlinesostart standoutsestop standout对照上面实际的man page页面可以看到：md对应蓝色部分；us对应绿色部分；so对应底部黄色状态栏。至于具体颜色设置方法，参考以下页面：ANSI escape code - Colors简而言之，在&amp;#39;\E[0x;3y;4zm&amp;#39;中：x代表是否加粗，1为加粗，2为正常；y和z分别代表文字前景色和背景色，使用默认值的话可省略，颜色列表如下：Intensity01234567NormalBlackRedGreenYellowBlueMagentaCyanWhiteBrightBlackRedGreenYellowBlueMagentaCyanWhite]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下让进程在后台可靠运行的方法</title>
      <link href="/2017/01/10/Linux_Background_Run/"/>
      <url>/2017/01/10/Linux_Background_Run/</url>
      
        <content type="html"><![CDATA[在登录到Linux服务器后运行某程序，之后断开连接，那之前运行的程序就会被中止掉。这是由于新进程默认都是当前进程的子进程，断开连接关闭当前终端就会把它的所有子进程都结束掉。不过很多时候我们需要让程序稳定的一直运行下去，这时候就需要使用一些方法来处理此问题了。IBM有一篇很好的文章深入探讨了此问题，本文就是对它的简化总结：Linux 技巧：让进程在后台可靠运行的几种方法下文使用python test.py作为示例命令。nohup &amp;amp;nohup用于让提交的命令忽略hangup信号：一般同时加上&amp;amp;把命令放到后台运行setsidsetsid的作用是在一个新的session中运行命令：提交的新进程的父进程会是init，即PPID=1。( &amp;amp;)提交的新进程的父进程也是init。disowndisown用于让某个已经在运行的程序忽略hangup信号，先将此任务放入后台中运行，之后使用如下命令即可：其中jobspec是任务的作业号。screenscreen用于运行很多需要放到后台中稳定运行的命令时使用，用法如下：详细说明见IBM的原始文章。另外，在Ubuntu下，默认是没有安装screen的，使用命令apt-get install screen进行安装即可。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH连接自动断开的解决方法</title>
      <link href="/2017/01/10/SSH_Broken_Pipe/"/>
      <url>/2017/01/10/SSH_Broken_Pipe/</url>
      
        <content type="html"><![CDATA[使用SSH连接远程服务器时，如果长时间不操作，SSH连接上就没有数据传输，此时连接会自动断开，常见的错误提示是：这种超时断开机制估计是出于安全考虑设计的，不过这也会对正常使用造成一定影响，需要进行一些设置来避免这一问题。核心思路就是定时发送心跳包，这样就可以保证连接上始终有数据传输，就不会触发超时断开了。客户端ssh和服务器端sshd均支持此功能，只需要配置一下就可以了，以下方法选择其一即可。服务器端配置如果在服务器端进行配置的话，所有连接到此服务器的会话都会产生效果。修改/etc/ssh/sshd_config文件，在其中添加一行：这样服务器端每隔30s就会向客户端发送一个keep-alive包，以此保持连接不会断开。还可以指定发送keep-alive包的最大次数：若发送了60个keep-alive包后客户端依然没有响应，则断开SSH连接，如果不指定此参数的话会一直发送下去，也就是永远不断开连接。客户端配置如果没有服务器端的权限，也可在客户端进行配置，这样这个客户端所发起的所有会话都会产生效果。修改/etc/ssh/ssh_config文件，与服务器端配置类似，添加以下两个参数即可：此时就是客户端定时向服务器端发送keep-alive包。会话配置如果不希望或不能修改配置文件，也可以在每次建立SSH连接时通过-o参数指定当前会话配置：参考资料：ssh连接linux服务器不断开－ “Write failed: Broken pipe”]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware中收缩Linux虚拟机体积</title>
      <link href="/2017/01/03/VMware_Shrink_Linux/"/>
      <url>/2017/01/03/VMware_Shrink_Linux/</url>
      
        <content type="html"><![CDATA[虚拟机使用一段时间后体积会越来越大，特别是进行了大程序编译等很占空间的行为后，虚拟磁盘文件经常会占用数十G的空间。而且就算之后删除了无用文件，虚拟磁盘文件的体积也不会自动缩小。此时就需要借助VMware Tools进行磁盘空间收缩。在正确安装了VMware Tools的前提下，root下执行以下命令：命令中最后一个参数是虚拟磁盘的挂载点，一般就是/。最后若出现disk shrinking complete即代表压缩完成，此时在Windows资源管理器中即可看到虚拟磁盘文件的体积显著缩小，基本上就与虚拟机实际已使用空间一样大（可使用df确认）。若输入上述命令后提示Shrink disk is disabled for this virtual machine.，需要检查是否存在快照（snapshot）、是否被预分配（preallocated）、是否存在不能收缩的物理硬盘等情况。我就是因为之前添加了一块虚拟硬盘用于访问SD卡，直接使用上述命令收缩硬盘就会报错，把这个虚拟硬盘删掉后即可正常收缩。参考资料：vmware 收缩硬盘大小（compat，shrink，vmware-vdiskmanager）]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware虚拟机中使用电脑内置SD读卡器</title>
      <link href="/2016/12/28/VMware_Internal_SD/"/>
      <url>/2016/12/28/VMware_Internal_SD/</url>
      
        <content type="html"><![CDATA[为树莓派SD卡烧写系统时，需要先在虚拟机中识别到SD卡。笔记本电脑有一个内置的SD读卡器，不过将SD卡插入后，虚拟机中是无法直接找到SD卡设备的，需要我们手动添加一下。如果使用的是外置USB读卡器，连接上电脑后VMware就会自动发现新的可移动设备，此时选择连接到虚拟机即可正常使用。不过笔记本内置的SD读卡器应该是直接连到PCIe总线上的，并不是一个USB设备，插入SD卡后，相关驱动使其在系统中表现为一块硬盘，这一点可以打开磁盘管理器确认：此时，要想在虚拟机中访问SD卡，最好的方式就是添加一块虚拟硬盘，以硬盘的方式去访问SD卡，具体步骤可参考以下文章：How to Use SD Card Reader in VMPlayer and VMWorkstation其中虚拟硬盘类型选择IDE、SCSI或SATA都是可以正常使用的，重点在于必须要选择使用完整的磁盘，且设备要选择正确：设备名称在主机Windows系统下的磁盘管理器中可以看到。需要注意的是，如果是在打开了VMware后再插入SD卡，VMware是无法识别到新硬盘设备的，此时重启VMware后即可正常识别。另外，在移除SD卡后需要同时移除这个虚拟硬盘，否则系统无法正常启动。设置完成后打开Ubuntu虚拟机，使用sudo fdisk -l命令即可列出所有的硬盘设备，如果添加正确的话就可以看到名为/dev/sd*的SD卡了。另外值得一提的是，在我的系统环境下，无论添加的是IDE还是SATA类型的虚拟硬盘，其名称均为/dev/sd*，并不会存在/dev/hd*。只是选择IDE设备的话，新添加的SD卡会出现在前面，即/dev/sda；选择SATA或SCSI设备的话，SD卡会在已有硬盘后面，即/dev/sdb。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware Ubuntu虚拟机中为终端配置Shadowsocks代理</title>
      <link href="/2016/12/27/VMWare_Ubuntu_Terminal_Shadowsocks/"/>
      <url>/2016/12/27/VMWare_Ubuntu_Terminal_Shadowsocks/</url>
      
        <content type="html"><![CDATA[很多常用的终端命令操作是需要联网的，比如git clone等，然而由于墙的存在，很多像Github这样的网站访问可靠性极差，或者直接就无法访问，这时候就需要梯子了……只使用浏览器时很简单，Chrome SwitchyOmega + Shadowsocks的方案很完美，不过涉及到终端命令时这种方案就无能为力了，此时需要使用其它一些方法来解决。最终目标是：虚拟机中的Ubuntu系统可以使用运行于主机Windows系统中的Shadowsocks代理服务器上网，且终端命令一样可以使用代理。解决方案是使用ProxyChains这个软件，安装过程很简单:之后新建一个配置文件~/.proxychains/proxychains.conf：前半部分是对ProxyChains的设置，来源于以下文章：命令行工具下使用Shadowsocks最后的[ProxyList]显然就是代理服务器设置，一般情况下都设置为本机127.0.0.1，然而这是针对Shadowsocks服务器运行于当前系统上使用的设置，此处主机Windows系统中已经运行了一个Shadowsocks服务器，我们可以直接使用这个服务器，只要将此处的IP地址设置为主机IP地址即可。VMware虚拟机与宿主机之间的网络连接一般是通过NAT方式，在Ubuntu中使用route命令可以列出此时的路由表，从默认网关中可以推断出主机的IP地址，当然，也可以在VMware的网络设置中看到NAT转发中主机的IP地址，此处即为192.168.175.1。最后，在Windows的Shadowsocks客户端中，需要选择“允许来自局域网的连接”，否则虚拟机是无法正常访问主机的Shadowsocks服务器的。安装配置完成后，即可通过proxychains来运行命令，如：在需要运行的命令前加上proxychains即可。如果有大量命令均需要翻墙的话，这样输入会比较麻烦，此时可以使用proxychain bash命令新建一个bash，在此bash中输入的任何命令均会使用proxychains。需要测试是否成功翻墙可使用curl ip.gs，这是一个测试当前IP地址的网站，通过返回的IP地址地理位置，可以很容易的判断出当前是否使用了Shadowsocks代理。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS2015 &amp; Qt中文编码方式</title>
      <link href="/2016/12/12/VS2015_Qt_UTF8/"/>
      <url>/2016/12/12/VS2015_Qt_UTF8/</url>
      
        <content type="html"><![CDATA[Linux下中文编码方式很好解决，统一用UTF-8就没问题了，然而在Windows下这个简单的问题会有很多坑……为了在VS中让Qt正确显示中文，折腾了好久终于尝试出一个可用的方法，记录如下。Linux和Qt内部都是使用UTF-8处理字符的，故考虑到跨平台的需求，将源代码保存为UTF-8格式兼容性最好。然而如果使用不带签名的UTF-8格式（即Unicode(UTF-8 无签名) - 代码页 65001）保存的话，在程序中存在奇数个字符的中文字符串时，无法正常编译，此时会出现error C2001:常量中有换行符。关于这个问题可参考：Visual Studio error C2001:常量中有换行符（解决办法）结论就是不要使用无签名的UTF-8编码源文件，无比的坑啊……另一篇文章中比较了各种编码格式的兼容性：[C/C++] 各种C/C++编译器对UTF-8源码文件的兼容性测试（VC、GCC、BCB）结论是使用带签名的UTF-8格式（即Unicode(UTF-8 带签名) - 代码页 65001）是兼容性最好的选择。选择了这种编码方式后可以正常编译含有中文字符串的源文件了，不过要是不做任何设置的话，此时在Qt中显示出来的效果会是乱码。为了正确显示中文，需要在使用到中文的源文件头部加上这样一句预编译指令：这条预编译指令的作用是指定字符串的输出编码方式为UTF-8，注意，这与文件本身的编码方式没有关系。详细说明可参考MSDN：execution_character_setMSDN中还提到，这条指令已经要过时了，需要使用新方法来替代，不过目前还能使用，就不再折腾了……这条指令也是VS下特有的，GCC没有也不需要这个设置，故加上条件编译来保证跨平台移植的兼容性：这样设置后，Qt中就可以正确显示中文了。需要注意的是，其实并没有必要使用QTextCodec::setCodecForLocale(QTextCodec::codecForName(&amp;quot;UTF-8&amp;quot;))来指定Qt的编码方式，因为默认情况下使用的就是UTF-8编码方式。]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV与Qt结合使用</title>
      <link href="/2016/12/10/OpenCV_and_Qt/"/>
      <url>/2016/12/10/OpenCV_and_Qt/</url>
      
        <content type="html"><![CDATA[OpenCV本身能生成的GUI界面极为简陋，故一般使用MFC或Qt等框架来搭建GUI界面，并将OpenCV嵌入进去。因为我之前也用过Qt，故此处选择了Qt作为GUI框架，二者结合的主要问题在于图片的显示上，本文就以最新的OpenCV3及Qt5为例介绍一下实现方法。基本环境的搭建首先保证独立的Qt及OpenCV程序都能在VS上正常的编译运行起来。相关版本Windows 10 64-bitVisual Studio 2015OpenCV 3.1Qt 5.7Qt @ VS参考之前的文章：VS2015搭建Qt 5.7开发环境注意Qt要选32-bit，以便和OpenCV兼容。OpenCV @ VS参考之前的文章：VS2015下编译OpenCV 3.1需要注意的是，CMake配置时有一个WITH_QT选项，这个选项是指OpenCV的highgui模块本身是否使用Qt，似乎可以不选这个选项的。如果选择了WITH_QT，点击Configure后会出现新的Qt相关路径的选项，如果Qt安装正常的话，这里的路径是会自动生成的：点击Generate后会出现很多如下warning：相关解释可以参考这里，直接忽略这个警告即可。另外，在编译OpenCV时也会出现很多和Qt有关的Warning，不过没有Error，可以忽略。选择了WITH_QT后，highgui本身的窗口界面会变成基于Qt的，比原来要好看一些，而且自动集成了一些图片缩放、保存等功能：不过这还是满足不了我们自由设计GUI界面的需求，接下来就要讨论如何在Qt项目中使用OpenCV。数据结构转换算法OpenCV中使用Mat保存图片，而Qt中则使用QImage或QPixmap，故二者结合的核心就在于这两个类之间的转换。网上已经有人实现了转换代码：Converting Between cv::Mat and QImage or QPixmap经实际测试，上述代码基本是可以正常使用的，只是有一些小Bug需要修正下，后文会具体说明。这里将其中Mat-&amp;gt;QImage的核心代码摘录备份如下：上述代码在处理CV_8UC1类型时存在Bug，sColorTable.isEmpty()这个判断永远都是不会为真的，即使是在第一次执行时。解决方法有以下几种：1.直接去掉这个if判断，此做法的缺点是每次都会生成颜色表，效率不高；2.使用sColorTable中元素的值来判断是否初始化过了；3.一般使用时会将这个方法封装在一个类中，此时可以将sColorTable设置为类变量，在构造函数中初始化即可。以上这种方法相当于调用构造函数生成了一个新的QImage，然后复制图像数据过去。另一种思路可参考以下链接：详解 QT 框架中快速应用OpenCV 基于图片 上篇Qt中图片的显示最简单的办法是使用QLabel，更高效一些的方法是使用QWidget。使用QLabel时只需调用setPixmap()方法设置图片即可，QPixmap与QImage间的转换可用QPixmap::fromImage()函数完成。另外，使用QLabel的setScaledContents()方法可以设置图像自动缩放。给出一个完整的例子：]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS2015搭建Qt 5.7开发环境</title>
      <link href="/2016/12/09/VS2015_Qt5_7/"/>
      <url>/2016/12/09/VS2015_Qt5_7/</url>
      
        <content type="html"><![CDATA[Qt自带的IDE Qt Creator还是比较好用的，如果只开发纯粹的Qt程序使用Creator很方便。不过很多时候Qt只是作为GUI接口，程序的核心其实是其他部分，比如我在项目中用到的OpenCV等，这时如果能将Qt集成到VS中使用会更方便。本文以最新版的Qt 5.7及VS2015为例介绍集成方法。安装Qt可以从Qt官网上下载其预编译版本，我选用的是Qt 5.7.0 for Windows 32-bit (VS 2015)，因为之前编译OpenCV只能使用32位（链接），故此处的Qt也选用了32位。在Windows上使用一般来说没有必要自行编译源代码，使用官方编译好的版本即可。安装过程就是正常的程序安装过程，没有什么特殊的地方。添加环境变量将Qt的bin目录...\5.7\msvc2015\bin添加到PATH中，这是为了在运行程序的时候能找到Qt的dll文件。安装VS插件之前Qt的VS插件叫做Qt VS Addin，这个插件似乎现在不能用了，不过我们可以用QtPackage这个插件来替代。下载安装完成后，打开VS配置Qt路径：其中名字任意取，路径要选择bin\文件夹所在的位置。确定后重启VS，再新建项目即有Qt相关的选项：配置工程建立好Qt项目后，需要添加包含目录及库目录：包含目录：...\5.7\msvc2015\include\; $(ProjectDir)\GeneratedFiles库目录：...\5.7\msvc2015\lib\其中第二个包含目录是指当前工程的GeneratedFiles文件夹，由窗体文件自动生成的ui_***.h文件均位于这个文件夹中。配置好后即可正常编译运行~不过需要注意的是，第一次编译运行必须选择“开始调试”，选择“生成解决方案”等会出错，且成功运行一次之后还需要执行一次“重新扫描解决方案”智能感知提示才正确。参考资料将 Qt 5.6 集成至 VS2015]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS2015下编译OpenCV 3.1</title>
      <link href="/2016/12/06/VS2015_OpenCV31/"/>
      <url>/2016/12/06/VS2015_OpenCV31/</url>
      
        <content type="html"><![CDATA[本文介绍一下如何从源码编译OpenCV 3.1，使用的环境是Win10 64bit + VS 2015。下载源文件OpenCV 3.1 ReleaseCMake GUI 3.7.1运行Cmake打开CMake GUI，选择Browse Source...指定源文件路径，Browse Build...指定目标文件路径；之后点击Configure，会弹出一个对话框选择Generator，对于VS2015来说选Visual Studio 14 2015或Visual Studio 14 2015 Win64，前者是32位，后者是64位。确定后CMake会自动下载一些依赖文件，所以需要保证良好的网络连接，不过其中ippicv_windows_20151201.zip文件会因为网络问题始终无法成功下载，可以从网上搜索这个文件下载下来，比如从这里。如果最终的状态是Configuring done，且列出了此时可用的设置，说明配置成功，再点击Generate即可生成VS工程，默认的配置是可以正常编译使用的。需要注意的是，选择Win32编译32位版本是完全正常的，不过选择Win64编译64位版本时，Debug版可以正常编译通过，而Release版则无法编译成功，显示编译器内部错误，根据网上的资料这应该是VS2015的Bug。故使用VS2015编译OpenCV 3.1时建议使用32位模式进行编译。VS编译点击Open Project按钮打开生成的VS工程，待其完全载入后即可编译了，需要注意的是，不要使用默认的生成解决方案（F7）进行编译，这样最终得到的install文件夹中的内容是不全的。正确方法是在INSTALL工程上点右键，选择生成，单独编译生成此工程。正常情况下是可以成功编译生成的，最终的得到的所有所需文件都位于目标文件路径下.\install文件夹中，其中.\install\include文件夹中存放的是头文件，.\install\x64\vc14\bin文件夹中是dll动态链接库文件，.\install\x64\vc14\lib和.\install\x64\vc14\staticlib中都是库文件。不过如果想对OpenCV源码进行Debug跟踪，是不能选用.\install文件夹中的库文件的，因为此处缺少.pdb调试文件，无法正常Debug。此时需要使用.\lib文件夹中的库文件，这时可以正常的跟踪到源代码中，且使用profiler分析代码性能时也可以正确定位到OpenCV内部函数上。定制优化OpenCV上面生成的文件已经是可以正常使用的了，不过自行编译源代码的一大优点就是可以根据自己的需求进行配置。使用World模块默认情况下编译结果是很多的lib文件及dll文件，使用起来不是很方便，OpenCV提供了一个World Module的功能，可以把生成的文件链接在一起，合成一个dll及lib文件。选取BUILD_opencv_world即可。不过实际测试表明，使用了World模块后编译的时间会明显变长，故是否使用根据需要决定。去除不需要的功能根据需要去掉一些不需要的功能即可，如WITH_1394等。开启CPU指令集支持根据使用的CPU，可以开启ENABLE_AVX、ENABLE_FMA3等矢量指令集支持功能，以提高整体性能。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组循环移位算法</title>
      <link href="/2016/11/28/Array_Shift/"/>
      <url>/2016/11/28/Array_Shift/</url>
      
        <content type="html"><![CDATA[给定一个数组，将其循环右移（或左移）k位，要求时间复杂度为O(N)，空间复杂度为O(1)。原始问题OJ系统可参考以下链接：https://www.patest.cn/contests/pat-b-practise/1008解题思路先用几个简单的例子分析下：原数组 ：1 2 3 4 5 6 7 8右移1位：8 1 2 3 4 5 6 7右移3位：6 7 8 1 2 3 4 5右移7位：2 3 4 5 6 7 8 1从中很容易看出，右移k位即是将数组最后k个元素与之前的元素整体交换位置。问题的关键就是如何不用辅助空间在线性时间内实现这一交换过程。解决这一问题依赖于以下数学原理：假设$X$、$Y$为两个序列，$X^T$代表其反转序列（即reverse），$XY$代表两个序列的拼接，则有以下结论：$$(X^T)^T=X$$$$(XY)^T=Y^TX^T$$我们要实现的交换过程其实就是将$XY$变换为$YX$，根据以上公式有：$$YX=(X^TY^T)^T$$这就是所谓的经典三步翻转法。根据以上原理很容易就可以写出代码，只需要注意两点：左移k位就相当于右移N-k位，故只需考虑一种情况即可；移位k位和移位k+N位结果完全相同，故只需考虑k % N的情况即可。C++代码其中reverse()函数实现反转数组，在C++中可以直接使用&amp;lt;algorithm&amp;gt;头文件中的reverse()函数来实现。若使用C语言，自行实现此函数即可，注意要正确处理当k=0时reverse(A+N, A+N)的情况。]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为Hexo博客移动端添加搜索功能</title>
      <link href="/2016/11/25/Blog_Search_Mobile/"/>
      <url>/2016/11/25/Blog_Search_Mobile/</url>
      
        <content type="html"><![CDATA[之前已经为博客的PC端界面添加了搜索功能，用起来效果不错，不过美中不足的是，使用手机访问的时候并不能使用搜索功能。这几天折腾了一下，终于给移动端界面上也加上了搜索功能~这里来记录一下实现方法。之前为博客添加搜索功能的方法见：为Hexo博客Yilia主题添加本地站内搜索功能要为移动端添加搜索功能，主要就是添加搜索框及搜索结果HTML样式及添加相关JS代码。添加搜索框及搜索结果区当前主题在移动端的布局中，点击左上角的菜单按钮就会弹出一个显示友情链接、标签等信息的叠层，综合看下来将搜索框添加在这个位置较合适，最终的效果如图：这里的搜索框和PC端基本是一样的，只是样式上做了些变化，使得整体效果更和谐。找到合适的位置添加搜索框及搜索结果区的HTML代码即可：布局和PC端的稍有差异，搜索结果区和搜索框放在了同一个form里面。CSS样式此处从略，如有兴趣可参考源文件：search.styl添加JS代码此主题移动端的时候使用的JS文件为mobile.js（PC端是pc.js），按照PC端的做法添加相关代码即可，注意搜索框等的名字要改为对应的移动端名字。这样修改后是可以实现基本功能了，然而用起来会有各种Bug，这两天的时间就主要花在解决这些Bug上了……解决触摸无响应问题直接把代码移植过来的第一个问题就是，在手机上那个搜索框实际上是没有用的，无法点击进行输入……具体原因并不清楚，只找到了可用的解决方案。在JS文件search函数中添加以下代码：监听touchstart事件，并通过程序触发focus及click事件。解决滚动异常问题加上以上代码后可以搜索了，只是搜索结果的滚动有各种奇怪的问题……比如只有输入单个字符的时候可以滚动、会发生点击穿透导致后面的页面滚动、只能按住标题进行滚动等等……各种尝试后决定不去解决这些问题了，直接监听触摸事件，自己重写滚动响应及滑动打开的代码。基本思路是这样的：在touchstart事件中记录触摸开始的坐标点，并且判断是按在了哪个搜索结果条目上；在touchmove事件中获取手指移动的方向，判断是进行垂直滚动还是水平移动搜索条目（用于打开搜索结果），之后修改对应元素的marginTop或marginLeft属性即可实现界面元素的移动；最后在touchend事件中判断是否发生了滑动打开链接事件，如果有的话打开对应链接。需要注意的是，要调用preventDefault()来阻止触摸事件的传递，以避免各种奇怪的问题。除了基本逻辑外，还做了些处理让视觉效果更好看些，具体见以下的实现代码：完整的mobile.js文件在这里。最终成品效果实际使用下来还是比较满意的，搜索效果像这样：]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Blog </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N皇后问题</title>
      <link href="/2016/11/22/N_Queen_Problem/"/>
      <url>/2016/11/22/N_Queen_Problem/</url>
      
        <content type="html"><![CDATA[N皇后问题是经典八皇后问题的扩展：在N*N的棋盘上，有N个皇后需要放置，需满足任意两个皇后不能位于同一行、同一列或者是同一对角线上，求一共有几种放置方法。N皇后问题是一个经典的回溯法的例子，核心思想就是逐行（或逐列）放置，若某一行没有可供放置的位置了，说明前面的放置有误，故回溯到上一行寻找下一个可能的位置。N皇后问题是一个NP-Hard问题，其算法复杂度是指数复杂度的。下面给出两种实现方法。经典回溯非递归实现程序很简单，就不多说明了。位运算递归实现上面使用数组实现的回溯法其实效率很低，N皇后最高效的解法是位运算算法，下面给出实现代码：此算法的详细解释见：八皇后问题详解及代码实现(位运算算法)N皇后问题的两个最高效的算法位运算简介及实用技巧（三）：进阶篇(2)实际测试表明，此方法的效率是简单回溯的10倍左右。附注：1~27皇后问题的解法数量见：A000170，这个可以用来验证自己写的算法是否正确。]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PMSM矢量控制算法调试流程</title>
      <link href="/2016/11/14/PMSM_Vector_Control/"/>
      <url>/2016/11/14/PMSM_Vector_Control/</url>
      
        <content type="html"><![CDATA[矢量控制又称磁场导向控制（Field Oriented Control, FOC），这是永磁同步电机（PMSM）的主要控制方法，与BLDC的简单控制策略相比，矢量控制要更为复杂，故需要一套系统的调试方法。TI提供了一个用于支持各种电机控制算法的DMC库，其中包含很多矢量控制中用得到的功能模块，与之配套的还有一份调试指南：Sensored Field Oriented Control of 3-Phase Permanent Magnet Synchronous Motors本文就以此为基础，结合实际调试经验，介绍一下矢量控制的基本调试流程。硬件平台基于TI C2000系列DSP，使用DMC库，不过基本方法也适用于其他各种平台。调试基本功能模块矢量控制中，需要获取转子位置、相电流及转速，输出是三相逆变器的占空比信号，故首先要配置好所需的硬件功能模块，并进行测试验证，这是之后所有工作的基础。配置PWM输出矢量控制中，一般需要六路三组PWM输出，配置为两两互补导通的形式，在大部分MCU中可使用定时器模块来实现PWM输出，不过TI C2000系列提供了专门的ePWM模块来实现这一功能。按照寄存器定义配置好模块后，需要验证配置的正确性。断开电机连接，依次将U、V、W三相的占空比设置为0、100%、50%，使用万用表测量对应端口的电压，0占空比时输出电压应接近0V，100%占空比时接近母线电压，50%占空比时为母线电压的一半。若测量结果符合预期，说明配置正确。配置电流采样矢量控制中需要同时获得三相电流，一般采集其中两相，根据基尔霍夫定律即可推出第三相的电流。电流采集有各种方法，可以参考：三相逆变器电流采样方案总结无论使用哪种方法，最后都是使用AD进行采样的，根据采样电路的结构可以推导出电流采样值与AD结果寄存器值之间的关系。所以先要配置好AD模块，一般情况下，可以使用PWM信号来触发AD采样，具体触发时机取决于使用的采样方案。配置好寄存器后，需要验证电流采样的正确性。首先断开电机连接，使用仿真器连续读取AD采样结果寄存器的值，此时的采样值即为电流零点。观察电流零点的稳定性，一般来说，如果电流采样的稳定性较好，AD结果寄存器中只会有最后一两位在波动。若电流零点波动得较严重，说明采样稳定性很差，此时需要在程序中增加滤波算法。之后接上电机，给U相输出一个很小的占空比，V、W两相占空比设置为0。具体占空比的值取决于母线电压及绕组电阻，可以预先估计一下，保证电流在安全范围内，一般可以取为1A左右。此时再用仿真器读取计算出的U、V、W三相电流，根据正电压产生正电流的电动机原则，U相电流应该是正的，V、W两相电流应该是负的，且V、W两相电流应基本相同。若正负号不对，需要进行调整。如有条件的话，可以使用电流探头或钳型电流表等仪器测量真实的电流值，将真实值与采样值进行对比，以此评估采样的正确性及精度。如果无法测量电流的真实值，可以改变PWM占空比，保证增大占空比电流也会增大，减小占空比电流也随之减小即可。配置角度及转速采样角度和转速都来源于旋转编码器，一般MCU定时器中均有正交解码功能，用于解码来自编码器的信号。在C2000 系列中，有独立的eQEP模块用于获取旋转编码器的输出信息。在TI DMC库中，提供了一个QEP模块，此模块可以将QPOSCNT寄存器中的计数值转换为电角度及机械角度，使用标幺值表示。若不使用此模块，自行编写程序计算出电角度、机械角度及转速也可以。转速的计算也有多种方法，可参考：旋转编码器速度测量方法这里配置好后只需要初步验证一下：用手旋转电机，角度采样值会发生变化即可，详细的验证放到后面步骤中进行。编写变换程序矢量控制的核心其实就在Clark与Park变换上，通过这两个变换实现了直轴与交轴的解耦。TI DMC库提供了现成的变换模块，即CLARKE、PARK及IPARK，可直接使用。如果是自行编写的程序，需要预先通过仿真等方法确定程序的正确性。调试SVPWM模块其实矢量控制也并不一定要使用SVPWM（空间矢量调制）方法，也可使用其他方法（如滞环控制等）进行电流控制，不过SVPWM是最优策略，也是主流做法。TI DMC库中使用SVGEN模块支持SVPWM算法，也可自行编写相关程序。SVPWM的输入是U_alpha及U_beta，输出是PWM占空比，上述步骤中已经确定了PWM输出的正确性，现在再加上SVPWM算法进行验证。系统框图如下：其中Ds、Qs、Angle均是调试变量，使用仿真器进行Debug时可以实时更改变量值。将Qs固定为0，Ds设置为一个较小的电压值，保证输出电流在安全范围内。之后将Angle由0开始，每次增加30°左右，此时电机应该是会旋转的，且每次旋转的角度应该是相同的，记录下这个旋转方向，这就是此系统固有的正方向。此时还可以验证电机的极对数，若Angle重复增加N个周期后电机回到起始点（可用记号笔进行标注），电机的极对数即为N。最后还需要验证角度采样的正确性。这里设置的Angle即是这个电机真实的电角度，对比Angle的设定值与角度的采样值，二者的绝对值一般是不一样的，这是正常的，不过每次的变化量应该是相同的，包括大小与方向，也就是说，两个变量间应该存在一个固定的相位差。若二者的变化趋势相反，说明编码器A、B相接反了，可以在硬件上交换接线来解决，C2000系列中也可以通过配置eQEP模块来交换A、B两相。若二者每次的变化量不一样，说明电机的极对数搞错了，需要仔细检查程序。调试电流PI控制器SVPWM模块调试正常后就可以加上电流PI控制器了，系统框图如下：其中IqRef、IdRef及Angle是调试变量。从图中可以看到，这里使用了两个PI控制器，需要对其参数进行粗略的整定。首先将Angle及IqRef设置为0，IdRef设置为一个安全的电流值，PI控制器参数均设置为0，此时应该是没有电流的。之后将IdPI控制器的Kp值设置为一个合适的值，具体值根据输入输出的数量级来确定，不要设置得太大，若都使用标幺值的话，可以设置为1。此时重新运行程序，观察Id的实际值，Id的值应该不等于0，不过与IdRef之间存在一个静差，逐步增加Ki，直到静差满足要求为止。将IqPI控制器参数值设置为相同的即可。之后与调试SVPWM模块时相同，逐步改变Angle的值，此时电机应该也是会动的。可以在程序中让Angle自动增加，不过增加的速度不要太快，此时电机应该会正向旋转起来。若让Angle自动减小，则电机会反向旋转。正转与反转应该是对称且相同的。注意，此时设置的是IdRef，IqRef需要始终保持为0。记录下旋转时角度采样值与Angle值，并绘制曲线进行观察，二者应该是频率相同的三角波，且有一个固定相位差。与此同时，相电流的采样值应该是比较接近正弦的波形。如下图所示：调试PI控制器参数时也可参考相电流曲线，若曲线发生畸变，不是图中那样的正弦波形，需要降低比例及积分作用。最后，检查采样计算出的转速值，正转时转速应该是正的，反转时是负的。根据Angle的变化周期可以计算出此时的实际转速，将实际转速与转速采样值进行对比，二者应该基本相同。如果有条件的话，可以进一步使用转速计进行验证。如果此处的转速符号或大小有误，需要检查程序进行修改。调试电流闭环上面几步调试过程中使用的Angle值均是由程序计算生成的，现在需要加入实际角度采样值，完成完整的电流闭环部分。上电开始运行时，如果没有霍尔信号或绝对值编码器，是很难获取转子绝对位置的，故一般的做法是先进行预定位操作。具体方法是：将Angle及IqRef设置为0，IdRef设置为合适值，此时电机会自动旋转到零点位置处，此过程中将角度累加寄存器（C2000中为QPOSCNT）持续置零即可，这样即完成了初始的预定位操作。之后按上一步调试电流PI控制器中的方法，自动改变Angle让电机旋转起来，再观察Angle与角度采样值，二者应该是严格相同的。确定了角度采样值的正确性后，修改程序，使用角度采样值替代Angle，这样就完成了完整的电流闭环程序。此时已经不再需要使用Angle了，初始预定位时，只要在程序中一直将角度值清零即可。最后验证电流闭环的正确性，在完成预定位后，依次验证Id与Iq。验证Id时将IqRef设置为0，IdRef设置为一个合适的正值，此时电机是不会旋转的，用手转动电机也是可以转动的，只是不同于自由转动状态，此时旋转电机时会感到阻力较大，有一个力始终在维持电机处于当前位置。验证Iq时同理将IdRef设置为0，IqRef设置为一个合适的值即可。需要注意的是，因为启动电流明显大于稳态电流，如果IqRef的值设置得过小，电机无法旋转起来，而增大IqRef，使电机可以旋转起来后，电机会一直加速到最高转速。为保证安全，需要对输出电压占空比进行限幅。将IqRef设置为正值时电机应该正转，设置为负值时电机应该反转，且正反转速应该是相同的。此时还可以进一步观察转速采样结果，如果和实际情况符合的话就可以进行下一步了。调试速度闭环最后一步是加上速度闭环，此时的系统结构框图如下：这就是矢量控制算法完整的控制系统结构框图。对于PMSM而言，除了在弱磁控制等情况下，IdRef一般是固定为0的。不过对于异步电机而言，因为要产生绕组电流，IdRef并不是零。IqRef连接至速度环PI控制器的输出上，一般会对IqRef的范围进行限幅，以保证电流在安全范围内。之前已经验证了速度采样的正确性，故这里只需要整定PI控制器参数即可。方法按照通用步骤，先设置一个Kp，再慢慢增大Ki，根据设定值与实际值的曲线进一步调节参数即可。整定完成后，系统应该是完全可控的，电机会按照给定速度旋转，且正转反转应该都是没有问题的。至此，整个矢量控制的基本流程已经完全打通，接下来就可以根据具体应用场景，进一步调节参数及优化上述控制策略了。]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Motor </tag>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 014. Longest Common Prefix (Easy)</title>
      <link href="/2016/11/01/LeetCode_014/"/>
      <url>/2016/11/01/LeetCode_014/</url>
      
        <content type="html"><![CDATA[给出一个字符串数组，返回其最长公共前缀子序列。原始问题https://leetcode.com/problems/longest-common-prefix/Write a function to find the longest common prefix string amongst an array of strings.解题思路以第一个字符串为基准，依次比较每个字符即可。AC代码C语言这里先进行比较，判断出最先几个字符为相同的字符，之后再申请内存空间，复制字符串作为结果返回。之所以要分两步处理，是因为开始的时候并不知道结果字符串的长度，若采用动态分配空间的方法效率会很低。C++]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 019. Remove Nth Node From End of List (Easy)</title>
      <link href="/2016/11/01/LeetCode_019/"/>
      <url>/2016/11/01/LeetCode_019/</url>
      
        <content type="html"><![CDATA[给出一个链表，移除其中倒数第N个元素。原始问题https://leetcode.com/problems/remove-duplicates-from-sorted-list/Given a linked list, remove the nth node from the end of list and return its head.For example,Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.Note:Given n will always be valid.Try to do this in one pass.解题思路双指针，后一个指针比前一个指针先走N步，后一个指针移动到链表末尾时前一个指针指向的就是要删除的元素。AC代码C语言这里使用了正确的删除节点的方法，使用free()释放了内存空间。]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 083. Remove Duplicates from Sorted List (Easy)</title>
      <link href="/2016/11/01/LeetCode_083/"/>
      <url>/2016/11/01/LeetCode_083/</url>
      
        <content type="html"><![CDATA[给出一个有序链表，去除其中的重复元素。原始问题https://leetcode.com/problems/remove-duplicates-from-sorted-list/Given a sorted linked list, delete all duplicates such that each element appear only once.For example,Given 1-&amp;gt;1-&amp;gt;2, return 1-&amp;gt;2.Given 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3, return 1-&amp;gt;2-&amp;gt;3.解题思路因为链表是有序的，直接从头循环搜索一遍即可。AC代码C语言这里使用了正确的删除节点的方法，使用free()释放了内存空间。]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu虚拟机中设置NAT使树莓派开发板可以联网</title>
      <link href="/2016/11/01/Ubuntu_NAT_Raspberry/"/>
      <url>/2016/11/01/Ubuntu_NAT_Raspberry/</url>
      
        <content type="html"><![CDATA[树莓派3自带了WiFi，可以将其连接到无线热点上来联网，不过实验室没有无线路由器可用，只能将其用双绞线连接到电脑上，此时要实现树莓派能正常联网就需要在电脑上的Ubuntu虚拟机中设置NAT转发，这里来记录一下设置过程。网络拓扑结构基本的网络结构如下所示：其中蓝色线条表示逻辑上的网络连接关系。树莓派上的LAN接口使用双绞线与电脑连接，在虚拟机中设置桥接模式，即会产生一块虚拟网卡eth1桥接到已有的以太网上构成局域网。虚拟机中还有一块虚拟网卡eth0，这是通过VMware的NAT模式产生的，VMware中运行着一个NAT服务实现了eth0到VMnet8这两块虚拟网卡间的转发，最终实现了虚拟机联网的目的。从图中可以看到，目前树莓派只连接到了一个局域网中，并没有和Internet建立连接，要实现联网的目的，最简单的方法就是在Ubuntu虚拟机中建立eth1至eth0的NAT转发。实现方法开启IPv4转发Linux内核本身就是支持IPv4转发的，只需要开启这个功能即可。使用以下命令：修改ip_forward文件可以实时启用IP转发，不过这是临时的，重启后会失效，要永久启用，需要修改配置文件/etc/sysctl.conf。在Ubuntu 14.04中，默认有下面这两行注释：根据说明去掉下面那行的注释即可：也可以在文件末尾直接添加上述语句，效果是一样的。要让修改实时生效，使用以下命令重新加载sysctl.conf文件：配置iptables首先确定目前防火墙的设置不会拦截来自树莓派开发板的数据包，之后使用以下命令添加NAT转发即可：192.168.1.7/32是树莓派的IP地址；eth0是可以联网的网卡。这个配置也是实时临时生效的，要让其永久生效，需要将其写入配置文件中。首先，使用iptables-save工具将目前的iptables规则保存为文件：之后修改/etc/network/interfaces文件，在文件最后加上：iptables-restore工具用于载入之前保存的规则文件；pre-up表示建立interface之前执行操作，类似的还有up、post-down等，可用命令man interfaces查询。这里就表示在每次建立接口前加载预设规则。配置网关及DNS服务器这一步是在树莓派开发板上进行的操作，根据之前文章的做法，我们为树莓派配置的是固定IP地址，故同时还要设置网关和DNS服务器，网关需要设置为Ubuntu虚拟机中eth1网卡的IP地址，以便将所有数据包送至Ubuntu虚拟机中。至于DNS服务器，经过测试，最好的选择是将DNS服务器设置为VMware软件生成的那个虚拟NAT网关的地址，这样VMware会自动选用主机使用的DNS服务器。如果要临时更改DNS服务器，可修改/etc/resolve.conf文件：通过上述方法进行设置后，树莓派就可以上网啦~此方式的实质是将Ubuntu虚拟机作为一台路由器进行网络地址转换，从而为树莓派开发板提供网络访问。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
            <tag> Raspberry Pi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为树莓派设置静态IP地址的方法</title>
      <link href="/2016/10/27/Raspberry_Pi_Static_IP/"/>
      <url>/2016/10/27/Raspberry_Pi_Static_IP/</url>
      
        <content type="html"><![CDATA[Raspbian系统默认是使用DHCP方式获取IP地址的，这就要求要有一个路由器。然而实验室里面并没有有线网和路由器可用……我只能配置成电脑用无线上网，然后用网线连接树莓派这样的网络结构。这就要求树莓派要配置成静态IP的形式，下面来总结一下配置方法。在网上搜索“树莓派 静态IP”可以找到很多的教程文章，然而它们大部分都不适用于现在新版本的Raspbian系统了，按那些方法进行配置是错误的。2015年5月后，Raspbian Jessie发布，这一版本引入了dhcpcd，进而更改了网络部分的配置方式，导致之前的所有教程都失效了……新版本的配置方式和相关讨论见以下链接：How do I set up networking/WiFi/Static IP这篇文章中提到了两种设置方法，这里对推荐使用的基于dhcpcd的新方法做一总结：首先，不要修改/etc/network/interfaces文件；之后打开/etc/dhcpcd.conf文件，在最后添加以下代码：其中eth0代表有线以太网接口，如要配置无线网，使用wlan0；ip_address就是IP地址，根据实际情况配置；routers是网关地址；domain_name_servers是DNS服务器的地址。最后使用sudo reboot命令重启后即可生效。相关文章：VMware虚拟机中嵌入式Linux开发环境网络配置]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
            <tag> Raspberry Pi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP地址中子网掩码的表示方法</title>
      <link href="/2016/10/27/IP_Mask/"/>
      <url>/2016/10/27/IP_Mask/</url>
      
        <content type="html"><![CDATA[今天看到类似192.168.1.1/24这样的IP表示方法，去查了下后面的/XX是什么意思，原来这是代表子网掩码。/24就是掩码中前24为1，也就相当于255.255.255.0，其他值以此类推。这样指定IP的同时也就给出了子网掩码，表示起来会更方便。另外，还看到一道关于子网掩码的题目，摘录如下：某网络的IP地址空间为192.168.5.0/24，采用定长子网划分，子网掩码为255.255.255.248，则该网络的最大子网个数，每个子网内的最大可分配地址个数为各为多少？解答：题目给出的IP地址空间基于CIDR划分，前24位是网络号，后8位是主机号。子网掩码最后是248，248 = 1111 1000。相当于主机号又被分成两部分，前5位是子网号，后3位是主机号，所以，子网个数是2^5 = 32, 主机个数为2^3 = 8。另外，主机号全0代表本地主机, 全1表示广播，所以还剩下6个有效的。]]></content>
      
      
      <categories>
          
          <category> 点滴之间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows防火墙允许ping请求设置方法</title>
      <link href="/2016/10/27/Windows_Ping/"/>
      <url>/2016/10/27/Windows_Ping/</url>
      
        <content type="html"><![CDATA[Windows系统出于安全性考虑，在开启了防火墙时，默认情况下是不会响应来自其他主机的ping请求的。这不利于开发过程中检测网络连通性，故这时就需要开启防火墙中的ICMP回显功能。以Windows 10为例，打开防火墙高级设置界面，在入站规则中允许ICMP回显即可，如图：]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道字符串填充算法题</title>
      <link href="/2016/10/26/String_Fill/"/>
      <url>/2016/10/26/String_Fill/</url>
      
        <content type="html"><![CDATA[偶然在idailylife的博客上看到Indeed Tokyo 笔试题一道，觉得很有趣，就思考了下这题，这里记录一下。问题描述输入字符串str=a[0] a[1] ... a[N]，其中0&amp;lt;N&amp;lt;=10^5。字符串的每一位是0-9或?，需要用0-9填充各个问号的值，使得整个字符串成为一个数（允许前导0），并且满足任意连续10位上的字符(或理解成数字)a[i] a[i+1] ... a[i+9]不重复，输出解的个数。例如，输入&amp;quot;04??2?7&amp;quot;，输出应当为120.解题思路使用回溯法暴力求解显然是不可行的，原文中作者给出了一个很好的做法：只计算str前10个字符有多少可能性。这是基于以下原理的：对任意区间a[k] a[k+1] ... a[k+9]，题目要求数字均不重复，而且一共也只有10个数字可以选择，故此区间内肯定用完了所有数字。下面将此区间向前移动一步，得到a[k+1] a[k+2] ... a[k+9] a[k+10]，对比两个区间易知，要满足条件只能是a[k] = a[k+10]。由于k是任选的，故可以得到结论：此序列是一个以10为周期的周期序列。原文中作者实际去填充了前10个字符中的空位，然后来依次判断每种情况的有效性，其实这是完全没有必要的，还有一种更高效的解法。假设a[k]为?，若任意a[k + 10n]不为?的话，？的值其实是可以唯一确定的。用此方法可以先排除一些能唯一确定的?，之后考虑前10个字符中剩余的?，这是一个简单的排列组合问题，不需要实际进行填充即可算出一共有几种填法。具体实现方法见下面的代码。另外，下面的代码中假设给出的字符串中已经有的数字是符合要求的，这样就可以不对已有数字进行有效性检验。扩展：这里之所以有如此巧妙的解法，关键在于可能填入的字符数量正好等于不重复区间长度，若二者不等该如何解决呢？这个问题之后有空可以再来思考下。实现代码]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 319. Bulb Switcher (Medium)</title>
      <link href="/2016/10/26/LeetCode_319/"/>
      <url>/2016/10/26/LeetCode_319/</url>
      
        <content type="html"><![CDATA[n盏灯，初始状态为全灭，第一次翻转编号为1的倍数的灯（即所有灯），第二次翻转编号为2的倍数的灯，以此类推，第n次翻转编号为n的倍数的灯。求最后有几盏灯亮着？原始问题https://leetcode.com/problems/bulb-switcher/There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.Example:Given n = 3. At first, the three bulbs are [off, off, off].After first round, the three bulbs are [on, on, on].After second round, the three bulbs are [on, off, on].After third round, the three bulbs are [on, off, off]. So you should return 1, because there is only one bulb is on.解题思路简单分析就可以知道，问题的关键是要求解每盏灯被翻转了奇数次还是偶数次，翻转了奇数次的灯就是最后亮着的灯。最直接的做法就是从第1盏灯开始循环判断每一轮是否翻转，若翻转次数为奇数则亮灯数加1。此方法的代码见C语言程序的方法一。然而，这种方法运行时间太长，在LeetCode上会超时，故需要使用数学分析来解决这一问题。我们要找到翻转次数为奇数的灯，可以先考虑这么一个问题，若第m轮翻转了第i盏灯，说明i肯定是m的倍数，即存在整数n满足m*n=i，这也就意味着在第n轮的时候这盏灯又会被再翻转一次。那什么时候会只翻转奇数次呢？仔细一想不难发现，只有i为完全平方数时才有可能，此时存在m*m=i，就会有一轮翻转没有与之对应的另一轮翻转，翻转次数就为奇数。用数学语言来描述这个结论就是：有且仅有完全平方数的因子个数为奇数。所以问题简化为求小于n的完全平方数有几个，易知这个数就是(int)(sqrt(n))，这样我们就可以写出只有一行代码的算法了~见C语言程序的方法二。AC代码C语言 - 方法一此方法直接循环判断，在LeetCode上会超时。C语言 - 方法二相关题目LeetCode 292. Nim Game (Easy)]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 292. Nim Game (Easy)</title>
      <link href="/2016/10/26/LeetCode_292/"/>
      <url>/2016/10/26/LeetCode_292/</url>
      
        <content type="html"><![CDATA[一堆石子，两个人依次从中拿1~3个，最后一个全部拿完的人获胜。给出石子数，请问先拿那个人在这种情况下是否能获胜？原始问题https://leetcode.com/problems/nim-game/You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.解题思路这题可以算一个智力题，通过简单的逻辑分析可知，当且仅当石子的数量不为4的倍数时，先拿者可以获胜，具体推理过程在此就不多说了。这样就可以写出很简洁的Java版程序。另外这题还可以用递归来解决，基本就相当于穷举所有情况，C语言版的代码就是用这种方法实现的。只是这种方法实际上是不可用的，计算时间会随n的增加而指数增加，当n=50时就需要超过10分钟才能计算出结果。最好的通用方法是使用动态规划来解决这一问题，记录每次递归的中间结果即可。AC代码C语言Java相关题目LeetCode 319. Bulb Switcher (Medium)]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治法算法复杂度</title>
      <link href="/2016/10/25/divide_conquer/"/>
      <url>/2016/10/25/divide_conquer/</url>
      
        <content type="html"><![CDATA[分治法是一种常用的算法设计技巧，二分法就是其最常见的特例。所谓分治，分而治之也：分（divide）：递归解决较小的问题治（conquer）：从子问题的解构建原问题的解一般来说，至少含有两个递归的程序才叫做分治法，只有一个递归的程序是不算的。下面来总结下分治法的算法复杂度问题，摘自《数据结构与算法分析——C语言描述》一书。假设每次递归均可把原问题分解为$b$个规模一样的子问题，并需要求解其中的$a$个问题，将这$b$个子问题的解合并起来所需的算法复杂度为$O(N^k)$，即：$$T(N)=aT(N/b)+\Theta (N^k)$$此方程的解为：$$T(N)=\begin{cases}O(N^{\log_b a}) &amp;amp; a&amp;gt;b^k\\O(N^k \log N) &amp;amp; a=b^k\\O(N^k) &amp;amp; a&amp;lt;b^k\end{cases}$$其中$a \geqslant 1, b &amp;gt; 1$这个公式的实质是分和治的过程在争夺主导地位。大部分情况下$a=b$，此时上式可以进一步简化：$$T(N)=\begin{cases}O(N^k) &amp;amp; k&amp;gt;1\\O(N \log N) &amp;amp; k=1\\O(N) &amp;amp; k&amp;lt;1\end{cases}$$一般也不存在 $k &amp;lt; 1$ 的情况，故我们可以得到一个最常用的结论：若合并复杂度为 $O(N)$, 则整个分治法的复杂度为 $O(N \log N)$ ; 若合并复杂度为 $O(N^k), k&amp;gt;1$ , 则整个分治法的复杂度就是合并复杂度。且无论将问题分为几个子问题求解，其算法复杂度相同。]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 345. Reverse Vowels of a String (Easy)</title>
      <link href="/2016/10/25/LeetCode_345/"/>
      <url>/2016/10/25/LeetCode_345/</url>
      
        <content type="html"><![CDATA[反转字符串中的所有元音字母。原始问题https://leetcode.com/problems/reverse-vowels-of-a-string/Write a function that takes a string as input and reverse only the vowels of a string.Example 1:Given s = “hello”, return “holle”.Example 2:Given s = “leetcode”, return “leotcede”.Note:The vowels does not include the letter “y”.解题思路双指针，一个left从头部开始找，另一个right从尾部开始找，若left及right均为元音，交换二者。截止条件为left &amp;gt;= right。AC代码C语言这里判断是否为元音字母使用了宏定义，以此提高运行效率。相关题目LeetCode 344. Reverse String (Easy)]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 344. Reverse String (Easy)</title>
      <link href="/2016/10/25/LeetCode_344/"/>
      <url>/2016/10/25/LeetCode_344/</url>
      
        <content type="html"><![CDATA[反转一个字符串。原始问题https://leetcode.com/problems/reverse-string/Write a function that takes a string as input and returns the string reversed.Example:Given s = “hello”, return “olleh”.解题思路直接反向复制即可。AC代码C语言相关题目LeetCode 345. Reverse Vowels of a String (Easy)]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 167. Two Sum II - Input array is sorted (Medium)</title>
      <link href="/2016/10/25/LeetCode_167/"/>
      <url>/2016/10/25/LeetCode_167/</url>
      
        <content type="html"><![CDATA[给定一个已经排序的整数集合及一个目标数，从集合中找出两个数，使其和等于目标数。原始问题https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.You may assume that each input would have exactly one solution.Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2解题思路要充分利用数组已排序的性质，使用双指针进行操作，若两数和小于目标数，增加左侧指针；若大于目标数，减小右侧指针。具体见代码。AC代码C++相关题目LeetCode 001. Two Sum (Easy)]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 001. Two Sum (Easy)</title>
      <link href="/2016/10/25/LeetCode_001/"/>
      <url>/2016/10/25/LeetCode_001/</url>
      
        <content type="html"><![CDATA[给定一个整数集合及一个目标数，从集合中找出两个数，使其和等于目标数。原始问题https://leetcode.com/problems/two-sum/Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution.解题思路最直接的思路就是直接两次循环，判断两数之和是否等于目标数。这样做算法复杂度是O(n^2)，效率很低。下面C语言版本的代码就是用这种方法实现的。另一种高效的方法是使用字典HashMap，仅需一次循环即可，算法复杂度O(n)。以题目中的Example为例，算法原理可用下图说明：添加到Map中的元素是将数组中元素值Number作为Key，而对应的数组的索引值Index作为Value的。循环过程中，先判断此数字在Map中是否存在，若不存在的话，将其互补元素（即target - nums[i]）添加到Map中，对应的值即为当前的i值；若存在的话，返回当前i值与Map[nums[i]]的值即可。具体实现见下面C++及Java版本的代码。AC代码C语言C++Java相关题目LeetCode 167. Two Sum II - Input array is sorted (Medium)]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apt与apt-get命令</title>
      <link href="/2016/10/25/apt_apt-get/"/>
      <url>/2016/10/25/apt_apt-get/</url>
      
        <content type="html"><![CDATA[apt-get是Debian及Ubuntu这类Linux发行版中最常用的软件安装命令，前几天又发现一个很相似的命令apt，也可以用于安装软件。去网上搜索了下这两个命令，整理如下。apt-get是一个传统的包管理程序，而apt似乎是Ubuntu Trusty之后才引入的一个新程序。具体讨论可参考下面这个链接：What is the difference between apt and apt-get?重点内容摘录如下：They are very similar command line tools available in Trusty. Apt-get and apt-cache’s most commonly used commands are available in apt.apt-get may be considered as lower-level and “back-end”, and support other APT-based tools. apt is designed for end-users (human) and its output may be changed between versions.The big news for this version is that we included a new apt binary that combines the most commonly used commands from apt-get and apt-cache. The commands are the same as their apt-get/apt-cache counterparts but with slightly different configuration options.一言以蔽之，apt可以视为是对apt-get及apt-cache中常用命令的二次打包封装，一般来说，可以直接使用apt来替代apt-get及apt-cache，它们之间并没有什么大的差别，而apt使用起来会更方便。apt支持以下命令操作：命令作用list列出已安装的软件包search在源索引文件中搜索软件包show列出特定软件包的详细信息install安装软件包remove移除软件包edit-sources编辑源列表update同步源索引文件upgrade升级现有软件包full-upgrade类似upgrade，只是会自动删除冲突的软件包]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 160. Intersection of Two Linked Lists (Easy)</title>
      <link href="/2016/10/25/LeetCode_160/"/>
      <url>/2016/10/25/LeetCode_160/</url>
      
        <content type="html"><![CDATA[两个链表，可能会有交叉，返回交叉点的元素，若没有交叉则返回null。原始问题https://leetcode.com/problems/intersection-of-two-linked-lists/Write a program to find the node at which the intersection of two singly linked lists begins.For example, the following two linked lists:begin to intersect at node c1.Notes:If the two linked lists have no intersection at all, return null.The linked lists must retain their original structure after the function returns.You may assume there are no cycles anywhere in the entire linked structure.Your code should preferably run in O(n) time and use only O(1) memory.解题思路若将b1节点连接到c3节点后面，此问题就转换为了LeetCode 142. Linked List Cycle II问题，可用相同方法求解，最后断开c3 -&amp;gt; b1的连接即可。LeetCode题解中就是这样做的，不过对此还可以进行优化。开始时直接设置slow及fast指针进行移动，fast指针在移动过程中会遇到null，对此进行处理即可。第一次遇到null时进行连接，若第二次遇到null则说明两个链表没有交叉。其余步骤与LeetCode 142中的做法完全一样，具体见代码。AC代码C语言相关题目LeetCode 141. Linked List Cycle (Easy)LeetCode 142. Linked List Cycle II (Medium)]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 142. Linked List Cycle II (Medium)</title>
      <link href="/2016/10/24/LeetCode_142/"/>
      <url>/2016/10/24/LeetCode_142/</url>
      
        <content type="html"><![CDATA[给定一个链表，返回链表中环的开始节点，若没有环，返回null。原始问题https://leetcode.com/problems/linked-list-cycle-ii/Given a linked list, return the node where the cycle begins. If there is no cycle, return null.Note: Do not modify the linked list.Follow up:Can you solve it without using extra space?解题思路类似LeetCode 141的解法，只是之后还要求出环开始的节点，这依赖于一些数学关系，下面来简要推导一下。如图所示，假设slow指针运动到$Y$节点时，fast指针位于环中任意位置（图中未标出），其距$Y$点的距离为$m$。首先证明当slow指针与fast指针相遇于环中某一点$Z$时，slow指针移动距离$b$小于环的长度$L$，且fast指针只会比slow指针多移动一圈。假设此时slow指针移动距离为$b$($b$ &amp;lt; $L$)，fast指针比slow指针多移动了$N$圈，则：$$b=m+2b-NL$$$$\Rightarrow b=NL-m$$$$\because 0 \leqslant b \leqslant L, 0 \leqslant m \leqslant L$$$$\therefore N = 1$$$$\Rightarrow b=L-m$$对任意$m$及$L$，均可由上式确定唯一的$b$，故原命题成立。下面在此基础上推导$a$与$c$之间的关系，应用上面得出的结论，两指针相遇时有：$$2(a+b)=a+b+KL$$式中$K$表示相遇时fast指针在环中运行的圈数。$$\Rightarrow a=KL-b$$$$\Rightarrow a=(K-1)L+L-b$$$$\Rightarrow a=(K-1)L+c$$上式意味着，若slow与fast指针相遇于$Z$点后，slow指针继续前进，同时增加一个指针p从$X$点出发，则slow与p的相遇点必定是$Y$，这也就是需要返回的节点。根据上述思路即可写出代码。AC代码C语言相关题目LeetCode 141. Linked List Cycle (Easy)LeetCode 160. Intersection of Two Linked Lists (Easy)]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 141. Linked List Cycle (Easy)</title>
      <link href="/2016/10/24/LeetCode_141/"/>
      <url>/2016/10/24/LeetCode_141/</url>
      
        <content type="html"><![CDATA[给定一个链表，确定其中是否有环。原始问题https://leetcode.com/problems/linked-list-cycle/Given a linked list, determine if it has a cycle in it.Follow up:Can you solve it without using extra space?解题思路最直接的想法是用一个集合将之前出现过的节点保存起来，之后判断新节点是否在已有节点的集合中即可，不过这种方法效率较低，而且需要很大的额外空间，并不是好方法。这个问题比较优秀的解法是，引入两个指针，一个slow指针一次前进一步，另一个fast指针一次前进两步，这两个指针相遇即是存在环的充要条件。AC代码C语言Java这里用了一种比较特殊的写法，使用了try...catch...语句块进行异常捕捉，当fast.next.next遇到null时即会发生异常，此时意味着到达了链表结尾，链表中不存在环，故返回false。相关题目LeetCode 142. Linked List Cycle II (Medium)LeetCode 160. Intersection of Two Linked Lists (Easy)]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 415. Add String (Easy)</title>
      <link href="/2016/10/24/LeetCode_415/"/>
      <url>/2016/10/24/LeetCode_415/</url>
      
        <content type="html"><![CDATA[给定两个字符串表示的非负整数，求其和，结果也用字符串表示。原始问题https://leetcode.com/problems/add-strings/Given two non-negative numbers num1 and num2 represented as string, return the sum of num1 and num2.Note:The length of both num1 and num2 is &amp;lt; 5100.Both num1 and num2 contains only digits 0-9.Both num1 and num2 does not contain any leading zero.You must not use any built-in BigInteger library or convert the inputs to integer directly.解题思路从最低位开始逐位相加即可，注意处理进位。网上搜索到的AC代码处理进位一般都使用/10及%10的方法：此方法代码简洁，不过效率很低，因为除法和取模开销会很大，故此处使用了其他方法进行处理，具体见下面的代码。AC代码C语言sumStr数组是一次性申请分配了全部所需空间，不需要动态扩容，这样做效率很高。不过这段代码有个小瑕疵，最后去除首位不需要的0时直接使用了sumStr++，这会导致一个字节的内存泄漏问题。C++这里使用了C++风格的string操作，用+=连接新加入的字符，最后用reverse()函数翻转字符串。显而易见，这样做的效率没有C语言版本高。]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM架构及内核</title>
      <link href="/2016/10/20/ARM_Architecture_Core/"/>
      <url>/2016/10/20/ARM_Architecture_Core/</url>
      
        <content type="html"><![CDATA[一般的ARM芯片都会涉及到以下一些概念：芯片型号、ARM内核名称、指令集名称等等，这些概念间既有联系也有区别。本文简要梳理下这些不同的概念，并选择一些我接触过的芯片进行下总结。一个比较完整的ARM产品线列表可参考Wikipedia页面：List of ARM microarchitectures基本概念ARM产品家族即ARM Family，就是ARM公司不同的产品系列，这个分类主要是从市场及销售角度进行的划分。1985年，ARM公司研发出未量产的第一代产品ARM1，之后陆续推出了ARM2、ARM3、ARM6三个系列的产品，不过这些产品基本都是没人知道的。直到1997年，ARM推出ARM7T系列产品，这才标志着ARM大规模商用推广的开始，2000年左右推出的ARM9T及ARM9E系列更成为了ARM公司里程碑式的经典产品。之后的ARM还推出了ARM10E及ARM11这两个系列。不过估计是觉得这样的命名太混乱了，不利于市场推广，在2005年左右，ARM将其新推出的所有CPU分为3大家族，这就是现在广为人知的Cortex-A、Cortex-M及Cortex-R系列，到目前为止10多年来都沿用了这一名字没有变过。其中Cortex-A定位于对计算性能要求较高的Application领域；Cortex-M定位于低功耗、低成本的微控制器Microcontroller领域；Cortex-R定位于对安全、实时性要求较高的Realtime领域。不知将来ARM的新产品会不会换个名字呢？毕竟现在的市场局势和10年前相比有了很大的变化，而且ARM还被软银收购了……我们拭目以待。ARM架构名称即ARM Architecture，就是指一套处理器体系结构及其对应的指令集等，这是从技术层面进行的划分，架构的升级就意味着产品的更新与迭代。架构与处理器家族系列间并不存在一一对应的关系，比如ARM7T与ARM9T系列使用的就是相同的ARMv4T架构，而Cortex-A系列中包含了ARMv7-A及ARMv8-A两种架构。除了基础架构外，ARM还会用后缀表示功能增强的衍生架构，比如E后缀代表DSP指令集增强（ARMv5TE）、J后缀代表Jazelle加速技术（ARMv5TEJ）等。目前最新的架构为ARMv8-A。关于ARM架构的详细信息，可参考Wikipedia页面：ARM architectureARM内核名称即ARM Core，就是实际实现出来的内核名称。ARM内核包括由ARM自己设计的公版内核及由其他架构授权合作伙伴设计的第三方内核。ARM自己设计的内核包括ARM920T、Cortex-M3、Cortex-M4、Cortex-A5、Cortex-A57等诸多型号；第三方内核中，最有名的就是高通的Snapdragon系列，包括Scorpion、Krait、Kryo三种型号的内核，还有苹果自己设计的Ax系列，目前包括Swift、Cyclone、Typhoon、Twister、Hurricane等型号的内核。产品名称就是最终的SOC芯片型号，一个SOC芯片只有CPU Core是不够的，还需要很多其他外设，整合到一起最终形成一个芯片。所以很多不同型号的芯片其实是共用一个CPU Core设计的，比如STM32F4系列，包含相当多的芯片型号，不过它们的CPU内核都是一样的——基于ARMv7E-M架构的Cortex-M4内核。部分ARM芯片总结这里仅选取我接触过的和一些近期比较有名的手机芯片进行总结，按照ARM架构和ARM内核进行分类排序。芯片型号或系列厂商AMR内核ARM架构S3C2410SamsungARM920TARMv4TSTM32F0STCortex-M0ARMv6-MSTM32F1STCortex-M3ARMv7-MSTM32F4STCortex-M4ARMv7E-MK60FreescaleCortex-M4ARMv7E-MSTM32F7STCortex-M7ARMv7E-MH3AllwinnerCortex-A7ARMv7-ABCM2836Broadcom4*Cortex-A7ARMv7-AS5PV210SamsungCortex-A8ARMv7-AAM3359TICortex-A8ARMv7-Ai.MX6DLFreescale2*Cortex-A9ARMv7-ABCM2837Broadcom4*Cortex-A53ARMv8-AMT6797MTK2*Cortex-A72 + 8*Cortex-A53ARMv8-AKirin 950Huawei4*Cortex-A72 + 4*Cortex-A53ARMv8-AExynos 8890Samsung4*Mongoose + 4*Cortex-A53ARMv8-ASnapdragon 820Qualcomm4*KryoARMv8-AA10Apple4*HurricaneARMv8-A]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>diff及patch的使用</title>
      <link href="/2016/10/19/Diff_Patch/"/>
      <url>/2016/10/19/Diff_Patch/</url>
      
        <content type="html"><![CDATA[Linux下，diff命令用于比较两个文件的差异，也可用于创建补丁文件，而patch命令用于打补丁，也就是应用diff命令生成的补丁文件更新现有文件。下面简要总结下这两个命令的使用方法。diff基本用法注意：diff命令是按行比较两个文本文件的，所以一般只用它比较两个基本相同的文本文件，如同一份源代码的不同版本。输出格式diff一共有3种输出格式：正常格式（normal diff）上下文格式（context diff）合并格式（unified diff）一般使用合并格式，这种格式比较适合阅读，加上-u参数即可：关于diff的输出格式详细说明可参考：读懂diff创建补丁文件所谓的补丁文件其实就是diff的输出，将其重定向至文件即可，生成的补丁文件习惯上使用.patch后缀。常用参数如下：其中：-r: 递归遍历子目录-u: 使用合并格式输出-a: 将所有文件视为文本文件-N: 将未出现的文件视为空文件（比较目录时有用）oldfile及newfile可以是一个目录，配合-r参数使用就会递归比较这两个目录。示例下面用一个例子来说明。有以下文件目录：old文件夹中存放的是老版本，new中是新版本。使用以下命令生成补丁文件：生成的update.patch文件如下：需要注意的是，使用如下命令也可以生成补丁文件：但是生成的补丁文件是不一样的：差异在于文件路径不同，这会导致之后使用patch打补丁时所需的命令有所区别，下文再讨论这一问题。patch应用补丁一般不需要指定需要打补丁的文件，这个可以从patchfile中自动推导出来，就是文件中---部分的oldfile，patch命令会自动将newfile中的变更应用于oldfile上。回滚补丁回滚补丁的意思是在对oldfile应用了补丁后，又需要取消这个补丁，即回滚到oldfile原始的状态。移去路径级别上面的用法中均是假定patchfile中的路径是正确的，然而很多时候这个路径会包含不需要的目录级别，这时就需要用-pNum参数来移去多余的路径级别：这里的Num是一个数字，如-p1、-p2等。p级别告诉patch命令忽略掉路径名的前几个部分以正确的识别文件，总的来说，从路径最开始删除路径分隔符（/）及其之前的所有字符，每次加1，直到剩下的部分存在于当前工作目录中，最后得到的就是p级别。 具体使用方法见下文的示例。示例接着上文diff命令中的示例进行，此时我们已经有了补丁文件update.patch，下面来应用这个补丁，使用以下命令即可：这样既可将old文件夹中的内容更新为new文件夹中的内容。如果需要回滚补丁，即恢复old文件夹中的原始内容，使用以下命令：不过针对update2.patch文件，如果直接使用上述命令打补丁会报错：此时可以手动输入对应文件的路径./old/1.txt，然而这并不是一个好方法，正确的方法是使用-pNum参数：-p1表示去掉第一层路径分隔符，即./，此时得到的old文件夹位于当前路径中，于是就可以正确的打补丁了。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更换博客主题啦~</title>
      <link href="/2016/10/13/Blog_New_Theme_2016/"/>
      <url>/2016/10/13/Blog_New_Theme_2016/</url>
      
        <content type="html"><![CDATA[前几天看到MOxFIVE的博客，很喜欢博主基于Yilia主题制作的的Yelee主题，于是先是折腾了一天，把搜索功能移植过来了；之后又想把层叠目录也移植过来，又是一天折腾，然而最终也没有成功:(后面一想，不如直接就用博主的Yelee主题吧，于是又是一天折腾，把主题由Yilia更换成了Yelee，并且根据自己的需求修改了此主题，做成了现在这个相对比较满意的效果~~之后尽量不再折腾这些了，还是好好学习嵌入式做项目更重要……]]></content>
      
      
      <categories>
          
          <category> 点滴之间 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>旋转编码器速度测量方法</title>
      <link href="/2016/10/13/Encoder_Velocity_Measure/"/>
      <url>/2016/10/13/Encoder_Velocity_Measure/</url>
      
        <content type="html"><![CDATA[大部分旋转编码器均产生两路正交的输出信号，即A相与B相；部分旋转编码器还有一个Z相输出，其主要作用是进行定位，以确定零点位置。通过A、B两相信号就可以确定转速和转向。旋转编码器的结构及其输出信号形式如下图所示：从原理上来说确定转速有两种方法：$$v(k)\approx \frac{\Delta X}{T}\ \ \ \ \ (1)$$$$v(k)\approx \frac{X}{\Delta T}\ \ \ \ \ (2)$$式(1)固定时间周期，测量在一定时间内的脉冲个数，进而计算出速度。这种方法中，可以认为时间是准确的，不过脉冲数是有误差的；式(2)固定脉冲数，测量一定脉冲数所需的时间，进而计算出速度。这种方法中，可以认为脉冲数是准确的，而时间是有误差的；一般来说，方法(1)适用于高速情况，而方法(2)适用于低速情况。而且定时器的精度一般都高于旋转编码器，故方法(2)的精度一般要更高一些。对于方法(2)，针对TI C2000系列DSP，我编写了一个简易Excel表格用于计算QCPDR、溢出次数、误差和同等情况下使用方法(1)所需的周期T，可以从这里下载。]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor </tag>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为Hexo博客Yilia主题添加本地站内搜索功能</title>
      <link href="/2016/10/10/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2Yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
      <url>/2016/10/10/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2Yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[博客的站内搜索功能一直是一个缺憾，最初使用了Swiftype，虽然效果不是很理想，不过也正常使用了一段时间，然而之后发现使用Swiftype会导致博客标签加载不完全，进而影响正常显示。奈何我基本不懂前端，瞎折腾了很久也没能解决这个问题，最后只得禁用了Swiftype，留下的搜索框成了一个摆设。前段时候发现Hexo博客可以使用本地站内搜索，于是又折腾了一天，然而最终还是没有做出可用的搜索界面来：(本来已经不抱什么希望了，今天偶然看见让 Hexo 博客支持本地站内搜索这篇文章，作者使用的主题也是基于Yilia的，顿时觉得有戏，于是又是一天折腾，终于做出了个像样的站内搜索功能来了~~写篇文章记录下折腾过程。生成索引文件安装插件本地站内搜索都是基于索引文件的，Hexo中可通过hexo-generator-search插件生成XML格式的索引文件，通过hexo-generator-json-content插件生成JSON格式的索引文件，此处选择了hexo-generator-search:然后在Hexo站点根目录下的_config.yml中添加如下配置即可：修改插件默认生成的search.xml文件很大，而且包含很多冗余信息，参考完美解决Hexo静态博客搜索问题这篇文章对其进行精简。首先在修改node_modules/hexo-generator-search/index.js文件，在其中添加3个函数：Netcan的文章中是去除代码行数，此处改成了去除所有代码，因为一般无需对代码进行搜索。之后修改模板文件search.ejs，主要目的是调用上面添加的3个函数对实际内容进行精简，修改&amp;lt;content type=&amp;quot;html&amp;quot;&amp;gt;标签中的内容即可：精简后，生成的search.xml文件体积可缩小为原来的1/3.Update 2018-01-21:目前新版的hexo-generator-search插件模板文件位置有所改变，改为了templates/xml.ejs文件，修改方法不变。界面结构及样式添加HTML代码搜索框沿用了之前Swiftype的搜索框，放在侧边栏的最上方，这个比较符合我的审美。参考MOxFIVE的做法将搜索结果也放在侧边栏中，没有添加搜索重置按钮。修改left-col.ejs文件，在其中添加相关代码：修改CSS样式CSS样式直接使用了MOxFIVE的样式（去掉了其中用不到的部分），在style.styl文件中添加以下代码：其中input.st-default-search-input是Swiftype提供的搜索框样式。添加侧边栏滚动条Yilia主题的侧边栏是不会添加滚动条的，这就会造成搜索结果显示不完全，需要修改main.styl文件：Javascript功能代码参考MOxFIVE的代码，进行了以下修改：修改搜索框的名称以便和HTML代码配套；去除重置搜索按钮相关代码；不在新标签页中打开搜索结果；搜索结果URL链接去掉主域名，使用相对路径表示；保持搜索结果中标题大小写格式；对搜索结果相关度进行了打分，根据关键词出现的次数进行排序首先在pc.js文件中添加以下代码：代码详细说明见MOxFIVE的文章。新建source/js/search.js文件：其中打分排序标题中出现的关键词计30分，内容中的关键词一个计1分，总分越高意味着相关度越高，排在越前面。实际效果可直接使用文章左侧边栏上的搜索框进行体验，总体来说还是很令人满意的，至此终于搞定了站内搜索问题啦~~]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于科学与工程</title>
      <link href="/2016/09/30/%E5%85%B3%E4%BA%8E%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B/"/>
      <url>/2016/09/30/%E5%85%B3%E4%BA%8E%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[偶尔也写点非技术的文章吧~我们很多工科学生将来都会成为工程师，而像我本科所学的化学专业则是以培养科学家为己任，那科学与工程是何关系呢？一言以蔽之，工程是科学有选择性的应用，Engineering is the purposeful use of science. 最早听到这句话是大一的时候在看MIT的公开课电路和电子学时，第一集中，Agarwal教授高屋建瓴的分析了这门课程在整个知识体系中的地位。从麦克斯韦方程组出发，引入一些约束条件后，得到了集总元件抽象（LMP)，也就是电路理论的基础。在这里，麦克斯韦方程组就是科学，它描述的是自然的运行规律；而电路理论则是工程，它是人类根据需要对麦克斯韦方程组进行了有选择性的应用后得到的理论。所以说，科学是工程的基础，工程是科学的结晶。科学与工程所追求的目标并不那么相同，从本质上来说，工程的目的是应用、是设计、是创造；而科学的目的是探索、是求真。正因为如此，工程很多时候是一门平衡的艺术，我们需要综合考虑各种技术和非技术因素，最终以技术为手段，去实现一个特定的目的。因为实现某一目的是一个确定的目标，所以说，工程是以结果为导向的，而科学，其实并不该以结果为导向，科学是对真理的探求，其原动力是对未知世界的好奇。刘慈欣有一部很好的短篇小说，叫《朝闻道》，取“朝闻道，夕死可矣”之意，其中对何谓真正的科学精神做出了一个我很欣赏的诠释——科学其实并没有什么目的，科学本身就足以让人着迷了，不是吗？工程是实现一个特定的目的，这个目的通常是一个“有价值”的目的，比如能创造经济效益一类的。不过一个优秀的工程师往往并不局限于做这些“有价值”的事，也会出于兴趣、出于好玩等目的去做一些“没有价值”的事。之前看过无人机大神Raffaello D’Andrea的一个TED演讲，Raffaello在其中展示了各种令人惊叹不已的炫酷控制技术。不过，研究制作这些无人机技术有什么用呢？事实是这并不能马上创造什么商业价值，不过在演讲的最后，Raffaello说了这样一段话：The reality is that it is difficult to predict the impact of nascent technology. And for folks like us, the real reward is the journey and the act of creation. It’s a continual reminder of how wonderful and magical the universe we live in is, that it allows creative, clever creatures to sculpt it in such spectacular ways.是啊，创造本身不就是有趣而有价值的吗？从这个角度上看，工程和科学又是那么的相像。那工程师又是怎样的人呢？之前在知乎上看过这样一句精彩的总结，“Engineers are versatile minds who create links between science, technology, and society”, 工程师们将科学、技术与社会相连接，从生活中发现问题、从社会中洞察需求，之后以技术为手段，以科学为基石去设计出解决方案，以此满足普罗大众的需求，创造人类更美好的明天。这也就是将来我所追求的了吧，从一个具体的环节做起，扩宽自己的深度与广度，之后以技术为工具，带领着更多人去实现更大的目标——突破现有的产品，创造出更好的产品，实现自身的价值。毕竟，对于一个工程师而言，自己设计出的东西能惠及越多的人，自身的成就感也就会越强吧~]]></content>
      
      
      <categories>
          
          <category> 人生之思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Android Studio中使用Lambda表达式</title>
      <link href="/2016/09/26/%E5%9C%A8Android%20Studio%E4%B8%AD%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2016/09/26/%E5%9C%A8Android%20Studio%E4%B8%AD%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[Lambda表达式是Java 8中的一个重要新特性，使用Lambda表达式可以简化很多代码，比如常见的为一个按键添加点击事件Listener的代码：其中有用的代码很有可能只有一行，其他部分其实都没有实际意义，只是语法需要，创建了一个匿名类而已。但是，如果使用Lambda表达式之后，上述代码就可以简化为：如果只有一行代码还可以进一步简化为：可以看到，使用了Lambda表达式后可以让程序代码更加优雅简洁。关于Java 8中的Lambda表达式详情，可参考以下几篇文章：Java8 lambda表达式10个示例Java 8新特性：lambda表达式然而遗憾的是，Android Studio中的Java版本被限制在了Java 1.7以下，与系统中安装的JDK版本无关，也就是就算安装了JDK 1.8也无法使用Java 8的新特性。不过我们依然可以通过一些方法来使用Lambda表达式的，主要方法有两种，下面将分别介绍。RetroLambdaRetroLambda是一个Gradle插件，用于实现让低版本的Java（Java 1.7、1.6、1.5等）支持Lambda表达式。做所周知，Android Studio使用的就是Gradle，Gradle Retrolambda插件的官方Github网站及使用说明见这里。在Android Studio中的使用步骤如下：1.安装JDK 8。2.在项目的build.gradle文件中添加以下代码：3.在工程模块的build.gradle文件中添加以下代码：4.在proguard-rules.pro文件中添加以下代码：5.还可以对Retrolambda进行一些配置，具体见Github页面的说明注意事项：retrolambda的版本这里选择了3.3.0，这是目前的最新版本，不过之后肯定会有新版本的，可以根据Github上的说明替换为最新版本。配置完成后第一次编译时，Android Studio中的Gradle不能配置为Offline模式，否则会提示错误：因为上述配置只是指明了需要使用me.tatarka:gradle-retrolambda:3.3.0，此时还需要联网下载retrolambda，若配置为离线模式是无法正常下载的。不过只要编译成功一次之后，retrolambda就会被下载到缓存中，此时就可以了改回Offline模式了。JackJack是Java Android Compile Kit的缩写，它是Google为Android推出的一个全新的Java编译工具链。关于Jack的详细信息可参考以下链接：Android 新一代编译 toolchain Jack &amp;amp; Jill 简介Compiling with Jack使用Jack也是Google官方给出的支持Java 8特性的方法：Java 8 语言功能要在Android Studio中使用Jack并开启Java 8，只需要在工程模块的build.gradle文件中添加以下代码：使用Jack后，除了支持Lambda表达式外，还可以支持更多的Java 8新特性。不过实际测试下来，使用Jack有两个很大的缺陷：首先，Jack的编译速度明显要慢很多，而且似乎每次都要从头全部重新编译一次，同样的工程编译所需的时间是原来的5~10倍；其次，使用Jack后就无法使用Instant Run功能了，Instant Run是一个很好用的功能，在修改程序后重新推送到设备运行时不需要再次安装apk文件，基本马上就可以看到更改后的变化，这可以大幅提升工作效率。然而目前版本的Jack并没有支持Instant Run。考虑到Jack这两个缺陷实在会严重降低工作效率，在目前看来使用Jack还不是一个很好的选择。如果要使用Lambda表达式，RetroLambda是一个更好的选择。]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架</title>
      <link href="/2016/09/16/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2016/09/16/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[Java中提供了丰富的容器类用于存储数据，这些容器类可分为两大类：Collection和Map，Collection用于保存单个元素，而Map则以键值对的形式进行存储，就像一个小型数据库一样。Collection中又可分为List、Set、Queue三类，其中List是列表，Set是集合，Queue是队列。整个Java集合框架的结构图如下：网上能找到的图都不是很全面，故我根据最新版的JDK 8文档绘制了此图。图中并没有包含所有的接口与类，仅仅只是最常用的部分，这些部分均位于java.util包中。图中蓝色的实现类就是我们实际可以直接使用的容器类了。JDK帮助文档中还有一张各接口与存储形式的对照表，摘录如下：InterfaceHash TableResizable ArrayBalanced TreeLinked ListHash Table + Linked ListSetHashSet-TreeSet-LinkedHashSetList-ArrayList-LinkedList-Deque-ArrayDeque-LinkedList-MapHashMap-TreeMap-LinkedHashMap上表中加粗显示的就是最常用的实现类，一般情况下选择这几个就可以了。接下来将各接口最常用的一些方法整理总结一下。Collection接口所有的List、Set、Queue均支持以下方法：|Function Name||–|–|–||size()|isEmpty()|contains()||add()|remove()|iterator()||toArray()|clear()|forEach()|Iterator接口|Function Name||–|–|–||hasNext()|next()|remove()|List接口在Collection接口的基础上添加了以下方法：|Function Name||–|–||get()|set()||add(int,E)|remove(int)||indexOf()|lastIndexOf()|ListIterator接口在Iterator接口的基础上添加了以下方法：|Function Name||–|–||add()|set()||hasPrevious()|previous()|Set接口Set接口没有添加新方法，与Collection接口中的相同。添加到Set中的类一般都要覆盖实现hashCode()及equals()函数。SortedSet接口在Set接口的基础上添加了以下方法：|Function Name||–|–|–||subSet()|headSet()|tailSet()||first()|last()|添加到SortedSet中的类需要实现Comparable接口。Deque接口在Collection接口的基础上添加了以下方法：|Function Name||–|–||addFirst()|addLast()||removeFirst()|removeLast()||getFirst()|getLast()|Map接口常用函数有：|Function Name||–|–|–||put()|get()|remove()||size()|isEmpty()||containsKey()|containsValue()||keySet()|values()|添加到Map中的Key类一般都要覆盖实现hashCode()及equals()函数。SortedMap接口在Map接口的基础上添加了以下方法：|Function Name||–|–|–||subMap()|headMap()|tailMap()||firstKey()|lastKey()|SortedMap是按照Key来进行排序的，要求Key需要实现Comparable接口。Arrays类用于支持数组操作，常用静态函数有：|Function Name||–|–|–||asList()|binarySearch()|copyOf()||equals()|fill()|sort()|Collections类用于支持集合框架的通用算法，常用静态函数有：|Function Name||–|–|–||sort()|binarySearch()|copy()||shuffle()|fill()|reverse()|关于各种容器类的具体介绍与使用方法，可参考官方的Tutorial：Trail: Collections以下几个链接也可供参考：Java 集合框架Java集合类: Set、List、Map、Queue使用场景梳理Java集合类详解]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大公约数算法</title>
      <link href="/2016/08/22/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%AE%97%E6%B3%95/"/>
      <url>/2016/08/22/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[两个（或更多个）整数的最大公约数（Greatest Common Divisor, GCD）是指能同时整除它们的最大正整数，求解最大公约数最常用的算法是辗转相除法（又称欧几里得算法）及Stein算法，至于直接穷举的暴力算法，因为过于低效，实际中是不会使用的。下面来总结下这两种方法。问题描述给定两个正整数M和N，求其最大公约数。函数原型：调用此函数时保证M≥N&amp;gt;0。辗转相除法辗转相除法的介绍可见维基百科，其理论基础就是下面这个公式：GCD(M, N) = GCD(N, M%N)此公式的证明在此不做介绍，直接给出算法实现：上述算法可以进一步优化，算法中使用了一个中间变量Rem，它用于交换两数，其实这是没有必要的。注意到：GCD(M, N) = GCD(N, M % N) = GCD(M % N, N % (M % N))在第一步计算出M % N后，保留N的值其实是没有必要的，可以直接跳过这一步，使用最后一个式子进行计算即可：因为这相当于计算了2次，截止条件变为M和N中的任意一个为0，否则就会出现%0这样的错误。返回结果是M和N中不为0那个，不过由于另一个数为0，可以用M + N替代。这样就可以写出代码：如此简单而优雅！Stein算法此算法又被称为Binary GCD algorithm，它是针对欧几里得算法的一些缺陷提出的。欧几里德算法是计算两个数最大公约数的传统算法，无论从理论还是从实际效率上都是很好的。但是却有一个致命的缺陷，这个缺陷在素数比较小的时候一般是感觉不到的，只有在大素数时才会显现出来。一般实际应用中的整数很少会超过64位（当然现在已经允许128位了），对于这样的整数，计算两个数之间的模是很简单的。对于字长为32位的平台，计算两个不超过32位的整数的模，只需要一个指令周期，而计算64位以下的整数模，也不过几个周期而已。但是对于更大的素数，这样的计算过程就不得不由用户来设计，为了计算两个超过64位的整数的模，用户也许不得不采用类似于多位数除法手算过程中的试商法，这个过程不但复杂，而且消耗了很多CPU时间。对于现代密码算法，要求计算128位以上的素数的情况比比皆是，设计这样的程序迫切希望能够抛弃除法和取模。由J. Stein 1961年提出的Stein算法很好的解决了欧几里德算法中的这个缺陷，Stein算法只有整数的移位和加减法。算法的理论和实现方法在此从略，此处仅摘录一下实现代码以供参考，引用自WiKi。递归实现：非递归实现：扩展问题如果需要求多个数的最大公约数，可以先求出任意两个数的最大公约数，然后再求此数与其它数间的最大公约数，即有以下等式成立：GCD(a, b, c) = GCD(a, GCD(b, c)) = GCD(c, GCD(a,b))由此，易写出求N个数最大公约数的算法：求出最大公约数的同时也就得到了最小公倍数（Lowest Common Multiple, LCM），二者存在以下关系：GCD(M, N) * LCM(M, N) = M * N故易得：]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最大连续子序列和问题</title>
      <link href="/2016/08/20/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2016/08/20/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[最大连续子序列和问题是一个经典的算法问题，在”Data Structures and Algorithm Analysis in C”一书第2章中介绍了此问题，并给出了复杂度从O(n^3)至O(n)的4种解法，这里对此问题稍作扩展总结一下。问题描述给定一个数字序列，求出其最大连续子序列和，并给出对应的区间。如给定{-2, 11, -4, 13, -5, -2}，最大子序列和为20，对应的区间为[1, 3]。（下标从0开始）输出区间中至少包含一个元素，即若输入的数全部为负数，需输出最大的那个负数。若有多个子序列和相同，返回任意一个子序列区间即可。函数原型：其中left及right为输出区间。注：原始问题中，不需要输出对应区间，且若均为负数输出0，此处进行了一些扩展。O(n^2)算法直接循环求解，代码如下：O(nlog(n))算法二分法递归求解，分成左半部分和右半部分分别求解，有三种可能：最大序列位于左半部分；最大序列位于右半部分；最大序列位于中间。只需要解决最大部分位于中间的情况即可。算法如下：O(n)算法只循环一遍，逐个累加，若累加结果为正，说明需要保留，若结果为负，说明需要丢弃。在这个算法中，数据顺序输入，且无需保留，是解决此问题最完美的算法。代码如下：注：当序列中有0的时候，上面几个算法输出的区间并不相同相关文章：算法探讨——再议经典算法问题：求最大子序列和、绝对值最大子序列和以及其区间程序员编程艺术：第七章、求连续子数组的最大和最大连续子序列和]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C标准库学习笔记(1)——time、ctype、stdarg、assert</title>
      <link href="/2016/08/02/C%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94time%E3%80%81ctype%E3%80%81stdarg%E3%80%81assert/"/>
      <url>/2016/08/02/C%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%E2%80%94%E2%80%94time%E3%80%81ctype%E3%80%81stdarg%E3%80%81assert/</url>
      
        <content type="html"><![CDATA[这一系列文章是对P.J. Plauger所著的《C标准库》（The Standard C Library）一书的学习笔记，此书是关于C标准库的经典著作，讲述了每一个库函数的使用方法和实现细节。C语言标准库是最顶尖程序员的智慧结晶，要深入理解其实现细节自然也是很困难的……这里记录一下阅读这本书的收获，跳过了其中不常用或太复杂的部分（stddef.h、float.h、limits.h、errno.h、setjmp.h、signal.h、locale.h、math.h）。需要注意的是，目前实际使用的Glibc或uClibc中的代码比书中描述的要更为复杂，而且实现机理也不尽相同，不过基本大同小异，所以此处主要是学习思想而不是具体的代码。相关文章：C语言标准库总结time.h日期和时间操作。需要特别注意的是，书中使用的time_t时间戳标准是从1900年1月1日午夜开始的，这与目前广泛使用的UNIX时间戳不一样，也和Glibc的实现不一样，书中是通过_TBIAS这个宏定义偏置量来解决这个问题的，为了简单起见，此处对此进行了改写，忽略了偏置问题，直接将其修改为与UNIX时间戳一样。使用方法通常使用time(NULL)获取一个time_t类型的UNIX时间戳，这一般是一个32位整数(signed int)，指的是从1970年1月1日午夜至今的秒数，大约可以表示到2038年。如果要获取更精确的时间，可使用clock()函数。其余函数用于在几种不同数据结构间进行转换，根据需要选取即可，其中tm类型的定义一般是这样的：需要注意的是，以上只是time_t的最小实现，实际Glibc 2.23版本的代码中除了上述成员外还添加了其它字段。**tm_year是从1900年开始的，并不是和UNIX时间戳相同的1970年。**实现方法time()和clock()函数是依赖于具体实现的，此处不作分析。difftime()函数返回两个时间戳之间的差值，考虑到time_t可能会被定义为无符号整数，故需要先比较二者的大小：tm与time_t间的转换函数是&amp;lt;time.h&amp;gt;中的重点，这里主要来看一下gmtime()和mktime()的实现方法。下列代码在书中给出的代码基础上进行了些改写，主要是做了些精简，没有考虑夏令时等问题。虽然以下两段代码比Glibc中的实现要简单得多，不过经测试完全可以正常使用。需要指出的是，上面这个mktime()函数没有考虑时区的问题，而标准的mktime()函数实现的是将由tm表示的地方时转换为time_t表示的GMT时间，所以二者并不等价。在1970~2038年这个范围内，闰年规律符合简单的4年一闰，所以可以用(year &amp;amp; 0x03) == 2来进行闰年判断。其余asctime()、ctime()等函数用于返回格式化的时间字符串，其原理和sprintf()等函数大同小异，在此不作分析。ctype.h包含字符测试及大小写转换函数。使用方法提供了若干isxxxx()函数用于判断字符类型，并提供了大小写转换函数，具体函数列表见：C语言标准库总结需要说明的是，字符集的具体定义和区域设置有关，不过常用的就是英文的情况，因为这些函数也无法处理中文编码。另外，函数接受的参数是一个int类型的整数，不过只有unsigned char类型所能表示的值加上EOF宏定义的值（一般为-1）是有效的，传入其它值的行为是未定义的。实现方法出于效率考虑，标准库中的实现方法是基于转换表的，这里不列举具体使用的转换表了，仅描述一下设计思路。首先将整个字符集合划分为若干个合理设计的子集，如数字（09）、小写字母（az）、大写字母（A~`Z`）等，每一类用一个比特位来表示，这样就可以得到如下宏定义：任何一个字符都属于某一子集（或某几个子集）中，这样就可以根据以上宏定义得到这个字符的编码了，将全体字符编码构成一个数组，这就是所谓的转换表，书中这个数组的名字叫做_Ctype。这样一来，要判断某个字符是否属于某个子集就很简单了，只要检查这个字符在转换表中对应值的特定位是否被置位了就可以了，比如检查一个字符是否是大写字母：大小写间的转换也是基于转换表的，这个转换表相当于在原始ACSII表的基础上将大写字母替换为小写字母（或相反）得到的。关于区域编码的问题此处从略。stdarg.h用于处理可变参数。使用方法可变参数函数的定义类似这样：必须要有至少一个固定参数，习惯上把最后一个固定参数叫做parmN。在函数中先调用va_start()初始化va_list，之后就可以通过va_arg()依次获取各参数，最后调用va_end()即可。需要注意的是，在可变参数中，应用的是“加宽”原则，也就是float会被扩展成double，char、short等会被扩展成int，也就是说，函数中只该使用以下这些表达式：实现方法这里给出的代码是简化版代码，没有考虑存储空隙及对齐问题，仅用来说明基本原理。assert.h提供断言。使用方法在需要使用断言的地方加入assert(x)即可，x是一个int，若x为零断言成立，此时程序会向标准错误流输出一条包含出错行号等的错误信息并调用abort()函数终止程序的运行。assert(x)返回void。一般只有在程序调试时才需要终止程序运行，发布时应该去掉这个功能，为实现这一目的，可通过定义NDEBUG这个宏来实现，一般使用编译器预定义。实现方法为了对NDEBUG作出正确回应，头文件的基本结构如下：其中active form的定义如下：_Assert()是一个隐藏库函数，用于调用&amp;lt;stdio.h&amp;gt;中的其它库函数输出错误信息并调用abort()函数，这个很简单，没有什么问题，上述代码的关键在于后面几行宏定义上。__FILE__及__LINE__这两个宏是由编译器定义的，代表当前文件名及当前代码行号，__FILE__是一个字符串，而__LINE__是一个十进制整数。_STR()及_VAL()这两个宏神奇的实现了将一个整数常量转换为字符串字面量的功能，二者缺一不可，也就是说，下面这个写法是错误的：使用这个写法的话，_STR(__LINE__)得到的是&amp;quot;__LINE__&amp;quot;而不是期望的结果。另外，_STR()及_VAL()这两个宏就是一般的宏，其名字没有任何特殊之处，改成aaa()一类的依然可以正常使用。至于这两个宏到底为何能起到这样的作用，想了很久也没有想清楚……只有留待将来哪时候能不能理解清楚了。最后一句宏定义还涉及到一个字符串常量拼接操作，这也是我之前不知道的……要是想把几个字符串常量拼接起来，直接将其写在一起就可以了，中间不需要也不能用+一类的符号进行连接。最后还有个神奇的#符号，书中叫做字符串创建操作符，这个符号可以起到把大多数信息转成字符串字面量的作用，最重要的是，这个符号似乎只能用于宏定义中，如下面这段程序是完全正确的：然而改成这样就是错误的了：考虑到预处理命令都是以#开头的，#本身应该也算是一个预处理指令，所以并不能直接用于程序中。Update 2017-10-06:以上用法都是C语言本身的特性，现在终于能很好的理解清楚了，详见：C语言中的字符串字面量连接深入理解C语言中宏定义]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python实现网站变化监测系统</title>
      <link href="/2016/07/26/%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E5%8F%98%E5%8C%96%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F/"/>
      <url>/2016/07/26/%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E5%8F%98%E5%8C%96%E7%9B%91%E6%B5%8B%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[很多时候我们都有监测某个网站变化的需求，比如是否发布新通知了，是否有新更新了等。之前使用过Chrome的几个插件来实现这个功能，不过用起来都觉得不是很方便，于是就想自己用Python写一个，之后将程序部署在服务器上即可实现24小时自动监测了。用了几天时间写了个还算可以用的程序出来，可以实现以下功能：定时去检查网站的某页面（或某几个页面），获取此时发布的信息，并与数据库中的数据对比，如果检测到新发布的信息，则将其加入数据库中，并通过微信公众号进行自动发布；可以实现关键词过滤功能，检查发布信息标题及内容页是否有指定关键词，如果没有的话忽略此信息；实现了一个相对比较通用的程序架构，可以很方便的向其中添加新网站。项目已上传至GitHub：https://github.com/g199209/Spider这个系统其实和爬虫所用的技术基本是一样的，下面来总结下此系统的实现方法。主程序主程序为Spider.py，使用时运行此程序即可，此脚本执行过程伪代码如下：首先初始化日志及网站列表，之后进入死循环，依次从网站列表中取出各网站，检查是否有更新及发布新消息，若此过程发生异常需进行处理，最后挂起一段时间进行下一次循环。此处的网站列表是各网站实例化对象的一个List，如果要添加新网站在此List中增加新元素即可。WebsiteBase类WebsiteBase类是所有网站类的基类，其中抽象了所有网站的共性行为，此类本身不能实例化，只能用于继承。WebsiteBase类中的公用接口函数只有3个：下面分别说明这3个函数的实现。构造函数__init__()的执行流程伪代码如下：进行微信发布时需要用到的corpid及corpsecret在此处从文件中读取得到。用于发布新消息的Update()函数的执行流程伪代码如下：实际代码中还增加了很多异常处理相关的代码，此处不多说明了。用于获取网站新消息的GET()函数是此类的核心，其执行流程伪代码如下：PageRange指页面参数，有时需要访问同一个网站的若干页面，就可以通过此参数来进行循环，以简化程序代码。Enclose指感兴趣的目标区域，先进行一次筛选，去掉无用的部分以便于后续操作。Tags指只包含一条消息记录的HTML部分，一般很容易从感兴趣的目标区域中分离出每一条消息记录来，之后就可以循环对每一条消息进行处理了。对每一条消息进行处理时，先获取标题，URL地址等信息，之后先判断此条消息对应的URL之前是否访问过，要是已经访问过就跳过。Addition Check用于执行一些附加检测，如果不符合要求也跳过此条消息。如果此条消息没有被检查过，就进行关键词检查，这一步是可选的，要是没有设置关键词就跳过。检查后不符合要求也跳过此条消息，不过会将此条消息加入已检查数据库中，下次就不再检查了。最后，如果此消息通过了上述所有检查，而且是一条尚未发布的新消息，那么就将其加入待发布数据库中，之后调用Update()函数时会进行微信发布。GET()函数中包含了很多获取网页信息的方法，这些方法在此基类中都没有实现，需要具体的网站子类去实现。这类似于C++中的虚函数，不过Python中没有这个概念。具体网站子类每一个网站就是一个类，此类必须继承自WebsiteBase类，WebsiteBase类中封装了获取信息及发布信息的整个基本流程，子类中只需要实现一些与具体网站相关的方法即可，包含构造函数具体有10个。Template.py文件就是具体网站子类实现的一个模板文件，如果需要添加新网站只需要复制此文件，在此基础上进行修改即可。具体需要修改的内容可以参考Github项目中的ReadMe文档。异常处理机制因为涉及到网络连接，难免会发生超时、无法访问等各种异常，在一个良好的设计中，此时程序是不应该崩溃的，而是能跳过此异常网站继续运行其他部分，并在之后网络正常后自动恢复。而且因为这个程序是运行在服务器上的，需要在发生异常和从异常中恢复时能提示下我，以便及时去进行处理。为实现这一目的，在WebsiteBase类中设置了一个err成员用于记录错误状态，当err由False变为True时自动发送一条错误报告；当err由True变为False时自动发送一条错误恢复报告。之所以设置为边沿触发是考虑到异常可能会持续一段时间，每次都发送报告没有什么必要。另外，在WebsiteBase类中也有自己的try...except语句，这是为了当一个页面发生异常时并不是退出整个网站的处理，而是继续处理下一条消息记录。最后用raise把这个异常送至顶层进行统一处理。数据库设计每一个网站子类实例都使用了两个数据库，一个用于记录哪些URL访问过了，另一个用于记录待发布信息的状态。如果一个URL之前已经访问过了，那之后就不需要再访问了，以此优化程序的性能。而待发布信息数据库中包含了待发布的消息相关信息，还有一个Published字段用于记录此消息是否已经发布了，在GET()方法添加记录到数据库中时此字段是0，在Update()方法中会检查Published字段为0的记录依次进行发布，并将Published字段置为1。杂项微信发布使用了微信企业号，这种类型的公众号没有每天发送消息的上限，极为适合用来做消息通知。企业号的另一个特性是不能自由关注，需要提前预先加到通信录中的人才能关注，这也很适合此系统的需要。关于微信的接口，其开发者帮助中有很详尽的说明，照着操作就可以了。关于网站编码问题，有些网站用的是utf-8编码，有些用的是gb2312编码，实际测试表明，对于用gb2312编码的网站，若是不手动指定编码格式读到的就是乱码，所以还是建议都手动指定一下编码格式。和爬虫一样，如果抓取频率太高的话是有可能被网站给禁掉的，网上有一些使用代理等方法，不过最简单也是最道德的解决方案是降低抓取频率，在此系统中连续抓取频率限定为3s一次，这么低的频率和正常人类访问也差不多，一般来说是不会被禁掉的，也不会对对方网站服务器造成过大的压力。]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Python </tag>
            
            <tag> Spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式总结</title>
      <link href="/2016/07/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2016/07/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[正则表达式（Regular Expression，在代码中常简写为regex、regexp或RE）是一个字符串，此字符串用于描述、匹配一系列符合某个句法规则的字符串。正则表达式引擎是一种可以处理正则表达式的软件。通常，引擎是更大的应用程序的一部分。在软件世界，不同的正则表达式引擎并不完全互相兼容。正则表达式引擎缺省是大小写敏感的。此处总结下常用的正则表达式规则。特殊字符有12个字符被保留作特殊用途，它们是：[ ] \ ^ $ . | ? * + ( )如果要在正则表达式中将这些字符用作文本字符，需要用反斜杠\对其进行转义。在编程语言中，一些特殊的字符会先被编译器处理，然后再传递给正则引擎。因此为了匹配&amp;quot;C:\temp&amp;quot;，要用正则表达式&amp;quot;C:\\temp&amp;quot;。而在C++中，正则表达式则变成了&amp;quot;C:\\\\temp&amp;quot;。重复不加数量限定则代表出现且仅出现一次。模式含义*重复零次或更多次（任意次）+重复一次或更多次（至少一次）?重复零次或一次（至多一次）&amp;#123;n&amp;#125;重复n次&amp;#123;n,&amp;#125;重复n次或更多次（至少n次）&amp;#123;n,m&amp;#125;重复n到m次* + ? 的重复具有贪婪性，即试图匹配尽可能长的字符串。如需要非贪婪模式，即匹配尽可能短的字符串，在任意一个重复限制符后加上一个?，即：*? +? ?? &amp;#123;n&amp;#125;? &amp;#123;n,&amp;#125;? &amp;#123;n,m&amp;#125;?获取文本使用**()。(exp)**匹配exp,并将匹配到的文本缓存到自动命名的组里。命名规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。要获得之前匹配的文本，在表达式中使用”&amp;quot;加上组号的形式，如”\1”。在VS替换文本操作中，替换为的文本中如需包含原文本，使用”$”加上组号的形式，如”$1”。字符集用[]组合表示一个匹配集合，如[abc]，字符集中不区分顺序。可以使用连字符-定义一个字符范围作为字符集。在左方括号[后面紧跟一个尖括号^，将会对字符集取反，结果是字符集将匹配任何不在方括号中的字符(包括\n)，很重要的一点是，取反字符集必须要匹配一个字符。在字符集中只有4个字符具有特殊含义，它们是：] \ ^ -]代表字符集定义的结束；\代表转义；^代表取反；-代表范围定义。其他常见的特殊字符在字符集定义内部都是正常字符，不需要转义。例如，要搜索星号*或加号+，可以用[+*]。当然，如果对那些通常的特殊字符进行转义，得到的正则表达式一样正确，但是这会降低可读性。如果用?*+操作符来重复一个字符集，将会重复整个字符集，而不仅是它匹配的那个字符。选择匹配即逻辑或操作，用|把不同的规则分隔开。通常使用(?:exp1|exp2)的形式。(?:)代表匹配但不获取匹配文本。位置锚定模式含义^匹配一行字符串第一个字符前的位置，即行首$匹配字符串中最后一个字符的后面的位置，即行尾\b匹配一个单词边界，也就是指单词和空格间的位置。常用字符集模式含义.匹配任何单个字符（换行符\n除外）\d匹配任何数字字符\s匹配任何空白字符，等价于[ \f\n\r\t\v]\w匹配字母或数字或下划线或汉字最后附上一张相对完整的正则表达式规则以供参考：参考资料：WiKi - 正则表达式深入浅出之正则表达式（一）正则表达式30分钟入门教程]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Regular Expression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫--使用re正则表达式解析文本</title>
      <link href="/2016/07/20/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8re%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90%E6%96%87%E6%9C%AC/"/>
      <url>/2016/07/20/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8re%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90%E6%96%87%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[进行文本匹配等操作最合适的工具就是正则表达式了，Python中的正则表达式模块叫做re，在此总结下此模块最基本的用法。关于正则表达式本身的模式字符串的构成，参考我的另一篇文章：正则表达式总结使用正则表达式首先要导入re模块：Match对象Match对象代表一次匹配的结果，包含了很多关于此次匹配的信息，其中最重要的就是获取匹配到的字符串，一般使用group()方法：group()等价于group(0)，返回整个匹配的子串；group(num)返回第num个组对应的字符串，从1开始。输出结果为：匹配使用re.match()方法，默认从字符串起始位置开始匹配一个模式，此方法一般用于检查字符串是否符合某一规则，函数基本语法：匹配成功返回一个Match对象，否则返回None。搜索使用re.search()方法，扫描整个字符串并返回第一个成功的匹配。匹配与搜索的区别在于：re.match()只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search()匹配整个字符串，直到找到一个匹配。函数基本语法与re.match()相同：匹配成功返回一个Match对象，否则返回None。替换使用re.sub()方法，先根据指定模式进行搜索，再用指定字符串进行替换，函数基本语法：repl是需要替换的字符串，返回替换后的字符串，如果模式没有发现，字符将被没有改变地返回。一个示例：输出结果：这段程序可以去除原字符串中的所有非数字。相关文章：Python爬虫–使用requests获取网页Python爬虫–使用BeautifulSoup解析HTML参考资料：Python正则表达式]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Spider </tag>
            
            <tag> Regular Expression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫--使用BeautifulSoup解析HTML</title>
      <link href="/2016/07/20/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8BeautifulSoup%E8%A7%A3%E6%9E%90HTML/"/>
      <url>/2016/07/20/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8BeautifulSoup%E8%A7%A3%E6%9E%90HTML/</url>
      
        <content type="html"><![CDATA[bs4用于解析获取到的HTML文件，其官方中文文档为：Beautiful Soup 中文文档，此处列举的只是最基本最常用的一些用法。使用BeautifulSoup首先要导入它：创建 BeautifulSoup 对象其中html是一段HTML文本字符串。上述代码使用Python内置的解析器进行解析，也可指定使用其它解析器，如：输出文档输出排版好HTML文档。获取标签直接使用标签对应的属性即可，如：返回的是第一个tag对象，使用name属性获取此标签的类型：返回一个字符串，对应标签名称。使用.string属性获取此标签包含的文本内容：获取到的字符串不包括标签本身，另外注意需要仅当此标签不包含子标签时才能使用.sting属性。如果此标签包含其他子节点，可以使用.contents属性获取所有子节点：返回对象是一个List。如需获取父节点，使用.parent属性即可，除此之外，还有些用于获取兄弟节点的.next_siblings等方法，此处从略。如果要获取标签的某个属性，直接使用类似List的语法即可：上述程序返回&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;标签的class属性。搜索对于爬虫来说，BeautifulSoup的搜索功能是最有用的，最常用的函数是：find_all(name, **kwargs )find_all()方法搜索当前标签中的所有子节点，并判断是否符合过滤器的条件。返回包含所有符合条件的tag对象的List。name参数可以传入很多东西，最常用的是传入目标标签名：上述代码将放回所有的&amp;lt;b&amp;gt;&amp;lt;/b&amp;gt;标签Tag。kwargs参数可以传入任意数量的属性，搜索时会匹配对应的标签属性，如：上述代码将会搜索包含id=&amp;quot;link&amp;quot;属性的&amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;标签。注意，如果标签属性的名称和关键词等冲突，可在其后面加一个_，如：另外，find_all()方法返回的是一个List，如果只需要简单的返回第一个结果，可使用find()函数，用法完全相同。一般使用Beautiful Soup筛选出所需的标签后，再配合正则表达式就可以准确提取出所需的内容了。相关文章：Python爬虫–使用requests获取网页Python爬虫–使用re正则表达式解析文本参考资料：Python爬虫利器二之Beautiful Soup的用法]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot 2016.05 Stage1代码分析</title>
      <link href="/2016/07/15/U-Boot%202016.05%20Stage1%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2016/07/15/U-Boot%202016.05%20Stage1%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[主流Bootloader的启动过程均可分为Stage1及Stage2两部分，一般来说，Stage1完成最基本的初始化操作、搬移代码及建立C语言运行环境；Stage2完成剩余的初始化操作。故Stage1一般使用汇编完成，Stage2一般使用C语言完成，不过这只是很粗略的情况，实际上Stage1中也会使用C语言代码。下面以之前针对S3C2440移植好的U-Boot 2016.05为例，分析U-Boot中Stage1的代码。程序入口点分析要分析启动流程首先要找到程序入口点，也就是最先运行的代码位于何处，这是由链接过程决定的，故找到链接脚本文件u-boot.lds：可以看到，位于映像文件最前面的依次是.__image_copy_start、.vectors及arch/arm/cpu/arm920t/start.o文件。.__image_copy_start位于映像文件的起始地址处，它在文件arch/arm/lib/sections.c中被定义：这个变量的用处应该是用来进行代码定位的，也就是这个变量的地址就代表映像文件的起始地址，并不占用真实的存储空间，所以此处使用了一个0长度的数组，其他变量的用处也是一样的。U-Boot作者对此的说明是：We need a 0-byte-size type for these symbols, and the compiler does not allow defining objects of C type ‘void’. Using an empty struct is allowed by the compiler, but causes gcc versions 4.4 and below to complain about aliasing. Therefore we use the next best thing: zero-sized arrays, which are both 0-byte-size and exempt from aliasing warnings..vectors是中断向量表，对于ARM920t来说，使用的是位于arch/arm/lib/vectors.S中的通用向量表：可以看到，复位后会首先执行b reset这条指令跳转至reset处执行，而reset标号正是位于arch/arm/cpu/arm920t/start.S文件中：所以一般都说，代码执行开始于start.S文件，这也就是程序的入口点。下面就从这个文件开始分析。start.Sstart.S的执行流程见下图：lowlevel_init是平台相关的，故它位于board/samsung/smdk2440/lowlevel_init.S中。此处需要完成内存控制器的初始化工作，以便之后能正常使用SDRAM。对于S3C2440来说，就是初始化了BWSCON、BANKCONn、REFRESH、BANKSIZE、MRSRB这些寄存器。_main是平台无关的，位于arch/arm/lib/crt0.S中，crt的意思就是C-runtime startup Code，此文件的目的就是建立C语言运行环境，以便之后跳转到Stage2，下面就来分析此文件。crt0.Scrt0.S文件开头的注释中说明了_main的执行序列，摘录如下：This file handles the target-independent stages of the U-Boot start-up where a C runtime environment is needed. Its entry point is _main and is branched into from the target’s start.S file._main execution sequence is:Set up initial environment for calling board_init_f().This environment only provides a stack and a place to store the GD (‘global data’) structure, both located in some readily available RAM (SRAM, locked cache…). In this context, VARIABLE global data, initialized or not (BSS), are UNAVAILABLE; only CONSTANT initialized data are available. GD should be zeroed before board_init_f() is called.Call board_init_f().This function prepares the hardware for execution from system RAM (DRAM, DDR…) As system RAM may not be available yet, , board_init_f() must use the current GD to store any data which must be passed on to later stages. These data include the relocation destination, the future stack, and the future GD location.Set up intermediate environment where the stack and GD are the ones allocated by board_init_f() in system RAM, but BSS and initialized non-const data are still not available.For U-Boot proper (not SPL), call relocate_code().This function relocates U-Boot from its current location into the relocation destination computed by board_init_f().Set up final environment for calling board_init_r().This environment has BSS (initialized to 0), initialized non-const data (initialized to their intended value), and stack in system RAM. GD has retained values set by board_init_f().For U-Boot proper (not SPL), some CPUs have some work left to do at this point regarding memory, so call c_runtime_cpu_setup.Branch to board_init_r().其程序流程图如下：全局变量gd是一个struct global_data类型的结构体，此结构体的定义位于include/asm-generic/global_data.h文件中。此结构体保存了初始化阶段需要用到的各种全局变量，大约有100个左右，相关说明如下：The following data structure is placed in some memory which is available very early after boot (like DPRAM on MPC8xx/MPC82xx, or some locked parts of the data cache) to allow for a minimum set of global variables during system initialization (until we have set up the memory controller so that we can use RAM).Keep it SMALL and remember to set GENERATED_GBL_DATA_SIZE &amp;gt; sizeof(gd_t)Each architecture has its own private fields. For now all are private下面具体说明每一步的作用：Step 1.1 初始化SP寄存器CONFIG_SYS_INIT_SP_ADDR在板子的配置文件include/configs/smdk2440.h中定义：GENERATED_GBL_DATA_SIZE是struct global_data按16字节对齐后的大小。可以看到，这里是使用了SDRAM开头4K部分来作为临时堆栈。Step 1.2 board_init_f_alloc_reserve为GD结构体分配保留空间，16字节对齐。结构体的存储方式是从低地址向高地址生长，故此处返回的就是gd的基地址。Step 1.3 board_init_f_init_reserve简化版的函数实现：将gd的基地址放到r9中保存起来，之后将刚刚分配的保留空间清零完成初始化。Step 2 board_init_fboard_init_f()函数主要是调用initcall_run_list(init_sequence_f)函数，而此函数的作用就是依次执行init_sequence_f中的各函数指针，去除错误处理、Debug信息输出等部分后，简化版的函数体很简单：下面来看一下init_fnc_t init_sequence_f[]这个数组，init_fnc_t是一个是用typedef定义的函数指针类型：init_sequence_f[]数组中包含的就是需要执行的初始化函数列表，这里面的函数很多，这些函数的核心目的就是填充gd结构体。其中比较重要的有下面这些(省略了其中大部分函数)：U-Boot自带的SMDK2410配置中，PLL时钟配置是在board_early_init_f中完成的，不过在针对2440移植时将此部分代码移到了start.S文件中，故board_early_init_f中只包含了GPIO端口初始化；serial_init及console_init_f完成串口终端的初始化，在此之后串口终端才会有输出。display_options和print_cpuinfo就是U-Boot运行时串口最先输出的那段版本信息。dram_init：对于2440来说，因为之前已经初始化好了DRAM，此处只是将DRAM大小写入gd中，在show_dram_config中将SDRAM大小信息输出至控制台。setup_dest_addr中根据RAM的大小计算了重定位开始地址，将RAM顶端地址存放在gd-&amp;gt;relocaddr = gd-&amp;gt;ram_top中。reserve_xxxxxx依次计算重定位每一部分所需的RAM空间，并从gd-&amp;gt;relocaddr中减去这部分空间，其中reserve_uboot是计算重定位U-Boot本身（.text + .bss）的地址；reserve_global_data是计算重定位gd的地址。从这里可以看出，重定位后的代码和数据位于RAM顶端。setup_reloc向gd中填入了重定位地址信息，并完成了gd本身的重定位，**gd-&amp;gt;reloc_off就是在这里计算出来的，代表重定位地址偏移量**：对于其他平台来说，最后还有一步jump_to_copy，这里会实现代码跳转，也就是不会再返回此函数，不过对于ARM平台来说，是没有这一步的，执行完init_sequence_f[]中的函数后会返回到board_init_f()中，最后回到_main中继续执行后面的代码。Step 3 设置中间变量这里面用到的gd中的值都是在board_early_init_f()中设置好的，其中有几句很重要的语句：here就是下面那个标号，此处将here的地址加上gd-&amp;gt;reloc_off这个偏移量后存放到lr寄存器中，之后调用b relocate_code命令返回后就会返回到lr寄存器中的地址处。这就实现了将代码拷贝到SDRAM后从新的重定位地址处接着运行的目的。这也就是源码中这一段注释的含义：Set up intermediate environment (new sp and gd) and call relocate_code(addr_moni). Trick here is that we’ll return ‘here’ but relocated.设置好这些寄存器后调用relocate_code实现代码重定位。Step 4 relocate_code位于/arch/arm/lib/relocate.S中，使用汇编完成，简化版的代码如下：在这段代码中，使用ldmia及stmia指令，每次使用r10及r11两个寄存器进行复制，实现了将__image_copy_start及__image_copy_end中的代码复制到gd-&amp;gt;reloc_off处的目的。这里省略了.rel.dyn部分的重定位代码，这部分代码和以上代码差不多，只是还做了些额外处理。最后调用bx lr返回，此时会进行状态切换后接着运行行下面的程序，不过此时运行的程序已是位于重定位的地址处了。之后执行的是bl relocate_vectors，这个实现的是中断向量表的重定位，具体就不展开了。在此之后还调用了c_runtime_cpu_setup，不过对于2440来说，这里没有做任何事情，可以跳过。Step 5 清零BSS段这一步建立C语言运行环境，实际上也就是清零BSS段，代码也很好懂，根据__bss_start及__bss_end的地址循环写入0即可。只是这有一个问题，注释中有说明：“this is auto-relocated!”，这说明__bss_start及__bss_end的地址已经是重定位后的新地址了，这是如何实现的呢？__bss_start及__bss_end的定义见本文最前面arch/arm/lib/sections.c中的代码，是两个长度为0的数组，估计是在relocate_code搬运代码过程中已经搬运了这两个0长度的代码了？这个问题还需要之后来仔细思考下。Step 6 board_init_r在调用board_init_r前还调用了两个函数：coloured_LED_init及red_led_on，不过在SMDK2410的BSP文件中没有实现这两个函数，目前使用的是common/board_f.c中的空函数，相关函数还有下面这些：最后来看看board_init_r()函数：initcall_run_list函数在上面”2.board_init_f”小节中已经分析过了，就是依次执行传入数组中的各函数，此处传入了init_sequence_r，这就是Stage2的初始化函数列表。至此，Stage1结束，开始执行Stage2的初始化流程。]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UART协议时序总结</title>
      <link href="/2016/07/12/UART%E5%8D%8F%E8%AE%AE%E6%97%B6%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2016/07/12/UART%E5%8D%8F%E8%AE%AE%E6%97%B6%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[UART使用异步模式工作，不需要时钟信号，其一般格式为：起始位+数据位+校验位+停止位。其中起始位1位，数据位5~8位，校验位0或1位，停止位1、1.5或2位。不过最常用的格式是1位起始位、8位数据位、没有奇偶校验、1位停止位，简记为8/N/1。8/N/1格式的时序图如下：空闲时数据线上规定为逻辑1。开始传输数据时先发送起始位，规定为逻辑0，接收端会检测这个下降沿，以便之后开始采样接收数据。起始位之后是数据位，规定先发送最低位，即LSB First。因为UART没有时钟信号，故使用波特率来确定每一位的长度，不过为保证检测的准确性，实际采样频率会高于波特率，一般每一位会进行若干次采样，取中间的采样值作为这一位的结果。奇偶校验位一般不使用。停止位一般使用1位，规定为逻辑1，除了表示传输结束外，停止位还可以起到时钟同步的作用。需要注意的是，这里的逻辑0并不一定是0V，这与使用的电平标准有关。对于TTL电平而言，逻辑0是0V，逻辑1是高电平（一般为3.3V或5V）；对于RS-232电平而言，逻辑0是3V15V，逻辑1是-3-15V。除了TX、RX、GND信号外，UART中还会有诸如RTS、CTS等流控信号，因为用得不是很多，此处就不总结了。]]></content>
      
      
      <categories>
          
          <category> 点滴之间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Small Protocol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编文件后缀.s与.S的区别</title>
      <link href="/2016/07/06/%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80.s%E4%B8%8E.S%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2016/07/06/%E6%B1%87%E7%BC%96%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80.s%E4%B8%8E.S%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[使用GCC（准确说是GCC调用了as汇编器）处理汇编代码时，汇编文件的后缀有两种：.s与.S。这两种文件都是汇编代码，其区别在于：.s格式的汇编文件中，只能包含纯粹的汇编代码，汇编器只对其进行汇编操作，没有预处理操作；.S格式的汇编文件中，还可以使用预处理命令，汇编器会先进行预处理，然后再进行汇编。预处理命令以#开头，基本与C语言中的预处理命令相同，包括#define、#include、#if、#endif等。在U-Boot和Linux内核源码中，这些汇编预处理命令用得十分广泛。]]></content>
      
      
      <categories>
          
          <category> 点滴之间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下查看编辑二进制文件</title>
      <link href="/2016/07/06/Linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E7%BC%96%E8%BE%91%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
      <url>/2016/07/06/Linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E7%BC%96%E8%BE%91%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[查看二进制文件：hexdump、hd、xxd编辑二进制文件：vim + xxd查看二进制文件使用hexdump、hd或xxd都可以，其中最简单的是使用hd。hd相当于hexdump -C，使用如下格式显示：使用xxd可以更灵活的控制显示的格式，具体参数使用man查询即可。常用的有：参数含义-b以二进制（0 &amp;amp; 1）模式显示（默认为十六进制模式）-e按照小端序模式显示（默认为大端序）-g n每n个字节归为一组显示（默认为2）-u十六进制显示使用大写字母（默认为小写）编辑二进制文件先使用vim -b以二进制的方式打开文件，之后执行以下命令将文件以16进制方式显示：按正常修改文本文件的方法修改此文件，修改完成后使用即可返回。此处xxd命令可以附加的参数与查看二进制文件时使用的xxd相同，可以使用各种显示方式。]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot DM9000网卡驱动提示&quot;could not establish link&quot;的解决方法</title>
      <link href="/2016/06/26/U-Boot%20DM9000%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E6%8F%90%E7%A4%BA%22could%20not%20establish%20link%22%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2016/06/26/U-Boot%20DM9000%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E6%8F%90%E7%A4%BA%22could%20not%20establish%20link%22%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[使用默认的DM9000网卡驱动进行网络操作时，好像都会提示”could not establish link”，而且感觉因此造成的延迟还很严重。在网上搜索了一下，解决方法是屏蔽dm9000x.c文件中下面这段代码：这样完全可以正常工作，不仅不会提示”could not establish link”，而且响应速度也得到了很大的提升。不过这段代码的作用究竟是什么还不清楚，将来有空了可以来仔细研究下。]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot 2016.05 在S3C2440上的移植——杂项</title>
      <link href="/2016/06/26/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/"/>
      <url>/2016/06/26/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%E2%80%94%E2%80%94%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[这里总结一些移植过程中零碎的问题。解决 WARNING: Caches not enabled 提示启动过程中会有一条提示”WARNING: Caches not enabled”，警告未开启Cache。搜索这句提示，找到如下代码：向上追踪函数的调用关系，可以找到是initr_caches()函数调用了enable_caches()。然而在/board/samsung/smdk2440/smdk2440.c中可以看到，board_init()函数会开启Cache的：这就涉及到初始化顺序了，找到初始化序列：可以很清楚的看到，board_init()函数会在initr_caches()函数后执行。这里有两种解决方案，一种是直接忽略enable_caches()；另一种是将board_init()中的缓存使能代码移到enable_caches()中，这里我采用了后一种方法。注释掉board_init()中的那两行代码，在board/samsung/smdk2440/smdk2440.c文件中加入以下代码：因为原来那个enable_caches()函数是使用__weak定义的，此处直接定义此函数即可，会覆盖掉原代码中的定义。修改完成后，编译运行，可以看到这个警告不再出现了。配置环境变量保存位置U-boot中使用saveenv命令可以保存设置的环境变量，存储位置可以在NOR Flash、NAND Flash或EEPROM中，此处我选择保存在NOR Flash中。具体的存储地址和空间大小由smdk2440.h文件中这几个宏决定：CONFIG_ENV_IS_IN_FLASH表明使用NOR Flash，CONFIG_ENV_ADDR和CONFIG_ENV_SIZE即是起始地址和大小，这里选择了NOR Flash的最后一个扇区。设置的时候要注意不要把其他数据（如U-Boot本身的代码）给覆盖了就行。配置启动参数为了实现上电自动引导Linux内核，需要正确设置以下3个环境变量：bootcmd、bootargs、machid。machid为U-Boot传给Linux Kernel的机器ID，内核会根据这个ID选取对应的初始化文件对开发板进行初始化，在Linux Kernel的源代码include/generated/mach-types.h中可以找到Mini2440开发板的机器ID为1999(0x7CF)。所以将machid设置为7CF即可。bootcmd为使用boot或bootd命令引导系统时实际调用的命令，这个根据实际情况设定，比如：当设置了bootcmd后，启动时就会有读秒了，超过一段时间没有按键输入自动引导系统。环境变量bootdelay用于指定这段延迟时间的长度，单位是秒。bootargs为启动参数，具体的设置值有待之后研究Linux内核时再来分析，目前使用的设置是：移植好的U-Boot见我的Github项目。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在U-Boot中添加自定义命令以实现自动下载程序</title>
      <link href="/2016/06/26/%E5%9C%A8U-Boot%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/"/>
      <url>/2016/06/26/%E5%9C%A8U-Boot%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[U-Boot中通过NFS下载程序是一种很普遍的方式，然而下载程序的过程并不能只用一条命令实现。以下载到NOR Flash中为例，一般需要以下几步：通过NFS将文件下载到内存中；解除NOR Flash写保护；擦除NOR Flash；写入NOR Flash。每一步都需要手动输入命令，十分麻烦，所以我们可以在U-Boot中添加一个自定义命令download，以实现一键全自动下载的目的。下面就来介绍一下实现方法。向U-Boot中添加命令以U-Boot 2016.05为例，其绝大部分命令都位于cmd/文件夹中，可以选择一个简单点的文件打开看看，就可以看到命令接口的基本结构如下：其中do_mycmd()函数就是命令的执行函数，它的名字可以是任意的，只是按照U-Boot惯例一般就叫做这种形式。此函数的cmdfp和flag两个参数是由U-Boot系统传入的和命令相关的一些信息，一般用不到，重点是后两个参数。argc是参数个数，至少为1，表示命令本身；argv就是具体传入的参数字符串数组。这个一般的函数是如何和命令关联起来的呢？靠的就是U_BOOT_CMD这个宏。这里不详细分析此宏的实现机理，仅从应用的角度说明一下。U_BOOT_CMD的命令格式为：各参数的含义为：参数含义name命令的名称，此处直接输入即可，不要用字符串&amp;quot;xxx&amp;quot;的形式maxargs命令的最大参数个数，至少为1，表示命令本身rep是否自动重复（为1的话下次直接按Enter键会重复执行此命令）cmd命令对应的响应函数，即之前的do_mycmd()函数，直接使用函数名usage简短的使用说明（字符串）help输入help后显示的较详细的帮助文档（字符串）按以上格式新建一个C源文件后，将其加入Makefile中编译即可。这个文件可以放在任何地方，不过cmd/文件夹中存放的是通用的命令，我们自己新加入的命令最好不要放在里面，而是放在board/中板子相关的文件夹里，比如board/samsung/smdk2440/。如果需要灵活控制是否添加此命令，可加入条件编译，仿照U-Boot本身的做法定义以下宏：这个定义可以放在板子的头文件中，也可加入defconfig文件中。之后在Makefile文件中加入条件编译即可：运行特定命令要实现自动下载，需要使用一个命令代替一系列命令，这就要求能够在程序中自动运行特定命令。U-Boot提供了一个方便的接口函数来实现这一目的：只需调用此函数即可运行特定的命令。自动下载程序最后给出完整版的自动下载程序的实现代码：此处实现了自动下载u-boot.bin文件、uImage文件和ramdisk.gz文件，分别输入download u、download l和download f即可。命令执行序列位于cmd_uboot、cmd_linux及cmd_fs数组中。此代码结构很好进行扩展，如要加入新的选项，仿照目前的结构添加即可。]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware虚拟机中嵌入式Linux开发环境网络配置</title>
      <link href="/2016/06/25/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/2016/06/25/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[嵌入式Linux开发中，主机一般在VMware上运行Ubuntu等桌面Linux系统，主机与板子之间通过网线连接，以实现文件挂载、通信等目的。此时我们希望Ubuntu系统既能正常访问互联网，又能和板子进行通信。解决方法是添加两块网卡，第一块使用NAT方式，第二块使用桥接方式桥接到有线网卡上。第一块网卡(eth0)用于上网，配置为DHCP自动获取地址；第二块网卡(eth1)用于和板子连接，配置为静态IP。这样就可以同时满足这两个需求了。需要注意的是，二者的顺序最好就按照上述顺序添加，要是将eth0与eth1反过来，会导致默认情况下无法上网的。这是由于默认情况下的路由表是这样的：default记录使用eth0，若eth0是通过桥接方式连接板子的，此时显然无法上网，不过这可以通过修改路由表来解决。关于route命令和路由表的详细说明，可参考：鳥哥的 Linux 私房菜 - 5.1.2 路由修改： route]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot 2016.05 在S3C2440上的移植（4）——DM9000网卡</title>
      <link href="/2016/06/25/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94DM9000%E7%BD%91%E5%8D%A1/"/>
      <url>/2016/06/25/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94DM9000%E7%BD%91%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[SMDK2410中默认使用的网卡为CS8900，而实际开发板上使用的网卡为DM9000，故需要进行替换。U-Boot中已经提供了现成的DM9000驱动程序，所以这部分移植相对比较简单，只需要更改下配置文件即可。打开include/configs/smdk2440.h文件，目前网卡部分的宏定义为：将其修改为：网卡的初始化入口位于board/samsung/smdk2440/smdk2440.c文件中，在其中找到board_eth_init()函数，仿照现有的CS8900网卡的形式添加DM9000的初始化代码即可：最后，需要正确设置器件的IP地址、子网掩码等信息，相关宏定义位于include/configs/smdk2440.h文件中：这里没有指定MAC地址，会使用一个随机MAC地址，而且运行时会提示下面这个警告：解决办法就是使用使用环境变量的方法指定一个MAC地址，具体操作方法见：U-Boot中IP地址设置方法上述修改完成后编译运行，使用ping命令检查网络是否可正常使用：这里ping的是主机虚拟机中的Ubuntu系统，可以看到连接是没有问题的。不过有一个需要注意的问题是，目前连上网线后在电脑端并不会显示已连接，而是显示：“网络电缆被拔出”，也就是和没插网线时是一样的。不过这不影响正常使用，这个问题的具体原因有待之后再来分析。另外，此处的移植针对的是DM9000网卡，目前有些开发板使用的是DM9000A，这是两个不同的芯片，驱动程序是不兼容的，针对DM9000A还要修改DM9000的驱动才能正常使用。这个问题也留待将来再来分析解决。移植好的U-Boot见我的Github项目。]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot 2016.05 在S3C2440上的移植（3）——NAND Flash</title>
      <link href="/2016/06/25/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94NAND%20Flash/"/>
      <url>/2016/06/25/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94NAND%20Flash/</url>
      
        <content type="html"><![CDATA[移植完NOR Flash后需要移植NAND Flash，下面介绍一下移植过程。开发板上使用的NAND Flash型号为Samsung K9F2G08U0B，256M x 8 Bit NAND Flash芯片。修改配置文件打开include/configs/smdk2440.h文件，在其中找到NAND Flash配置部分，将其由2410的定义修改为2440的：NAND Flash的相关驱动代码位于dirvers/mtd/nand/下，打开其中的Makefile文件，仿照2410的写法添加2440的支持：以2410的配置为基础复制一份过来：将其中的S3C2410全部替换为S3C2440，这样，针对S3C2440的配置文件就建立好了，下面就要针对2440来修改其中的内容。修改寄存器及时序定义2440的NAND Flash控制器寄存器定义和2410的不一样，所以要先修改s3c2440_nand.c中的寄存器定义。关于2410与2440的详细区别及这些寄存器的具体用处，可参考这篇文章。将原来寄存器定义全部删掉，改成下面这样：以上宏定义的值是根据2440的数据手册确定的，比如NFCONT寄存器的定义如下：再来看时序设置，程序中有这么一段：故我们需要定义相关的一些宏：宏定义值根据Flash芯片数据手册确定，以开发板上使用的K9F2G08U0B为例，从它的数据手册中可以查到：具体变量间的对应关系可对比其时序图得到，这里就不展开了。这几个量的值会影响读写速度，需要仔细对照数据手册才能确定最优值，以取得最佳的读写性能，充分发挥出硬件的潜力。修改初始化代码根据终端输出信息NAND: 0 MiB，以NAND: 为关键词搜索，之后跟踪代码执行流程即可找到NAND Flash初始化的入口为nand_init_chip()函数，这个函数的主要结构如下：board_nand_init()函数用于对NAND Flash进行底层初始化；nand_scan()函数用于识别NAND Flash的型号及大小。仅有board_nand_init()函数是和底层硬件相关的，故移植时只需关注此函数即可，此函数也位于s3c2440_nand.c文件中。只需修改NFCONF及NFCONT寄存器配置，将原有代码替换为：修改写入函数对于S3C24x0系列CPU，是通过s3c24x0_hwcontrol()函数实现命令和地址的写入的。然而2410的s3c24x0_hwcontrol()函数不直接适用于2440，需要稍微修改一下。主要就是将NFCONF寄存器替换为NFCONT寄存器。最后修改后的代码如下：特别需要注意的是第15~16行，很多移植资料上都没有这两行，然而实际测试表明，不加这个判断会写入失败，因此一定要加上这条语句，这是因为在写完命令和地址后，一定还要把IO端口的地址重新设置为寄存器NFDATA。修改硬件ECC函数在include/configs/smdk2440.h文件中我们定义了宏CONFIG_SYS_S3C2440_NAND_HWECC，此时会启用硬件ECC功能。相关函数有三个：s3c24x0_nand_enable_hwecc()、s3c24x0_nand_calculate_ecc()、s3c24x0_nand_correct_data()，其中需要修改的函数只有s3c24x0_nand_enable_hwecc()，主要还是将NFCONF寄存器改为NFCONT寄存器。修改后的代码如下：测试修改完成后编译运行，从终端输出中可以看到已经正确识别出了NAND Flash容量：NAND: 256 MiB。要进一步测试NAND Flash是否可以正常使用可使用以下方法：使用nand info命令可输出NAND Flash的基本信息，若正确识别出NAND Flash的话，就会显示类似下面这样的信息：之后测试Flash的读写是否正常，可将内存中的一段数据写入Flash中再读取回来，比较二者是否相同即可。先擦除一段空间：读取内存开始部分的数据：将这些数据写入NAND Flash中，并回读写入的数据：可以看到，二者完全相同，这说明U-Boot已完全支持了目标板上的NAND Flash。移植好的U-Boot见我的Github项目。]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot 2016.05 在S3C2440上的移植（2）——NOR Flash</title>
      <link href="/2016/06/24/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94NOR%20Flash/"/>
      <url>/2016/06/24/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94NOR%20Flash/</url>
      
        <content type="html"><![CDATA[移植好基本框架能运行后就可以开始移植NOR Flash了，需要让U-Boot支持实际硬件平台中的NOR Flash。开发板上使用的NOR Flash型号为EN29LV160B，1024K * 16-bit。U-Boot中默认没有对此型号NOR Flash的支持，故需要添加相关代码。U-Boot对NOR Flash的检测有两种方法，使用Legacy方法进行检测和使用CFI接口进行检测，下面将分别介绍这两种方法。其中使用CFI接口进行检测应该是更好的方法，优先使用此方法。更改NOR Flash扇区数宏定义无论使用哪种检测方法，都需要先修改NOR Flash扇区数的定义，这个定义在include/configs/smdk2440.h文件中：具体值根据实际使用的NOR Flash确定，在数据手册中都会有说明的，以EN29LV160B为例：可以算出其扇区数为35。两种检测方式的切换NOR flash初始化函数flash_init()位于drivers/mtd/cfi_flash.c文件中，其中有这么一段代码：第一行调用flash_detect_legacy()函数使用Legacy方法进行检测，第二行调用flash_get_size()函数使用CFI方法进行检测。再来看flash_detect_legacy()函数的基本结构：从这里可以看到，使用哪种检测方法由board_flash_get_legacy()函数的返回值确定，如果此函数返回1，使用Legacy方法；返回0则使用CFI方法。board_flash_get_legacy()函数是和具体硬件平台相关的，故它位于board\samsung\smdk2440\smdk2440.c文件中。从SMDK2410移植过来的默认版本为：如果要使用Legacy方法进行检测，直接使用这段代码就可以；如果要改为使用CFI方式进行检测，将返回值改为0即可。因为实际使用的EN29LV160B与AM29LV800BB的接口方式是一样的，故其他代码无需修改，不过亦可修改下函数注释，说明一下板子实际使用的NOR Flash型号等。Legacy检测使用Legacy方法进行检测的基本步骤如下：依次使用AMD及Intel标准去读取Flash的厂商ID及器件ID；根据读取到的ID查找现有的器件列表，从而获得Flash更详细的信息。从中可以看到，移植的关键就是要添加所使用的Flash芯片的配置文件。EON公司的厂商宏定义已经存在，位于include\flash.h中，不需要更改，其定义如下：EN29LV160B这个型号的NOR Flash不存在，需要添加相应的宏定义，可添加在EN29LV040A的宏定义下方：具体宏定义的值可参考数据手册，其中有对Device ID的描述：最后找到drivers/mtd/jedec_flash.c文件，需要在jedec_table这个数组中添加此型号NOR Flash的结构体，此数组会在jedec_flash_match()函数中被调用，此函数代码如下：可以看到，其中会将jedec_table成员的mfr_id、dev_id与读取到的manufacturer_id、device_id进行对比，若相同者调用fill_info()函数填充info结构体中的其它信息。找到jedec_table的定义，这是一个数组，其中每个元素都是一个amd_flash_info类型的结构体：可仿照已有配置格式添加EN29LV160B的定义：下面对其中每一个字段的含义进行说明：字段含义说明.mfr_id制造商IDEON公司的宏定义已经存在，直接使用.dev_id器件型号ID之前已经添加了此宏定义.name器件名称字符串主要用于显示.uaddrUnlock Address发送命令时需要写入的地址，下面详细说明.DevSize器件容量从已有的宏定义中选择一个正确的即可.CmdSet命令集具体有哪些可能的选择还不太清楚，这里选择了AMD兼容命令集.NumEraseRegions扇区种类指定有几类不同大小的扇区.regions扇区分配情况下面详细说明.uaddr 这个字段是一个数组，分别用于存放8位、16位、32位访问时的地址，这里只需要写入16位访问时的地址即可。地址使用了枚举的形式，有以下一些选择：从名称上就可以看出其意义，选用哪种根据数据手册确定；.NumEraseRegions、.regions这两个参数指定了Flash芯片的扇区配置情况，其中.NumEraseRegions指定有几类不同大小的扇区，.regions指定每一类扇区的大小及个数。从amd_flash_info结构体的定义中可以看到，.regions是一个数组，且其大小默认设置为了6，如果扇区类型过多（一般不会出现），可修改此数组大小即可。再来看一下ERASEINFO，这是一个宏，其宏定义为：其意义在于使用一个ulong类型的整数同时表示扇区大小及扇区个数。.NumEraseRegions与.regions配合就可以确定每一个扇区的起始地址及器件的容量，下面就来分析下这一过程。这一部分代码位于fill_info()函数中，以下是fill_info()函数的精简改写版，仅保留了计算扇区部分最核心的代码：第717行的循环遍历NumEraseRegions，依次处理每一类扇区；第8、9行获取erase_region_size及erase_region_count，这一过程就是ERASEINFO宏的逆过程；第1216行依次循环处理每一个扇区，计算各扇区的起始地址，并计算总的扇区数。分析清楚了扇区的计算方法后结构体中的.regions部分该如何编写就很清楚了，参考数据手册中的地址分配表即可写出所需的代码。最后编译下载运行，可以看到已经正确识别出了Flash的容量。CFI检测使用Legacy方法进行检测相当于要自己手动指定Flash的信息，不是很灵活，那是否可以自动检测Flash信息呢？答案是可以的，就是使用CFI方法进行检测。CFI是一种通用的接口规范，关于其详细说明可参考Cypress公司的这份文档。按上面的说明将board_flash_get_legacy()函数的返回值改为0即可启用CFI检测，之后不用做任何配置，直接编译运行即可，极为简单方便，而且可以自动适配不同型号的Flash。在两块不同的板子上测试了CFI方法，结果表明，都能正确识别出Flash，这说明CFI方法具有很好的适应性。测试要测试NOR Flash是否正常工作可使用以下方法：使用flinfo命令可输出Flash的基本信息，若成功识别了Flash后，就会显示正确的信息。使用Legacy方式进行检测会输出类似这样的信息：使用CFI方式进行检测则会输出：之后测试Flash的读写是否正常，可将内存中的一段数据写入Flash中再读取回来，比较二者是否相同即可。先擦除最后一个扇区：读取内存开始部分的数据：将这些数据写入Flash的最后一个扇区，并回读写入的数据：可以看到，二者完全相同，这说明U-Boot已完全支持了目标板上的NOR Flash。移植好的U-Boot见我的Github项目。]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nor Flash中的启动扇区（Boot Sector, Boot Block）</title>
      <link href="/2016/06/23/Nor%20Flash%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8%E6%89%87%E5%8C%BA%EF%BC%88Boot%20Sector,%20Boot%20Block%EF%BC%89/"/>
      <url>/2016/06/23/Nor%20Flash%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8%E6%89%87%E5%8C%BA%EF%BC%88Boot%20Sector,%20Boot%20Block%EF%BC%89/</url>
      
        <content type="html"><![CDATA[在Nor Flash中，有个启动扇区（Boot Sector，有时也被称为启动块）的概念，这个概念应该是只针对Nor Flash的，因为Nand Flash无法直接寻址，故Nand Flash中是没有Boot Sector的。一个Nor Flash一般被分为若干块（Block）或若干扇区（Sector），这应该只是不同厂家用的名字不同，并不存在一个Block中包含若干Sector的说法。这些扇区的大小一般并不相同，通常情况下会配置为大量大容量扇区加上少量小容量扇区的结构，这些小扇区就被称之为启动扇区。这样设计是考虑到小容量扇区的擦写速度比较快，而且一般可以对其进行写保护，故可用其存放Bootloader及其他一些用户配置数据。实际上可以有多个小扇区，这些小扇区中具体哪一个是启动扇区，还是都是启动扇区，这一问题并没有明确的说法，也无需纠结于此。根据启动扇区的地址不同，可分为两大类：Top Boot &amp;amp; Bottom Boot。Top Boot是指Boot Sector位于最高地址处；Bottom Boot是指Boot Sector位于最低地址处，一般同一型号的Nor Flash都会同时提供这两个版本，除了地址分配的差异外，其它的主要参数二者应该完全相同。一张比较清晰的对比图如下：下面以AMD公司的Am29LV160D为例来具体看看这个问题。Am29LV160D可配置为2M * 8-Bit或1M * 16-Bit，这个是通过一个引脚电平来确定的，下面仅讨论1M * 16-Bit的配置。在此配置下，Am29LV160D被分为35个扇区：1个8Kword扇区2个4Kwork扇区1个16Kword扇区31个32Kword扇区这些扇区中，前面那4个扇区就是Boot Sector。AMD公司同时提供了Top Boot和Bottom Boot两种芯片，见下图：对于Top Boot的器件来说，其扇区分配如下：可以看到，其中小容量扇区被安排到了最高地址处，即最后几个扇区。对于Bottom Boot的器件来说，其扇区分配如下：可以看到，其中小容量扇区被安排到了最低地址处，即最前几个扇区。不过实际上，像U-Boot这类Bootloader的体积一般都会超过100KByte的，此时显然无法只用启动扇区保存，所以说这时候启动扇区就仅仅只是个名字，使用时也无需特别关注的。不过Top Boot和Bottom Boot器件的器件ID等可能会有所区别，使用时需要注意一下。]]></content>
      
      
      <categories>
          
          <category> 点滴之间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串口终端picocom的使用</title>
      <link href="/2016/06/22/%E4%B8%B2%E5%8F%A3%E7%BB%88%E7%AB%AFpicocom%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/06/22/%E4%B8%B2%E5%8F%A3%E7%BB%88%E7%AB%AFpicocom%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[Linux下的串口终端程序主要有这几个：minicom、kermit、picocom。其中用的最多的应该是minicom，不过picocom最为简单易用，从其名字pico-com上也可以看出，这是一个比mini-com更精简的串口终端，不过其功能足够满足大多数时候的需求。使用时，指定波特率和串口设备文件即可打开终端：一般情况下，USB转串口的名字都是 ttyUSB*，需要注意的是，必须使用sudo命令或以root的身份运行picocom，这是由于ttyUSB*设备的权限一般都是660，普通用户没有读写权限。成功打开后会显示一些基本信息，并进入正常终端模式：如要退出，先按Ctrl + A进入转义模式，再按Ctrl + Q即可正常退出。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jlink为S3C2440下载程序提示&quot;Unable to halt cpu core&quot;的解决办法</title>
      <link href="/2016/06/20/Jlink%E4%B8%BAS3C2440%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F%E6%8F%90%E7%A4%BA%22Unable%20to%20halt%20cpu%20core%22%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2016/06/20/Jlink%E4%B8%BAS3C2440%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F%E6%8F%90%E7%A4%BA%22Unable%20to%20halt%20cpu%20core%22%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[今天使用JLink为S3C2440下载U-Boot程序时发现连不上设备了，选择Connect后提示”Unable to halt cpu core. Failed to connect”，然而之前明明是正常的，于是开始寻找解决方案。首先使用J-Link Commander尝试连接，不出意外，打开程序后提示”Unable to halt cpu core”，然而尝试复位后就可以连接了：再回到J-Flash ARM中，设置菜单中有一项”Use following init sequence”，按照之前的做法是设置成了”Reset &amp;amp; Delay 2ms”。注意上面J-Link Commander的输出信息，输入r进行复位后第一行就是:复位延时是0ms。受此启发，将J-Flash ARM中的复位延时也改为0ms，此时再尝试连接，发现可以建立连接了。不过问题并没有解决，之后下载程序时会提示错误：”PC of target system has unexpected value after programming”，这也就是之前为何要设置成”Reset &amp;amp; Delay 2ms”的原因（详见使用JLink为2440 NOR Flash下载程序）。面对这个矛盾的问题，我想到的解决方案是：使用两次复位，第一次延时设置为0ms，这是为了能顺利建立连接；第二次复位延时设置为2ms，这是为了能顺利下载程序。实际测试表明，这样设置后的确能正常工作了。虽然表面上看问题是解决了，不过这种解决方案不明不白的，还是要深入分析下问题的原因。之前屡次实验的结果是：直接在程序运行时去连接 -&amp;gt; 无法连接切换到NAND Flash启动（其中没有程序）后去连接 -&amp;gt; 正常连接复位延时0ms后连接 -&amp;gt; 正常连接复位延时2ms后连接 -&amp;gt; 无法连接从中可以看到，只要是程序运行起来后均无法正常连接，复位延时2ms后连接可以视为此时程序已经运行起来了，而复位延时0ms后连接相当于程序还没运行就去连接。JATG的连接过程相当于中断（Halt）CPU的过程，这也就意味着问题是由于程序造成的，程序运行起来后因为某些原因导致CPU无法被Halt了。为验证此猜想，在启动代码中，关闭了中断和看门狗后就加入一个死循环指令：然后再编译下载运行，此时就可以去掉第一次复位了，连接过程很正常，而且在程序运行中打开J-Link Commander也可以直接连上了，说明JLink此时成功的Halt并连接上了CPU。这就确定应该是程序中有些问题，导致CPU在某些时候进入了异常状态，从而无法使用JTAG连接。既然确定了是程序中的问题，那么是程序中的什么问题造成的呢？联想到之前测试时发现U-Boot的输出每次都不太一样，有些时候可以正常输出用户交互命令行：然而更多的时候会卡在Net: 处：这就暗示我们会不会是网卡设置出错了呢。LT2440开发板上使用的DM9000网卡连接在了Bank 4上，目前的程序没有对其访问模式做设置，然而根据网上的各种资料，其访问模式应该要设置为：即加入等待和启用UB/LB。按这个进行设置后，编译下载运行一切正常。至此，问题已经完全搞清楚了，因为对网卡的总线访问模式有误，导致CPU进入了异常状态，从而无法建立JTAG连接，修正此问题后一切正常。]]></content>
      
      
      <categories>
          
          <category> 点滴之间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
            <tag> Bootloader </tag>
            
            <tag> Debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot 2016.05 在S3C2440上的移植（1）——基本运行</title>
      <link href="/2016/06/19/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E8%BF%90%E8%A1%8C/"/>
      <url>/2016/06/19/U-Boot%202016.05%20%E5%9C%A8S3C2440%E4%B8%8A%E7%9A%84%E7%A7%BB%E6%A4%8D%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[相关环境：系统版本：Ubuntu 16.04 64bitU-boot 版本：2016.05交叉编译链GCC版本为5.20，使用crosstool-ng自行制作。基本运行的目标是能够顺利的编译通过，是之后移植修改的基础。创建2440配置文件复制2410的板子配置文件，以便在此基础上建立2440的配置文件。涉及到的文件可在board/samsung/smdk2410/MAINTAINERS文件中找到。此文件实际上是一个代码维护说明，指出了这个板子的配置包含哪些文件，由谁维护等，其内容如下：从中可以看到，有三处需要复制：MAINTAINERS文件修改board/samsung/smdk2440/MAINTAINERS文件，将其中2410的部分全部改为2440：Kconfig文件同理修改board/samsung/smdk2440/Kconfig文件：Makefile文件同理修改board/samsung/smdk2440/Makefile文件：smdk2440.c文件同理修改board/samsung/smdk2440/smdk2440.c文件：smdk2440_defconfig文件修改configs/smdk2440_defconfig文件：arch/arm/Kconfig文件因为前面修改了smdk2440_defconfig文件，将其中的配置项名称由CONFIG_TARGET_SMDK2410改成了CONFIG_TARGET_SMDK2440，故还需要修改arch/arm/Kconfig文件，在其中添加SMDK2440的板子配置才行：mach-types.h文件smdk2440.c中将MACH_TYPE_SMDK2410改成了MACH_TYPE_SMDK2440，此时需要在arch/arm/include/asm/mach-types.h中添加对应的代码才行：此处MACH_TYPE的宏定义值是根据Linux kernel中的定义值来确定的，二者最好匹配起来，不过要是不同也没有关系，在引导内核的时候也可以通过环境变量来设置这个值。smdk2440.h文件修改include/configs/smdk2440.h文件：添加交叉编译链路径最后，添加交叉编译链的路径，根据U-Boot README说明，可以不修改Makefile文件，而是使用环境变量CROSS_COMPILE来指定交叉编译链，不过这里还是采用了修改Makefile文件的方法。修改顶层Makefile文件，即Makefile：测试编译至此，已成功创建2440的配置文件，使用以下命令进行配置和编译：顺利编译后就会在U-Boot根目录下生成所需的u-boot.bin文件。当然，此文件目前还是针对2410的，接下来需要针对2440进行修改移植。Stage 1代码移植第一阶段代码一般是汇编代码，用于初始化硬件，建立C语言运行环境等。从README文件中可以找到U-Boot初始化流程的说明，位于Board Initialisation Flow部分，其中提到最初执行的启动代码为start.S文件，对于2440来说，就是arch/arm/cpu/arm920t/start.S文件，下面针对2440来修改此文件。修改屏蔽中断代码修改屏蔽中断的代码：此处的设置参考2440数据手册中对INTSUBMSK寄存器的说明：更改时钟设置更改时钟设置，默认start.S中只有时钟分频设置，PLL的设置放在Stage 2中进行。对此进行下修改，在此完成所有时钟部分的初始化设置。一般都将2400配置为：FCLK=400M；HCLK=100M；PCLK=50M，需要将原来的：改为：修改SDRAM设置start.S文件会跳转到board/samsung/smdk2440/lowlevel_init.S中继续执行，下面来修改此文件。修改SDRAM刷新周期、预充电时间，根据SDRAM的数据手册刷新要求为8192/64ms，一般HCLK设置为100M，故需要将REFCNT的值改为1268；Trp根据数据手册为20ns，故选择3 clk即可；另外2440中没有Tchr寄存器，需要删掉：Stage 1中，start.S还会跳转去执行_main，不过这个是平台无关的代码，移植时不需要考虑。下面开始移植Stage 2代码。Stage 2代码移植因为在Stage 1中已经完成了PLL时钟的初始化，这里将Stage 2中的相关代码全部删掉。所在文件为board/samsung/smdk2440/smdk2440.c：编译运行做完上面的修改后，编译UBoot：将生成的u-boot.bin文件通过JTAG烧写到板子的Nor Flash中，之后连上串口（Serial 0），波特率设置为115200，复位后即可看到串口有数据输出：这说明U-Boot已经运行起来了，不过没有识别出Flash，而且网卡配置有误，故我们还需要继续进行修改。移植好的U-Boot见我的Github项目。]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenSSH使用多个私钥（SSH Key）配置</title>
      <link href="/2016/06/17/OpenSSH%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%A7%81%E9%92%A5%EF%BC%88SSH%20Key%EF%BC%89%E9%85%8D%E7%BD%AE/"/>
      <url>/2016/06/17/OpenSSH%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E7%A7%81%E9%92%A5%EF%BC%88SSH%20Key%EF%BC%89%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[在使用SSH时，有时候需要针对不同网站使用不同私钥，最简单的方法就是在.ssh目录（一般为~/.ssh/）下创建一个配置文件config，其内容示例如下：这样在登录github.com时使用id_rsa_github，而登录git.oschina.net时使用id_rsa_oscchain。如果登陆一个没有在config文件中出现的地址，则会使用默认的id_rsa文件。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crosstool-ng参数配置</title>
      <link href="/2016/06/16/crosstool-ng%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/"/>
      <url>/2016/06/16/crosstool-ng%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[本文以Samsung S3C2440处理器为例，介绍使用crosstool-ng制作交叉编译链时该如何针对特定的目标CPU进行配置。一般来说，常用的CPU架构都有至少一个现成的示例配置文件，对于S3C2440来说，一般选用arm-unknown-linux-gnueabi，下面就以这个示例配置为基础进行修改。crosstool-ng版本为1.22.0。Paths and misc options这部分是crosstool-ng本身的配置，目的是为了提高编译效率与工作效率，具有通用性，在制作不同交叉编译链时都是一样的。重要配置参数如下：将此值设置为所需线程数即可，一般设置为CPU线程数（对于支持超线程的CPU来说就是核心数 * 2）。此处的多线程参数，crosstool-ng内部是将其传给make的-j参数实现的，如：make -j4开启逐步编译功能，如果编译过程出错，只要找到最后成功的那一步，使用如下命令即可恢复编译：关于此功能的详细用法参考这里。此外，crosstool-ng还可以实现出错时不立刻退出，即Interactive shell on failed commands，在此不多做说明，可参考这里的说明。分别是值工作路径、源码包保存路径及目标安装路径。工作路径：编译时生成的所有文件都放在这里面，一般使用默认配置即可；源码包保存路径：所需各模块的源码包存放路径，如果之前下载好了可以直接放到这个路径中，如果没有的话crosstool-ng会自动下载。一般将此路径改为工作目录下的./src/目录；目标安装路径：生成的交叉编译链存放的路径，改为需要路径，一般也放在当前工作目录下。Target options重要配置参数如下：是否使用MMU，S3C2440有MMU。字节序，S3C2440为小端，大部分ARM处理器均为小端。CPU运算位数，S3C2440为32 bit，最新型号的ARM Cortex-A处理器为64 bit。目标CPU核心名称，对应GCC中的-mcpu参数。对于S3C2440来说，其ARM核为ARM920T。设置了这个参数后，Architecture level及Tune for CPU这两个选项就会自动消失。关于这个问题，参考我的另一篇博客文章：GCC中-march、-mtune、-mcpu三个参数的设置。与FPU相关配置，S3C2440没有FPU，如果有FPU的话，按实际情况设置即可，其中Use specific FPU对应GCC中的-mfpu参数，可以指定所用的FPU的类型。配置好的界面：Toolchain options重要配置参数如下：构建静态链接的交叉编译链，这里的静态链接是指交叉编译链本身，不是它编译出来的文件。这个主要是用于需要发布交叉编译链时，如果其他主机没有所需版本的系统库，使用动态链接就会出错，这是就需要使用静态链接。不过静态链接会增大生成的可执行文件的体积，这里只考虑在本机上用，故不选择这个选项。可以自定义一个版本号，接在标准默认版本号的后面。指定交叉编译链标准命名arch-vendor-kernel-system中的第二部分vendor。配置好的界面：Operating System重要配置参数如下：目标系统，可以选择bare-metal或linux。编译Bootloader时严格来说是该选择bare-metal的，不过这样编译Bootloader和编译其他应用就要选用两套不同的交叉编译链，使用起来不是很方便。实际上使用针对linux的交叉编译链来编译Bootloader也是可以的，而编译Kernel时必须选择linux，故此处一般都选择linux。相关说明如下：You probably want to say ‘y’ here if you plan to use your compiler to build bootloaders. It is not yet suitable to build Linux kernels, though, because the APCI stuff relies on the target C library headers being available?!?!…Linux kernel版本，可以从列表中选择，也可以自定义一个tar包，自定义tar包的版本有何要求之后再来研究。是否编译共享库，编译Linux应用时不需要，不过编译Bootloader和Linux kernel等东西时需要，为了保证通用性，一般选上这个。配置好的界面：Binary utilities使用默认配置，重要配置参数如下：生成的二进制文件的格式，当Target options中选择了MMU后，此处只能选择ELF格式；若没有MMU，此处一般选择Flat格式。选择是否使用Linaro binutils，这是另一套binutils，专为ARM架构做过优化，相关说明：Linaro is maintaining some advanced/more stable/experimental versions of binutils, especially for the ARM architecture. Those versions have not been blessed by the binutils comunity (nor have they been cursed either!), but they look to be pretty much stable, and even more stable than the upstream versions. YMMV…Linaro binutils is a release of the GNU binutils with bug fixes and enhancements for ARM platforms. GNU binutils is a collection of tools including the ld linker and as assembler.对此目前还没有研究过，就选用主流的社区版本就行了。C-library &amp;amp; C compiler &amp;amp; Debug facilities &amp;amp; Companion libraries &amp;amp; Companion tools主要是各种C标准库、编译器、调试工具及其它一些库的版本选择及相关配置，它们之间似乎并不能任意组合，故这里都选用默认配置。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compiler </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC中-march、-mtune、-mcpu三个参数的设置</title>
      <link href="/2016/06/15/GCC%E4%B8%AD-march%E3%80%81-mtune%E3%80%81-mcpu%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
      <url>/2016/06/15/GCC%E4%B8%AD-march%E3%80%81-mtune%E3%80%81-mcpu%E4%B8%89%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[在配置交叉编译链时，需要指定目标CPU的型号，根据网上广为流传的说法，需要同时指定-march、-mtune、-mcpu这三个参数，并且这三个参数还是不同的。在使用crosstool-ng时，就对应CT_ARCH_ARCH、CT_ARCH_TUNE、CT_ARCH_CPU这三个参数，针对S3C2440，网上所有文章中的设置均是：Architecture level = CT_ARCH_ARCH = -march = armv4tEmit assembly for CPU = CT_ARCH_CPU = -mcpu = arm9tdmiTune for CPU = CT_ARCH_TUNE = -mtune = arm920t比如以下这些文章：【整理】crosstool-ng中的Architecture level，Emit assembly for CPU，Tune for CPU对于TQ2440的S3C2440的ARM920T填写何值第一部分：crosstool-ng 制作交叉编译工具链 for s3c2440用crosstool-ng建立自己的ARM交叉编译工具链 (适用于S3C6410以及其它处理器)这样设置不能说是错的，然而并不是推荐的设置方法。老版本的GCC的确是需要这样同时设置三个参数的，然而新版本的GCC（具体是哪个版本之后估计不可考了）并不需要这样设置，只需要使用-mcpu(CT_ARCH_CPU)这一个参数就可以了。网上很多近些年来的文章还这样说其实是以讹传讹。以GCC 5.2.0为例，其帮助文档中关于这三个参数的说明如下（ARM部分）：-march=nameThis specifies the name of the target ARM architecture. GCC uses this nameto determine what kind of instructions it can emit when generating assemblycode. This option can be used in conjunction with or instead of the -mcpu=option.Permissible names are: armv2, armv2a, armv3, armv3m, armv4,armv4t, armv5, armv5t, armv5e, armv5te, armv6, armv6j, armv6t2, armv6z,armv6zk, armv6-m, armv7, armv7-a, armv7-r, armv7-m, armv7e-m, armv7ve,armv8-a, armv8-a+crc, iwmmxt, iwmmxt2, ep9312.-mtune=nameThis option specifies the name of the target ARM processor for which GCCshould tune the performance of the code. For some ARM implementationsbetter performance can be obtained by using this option.Permissible namesare: arm2, arm250, arm3, arm6, arm60, arm600, arm610, arm620, arm7, arm7m,arm7d, arm7dm, arm7di, arm7dmi, arm70, arm700, arm700i, arm710, arm710c,arm7100, arm720, arm7500, arm7500fe, arm7tdmi, arm7tdmi-s, arm710t,arm720t, arm740t, strongarm, strongarm110, strongarm1100, strongarm1110,arm8, arm810, arm9, arm9e, arm920, arm920t, arm922t, arm946e-s, arm966e-s,arm968e-s, arm926ej-s, arm940t, arm9tdmi, arm10tdmi, arm1020t, arm1026ej-s,arm10e, arm1020e, arm1022e, arm1136j-s, arm1136jf-s, mpcore, mpcorenovfp,arm1156t2-s, arm1156t2f-s, arm1176jz-s, arm1176jzf-s, cortex-a5, cortex-a7,cortex-a8, cortex-a9, cortex-a12, cortex-a15, cortex-a53, cortex-a57,cortex-a72, cortex-r4, cortex-r4f, cortex-r5, cortex-r7, cortex-m7,cortex-m4, cortex-m3, cortex-m1, cortex-m0, cortex-m0plus,cortex-m1.small-multiply, cortex-m0.small-multiply,cortex-m0plus.small-multiply, exynos-m1, marvell-pj4, xscale, iwmmxt,iwmmxt2, ep9312, fa526, fa626, fa606te, fa626te, fmp626, fa726te, xgene1.Additionally, this option can specify that GCC should tune the performanceof the code for a big.LITTLE system. Permissible names are:cortex-a15.cortex-a7, cortex-a57.cortex-a53, cortex-a72.cortex-a53.-mcpu=nameThis specifies the name of the target ARM processor. GCC uses this name to derive the name of the target ARM architecture (as if specified by -march)and the ARM processor type for which to tune for performance (as if specified by -mtune). Where this option is used in conjunction with -marchor -mtune, those options take precedence over the appropriate part of this option.Permissible names for this option are the same as those for -mtune.特别注意其中对-mcpu参数的说明，指定了-mcpu后，GCC编译器会自动推导出-march及-mtune，故不需要再指定这两个参数，只需要给出-mcpu即可，而且-mcpu的可能取值与-mtune完全相同。比如S3C2440，只需要加上-mcpu=arm920t即可。在crosstool-ng的新版本（比如1.22.0）中，使用menuconfig进行配置时，一旦设置了Emit assembly for CPU这个选项，Architecture level及Tune for CPU这两个选项就会自动消失。最初在配置的时候还以为是Bug，后面仔细研究下才发现这是crosstool-ng已根据GCC的新特性进行了升级。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Compiler </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crosstool-ng的基本使用流程</title>
      <link href="/2016/06/15/crosstool-ng%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2016/06/15/crosstool-ng%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[按照crosstool-ng的安装中的做法安装好crosstool-ng后就可以使用crosstool-ng了，基本使用流程在其官网上有说明：Using a released version，这里做下总结。需要注意的是，目前新版本的crosstool-ng不能以root身份运行，否则会提示以下错误：故下面的所有操作都不要在root下进行。当然，如果非要用root运行的话也是可以的，见本文最后的附注。创建工作目录一般专门创建一个工作目录用于之后的编译过程：这里创建了工作目录~/toolchain/及两个子文件夹~/toolchain/src、~/toolchain/x-tools，分别用于存放下载到的源码tarball及最终生成的交叉编译链。最后新建了一个build变量，代表当前工作目录。使用Sample示例配置crosstool-ng中自带了很多示例配置，可用以下命令列出所有Samples及查看某个特定的示例的主要配置参数：如果有合适的示例配置可用的话，可以在其基础上进行修改。在工作目录中执行ct-ng &amp;lt;sample&amp;gt;，如：此命令会自动在当前目录下创建示例的配置文件，shell输出类似这样的：网上很多教程中都说要手动复制配置文件，目前新版本的crosstool-ng不需要这样做，而且手动复制还会出错，直接使用上述命令生成示例配置即可。修改配置文件一般来说，示例配置是不能直接使用的，需要对其进行一些修改，在工作目录中输入：会进入下图这样的menuconfig配置界面：一般需要更改下路径，进入Paths and misc options，修改Local tarballs directory &amp;amp; Prefix directory。前者是下载的源码包存放的路径，后者是生成的交叉编译链存放的路径，将其改为之前在工作目录下新建的文件夹即可：具体参数的配置方法见：crosstool-ng参数配置编译配置完成后使用命令即可开始编译。crosstool-ng会先下载所需的tar包，之后进行编译。如果没有出现错误的话，最终会在Prefix directory中生成所需的交叉编译链，可使用tar进行打包。使用时将其中的bin目录加入PATH中即可。附：以root身份运行crosstool-ng的方法出于安全性考虑，crosstool-ng默认不能以root身份运行，如果确定要在root下运行，需要在配置中开启这一选项：在这一选项的HELP文档中，可以看到crosstool-ng的作者极力反对用root运行：）]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compiler </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crosstool-ng的安装</title>
      <link href="/2016/06/14/crosstool-ng%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2016/06/14/crosstool-ng%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[crosstool-ng用于制作交叉编译器，其本身作为Linux下的一个软件，也需要进行编译安装。下面简要记录下安装过程。开发环境：Ubuntu 16.04 64bitgcc v5.3.1make v4.1下载在crosstool-ng的首页crosstool-ng.org上可以下载到其源代码，目前最新版本是crosstool-ng-1.22.0。配置解压下载到的tar包，切换到crosstool-ng文件夹中执行这一步的目的是生成Makefile文件，使用configure的默认配置即可。在Ubuntu环境下，因为安装的开发工具不全，可能会提示缺少一些工具，这时候用apt-get安装缺少的工具即可。不过有几个提示不是那么直接：错误提示：解决方法：错误提示：解决方法：错误提示：解决方法：这里仅安装libtool是不够的，还需要安装libtool-bin。错误提示：解决方法：这里缺少的是ncurses这个库，对应的Ubuntu下的包是libncurses5-dev。编译配置完生成Makefile后直接用make进行编译即可，这一步在我使用的开发环境下没有发生任何错误。可能出现的错误及解决方法可参考这里的说明。安装编译完后使用make install安装即可，默认安装在/usr/local/bin、/usr/local/lib等目录下，如需更改安装目录，可在./configure配置时进行设置，具体可使用./configure -h命令查看帮助文档中的说明。一般来说，/usr/local/bin目录已经在环境变量PATH中了，故不需要再手动添加。安装完成后使用ct-ng version命令进行测试，如果能正确输出如下版本信息说明安装正确：]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compiler </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转编码器绝对位置测量方法</title>
      <link href="/2016/06/06/%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%9D%E5%AF%B9%E4%BD%8D%E7%BD%AE%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95/"/>
      <url>/2016/06/06/%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E7%BB%9D%E5%AF%B9%E4%BD%8D%E7%BD%AE%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[一般的旋转编码器本身只能提供相对位置信息，不过配合零点信号（即Z相信号）即可确定绝对位置，下面结合TI C2000系列单片机来讨论具体实现方法。基本原理在C2000系列单片机中，使用QEQP模块对旋转编码器输入信号进行处理，先根据输入的A、B、Z三相信号生成QCLK内部时钟信号、QDIR方向信号及QI同步信号，这部分工作是由QDU（Quadrature Decoder Unit）子模块完成的。输入信号的极性，输出的来源等均可配置，具体详见数据手册。生成的QCLK信号来源于A、B两相信号跳变沿，此信号与QDIR方向信号一起确定QPOSCNT寄存器的计数增减，具体时序图如下：从理论上说，只要确定了一点的绝对位置，就可以通过读取QPOSCNT寄存器获取任意时刻的绝对位置，以两对极电机为例，示例性代码如下：此处的theta是电角度而不是机械角度，QEP_LINE为编码器线数。对于两对极电机来说，假设QPOSCNT的初值是0，电机完整的顺时针转过一圈后QPOSCNT中的值应该是4 * QEP_LINE，使用上式计算得到的对应电角度就是4PI rad。再考虑到电机的对称性及角度的周期性，theta的范围在[0, 2PI)内即可，对应的QPOSCNT的范围就是[0, 2 * QEP_LINE)。在C2000单片机中，可以通过QPOSMAX寄存器来设置这个最大值，示例代码如下：然而，这有两个问题，首先是初始时刻的绝对位置如何确定；其次是如何消除累积误差。解决方法是：初始时刻的绝对位置通过霍尔信号进行估测，累积误差通过Z相同步信号来消除。下面分别来讨论这两个问题。初始时刻定位初始时刻的位置确定比较简单，只要预先测定出Ha、Hb、Hc三个霍尔信号输出与绝对角度间的关系，在启动时通过查表的方法即可大致估算出初始角度。因为这一估算过程本来就不要求也不可能精确，故也无需测定霍尔信号跳变沿的准确位置，粗略的使用示波器观察信号估计一下即可。示例性代码如下：这句代码在初始化EQEP模块的时候调用一次，GetHall()函数可返回根据Hall信号猜测出的QPOSCNT寄存器的初值：Z相同步信号Z相信号用于对QPOSCNT寄存器进行同步定位，这个信号需要仔细考虑下，否则会造成之后得到的绝对位置存在误差。首先需要考虑的是，Z相信号本身是一个存在一定宽度的脉冲信号，从旋转编码器的原理上来看，正转和反转时Z相信号的上升沿和下降沿对应的绝对位置是不同的，正转时的上升沿对应反转时的下降沿，反之亦然。这就需要在正转和反转时使用不同的边沿触发同步事件，C2000单片机中可以很方便的实现这一功能，只需要设置IEI寄存器即可：同步事件发生时写入QPOSCNT中的值由QPOSINIT寄存器确定：这里就涉及到INDEX_OFFSET这个值怎么确定的问题，因为Z相脉冲并不是严格的出现于绝对零点位置处，故需要进行角度校正。角度校正角度校正的基本思想是，记录下Z相信号对应的绝对角度值，将其写入QPOSINIT寄存器即可，即上述代码中的INDEX_OFFSET宏定义的值。要确定绝对角度，必须要有一个基准，在进行角度校正时，使用预定位的方式确定绝对角度的零点。具体做法是， 使能三相逆变器，使用SVPWM算法生成一个Ualpha &amp;gt; 0；Ubeta = 0的矢量，Ualpha不宜设置得过大，以免电流过大，此时电机会旋转至绝对零点处。之后使能EQEP模块，将QPOSCNT的值设为0，SEI设为0，以禁用QI信号信号的自动同步复位功能；与此同时，使能IEL，以便在QI信号发生时自动锁存QPOSCNT寄存器的值。以上初始化过程用代码表示如下：按照以上步骤初始化EQEP模块后，禁用三相逆变器，此时电机可以自由旋转。用手旋转电机以产生QI信号，此时QPOSCNT寄存器中的值会被自动锁存在QPOSILAT寄存器中，可以正反多旋转几次电机，记录下若干次QPOSILAT寄存器中的值取平均值即可。读取寄存器的值可以通过使用仿真器进入调试模式实现。计算得到的平均值即QI信号对应的绝对角度值，将此值定义为INDEX_OFFSET宏写入QPOSINIT寄存器中即可。注：上述叙述假设编码器Z相信号连接至了QEPI输入端上，若连接至了QEPS输入端处，只需将QI相关部分改为QS即可，二者的功能基本相同。]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor </tag>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫--使用requests获取网页</title>
      <link href="/2016/06/03/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8requests%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5/"/>
      <url>/2016/06/03/Python%E7%88%AC%E8%99%AB--%E4%BD%BF%E7%94%A8requests%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[requests包用于获取网站的内容，使用HTTP协议，基于urllib3实现。其官方中文文档为：Requests: HTTP for Humansrequests的基本使用方法很简单，这里记录一些最常用的方法，完整的介绍见其官方文档，以下介绍基于Python 3.5。 使用requests首先需要导入它：发送请求最基本的方法是GET请求：返回的r是一个Response类对象，包含所有返回数据，可以从这个Response中提取所需的信息。除了get()外，常用的请求还有post()，用法完全相同。除此之外requests也支持其它各种请求方法，具体参见其文档说明。可通过r.url()获取请求的URL。读取响应内容使用Response的text属性即可:text属性是针对相应内容是文本（如HTML等）的情况下使用，如果返回的数据是二进制数据（如图片等），则通过content属性来读取二进制比特流：如果返回的数据是json，requests中自带了一个解析器，可以直接使用json()函数进行解析，返回的是一个字典：上面这个例子演示了淘宝的IP查询服务。附加查询参数可以构造类似http://www.baidu.com/s?ie=utf-8&amp;amp;wd=Python这样的查询URL，其中附加在?之后的部分就是查询参数，可以手动构造这样一个字符串，不过requests中提供了更优雅的解决方案，使用一个字典作为params参数即可：附加表单与附加查询参数类似，在POST请求中，可以附加表单信息，这一般用于实现登录或提交信息等，使用一个字典作为data参数即可：读取与设置响应数据的编码一般情况下requests均能从响应头部获得正确的编码，不过若头部没有相应信息，则需要手动设置，不然可能会出错。使用Response的encoding属性即可:使用代理使用一个字典作为proxies参数即可，下面这段代码演示了使用ShadowSocks作为代理的方法：获取响应状态码使用Response的status_code属性即可:自定义请求头部传递一个字典作为headers参数即可：会话会话可以跨请求保持某些参数，它也会在同一个Session实例发出的所有请求之间保持cookies。使用如下方法新建一个会话：会话对象s具有主要的Requests API的所有方法。会话一般用于连续发起一系列请求的时候使用，它会自动处理cookies的问题，十分方便。相关文章：Python爬虫–使用BeautifulSoup解析HTMLPython爬虫–使用re正则表达式解析文本参考资料：python requests的安装与简单运用]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python爬虫抓取网页</title>
      <link href="/2016/06/03/%E4%BD%BF%E7%94%A8Python%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E7%BD%91%E9%A1%B5/"/>
      <url>/2016/06/03/%E4%BD%BF%E7%94%A8Python%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[可以使用Python实现一个基本的爬虫，用来抓取网站上的特定内容。之前写过一个自动查询成绩的小程序，只是之后好久不用也忘了当初是怎么实现的了……最近又想研究下Python爬虫，故写点文章来记录一下。使用Python实现一个爬虫的方法有很多，相关的包有urllib、urllib2、requests、bs4、scrapy、pyspider等，此处我选择了requests + bs4 + re(正则表达式包)的解决方案。**requests用于获取网站数据，bs4及re配合用于解析获取到的HTML数据。**关于学习Python爬虫的技术路线，可参考知乎上的这个回答。需要安装requests及BeautifulSoup4这两个依赖包，最好使用pip自动安装：关于这几个包的具体使用参考可我的这些文章：Python爬虫–使用requests获取网页Python爬虫–使用BeautifulSoup解析HTMLPython爬虫–使用re正则表达式解析文本]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Spider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NFS服务器的搭建</title>
      <link href="/2016/05/30/NFS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2016/05/30/NFS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[NFS是Network File System的缩写，用于在Linux系统间实现磁盘文件共享。严格来说NFS是一种文件系统（类似Ext2、FAT32等），而不是一种传输协议（如FTP、HTTP等），它依赖于RPC协议进行数据传输。下面以Ubuntu 14.04为例，介绍NFS的搭建方法。安装apt-get会自动安装所有依赖包。配置NFS的配置文件为/etc/exports，编辑此文件，格式为：上述参数设置也是最常用的设置，全部可用参数及其含义可参考这篇文章。另外，使用man exports命令可以获得关于此文件更详细的说明。运行开启NFS停止NFS重启NFS测试运行情况如果NFS已启用，此命令会显示出共享目录。查看挂载点情况显示已与客户端连上的目录信息挂载注：目前较新版本的NFS已不依赖于portmap，而使用rpcbind代替，网上相关文章中与portmap相关的部分已不再需要。参考：Linux下nfs搭建]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot中IP地址设置方法</title>
      <link href="/2016/05/30/U-Boot%E4%B8%ADIP%E5%9C%B0%E5%9D%80%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
      <url>/2016/05/30/U-Boot%E4%B8%ADIP%E5%9C%B0%E5%9D%80%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[U-Boot中网络IP、网关等的设置保存在环境变量中，一共有下面这几个：名称含义示例ethaddrMAC地址08:08:11:18:12:27ipaddr本地IP地址192.168.1.7serverip提供下载服务的计算机IP地址192.168.1.3getewayip网关IP地址192.168.1.1netmask子网掩码255.255.255.0使用setenv命令进行设置，使用printenv命令查看目前环境变量，最后如果需要永久保存当前环境变量设置的话使用saveenv命令保存。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>U-Boot版本命名规则及源码下载途径</title>
      <link href="/2016/05/27/U-Boot%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E5%8F%8A%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E9%80%94%E5%BE%84/"/>
      <url>/2016/05/27/U-Boot%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E5%8F%8A%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E9%80%94%E5%BE%84/</url>
      
        <content type="html"><![CDATA[U-Boot的正式发布版本（即Released Versions）每2个月更新一次，并且正常情况下都是在此月中旬的某个周一进行更新，这被称为“U-Boot Release Cycle”。U-Boot所有发布版本的源码皆可以从其官方ftp上下载到，地址为：ftp://ftp.denx.de/pub/u-boot/其源代码使用Git进行管理，如果想获取最新的代码或参与贡献代码，可追踪其Git Repository。自从2008年10月之后，U-Boot正式发布版本的命名就使用了基于时间戳的版本号，版本号中包含发布年份及月份，rc后缀代表Release Candidate。几个例子如下：U-Boot v2009.11 - Release November 2009U-Boot v2009.11.1 - Release 1 in version November 2009 stable treeU-Boot v2010.09-rc1 - Release candidate 1 for September 2010 release如对各发布版本的一些统计信息有兴趣，可参考其官网上的Statistics。]]></content>
      
      
      <categories>
          
          <category> 点滴之间 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootloader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中实现多线程的方法</title>
      <link href="/2016/05/24/Android%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2016/05/24/Android%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[在Android中，所有耗时操作都不能放在主线程（即UI线程）中执行，否则会引起ANR异常，进而导致应用程序崩溃。解决办法是使用多线程，将耗时操作放到异步子线程中执行。Android中实现多线程有两种基本方法：1. Thread + Handler2. AsyncTask其中AsyncTask可以视为是对Thread + Handler机制的再次封装实现。一般来说，数据简单、耗时较短的单个后台异步处理使用AsyncTask，此方法实现代码较为简单，而且更新UI控件更为简单；而执行时间长且逻辑复杂的多后台任务则使用Thread + Handler，此方法与AsyncTask相比能更好的利用系统资源，但是和UI线程的通信会更为复杂。Android系统推荐使用AsyncTask来处理简单的异步操作，通常是在Activity中通过内部类的方式来使用AsyncTask，若不使用内部类，则无法直接更新UI控件，这就失去了使用AsyncTask的意义，不如直接使用Thread + Handler机制来实现多线程。在Android中，线程池是有限的，创建过多的异步线程会导致ANR异常，除此之外，使用AsyncTask还需要注意以下这些问题：由于 AsyncTask 内部的线程池是 static 类型，整个进程共用一个线程池；如果使用不当，会产生阻塞问题，尤其是单任务顺序执行的情况下，一个任务执行时间过长会阻塞其他任务的执行static 线程另外一个问题是，如果第一次调用 AsyncTask 在非 UI 线程中，那么以后使用 AsyncTask时，onPosExecute 也会在非 UI 线程中，此时如果执行 UI 操作会 Crash，所以第一次使用 AsyncTask 一定要在 UI 线程中使用，尤其是使用第三方 SDK 时要注意这点通常使用 AsyncTask 是在 Activity 中使用匿名的内部类来使用，内部类的一个问题是会保持外部类的实例，如果 AsyncTask 中的异步任务在 Activity 退出时还没执行完或者阻塞了，那么这个保持的外部的 Activity 实例得不到释放，会引起 OOM 问题，解决办法是：在 AsyncTask 使用弱引用外部实例，或者保证在 Activity 退出时，所有的 AsyncTask 已执行完成或被取消关于AsyncTask导致的内存泄漏问题，可参考下面这篇文章：Android内存泄漏－AsyncTask的不正确使用]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C28x IQmath库使用</title>
      <link href="/2016/05/15/C28x%20IQmath%E5%BA%93%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/05/15/C28x%20IQmath%E5%BA%93%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[IQmath库是TI C28x系列DSP中使用的一个高度优化且高精度的数学库，用于使用定点算法实现浮点运算。在DSP编程中，出于性能的考虑，应尽量使用IQmath库代替ANSI C中的math库。IQmath库同时支持C和C++，此处仅讨论使用C语言的情况。IQmath的官方使用手册为SPRC990 C28x IQmath Library，在ControlSUITE中可以找到这份文档的最新版本。使用方法添加库文件IQmath.lib或IQmath_f32.lib，后者用于带FPU单元的DSP；包含头文件IQmathLib.h；修改CMD文件，添加其中与IQmath相关的部分。Q格式Q格式是一种定点小数表示方法，具体来说，二者的转换关系为：**定点数 = 浮点数 * 2^Q **在C2000中，统一使用32位来表示。QN格式对应数据类型为_iqN，表示使用N位来表示小数，其余32-N位表示整数，故Q0其实就是一般的32位整数。具体的Q1~Q30的取值范围及精度见下表：_iq类型代表使用GLOBAL_Q定义的精度，GLOBAL_Q在IQmathLib.h文件中定义，默认为：可直接更改IQmathLib.h文件中的定义，也可使用如下方法覆盖此定义：常用函数函数命名惯例为：_IQNxxx()，其中N代表使用的Q格式，省略的话使用GLOBAL_Q中的定义；xxx为函数名，如sin、exp等。下面列举一些常用函数，其中的N大部分都可以省略使用GLOBAL_Q。格式转换函数原型说明_iqN _IQN(float F)将float转为_iqN格式float _IQNtoF(_qiN A)将_iqN格式转为float_iqN _IQtoIQN(_iq A)将全局_iq格式转为_iqN格式_iq _IQNtoIQ(_iqN A)将_iqN格式转为全局_iq格式long _IQNint(_iqN A)提取整数部分_iqN _IQNfrac(_iqN A)提取小数部分_iqN _atoIQN(char *S)将字符串转为_iqN格式int _IQNtoa(char *S, const *format, long x)将_iqN格式转为字符串算数运算对于相同_iqN格式的两个数之间的加减法，可以使用+、-直接进行，注意不要溢出即可；对于不同_iqN格式的两个数，需要转换为相同_iqN格式后再进行加减。函数原型说明_iqN _IQNmpy(_iqN A, _iqN B)基本乘法_iqN _IQNrsmpy(_iqN A, _iqN B)带凑整(rounding)和饱和(saturation)的乘法_iqN _IQNmpyI32(_iqN A, long B)_iqN与long相乘_iqN _IQNdiv(_iqN A, _iqN B)基本除法三角函数函数原型说明_iqN _IQNsin(_iqN A)正弦_iqN _IQNcos(_iqN A)余弦_iqN _IQNtan(_iqN A)正切_iqN _IQNasin(_iqN A)反正弦_iqN _IQNacos(_iqN A)反余弦_iqN _IQNatan(_iqN A)反正切其它常用函数函数原型说明_iqN _IQNabs(_iqN A)绝对值_iqN _IQNexp(_iqN A)exp_iqN _IQNlog(_iqN A)自然对数_iqN _IQNsqrt(_iqN A)开平方_iqN _IQNisqrt(_iqN A)开平方后取倒数_iqN _IQNmag(_iqN A, _iqN B)欧氏距离Benchmark完整的IQmath函数及性能评估表如下：]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体内存边界对齐问题</title>
      <link href="/2016/04/28/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E8%BE%B9%E7%95%8C%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/"/>
      <url>/2016/04/28/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E8%BE%B9%E7%95%8C%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[结构体成员在内存中并不是紧凑排列的，这就是所谓的结构体内存边界对齐问题，默认情况下会按照其自然边界对齐，本文将具体研究下这一问题。先来看一个简单的小程序：使用GCC编译运行，输出结果为：从结果中可以很明显的看到，结构体成员在内存中并不是紧凑排列的，这就是所谓的内存边界对齐问题。进行结构体内存边界对齐是为了让CPU读取数据时效率达到最大化，关于这个问题此处不深入研究，仅引用一个网上的解释：字，双字，和四字在自然边界上不需要在内存中对齐。（对字，双字，和四字来说，自然边界分别是偶数地址，可以被4整除的地址，和可以被8整除的地址。）无论如何，为了提高程序的性能，数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；然而，对齐的内存访问仅需要一次访问。一个字或双字操作数跨越了4字节边界，或者一个四字操作数跨越了8字节边界，被认为是未对齐的，从而需要两次总线周期来访问内存。一个字起始地址是奇数但却没有跨越字边界被认为是对齐的，能够在一个总线周期中被访问。某些操作双四字的指令需要内存操作数在自然边界上对齐。如果操作数没有对齐，这些指令将会产生一个通用保护异常（#GP）。双四字的自然边界是能够被16 整除的地址。其他的操作双四字的指令允许未对齐的访问（不会产生通用保护异常），然而，需要额外的内存总线周期来访问内存中未对齐的数据。 下面主要分析一下编译器是如何处理结构体内存边界对齐问题的。自然边界对齐如果不手动指定对齐方式，就按照自然边界对齐原则进行对齐。所谓自然边界，对于8bit数据来说，任何地址都是其自然边界；对于16bit数据来说，偶数地址是其自然边界（即最低位地址为0）;对于32bit数据来说，能被4整除的地址是其自然边界（即最低两位地址为0）；对于64bit数据来说，能被8整除的地址是其自然边界（即最低3位地址为0）。结构体按照自然边界对齐原则进行对齐即是指：结构体中的每个成员都存放在其自然边界上;各个成员严格按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同；结构体整体的对齐方式与其成员中长度最长那个元素相同；为满足以上要求，在成员间和结构体最后可使用空字节进行填充。根据以上原则就很好理解默认对齐方式了，下面给出几种结构体声明方式及其对应的内存分配情况图。图中每一个单元格代表一字节数据，灰色部分代表不属于此结构体的部分。Case 1Case 2Case 3Case 4指定边界对齐可使用一些编译器预处理指令来手动指定对齐方式，不同的编译器有不同的预处理指令，此处仅简要总结下GCC中的预处理指令。#pragma pack(n)其中n必须为2的若干次幂，如1，2，4，8，16等；若不指定n，相当于恢复默认的自然边界对齐方式。这个指令的效果是：按照#pragma pack指定的数值和这个数据成员自身长度中比较小的值来对齐。也就是说，当#pragma pack的值等于或超过所有数据成员长度的时候，这个值的大小将不产生任何效果，也就是说，这条指令仅可用于减小间隙。用自然边界对齐中的Case 1为例，使用#pragma pack(1)强制对齐至1字节地址处：程序输入为：内存分配情况如下所示：__attribute((aligned(n)))同样，n需要为2的若干次幂，这条指令仅可以用于增加间隙。用自然边界对齐中的Case 2为例，使用__attribute((aligned(4)))将每个成员都强制对齐至4字节地址处：程序输出为：内存分配情况如下图：]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Compiler </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM Cortex-M内核复位启动过程分析</title>
      <link href="/2016/04/27/ARM%20Cortex-M%E5%86%85%E6%A0%B8%E5%A4%8D%E4%BD%8D%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2016/04/27/ARM%20Cortex-M%E5%86%85%E6%A0%B8%E5%A4%8D%E4%BD%8D%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[ARM Cortex-M内核的复位启动过程也被称为复位序列(Reset sequence)，下面就来简要总结分析下这一过程。ARM Cortex-M内核的复位启动过程与其他大部分CPU不同，也与之前的ARM架构（ARM920T、ARM7TDMI等）不相同。大部分CPU复位后都是从0x0000_0000处取得第一条指令开始运行的，然而在ARM Cortex-M内核中并不是这样的。其复位序列为：从地址0x0000_0000处取出MSP的初始值；从地址0x0000_0004处取出PC的初始值，然后从这个值对应的地址处取指。即下图所示过程：事实上，地址0x0000_0004开始存放的就是默认中断向量表（有些资料中将地址0x0000_0000处的MSP指针初始值也算作中断向量表的一部分，这个说法似乎不太妥当），ARM Cortex-M内核的中断向量表布局情况如下图所示：注意：中断向量表的位置可以改变，此处是默认情况下的设置。值得注意的是，在ARM Cortex-M内核中，发生异常后，并不是去执行中断向量表中对应位置处的代码，而是将对应位置处的数据存入PC中，然后去此地址处进行取指。简而言之，在ARM Cortex-M的中断向量表中不应该放置跳转指令，而是该放置ISR程序的入口地址。有了上面的分析就很好理解复位序列了，复位其实就相当于发生了一次Reset异常，而从图中可以看到，地址0x0000_0004处存放的正是Reset异常对应的中断处理函数入口地址。另外还有两个细节问题需要注意：0x0000_0000处存放的MSP初始值最低三位需要是0；0x0000_0004处存放的地址最低位必须是1。第一个问题是因为ARM AAPCS中对栈使用的约定是这样的：5.2.1.1Universal stack constraintsAt all times the following basic constraints must hold:Stack-limit &amp;lt; SP &amp;lt;= stack-base. The stack pointer must lie within the extent of the stack.SP mod 4 = 0. The stack must at all times be aligned to a word boundary.5.2.1.2Stack constraints at a public interfaceThe stack must also conform to the following constraint at a public interface:SP mod 8 = 0. The stack must be double-word aligned.简而言之，规约规定，栈任何时候都必须4字节对齐，在调用入口需8字节对齐，而且SP的最低两位在硬件上就被置为0了。第二个问题与ARM模式与Thumb模式有关。ARM中PC中的地址必须是32位对齐的，其最低两位也被硬件上置0了，故写入PC中的数据最低两位并不代表真实的取址地址。ARM中使用最低一位来判断这条指令是ARM指令还是Thumb指令，若最低位为0，代表ARM指令；若最低位为1，代表Thumb指令。在Cortex-M内核中，并不支持ARM模式，若强行切换到ARM模式会引发一个Hard Fault。最后写一段小程序来验证下以上分析。这段程序基于STM32F4系列单片机，作用是让PA0管脚输出高电平。这应该也是实现这一目的最精简的写法了。第11行使用DCD伪指令分配了4个字节的存储空间，并将其值设置为0x0000_0400；第12行同理，将Start标号处的地址放置在偏移量为4字节的位置处；第17行Start标号之后的部分就是程序主体，依次完成了GPIOA端口RCC时钟使能、PA0设置为输出模式、PA0置高这三个步骤。程序在链接时会将RESET段放置在目标文件开头，故相当于在地址0x0000_0000处的数据为0x0000_0400，在地址0x0000_0004处的数据为Start部分的入口地址。不过需要指出的是，实际上在STM32F4芯片中，内部Flash的地址是从0x0800_0000处开始的，在BOOT管脚设置为Flash启动的时候，芯片内部会自动将0x0000_00000x000F_FFFF区域映射至0x0800_00000x080F_FFFF处，此时可以视为二者是等价的。使用Debug模式进行调试，复位后CPU寄存器的值如下所示：Flash中的数据如图：可以看到，编译器很智能的将0x0800_0004处的数据设置为了0x0800_0009，而不是Start标号真实的地址值，这说明了这是一条Thumb-2指令。复位后PC中的值是0x0800_0008，SP中的值是0x0000_0400，与预期结果完全相同。最后顺便提一下，上面那段简单的程序有个问题，实际上Start部分的程序是占用了中断向量表的空间，这在没有异常发生的时候是没有问题的，不过一旦有异常发生，显然程序执行是会出错的。]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
            <tag> Bootrom </tag>
            
            <tag> Top </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Socket Error： Address already in use的解决办法</title>
      <link href="/2016/04/27/Python%20Socket%20Error%EF%BC%9A%20Address%20already%20in%20use%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2016/04/27/Python%20Socket%20Error%EF%BC%9A%20Address%20already%20in%20use%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[之前用Python写了个简单的TCP通信程序，放在腾讯云上24小时运行。不过有个问题，有时候使用kill -9 pid命令结束掉python进程后，再次运行程序就会提示Address already in use这个错误，然而等一段时间再去运行就可以了。造成这个问题的原因在于此时TCP连接还没有完全关闭，而Socket默认不支持地址复用。深入的原因打算等之后仔细学习TCP/IP协议的时候再来研究，目前只是要找一个解决方案。找到的解决方案也很简单，在绑定前调用setsockopt()函数让Socket允许地址复用即可，即以下代码：第2行代码就是调用setsockopt()函数，其中SOL_SOCKET代表对Socket层进行设置，SO_REUSEADDR代表是否允许在bind过程中本地地址可重复使用，最后的1表示允许。]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
            <tag> Debug </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C2000 DSP中全局变量清零问题</title>
      <link href="/2016/04/24/C2000%20DSP%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%B8%85%E9%9B%B6%E9%97%AE%E9%A2%98/"/>
      <url>/2016/04/24/C2000%20DSP%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E6%B8%85%E9%9B%B6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[一般情况下，未明确赋初值的全局变量会被自动清零，而且ANSI C中似乎也有这一规定，之前写程序都默认这是没有例外的规定了。然而，前段时间在调试28030程序的时候发现，未赋初值的全局变量并没有被清零，而是一个随机值，这说明在TI的DSP中，全局变量并不会自动清零。TI论坛中的这个讨论也证实了这一结论，由此可见，TI的编译器的确有些很特别的地方……下面来具体谈谈全局变量清零这个问题。全局变量一般被称为.bss段，ARM编译器中也将其称为ZI-data段，即”Zero Initialize”之意。.bss段是不占用ROM空间的，程序运行起来后.bss段显然应该是在RAM中的，这就有一个问题，RAM中的.bss段是什么时候完成清零的呢？答案是在进入main()函数之前，由启动代码或库函数完成清零操作，如果使用了操作系统，则由Bootloader完成这一工作。以ARM MDK附带的启动代码为例，在执行完使用汇编语言编写的启动代码后，程序并没有跳转到main()处，而是跳转到了__main()处执行。__main()函数是一个库函数，这个函数最重要的作用就是完成所谓的“段拷贝”工作，具体来说，就是完成了以下三个步骤：将非零(只读和读写)运行区域从其载入地址复制到运行地址；清零ZI-data区域（即.bss段）；跳转到__rt_entry，最终会跳转到main()处，用户程序开始执行。由此可见，是否对全局变量进行清零完全是由启动代码和库函数决定的，而TI的编译器就没有链接完成这一工作所需的库函数，自然也就无法完成全局变量自动清零的工作了。解决这一问题的方法有两个：在声明全局变量显式的赋初值0程序中仿照__main()库函数的写法，自己写一个清零函数完成这一工作值得注意的是，通过请教导师得知，这并不是TI编译器的设计缺陷，TI的编译器是专门这样设计的，这样设计的目的在于赋予程序员更大的灵活性。在某些情况下，是需要对全局变量进行选择性清零或其它操作的。一个实际的例子是：假设使用了看门狗，在某些情况下系统看门狗复位了，对于某些控制系统而言，这时是要求系统在最短的时间内恢复之前的工作状态的。这种情况下，一般在程序开头加上一段检测代码，检测复位原因，如果是正常上电复位，则对全局变量进行清零操作；若判断出是看门狗复位，则自动执行之前的程序。系统软复位时并没有掉电，故RAM中的数据不会丢失。因为此时并没有对全局变量进行清零，之前的全局变量数据全部都在，此时就可以很快的恢复之前的工作状态，并且还可以使用一些全局变量辅助判断之前的错误复位的原因。]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> DSP </tag>
            
            <tag> C </tag>
            
            <tag> Runtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言中函数指针的声明及使用</title>
      <link href="/2016/04/21/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/04/21/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[函数指针一般的声明方式为：其中Return代表返回值的类型，Params代表函数参数列表，如下面两个比较简单的声明：使用的时候可以使用以下两种等价的赋值及调用方式：更为复杂一点的问题是，如果一个函数指针作为函数的参数与函数的返回值时该如何进行声明呢？作为函数参数的情况比较简单，像这样处理即可：这个例子中，声明并定义了一个函数Fun()，这个函数接受3个参数，后两个参数为int，第一个参数的类型是void (*)(int, int)，这是一个函数指针，指向一个返回值为void，参数为两个int的函数。然而如何处理函数指针作为返回值的情况呢？标准库&amp;lt;signal.h&amp;gt;中的signal()函数就是一个这样的函数，其声明形式如下：这个函数声明一眼看过去不是很好懂，下面来仔细分析一下。如果我们要声明一个整形变量a，可以这样写：如果要改为声明一个返回值为整形的函数fun()，可以视为只要将声明变量时使用的a改为fun()即可，即用同样的思路来分析声明一个返回值为函数指针的函数的声明方法，只要将函数指针声明中的变量名部分换为函数体即可。用实例分析一下：这里面pf是一个函数指针，指向一个输入参数为int，返回值为void的函数。将其中的pf换为一个函数fun()，即这样就得到了一个返回值为函数指针的函数fun()，它返回的函数指针其实就是上面的pf。理解了这样的声明方式后再来看signal()函数的声明就不那么难理解了。先看最里层：这是一个函数指针handler，带一个int参数，返回值为空。再向外一层：这是一个函数signal()，其参数为一个整形和一个函数指针。那这个函数的返回值是什么呢？由上面的分析易知，也是一个函数指针，这个函数指针的原型是这样的：对比Returnpf和handler的声明，可以看到二者是完全一样的。这时候就可以利用typedef这个好东西来简化之前那个复杂的signal()函数的声明了，具体做法如下：其中第1行与第5行的声明是完全等价的，使用第5行这种声明方式就显得直观多了。最后编写了两个简单的测试程序来进一步熟悉下函数指针的使用方法。不使用typedef的版本：使用typedef的版本：程序运行输出结果均为：使用typedef的版本明显可读性要好得多。]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言标准库总结</title>
      <link href="/2016/04/18/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93/"/>
      <url>/2016/04/18/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[标准库（Standard Library）是C语言重要的一部分，不过学习C语言这么长时间，都没有细致的了解过标准库到底中包含哪些内容，这几天打算来仔细看看这部分内容。C语言标准库有各种不同的实现，比如最著名的glibc， 用于嵌入式Linux的uClibc，还有ARM公司的自己的C语言标准库及精简版的MicroLib等。不同标准库的实现并不相同，而且提供的函数也不完全相同，不过有一个它们都支持的最小子集，这也就是最典型的C语言标准库。这个C语言标准库中一共包含15个头文件，粗略的按常用程度排序列举如下：Header FileContent**&amp;lt;stdio.h&amp;gt; **输入和输出&amp;lt;stdlib.h&amp;gt;最常用的一些系统函数&amp;lt;string.h&amp;gt;字符串处理&amp;lt;math.h&amp;gt;数学函数&amp;lt;ctype.h&amp;gt;字符类测试&amp;lt;time.h&amp;gt;时间和日期**&amp;lt;stdarg.h&amp;gt; **可变参数列表&amp;lt;signal.h&amp;gt;信号&amp;lt;assert.h&amp;gt;断言&amp;lt;setjmp.h&amp;gt;非局部跳转&amp;lt;errno.h&amp;gt;定义错误代码&amp;lt;stddef.h&amp;gt;一些常数、类型和变量&amp;lt;locale.h&amp;gt;本土化&amp;lt;float.h&amp;gt;浮点数运算&amp;lt;limits.h&amp;gt;定义整数数据类型的取值范围在这里不准备列举所有库函数的详细用法，如需查询具体的库函数用法，可以参考以下几个链接：Standard C 语言标准函数库速查 (Cheat Sheet)C标准库参考手册C Standard Library Reference Tutorial本文总结的是不完整的C标准库，仅列举一些常用且最重要的部分。关于C标准库本身的实现分析，可参考我的学习笔记：C标准库学习笔记(1)——time、ctype、stdarg、assertstdio.h输入和输出。在其中定义了以下一些常用的类型及常量：NameCommentFILE文件指针EOFEnd Of File，表示文件的结尾stderr标准错误流stdin标准输入流stdout标准输出流其中stderr、stdin、stdout为宏定义，是指向FILE类型的指针。&amp;lt;stdio.h&amp;gt;中的函数有很多，大致可分为对标准输入输出流的操作、对文件流的操作、对标准错误流的操作、对字符串的操作这几大类。标准输入输出流其实从stdin与stdout的定义中也可以看到，标准输入输出流也就是文件，只是一般情况下已经默认定义为键盘和屏幕。这与Linux中一切皆文件的思想一脉相承。常用的函数有以下这些：NameCommentint printf(const char * format, ...)格式化输出数据至stdoutint scanf(const char * format, ...)由stdin读取格式化输入数据int putchar(int c)向stdout输出一个字符int getchar(void)由stdin读入一个字符int puts(const char * s)向stdout输出一串字符串char * gets(char * s)由stdin读入一串字符串另外，vprintf()函数主要用于需要自己实现一些类似printf()的函数时使用，关于这个函数的用处可参考StackOverflow上的讨论，用于文件流的vfprintf()与用于字符串的vsprintf()的用处也是相似的。文件流对文件的操作是&amp;lt;stdio.h&amp;gt;中的核心，其他函数均可视为对特定文件的操作，大部分函数均以f****()命名。最重要的函数是以下这几个：NameCommentFILE * fopen(const char * filename, const char * mode)打开文件，失败返回NULLint fclose(FILE * stream)关闭文件，成功返回0，失败返回EOFsize_t fread(void * ptr, size_t size, size_t nmemb, FILE * stream)读取文件内容size_t fwrite(cosnt void * ptr, size_t size, size_t nmemb, FILE * stream)写入文件内容只使用这4个函数就可以完成基本的文件读写操作了，其它函数可以视为是为了更方便的进行文件读写而引入的。在Linux中，文件不仅仅是指磁盘上的一个file，也有可能是一个设备等，不过都可以以统一的方式进行读写。常用的打开模式有r(读)、w(写)、a(附加)、b(二进制)等。与标准输入输出流的操作相同，对文件的操作也有以下这些函数：NameCommentint fprintf(FILE * stream, const char * format, ...)格式化输出数据至文件int fscanf(FILE * stream, cosnt char * format, ...)由文件读取格式化输入数据int putc(int c, FILE * stream)向文件输出一个字符int getc(FILE * stream)由文件读入一个字符int fputc(int c, FILE * stream)向文件输出一个字符int fgetc(FILE * stream)由文件读入一个字符int fputs(const char * s, FILE * stream)向文件输出一串字符串（或比特流）char * fgets(char * s, int n, FILE * stream)由文件读入一串字符串（或比特流）其中putc()与fputc()、getc()与fgetc()的区别在于前者可能是使用宏定义实现的，而后者一定是函数，具体分析可以参考这篇文章。用于对文件进行修改（如删除文件等）的函数有以下这些：NameCommentint remove(const char * filename)删除文件，成功返回0int rename(const char * old, const char * new)更改文件名称或位置，成功返回0FILE * tmpfile(void)以wb+形式创建一个临时二进制文件其中tmpfile()创建的临时文件在调用fclose()关闭时会被自动删除。对文件流的定位通常使用以下这些函数：NameCommentint fseek(FILE * stream, long int offset, int fromwhere)移动文件流的读写位置，错误返回非0long int ftell(FILE * stream)取得文件流的读取位置void rewind(FILE * stream)重设读取目录的位置为开头位置int feof(FILE * stream)检测文件结束符whence可设置为SEEK_SET、SEEK_END或SEEK_CUR。使用这两个函数处理读写文件流操作中的错误：NameCommentint ferror(FILE * stream)检查流是否有错误void clearerr(FILE * stream)复位错误标志与缓冲(Buffer)机制有关的函数常用的有以下这两个：NameCommentvoid setbuf(FILE * stream, char * buf)把缓冲区与流相联int fflush(FILE * stream)更新缓冲区，成功返回0，错误返回EOF其他流操作对stderr的操作通过以下函数完成：NameCommentvoid perror(const char * s)打印出错误原因信息字符串此函数将上一个函数发生错误的原因输出到stderr，此错误原因依照全局变量errno的值来决定要输出的字符串，errno在&amp;lt;errno.h&amp;gt;中声明。对字符串也提供了格式化输入输出函数：NameCommentint sprintf(char * s, const char * format, ...)格式化字符串复制int sscanf(const char * s, const char * format, ...)格式化字符串输入stdlib.h最常用的一些系统函数。在其中定义了以下一些常用的类型及常量：NameCommentsize_tsizeof运算符产生的数据类型，一般是一个无符号整数wchar_t一个宽字符的大小NULL空RANDMAXrand()的最大返回值下面分类整理一下其中的重要函数。内存管理函数最常用的是以下两个函数：NameCommentvoid * malloc(size_t size)从堆上动态分配内存空间void free(void * ptr)释放之前分配的内存空间还有一些常用的内存控制函数位于&amp;lt;string.h&amp;gt;中。数学函数常用函数有：NameCommentint abs(int j)int类型数据绝对值long labs(long j)long类型数据绝对值int rand(void)产生一个随机数void srand(unsigned int seed)初始化随机数种子关于rand()与srand()的用法，之前写的这篇文章中进行了总结。字符串转换函数常用的有以下这3个函数：NameCommentint atoi(const char * nptr)将字符串转换为整数（int）long atol(const char * nptr)将字符串转换为长整数（long）double atof(const char * nptr)将字符串转换为浮点型数（double）环境函数常用的函数有：NameCommentint system(const char * string)执行Shell（或命令行）命令char * getenv(const char * name)获取环境变量中的内容int exit(int stauts)结束进程搜索和排序函数NameCommentvoid qsort(void * base, size_t nmemb, size_t size, int (* compar)(const void *, const void *))快速排序算法void * bsearch(const void * key, const void * base, size_t nmemb, size_t size, int (* compar)(const void *, const void *))在数组进行二分法查找某一元素，要求数组预先已排好序在&amp;lt;stdlib.h&amp;gt;中还有一些用于进行多字节字符处理的函数，此处没有列出。string.h&amp;lt;string.h&amp;gt;中除了字符串处理函数，还有一些内存管理函数：NameCommentvoid * memset(void * dest, int c, size_t n)将一段内存空间填上某值void * memcpy(void * dest, const void * src, size_t n)复制一段内存内容int memcmp(const void * s1, const void * s2, size_t n)比较两段内存内容void * memchr(const void * s, int c, size_t n)在某一段内存范围中查找特定字节常用的字符串操作函数有：NameCommentchar * strcat(char * deat, const char * src)连接两个字符串char * strcpy(char * dest, const char * src)复制字符串int strcmp(const char * s1, const char * s2)比较两个字符串size_t strlen(const char * s)获取一个字符串的长度char * strtok(char * s1, const char * s2)分割字符串以下这些函数用于进行字符串查找：NameCommentchar * strchr(const char * s, int c)正向查找一个字符char * strrchr(const char * s, int c)反向查找一个字符char * strstr(const char * s1, const char * s2)查找一个字符串char * strpbrk(const char * s1, const char * s2)查找一个字符集合math.h标准数学库，常用函数如下：三角函数NameCommentdouble sin(double x)正弦double cos(double x)余弦double tan(double x)正切double asin(double x)反正弦double acos(double x)反余弦double atan(double x)反正切double atan2(double y, double x)计算y/x的反正切双曲三角函数NameCommentdouble sinh(double x)双曲正弦double cosh(double x)双曲余弦double tanh(double x)双曲正切指数与对数NameCommentdouble exp(double x)e的n次幂double pow(double x, double y)x的y次幂double sqrt(double x)开根号double log(double x)e为底的对数double log10(double x)10为底的对数取整NameCommentdouble ceil(double x)向上取整double floor(double x)向下取整其它NameCommentdouble fabs(double x)计算绝对值ctype.h包含字符测试及大小写转换函数。字符测试NameCommentisalpha(c)是否为字母isupper(c)是否为大写字母islower(c)是否为小写字母isdigit(c)是否为数字isxdigit(c)是否为16进制数字（数字 &amp;amp; AF &amp;amp; af）isalnum(c)是否为字母及数字ispunct(c)是否为标点符号isspace(c)是否为空白字符（空格、\r(CR)、\n(LF)、\t(TAB)、\v(VT)、\f(FF)）iscntrl(c)是否为控制字符（ASCII 0 ~ 37(0x1F) &amp;amp; 177(0x7F)）isgraph(c)是否为可显示字符（字母 &amp;amp; 数字 &amp;amp; 标点）isprint(c)是否为可打印字符（字母 &amp;amp; 数字 &amp;amp; 标点 &amp;amp; 空白）大小写转换NameCommenttolower(c)转换为小写toupper(c)转换为大写time.h日期及时间操作。定义了time_t、clock_t及tm这几种类型，常用函数有：获取时间及相关计算NameCommenttime_t time(time_t * timer)获取UNIX时间戳，一般传入NULLclock_t clock(void)获取CPU时钟计数double difftime(time_t time1, time_t time0)计算时间差，time1 - time0struct tm * gmtime(const time_t * timer)GMT时间struct tm * localtime(const time_t * timer)地方时时间time_t mktime(struct tm * timeptr)地方时时间转换为可阅读的字符串NameCommentchar * ctime(const time_t * timer)返回标准时间字符串，地方时时间，等价于asctime(localtime())char * asctime(const struct tm * timeptr)返回标准时间字符串size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *)返回自定义格式时间字符串stdarg.h用于支持可变参数，定义了va_list这个结构体，通过以下三个宏进行操作：NameCommentvoid va_start(va_list ap, parmN)初始化va_listtype va_arg(va_list ap, type)从va_list中获取一个type类型的参数void va_end(va_list ap)释放va_listsignal.h定义了信号(Signal)处理的相关宏及函数，这与Linux中的信号机制密切相关，包含下面两个函数：NameCommentsignal()设置处理特定Signal的Handlerraise(int sig)产生一个Signalsignal()函数原型如下：void (* signal(int sig, void (* handler)(int)))(int);assert.h此头文件的唯一目的是提供assert(int x)这个宏，如果断言非真，程序会在标准错误流输出错误信息，并调用abort()函数使程序异常终止。setjmp.h非局部跳转，用于从一个深层次嵌套中直接返回至最外层，通过这两个宏完成：NameCommentint setjmp(jmp_buf env)设置跳转点void longjmp(jmp_buf env, int val)进行跳转errno.h声明了一个外部整形变量errno用于表示错误，可用perror(const char * s)输出错误原因，其中s是错误提示前缀。标准使用方法是：在一个库函数调用之前把它设为0，然后在下一个库函数调用前测试它，任何非零值均表示错误。示例代码：stddef.h定义了一些标准定义，如size_t、wchar_t、NULL等，这些定义也会出现在其他的头文件里。还定义了以下这个宏：NameCommentoffsetof(type, member)返回结构体中某一成员相对于结构体起始地址的偏移量locale.h国家、文化和语言规则集称为区域设置，主要影响字符串格式，通过以下函数进行设置：NameCommentsetlocale()设置或恢复本地化信息float.h用宏定义的方式定义了浮点数的最大值、最小值等信息。limits.h定义了基本数据类型（int、char、short等）的最大值及最小值。常用宏定义有：NameCommentCHAR_BIT一个字节的比特数SCHAR_MIN带符号字符最小值SCHAR_MAX带符号字符最大值UCHAR_MAX无符号字符最大值CHAR_MINchar的最小值CHAR_MAXchar的最大值SHRT_MIN带符号短整型最小值SHRT_MAX带符号短整型最大值USHRT_MAX无符号短整型最大值INT_MIN带符号整形最小值INT_MAX带符号整形最大值UINT_MAX无符号整形最大值LONG_MIN带符号长整形最小值LONG_MAX带符号长整形最大值ULONG_MAX无符号长整形最大值]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP中确定报文结束的方法</title>
      <link href="/2016/04/14/HTTP%E4%B8%AD%E7%A1%AE%E5%AE%9A%E6%8A%A5%E6%96%87%E7%BB%93%E6%9D%9F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2016/04/14/HTTP%E4%B8%AD%E7%A1%AE%E5%AE%9A%E6%8A%A5%E6%96%87%E7%BB%93%E6%9D%9F%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[HTTP中，确定报文结束有几种不同方法，较为常见的是：关闭TCP连接通过Content-Length检测若不关闭TCP连接，也不在HTTP头部加上Content-Length字段，则无法正确确定HTTP报文是否结束，对于浏览器来说，此时就会一直处于加载状态。这几天学习Python Socket编程时就遇到了这个问题，下面是一段最简单的HTTP服务器代码，无论收到什么请求都返回一个Hello World!然而，这段代码是无法正常工作的，运行之后使用浏览器访问http://localhost/，得到的结果是这样的：从Shell的输出结果来看，HTTP响应报文已经发送成功了，此时服务器已经在等待下一次请求了，而浏览器却始终处于Connecting状态中。可以通过由服务器主动关闭TCP连接来解决这一问题，修改后的代码是这样的：修改后就可以正常运行了：如果不关闭TCP连接，也可以通过加上Content-Length字段来解决这一问题，代码如下：这样浏览器也可以正常访问服务器，运行结果和之前关闭TCP连接完全相同。一般来说，没有必要始终维持着一个TCP连接，所以最佳的解决方案是：使用Content-Length字段，并且在每次响应之后关闭TCP连接，即以下代码：]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言运算符优先级与结合性</title>
      <link href="/2016/04/08/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E6%80%A7/"/>
      <url>/2016/04/08/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E7%BB%93%E5%90%88%E6%80%A7/</url>
      
        <content type="html"><![CDATA[整理下C语言中的运算符优先级与结合性问题，方便将来查阅。总结：单目运算符高于双目运算符，高于三目运算符，高于赋值运算符，逗号运算符优先级最低单目运算符中，成员选择、数组下标、括号、函数调用的优先级高于其它双目运算符中，算数运算高于移位，高于大于小于，高于==及！=，高于位运算，高于逻辑运算比较容易出错的有下面这些：完整的表格如下：优先级运算符名称或含义使用形式结合方向说明1[]数组下标数组名[常量表达式]左到右&amp;nbsp;()圆括号（表达式）/函数名(形参表)&amp;nbsp;.成员选择（对象）对象.成员名&amp;nbsp;-&amp;gt;成员选择（指针）对象指针-&amp;gt;成员名&amp;nbsp;2-负号运算符-表达式右到左单目运算符(类型)强制类型转换(数据类型)表达式&amp;nbsp;++自增运算符++变量名/变量名++单目运算符- -自减运算符- -变量名/变量名- -单目运算符 \* 取值运算符\*指针变量单目运算符&amp;amp;取地址运算符&amp;amp;变量名单目运算符!逻辑非运算符!表达式单目运算符~按位取反运算符~表达式单目运算符sizeof长度运算符sizeof(表达式)&amp;nbsp;3/除表达式/表达式左到右双目运算符 \* 乘表达式\* 表达式双目运算符%余数（取模）整型表达式%整型表达式双目运算符4+加表达式+表达式左到右双目运算符-减表达式-表达式双目运算符5&amp;lt;&amp;lt;左移变量&amp;lt;&amp;lt;表达式左到右双目运算符&amp;gt;&amp;gt;右移变量&amp;gt;&amp;gt;表达式双目运算符6&amp;gt;大于表达式&amp;gt;表达式左到右双目运算符&amp;gt;=大于等于表达式&amp;gt;=表达式双目运算符&amp;lt;小于表达式&amp;lt;表达式双目运算符&amp;lt;=小于等于表达式&amp;lt;=表达式双目运算符7==等于表达式==表达式左到右双目运算符!=不等于表达式!= 表达式双目运算符8&amp;amp;按位与表达式&amp;amp;表达式左到右双目运算符9^按位异或表达式^表达式左到右双目运算符10|按位或表达式|表达式左到右双目运算符11&amp;amp;&amp;amp;逻辑与表达式&amp;amp;&amp;amp;表达式左到右双目运算符12||逻辑或表达式||表达式左到右双目运算符13?:条件运算符表达式1? 表达式2: 表达式3右到左三目运算符14=赋值运算符变量=表达式右到左&amp;nbsp;/=除后赋值变量/=表达式&amp;nbsp;*=乘后赋值变量*=表达式&amp;nbsp;%=取模后赋值变量%=表达式&amp;nbsp;+=加后赋值变量+=表达式&amp;nbsp;-=减后赋值变量-=表达式&amp;nbsp;&amp;lt;&amp;lt;=左移后赋值变量&amp;lt;&amp;lt;=表达式&amp;nbsp;&amp;gt;&amp;gt;=右移后赋值变量&amp;gt;&amp;gt;=表达式&amp;nbsp;&amp;amp;=按位与后赋值变量&amp;amp;=表达式&amp;nbsp;^=按位异或后赋值变量^=表达式&amp;nbsp;|=按位或后赋值变量|=表达式&amp;nbsp;15,逗号运算符表达式,表达式,&amp;hellip;左到右从左向右顺序运算]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MCS-51 基本数据类型</title>
      <link href="/2016/03/25/MCS-51%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2016/03/25/MCS-51%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[以Keil C51编译器为例，MCS-51上基本数据类型及其占用空间如下表：数据类型占用空间范围char1 Byte (8 bits)0 ~ 255signed char1 Byte (8 bits)-128 ~ +127short2 Bytes (16 bits)-32768 ~ +32767unsigned short2 Bytes (16 bits)0 ~ 65535int2 Bytes (16 bits)-32768 ~ +32767unsigned int2 Byte (16 bits)0 ~ 65535long4 Bytes (32 bits)-2147483648 ~ +2147483647unsigned long4 Bytes (32 bits)0 ~ 4294967295float4 Bytes (32 bits)±1.175494E-38～±3.402823E+38double4 Bytes (32 bits)±1.175494E-38～±3.402823E+38* (Pointer)3 Bytes (24 bits)-bit1 bit0 or 1sbit1 bit0 or 1sfr1 Byte (8 bits)0 ~ 255sfr162 Bytes (16 bits)0 ~ 65535关于MCS-51中的指针，分为通用指针（3字节）、xdata指针（2字节）、code指针（2字节）、idata指针（1字节），详见以下文章：C51:Keil c51指针变量关于Keil C51指针的使用参考资料：KEIL C51编译器所支持的数据类型及各其长度]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> MCS-51 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半导体存储器总结</title>
      <link href="/2016/03/22/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2016/03/22/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[概述半导体存储器在任何一个包含处理器的系统中都是必不可少的一部分，一般将其分为RAM与ROM两大类；根据系统掉电后存储内容是否可以保持又可分为易失（Volatile）与非易失（Non-volatile）两大类。下面是常见的半导体存储器分类图原理基本所有的存储器都是做成阵列结构的，即所谓的Memory Array，其中每个最小存储单元称为一个Cell，一般是存储1 bit数据，不过目前也有新工艺（如MLC、TLC）可以在一个存储单元内存放超过1 bit的数据。Memory Cell的结构示意图如下ROMROM全称Read Only Memory，在一般正常工作状态下，它是只读的。不过，也有一些ROM中的内容可对其进行编程修改，这就是所谓的可编程ROM；与此对应的就是不可编程ROM，即Mask ROM（掩膜 ROM）。ROM的工作原理可参考以下视频：sec 16-04 Memory ConceptsMROMMROM即Mask ROM，其Memory cell简化结构示意图如下从中可以看到，MOSFET源极连接关系在芯片掩膜中就确定了，所以MROM是无法编程的，其中的内容也是不会发生改变的。在MCU中，MROM一般用于实现一些固化于芯片内部的功能，如引导程序，某些内置的库函数等。PROMPROM即User-Programable ROM，亦称OTP ROM（One-Time Programable ROM）。PROM基于熔丝技术，即Fusible-Link，其Memory cell简化结构示意图如下在出厂时，所有熔丝均处于图(b)的状态，即存储器中存储的内容是0。用户可对其进行编程，用大电流使源极熔丝熔断即可将此位置为1。此编程过程是一次性不可逆的，也就是所谓的一次编程（OTP）。上面的原理图中描述的是基于熔丝原理的PROM，事实上，目前更为广泛使用的是反熔丝技术。二者的区别在于，熔丝（Fuse）在初始状态是闭合的，可通过编程使其断开；反熔丝（Antifuse）在初始状态是断开的，可通过编程使其闭合。反熔丝技术的基本原理见下图EPROM &amp;amp; EEPROM &amp;amp; FlashEPROM、EEPROM及Flash的基本原理是相同的，都是基于浮栅技术（Floating-gate MOSFET）。浮栅MOS管的结构示意图如下悬浮栅极位于两层二氧化硅绝缘层之间，因此存储于其中的电荷可以得到长久的保持。EPROM、EEPROM及Flash的Memory cell简化结构示意图如下三者的区别主要在于其编程的方式不同。EPROM通过紫外线（UV）照射进行数据擦除，浮栅中的电荷形成光电流泄漏走；EEPROM与Flash均是通过超薄氧化层的Fowler-Nordheim隧道电流使浮栅充放电。EEPROM的Memory cell是由FLOTOX(Floating- gate tuneling oxide transister)及一个附加的晶体管（Transister）组成，由于FLOTOX的特性及两管结构，所以可以单元读/写。技术上，Flash是结合EPROM和EEPROM技术达到的，很多Flash使用雪崩热电子注入方式来编程，擦除和EEPROM一样用Fowler-Nordheim tuneling。但主要的不同是，Flash对芯片提供大块或整块的擦除，这就降低了设计的复杂性，它可以不要EEPROM单元里那个多余的Tansister，所以可以做到高集成度，大容量。另外Flash的浮栅工艺也有所不同，写入速度更快。RAMRAM全称Random Access Memory，顾名思义，RAM可根据存储单元的行地址和列地址进行快速读取或写入操作。随机访问的含义是RAM可以直接读取或写入任意一个存储单元，因此，从这个意义上来说，NOR Flash似乎也该算作RAM的一种，不过一般情况下还是把它归为ROM。而严格地说，DRAM不属于Random Access，因为在DRAM中数据读取是突发（Burst）传输的。RAM可分为三大类，SRAM、DRAM及nvSRAM。SRAMSRAM即Static RAM，所谓的Static是指它没有刷新操作，在不掉电的情况下Memory Cell可无限长时间的保存数据。SRAM的工作原理可参考以下视频：sec 16 02 Static RAMs其Memory cell简化结构示意图如下这是典型的6晶体管结构的SRAM（6T Cell），该结构的SRAM每个存储单元由六个MOS管组成，Q1、Q2、Q5、Q6构成双稳态触发器，Q3、Q4的开关状态由同一个选择信号CE控制。A1与A2是输入输出Buffer。DRAMDRAM即Dynamic RAM，所谓的Dynamic是指每个一段时间就要对每个Memory Cell进行一次刷新操作，否则数据就会丢失。DRAM的工作原理可参考以下视频：sec 16 03 Dynamic RAMs其Memory cell简化结构示意图如下DRAM每个存储单元由一个MOS管及其寄生电容构成，由于数据信号的状态由电容的电荷量决定，因此每隔一段时间需对电容做一次充放电的刷新操作。nvSRAMnvSRAM即Non-volatile SRAM，某些地方将NOR Flash也算作nvSRAM的一种，不过一般认为的nvSRAM是指FRAM、MRAM一类的新型SRAM，这类器件读取速度与传统的SRAM不相上下，而且掉电后还可以保持之前的数据，是一类很有发展潜力的存储器。其中FRAM就是一种很有代表性的新型存储器。FRAM目前主要由日本富士通公司（Fujitsu）生产，其核心在于使用PZT(锆钛酸铅，Pb{ZrTi}O3)晶粒作为电容存储数据。关于FRAM的详细技术说明，可参考Fujitsu的FRAM Guide Book。除此之外，还有一种nvSRAM是将电池与SRAM封装在了一起，这个从严格意义上来说并不能算nvSRAM，仅仅只是SRAM+电池而已。寄存器一般并不把使用Flip-Flop的寄存器算作存储器的一种，不过实际上它起到的作用和存储器是一样的。在进行嵌入式系统编程时经常涉及到寄存器，其实质就是若干个并联的触发器（Flip-Flop）。以4位寄存器为例，其原理图如下应用选取几种比较有代表性的器件介绍下其应用。PROMPROM一般用于OTP芯片中，这类芯片仅可进行一次编程，其价格与使用Flash的同类产品相比有很大优势。部分MCU内部也会有一小块OTP区域供用户使用。除此之外，部分FPGA和CPLD也使用PROM工艺，这还成为了其一大特色，一般用于航天和军工等可靠性要求极高的场合。这类器件使用的是反熔丝工艺，具有以下一些优点：编程不可逆，抗高低温，稳定性极高抗辐射强寿命长EEPROMEEPROM一般用于保存一些系统参数，最常用的分立EEPROM芯片为24Cxx系列，包括容量不同的24C02、24C04、24C08、24C16，分别能存储2k、4k、8k、16k bit数据。24Cxx系列的引脚定义如下24Cxx系列通过标准I2C接口与MCU进行通信。A0-A2引脚是器件地址输入，可以将多片24Cxx（24C16除外）同时接到I2C总线上以达到扩大容量的目的，不过这个功能一般不使用。WP引脚是写保护，一般也不使用，直接接地即可。两个典型操作的时序图如下：FlashFlash一般作为系统的主要存储设备用来保存程序和数据，可分为两种，NOR Flash与NAND Flash。Nor Flash数据线和地址线分开，可以实现RAM一样的随机寻址功能，可以读取任何一个字节。但是擦除仍要按块（Block）来擦。NAND Flash同样是按块擦除，但是数据线和地址线复用，不能利用地址线随机寻址，读取只能按页（Page）来读取。二者的结构对比见下图由于NAND Flash引脚上复用，因此读取速度比NOR Flash慢一点，但是擦除和写入速度比NOR Flash快很多。NAND Flash内部电路更简单，因此数据密度大，体积小，成本也低。因此大容量的Flash都是NAND型的。小容量的1MB～16MB的Flash多是NOR型的。二者的尺寸及密度对比见下图二者的综合性能比较见下图从使用上来说，NOR Flash也要比NAND Flash简单。另外，因为NAND Flash无法直接寻址，故程序无法在NAND Flash中运行，需要将其拷贝到RAM中才能运行。关于NAND Flash与NOR Flash的详细比较，可参考M-System公司的技术白皮书:Two Flash Technologies Compared: NOR vs NAND。对于NOR Flash而言，因为它有独立的地址线和数据线，其使用方法较为简单，只要将其接到CPU的地址总线和数据总线上即可，可参考下面这张工作模式图：至于具体的读取和擦除操作的命令及时序图，参考所使用的芯片的数据手册即可。对于NAND Flash而言，它没有专用的地址线，而是通过控制接口与CPU 相连，数据总线为8-bit或16-bit。以K9F1G08U0B为例，其内部存储单元的组织形式如图所示：一般NAND Flash有以下这些信号线：大部分CPU中均集成了NAND Flash控制器，此时只需要将对应引脚连接起来，然后根据CPU数据手册进行配置即可。如果需要自己实现NAND Flash控制器，那就需要根据NAND Flash的命令集及时序图进行编程了，这个对大部分NAND Flash应该都是基本通用的。具体可进一步参考相关文章，如NAND Flash操作技术详解从单个存储单元能存储的比特数来看，Flash芯片又可分为三种，SLC，MLC及TLC。这三者的区别简单来说就是SLC在每个存储单元中只存储1-bit数据，MLC为2-bit，而TLC为3-bit。关于这个问题，可进一步参考Micron公司的文章TLC MLC and SLC Devices和这篇博客文章。eMMCeMMC并不是一种存储介质，它是Embedded Multi Meida Card的缩写，而MMC就是指常见的SD卡、TF卡一类的存储卡。MMC相当于一种接口标准，可通过SPI或SDIO总线进行访问，而eMMC就是指符合这种接口标准的存储芯片。它是由NAND Flash加主控封装在一起做出来的，与种类繁多的NAND Flash相比，eMMC统一了接口形式，可以使用和操作SD卡一样的方式去控制NAND Flash。eMMC与NAND Flash相比，其优点在于更为稳定可靠，内部集成的主控IC会自动完成坏块处理等工作。另外，如果直接使用NAND Flash的话，产品升级就需要重新修改不少软件，而使用eMMC则不需要，这有助于减小开发新产品的工作量。Samsung、SanDisk、Kingston、Toshiba等公司均提供eMMC芯片，容量从2G~64G不等，基本所有的eMMC均使用BGA封装。SRAMSRAM的特点在于其的高速与小容量，它是目前读写速度最快的存储设备，但它也较为昂贵。CPU内部的Cache使用的就是SRAM，嵌入式SoC内部集成的内存也都是SRAM。SRAM可以直接对任意地址寻址，其读取是严格意义上的随机的（Random）。SRAM基本上可以分为两大类：异步（Asynchronous）SRAM和同步（Synchronous）SRAM。异步SRAM的访问独立于时钟，数据输入和输出都由地址的变化控制。同步SRAM的所有访问都在时钟的上升/下降沿启动。地址、数据输入和其它控制信号均于时钟信号相关。ISSI公司提供了很多型号的SRAM可供选择，从类型上来看主要有ZBT SRAM、DDR SRAM、QDR SRAM等。ZBT SRAM即Zero Bus Turnaround，零翻转SRAM。对于普通SRAM而言，由于读操作和写操作驱动方不同，当出现类似写-读-写操作时，相邻操作之间需插入一个空闲周期以便切换驱动方法。在读写操作切换频繁的应用中，这种空闲周期将严重地影响存储性能。对于ZBT SRAM，在读写操作之间不存在空闲周期，即读写操作可无缝连接，从而提高了存储性能。SRAM主要应用于高速缓存，是决定整个系统性能的关键部分。然而，ZBT SRAM的运行频率无法超过200MHz，随着系统的升级，ZBT SRAM已无法满足更高性能系统的要求，由此又诞生了QDR/DDR SRAM（升级后分别为QDR II/DDR II SRAM），其中DDR II SRAM又分为CIO（Common IO）和SIO（Separated IO）两大类。QDR是指四倍数据速率（Quad Data Rate），DDR的双倍数据速率是通过双边沿对数据采样实现的，QDR的数据采样同样基于双边沿，且进一步将数据的读端口和写端口分开，利用同一组地址和控制信号实现对这两个端口的访问，输入输出同时进行，从而实现四倍数据速率的同时，消除了读写操作之间的空闲周期，提高了存储效率。DRAMDRAM一般作为系统的主内存，常用的DRAM可进一步分为SDRAM（Synchronous）、DDR SDRAM、DDR2 SDRAM、DDR3 SDRAM等。SDRAM即同步动态随机存储器，同步指存储器的工作需要参考时钟。对于同步存储器件，有三个与工作速率相关的重要指标：内核工作频率，时钟频率和数据传输速率。不同类型的SDRAM的区别主要在于其读取速度不同，见下图和下表：SDRAM需要定时进行刷新，这一般是由专用的控制器模块或驱动芯片完成的，绝大部分CPU和一些高端MCU中都集成了控制器模块，只需要将对应的引脚连接起来，再进行相应的配置后即可使用了。PSRAMPSRAM即Pseudo static random access memory，伪静态随机存储器。它的内部存储颗粒其实与SDRAM的结构类似，不过外部接口则与SRAM类似。可以视为是内部集成了控制器的SDRAM，这主要用于没有SDRAM控制器的MCU应用中。它的容量介于SRAM与SDRAM之间。FRAMFRAM在某些时候可用于替代SRAM或EEPROM及Flash。TI就在各大MCU厂商中率先使用了FRAM，MSP430FR系列MCU中就只有FRAM。详细信息可参考TI的文章What is FRAM。下面这个Demo视频中演示了FRAM的读取速度：FRAM Write Speed Demo (FRAM vs. SRAM vs. EEPROM)比较可参考FRAM Guide Book中的比较表格：最后对各种存储器的应用范围做一总结：**Msak ROM和PROM一般作为芯片的一部分存在；EPROM已基本被淘汰；EEPROM用于需要能够很方便的进行随机存储（单字节操作）的场合，且其容量一般不大；Flash用于大量数据的存储，其中NOR Flash容量较小，不过能进行随机读操作，也可以运行程序；NAND Flash容量较大，不过只能按页操作，不可在其中运行程序；SRAM容量较小，用在对速度要求高的地方，如果需要掉电后保存数据，可考虑使用FRAM；DRAM容量较大，用于当做系统的主内存。**参考资料[1] William Kleitz. Digital Electronics: A Practical Approach with VHDL (9th Edition). Pearson Prentice Hall, 2011.[2] 存储器概述]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> HW Component </tag>
            
            <tag> Flash </tag>
            
            <tag> DDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Altium Designer导出Gerber文件方法</title>
      <link href="/2016/03/04/Altium%20Designer%E5%AF%BC%E5%87%BAGerber%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/"/>
      <url>/2016/03/04/Altium%20Designer%E5%AF%BC%E5%87%BAGerber%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[详细步骤参考此文档与这篇文章，此处仅简要记录一下所需的操作步骤。将坐标原点设置为板子的左下角在Drill Drawing层添加字符串.Legned，这是孔位图生成的位置，一般放在板子右侧下方输出Gerber Files1 General选项卡中，单位Inches，格式2:52 Layers选项卡中，选中所需层，一般不要选Mirror，不要选Mechanical Lyaers(s) to Add to All Plots中的层3 Drill Drawing选项卡中，勾选Drill Drawing Plots，.Legend Symbols选Characters4 Apetures选项卡中勾选RS274X5 Advanced选项卡中，选取Suppress leading zeros、Reference to relative origin、Unsorted(raster)，其余用默认值即可输出NC Drill Files，单位Inches，格式2:5，选取Suppress leading zeros、Reference to relative origin、Optimize change location commands，其余用默认值即可打包输出文件，并不是所有输出文件都是必要的，不过出于简单考虑，可以全部一起打包即可]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客修改Archive页面显示文章数量</title>
      <link href="/2016/03/03/Hexo%E5%8D%9A%E5%AE%A2%E4%BF%AE%E6%94%B9Archive%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%95%B0%E9%87%8F/"/>
      <url>/2016/03/03/Hexo%E5%8D%9A%E5%AE%A2%E4%BF%AE%E6%94%B9Archive%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[之前配置的Swiftype站内搜索功能很不稳定，经常因为网络问题无法返回搜索结果，所以要找写过的某篇文章就不太方便。为解决这个问题，有一个方法是在Archive页面上不分页，然后就可以用浏览器自带的搜索功能来搜索标题了。默认情况下，Hexo无法对主页、Archive页面、标签页面每页显示文章数量进行单独设置，所以需要安装hexo-generator-archive插件来实现这个功能。使用如下命令安装：安装好后修改_config.yml中的相关配置，分别对index、archive、tag及category页面进行设置即可：参考资料：Hexo程序archive页面数量设置]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Population Count算法</title>
      <link href="/2016/02/24/Population_Count/"/>
      <url>/2016/02/24/Population_Count/</url>
      
        <content type="html"><![CDATA[所谓Population Count算法，即是指计算一个二进制数中1的个数的算法。具体来说，就是任意给定一个无符号整数N，求N的二进制表示中1的个数，比如N = 5（0101）时，返回2；N = 15（1111）时，返回4。这个问题是一个经典的面试题目，在实际中也有应用。关于这个问题，以下两篇博客文章中有较详细的论述：详解二进制数中1的个数算法-求二进制数中1的个数在此，仅对其中一些较为常规和较为巧妙的方法做一总结，并比较一下他们的执行效率。直接法1直接逐位判断，最直接也是最低效的方法。直接法2在“直接法1”的基础上进行改进，当移位结果为0后就退出循环，这样循环次数与首位1的位置有关。最优情况下只循环一次，最坏情况下循环N次。逐次清除最低位1此方法利用num &amp;amp;= (num - 1)可清除最低位1的原理进行计数。num与num - 1的区别在于，num的最低位1在num - 1中变为了0，故二者取与后即可清除最低位1.分支法思路类似二分法，两两相加后即可得到结果，见下图：在详解二进制数中1的个数中对此有详细描述。此方法复杂度为Log(N)(之前几种方法复杂度均为N)，对于32位整数只需要计算5次即可。三分法这是一种很巧妙的方法，在此对其原理不多做说明，可参考之前提到的那两篇博客文章。CPU指令实现部分CPU中直接提供了指令来完成这一操作，这无疑是效率最高且最为简洁的方法。在Intel x86中，如果CPU支持SSE4指令集，那可以使用POPCNT指令来计算二进制数中1的个数，实验表明，这应该是一个单周期指令，所以这无疑是最优的解决方案。在MSVC下，可通过_mm_popcnt_u32()函数来调用POPCNT指令，详细信息可参考MSDN上的帮助。调用示例如下:在GCC下，可直接调用__builtin_popcountll()函数，编译时加上编译选项-mpopcnt即可，此时编译器会自动使用POPCNT指令。在ARM中，也有类似的指令，比如POPCOUNT宏（需要约10个时钟周期），NEON SIMD指令集中的VCNT及CNT指令。POPCNT指令应该是有其实际重要作用的，比如在OpenCV的编译过程中就可以选择是否启用POPCNT指令。执行时间对比毫无疑问，直接调用CPU指令是最佳的解决方案，将其执行时间规定为1，对其他算法的执行时间进行归一化处理，结果如下：从中可以看到，除了特别简单的情况下（如0x01），分枝法与三分法的执行效率是最好的，且这两种算法是稳定的算法，其执行时间不依赖于输入数据。逐次清除最低位1法在1的个数较少时也不失为一种好方法。]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Matlab调用Origin作图</title>
      <link href="/2016/01/28/Matlab%E8%B0%83%E7%94%A8Origin%E4%BD%9C%E5%9B%BE/"/>
      <url>/2016/01/28/Matlab%E8%B0%83%E7%94%A8Origin%E4%BD%9C%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[Matlab作出的图普遍没有Origin作出的美观好看，而且导出为eps或emf格式后会有各种奇怪的Bug。目前普遍采用的一种方法是，将Matlab数据导出为mat文件后再导入Origin中手工作图，这种方式需要不少重复性劳动，并不是一种很完美的解决方案。前几天偶然看到Origin提供了COM接口可供Matlab调用，于是就研究了下可否用Matlab调用Origin来生成所需的emf格式图片，最终经过一番折腾，基本完成了这个目标。之所以能用Matlab来调用Origin，这要依赖于Origin中提供的Automation Server服务。这个服务提供了一个COM接口来供其他程序调用，官方提供了Matlab、VB、Excel、C#、LabVIEW等诸多程序调用Origin的例子。Automation Server的详细使用方法可参考其官方帮助文档。Matlab调用Origin的示例程序位于&amp;lt;Install Path&amp;gt;\Samples\COM Server and Client\MATLAB路径下（以Origin 2015为例，其他版本的位置可能有所不同）。一共有两个m文件，CreatePlotInOrigin.m及MATLABCallOrigin.m，前者用于实现调用Origin绘图，并将结果保存到剪贴板中，后者演示了如何创建工作表(Worksheet)，如何插入新列等操作。另外一个CreatePlotInOrigin.opj文件是供CreatePlotInOrigin.m调用的一个Origin模板文件。根据这两个示例程序基本就可以依葫芦画瓢写出一个符合自己要求的程序了，然而这其中并没有导出emf格式图片的示例，于是开始研究其官方帮助文档……官方帮助文档很多地方都语焉不详，而且其间还经历了种种坑，比如上篇文章这个。不过最终还是找到了正确的解决办法，就是使用Origin X-Function中的expGraph命令。最终找到的较好的解决方案是这样的：首先，用Origin生成一个空白模板工程，其中包含了基本的Worksheet结构及Graph样式，比如示例文件中提供的这个：这个模板工程需要保证只要向Worksheet中填入数据，Graph中就能生成所需的图，就像这样：这里的Worksheet和Graph可以不止有一个，不过一般情况下一个就足够了。制作好了模板文件后，在Matlab程序中只需要通过COM接口调用Origin，打开这个模板文件，然后向其中的Worksheet填入正确的数据，最后导出图片文件即可。Matlab程序如下：上面这段程序中要求Worksheet的名称需要为Data1，这是由invoke(originObj, &amp;#39;PutWorksheet&amp;#39;, &amp;#39;Data1&amp;#39;, mdata);这句代码确定的；导出的图片为emf格式，图像宽度为10000像素，因为这是矢量图，所以文件体积并不大的。以上这个版本只是个最基本的版本，不过一般使用也够用了，更多的高级功能，比如动态调整坐标轴名称，动态调整x、y轴的范围以适应不同数据等之后有空再来研究……]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Origin Script Window 执行脚本代码的方法</title>
      <link href="/2016/01/27/Origin%20Script%20Window%20%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2016/01/27/Origin%20Script%20Window%20%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[在Origin中，有一个Script Window可用于执行LabTalk和X-Function脚本程序，可通过菜单栏上的Window-&amp;gt;Script Window打开。然而这个Script Window有一个大坑，就是它诡异的执行代码的方式。这个Script Window是像这样的：界面上并没有一个执行按钮，按正常思路应该是输完一行代码后敲一下回车就会执行这行代码了，然而，这个Script Window却不是这样的，其运行代码的方式极为诡异……在Script Window中，输完一行代码后按回车键的作用是正常的换行，要想执行代码，需要把光标输入点移动到这一行之前的任意位置处（即不要是行尾即可），然后再按回车键，这样就会执行这一行代码了。另一个更坑的问题是，这样也仅仅只是执行这一行代码，并不是执行所有代码……要执行某一行代码就需要把光标移动到这一行中间按回车才行……]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>集成式负载开关</title>
      <link href="/2016/01/24/%E9%9B%86%E6%88%90%E5%BC%8F%E8%B4%9F%E8%BD%BD%E5%BC%80%E5%85%B3/"/>
      <url>/2016/01/24/%E9%9B%86%E6%88%90%E5%BC%8F%E8%B4%9F%E8%BD%BD%E5%BC%80%E5%85%B3/</url>
      
        <content type="html"><![CDATA[在很多系统中，需要能够控制某些支路的电流通断，常用的方法是使用一个PMOS管或是一个PMOS管加上一个NMOS管，典型的分立器件方案如下：此电路的完整仿真分析见：带软启动的分立负载开关电路出于节省空间的考虑，也可使用一个单独的集成式负载开关来实现这一目的，典型器件如TPS27081A。这一类器件内部基本原理框图如下所示:这类器件除了基本的开关功能外，其压摆率可以进行控制，以此减小浪涌电流，这也被称为“软启动”功能。关于负载开关更详细的说明可参考以下一些文章：什么是负载开关？How to save power using load switchesLoad Switches: What Are They, Why Do You Need Them And How Do You Choose The Right One?TI器件选型：Products for Integrated Load Switches封装形式多样，如SOT、QFN、DSBGA等。]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HW Component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartus中配置FPGA未使用引脚状态方法</title>
      <link href="/2016/01/12/Quartus%E4%B8%AD%E9%85%8D%E7%BD%AEFPGA%E6%9C%AA%E4%BD%BF%E7%94%A8%E5%BC%95%E8%84%9A%E7%8A%B6%E6%80%81%E6%96%B9%E6%B3%95/"/>
      <url>/2016/01/12/Quartus%E4%B8%AD%E9%85%8D%E7%BD%AEFPGA%E6%9C%AA%E4%BD%BF%E7%94%A8%E5%BC%95%E8%84%9A%E7%8A%B6%E6%80%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[FPGA开发中未使用的引脚一般需要配置为输入悬空状态，即“As input tri-stated”，配置方法也很简单，下面以Quartus 14.0为例说明一下：]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IGBT与MOSFET比较</title>
      <link href="/2016/01/11/IGBT%E4%B8%8EMOSFET%E6%AF%94%E8%BE%83/"/>
      <url>/2016/01/11/IGBT%E4%B8%8EMOSFET%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[大功率IGBT与MOSFET都属于功率器件，一般都用来当做开关管，本文对这两种器件进行些简要的比较。电路符号IGBT（Insulated Gate Bipolar Transistor, 绝缘闸双极晶体管）的电路符号如下：三个极分别称为：G：Gate，栅极C：Collector，集电极E：Emitter，发射极MOSFET（Metal-Oxide-Semiconductor Field-Effect Transistor, 金属氧化物半导体场效应管）的电路符号如下：三个极分别称为：G：Gate，栅极D：Drain，漏极S：Source，源极结构IGBT与MOSFET的结构对比如下：从结构上来说，IGBT可以视为一个MOSFET与一个三极管的组合，即可用下面这个等效电路来表示：应用特性一言以蔽之：IGBT高压高功率性能优越，而MOSFET高频性能优越，见下图：控制方法二者的驱动电路基本完全相同，可以相互替换。工作原理对于MOSFET来说,仅由多子承担的电荷运输没有任何存储效应,因此,很容易实现极短的开关时间。POWER MOSFET其高频特性十分优秀，所以MOSFET可用于较高频率的场合。在低电源电压下动作时之功率损失（POWER LOSS）远低于以往之组件，但是问题是,在高压的”开”状态下的源漏电阻很高(压降高),而且随着器件的电压等级迅速增长（耐压越高导通电阻越大,除了采用COOLMOS管芯的以外)。因而其传导损耗就很高,特别在高功率应用时,很受限制。和MOSFET有所不同,IGBT器件中少子也参与了导电,IGBT是采用MOS结构的双极器件导通电阻小(发热就少)高耐压,因而可大大降低导通压降。但另一方面,存储电荷的增强与耗散引发了开关损耗、延迟时间(存储时间)、以及在关断时还会引发集电极拖尾电流。同时存在的电流尾巴和较高的IGBT集电极到发射极电压将产生关闭开关损耗，这样就限制了IGBT的上限频率。总结MOSFET一般在较低功率应用及较高频应用（即功率&amp;lt;1kW及开关频率≥100kHz）中表现较好，而IGBT则在较低频及较高功率设计中表现卓越。参考资料IGBT or MOSFET: Choose WiselyIGBT (Insulated Gate Bipolar Transistor)IGBT、MOSFET与三极管的区别IGBT与MOSFET的区别]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor </tag>
            
            <tag> HW Component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三相逆变器电流采样方案总结</title>
      <link href="/2016/01/01/%E4%B8%89%E7%9B%B8%E9%80%86%E5%8F%98%E5%99%A8%E7%94%B5%E6%B5%81%E9%87%87%E6%A0%B7%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/"/>
      <url>/2016/01/01/%E4%B8%89%E7%9B%B8%E9%80%86%E5%8F%98%E5%99%A8%E7%94%B5%E6%B5%81%E9%87%87%E6%A0%B7%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[当使用三相逆变器进行电机控制时，经常需要获取相电流以进行闭环控制，这就涉及到一个电流采样问题。尽管现在有许多电流检测方法，但低成本、大批量应用中常见的只有三种，其它都是昂贵的实验室系统、新兴技术或很少使用的方法[1]。常用技术包括：采样电阻、霍尔元件与电流互感器。这些技术又可进一步细分，详见下图：本文将具体介绍这些方案。霍尔元件使用霍尔元件进行电流检测最大的优势是霍尔传感器与载流导体之间没有电气接触，导体的电位可偏置几百伏且确保传感器良好运行。因此，使用霍尔元件进行电流检测时都是直接测量相电流的，如图所示[1]：图中的Current Sensor即是霍尔传感器。在此图中，使用了3个霍尔传感器来测量三相电流，但一般情况下，只需使用2个霍尔传感器即可。根据基尔霍夫电流定律，三相电流之和必为0，故可以通过两相的电流来推出第三相电流。开环霍尔元件与闭环霍尔元件霍尔传感器从原理上可分为两大类，开环霍尔元件和闭环霍尔元件，其测量原理示意图如下[2]：开环霍尔元件直接检测由待测电流激发出的磁场磁感应强度；闭环霍尔元件则是在磁环上又缠绕了一组线圈，其中电流通过反馈确定，以保证最终磁环中的磁感应强度为0，这样通过测量线圈中电流的大小即可推算出待测电流的大小。闭环霍尔元件与开环霍尔元件相比，其检测精度较高，并且在响应时间、带宽等指标上也优于开环霍尔元件；不过其缺点在于结构较为复杂，这也就导致了其体积较大且成本较高。目前，开环霍尔元件使用的更多，且随着技术的发展，开环霍尔元件的检测精度也在不断提高，与闭环霍尔元件的差距并不是很大。传感器IC一般情况下，直接选用现成的霍尔电流传感器IC进行电流检测。提供这类产品的厂家有很多，其中最为常用的为Allegro公司的产品，下面就对此做一简要介绍。Allegro公司的产品全部均为开环霍尔传感器，不过根据其宣传资料中的说明，其性能已经可以做到接近闭环霍尔元件的水平。其产品根据检测电流范围分为3个系列：0至50A整合式导体传感器IC50至200A整合式导体传感器ICSIP封装0到&amp;gt;1000A传感器IC从上面的传感器原理示意图中可以看到，Allegro公司的整合式导体传感器IC不需要额外的磁环，待测电流从传感器芯片中流过，这在电流不大（&amp;lt;200A）时使用起来很方便。不过这种结构无法承载特别大的电流，故需要测量大电流（&amp;gt;200A）时需要使用其SIP封装的传感器并使用外置的磁环进行测量。在使用外置磁环时，不同磁环对应的磁感应强度与电流的关系并不相同，故需要进行标定。然而，精确提供一个很大的参考电流来进行标定并不容易，故在这种情况下，一般选用专业厂家使用Allegro传感器配合磁环做出来的模块。下面简要介绍下上海粲斯电子科技有限公司的QFO12HC系列电流传感器模块。此模块外形如图所示：传感器通电后，当被测电流从传感器箭头方向穿过，即可在输出端测得同相电压值。输出电压与待测电流间为线性关系，可使用Vout = (Vcc/5)×(2.5+2×Ip/Ipmax)进行计算，其中Ipmax为原边额定输入电流，Ip为待测电流。厂家已经对模块进行过标定处理，故直接上电即可使用，无需进行任何配置，使用起来极为方便。对一个Ipmax = 600A的模块进行了测试，测试结果如下：电流使用电子负载进行设定，输出电压用万用表测得。从测试结果中可以看到，在0~10A这一范围内，模块的线性度很好，回归系数&amp;gt;0.999，线性度为0.0176 %F.S。电流互感器电流互感器其实就是一个变压器，它的一次侧绕组匝数很少，串在需要测量的电流的线路中，二次侧绕组匝数比较多，串接在测量仪表和保护回路中，电流互感器在工作时，它的二次侧回路始终是闭合的，因此测量仪表和保护回路串联线圈的阻抗很小，电流互感器的工作状态接近短路。电流互感器是把一次侧大电流转换成二次侧小电流来测量 ，二次侧不可开路。其原理示意图如下[1]：电流互感器一般用于电力电子系统中，而且一般是以一个仪表产品的形态出现。值得一提的是，广泛使用的钳型电流表实质上就是一个电流互感器。采样电阻在绝大部分低成本应用中，都是使用采样电阻来进行电流采样的，故此方法可以说是最重要的电流采样方案。采样电阻被称为Sense Resistor或Shunt Resistor，其阻值一般较小，在1mΩ~1Ω之间。在简单的应用中，使用一般的两触点电阻即可。根据功率不同可选择不同形式的电阻，如贴片电阻、康铜丝、水泥电阻等。然而，在需要进行精确电流采样的场合，使用普通的两触点电阻就不合适了。由于采样电阻本身的阻值很小，焊料的电阻并不能忽略，它们不确定，且随温度变化，会影响测量输出。此时，应该选用4触点的采样电阻。不过在三相逆变器相电流采样的过程中，一般是不需要考虑这个问题的，使用普通的两触点电阻即可。按照采样电阻放置位置不同，电阻采样方案可分为两大类——高端采样(High-Side Sensing)与低端采样(Low-Side Sensing)，其区别见下图[4]：正如图中所示，高端采样中，采样电阻位于负载高端，即一端与电源连接；低端采样中，采样电阻位于负载低端，即一端与地平面连接。下面先介绍高端采样方案，再介绍低端采样方案。高端采样对于三相逆变器电路，采样电阻直接置于相电流桥臂上即可，如图所示[5]：根据基尔霍夫电流定律，只需要测量两相的电流即可，另一相电流可通过计算得到。高端采样的优势在于：采样得到的电流值在任何时刻都等于相电流值，对于采样时刻无需特别考虑；因为使用类似差分输入的形式，可以很好的避免地平面噪声的干扰，检测精度会更高。高端采样最大的缺陷在于其对后级处理电路的要求很高，后级运放要能承受很高的且急剧变化的共模电压，这样的运放选择起来并不是很容易。不过目前不少半导体厂商均有专门针对高端电流检测的运放芯片，比如TI有专门的Current Sense Amplifiers系列运放，最大共模电压为80V；ADI的AD8479能承受600V的共模电压；IR的IR2277更是能承受高达1200V的共模电压，其共模抑制比CMRR也达到了100dB。低端采样一般来说，高端采样是一种较为昂贵的解决方案，考虑到成本问题，更为普遍使用的是低端采样方案。常用的低端采样方案根据使用电阻数量的不同可分为三种——三电阻采样、双电阻采样与单电阻采样，其电路结构见下图[6]：三电阻采样：双电阻采样：单电阻采样：其中，最为常用的是双电阻采样方案，在某些成本敏感的应用中，也会选用单电阻采样方案。低端采样的优势在于：对运放没有特殊要求，选用常规通用运放即可；成本低廉，特别是单电阻采样方案，具有较大的价格优势。其缺点在于：由于开关管的存在，流经采样电阻的电流并不随时等于相电流，对采样时刻有严格的要求；地平面噪声会影响采样的准确性。采样时刻问题是使用低端采样时需要重点考虑的问题，下面将具体分析此问题。开关管的调制方式以SVPWM为例。从原理图中可以看到，当下桥臂的开关管断开的时候，采样电阻上显然是不会有电流流过的；只有当下桥臂开关管导通的时候，由于负载是感性负载，此时才会有续流电流从下桥臂流过，这个续流电流就等于相电流。以SVPWM调试波形为例，使用Simulink对此过程进行仿真，结果见下图：从图中可以看到，相电流是基本连续的，然而下桥臂电流并不连续，当且仅当下桥臂导通时流过下桥臂采样电阻的电流才等于相电流。所以对于双电阻及三电阻采样方案而言，只需要在SVPWM的零矢量（000）中央处进行采样即可获得正确的相电流。采样时刻示意图见下面这两张图[7, 8]：双电阻采样的情况下，可以通过电流平衡条件推算出第三相的电流,不过此方案有一个问题，在某些情况下（如SVPWM几个扇区的交界处），采样窗口时间会变得很短。三电阻采样则不存在此问题，任何时刻都可丢弃采样窗口时间较短采样电阻的结果，用其他两相的电流值来推出此相的电流，其原理说明见下图[9]：单电阻采样方案中，是通过在一个PWM周期内进行两次AD采样实现相电流检测的，其采样时刻见以下三张图[6, 7, 8]：图中T1与T2阶段就是采样时刻。采样得到的电流值与相电流的对应关系见下表[6]：与双电阻采样方案一样，单电阻采样方案也存在一些不允许单分流三相重构的特殊情形。在SVPWM中，有些时候会输出两路占空比相等的PWM信号，如下图所示[6]，此时T2=0，不能重构得到三相电流信息。除此之外，死区时间等因素也会影响采样窗口，具体可参考文献[6]中的说明。解决此问题有几种不同的方案，详见文献[6, 10]中的分析。其中最常用的一种方法是：在相邻边界的时候插入固定时间的有效矢量，而在低调制区域的时候，采用轮流插入有效矢量的方法。插入有效矢量会给电流波形带来失真，这种情况下需要通过软件来进行补偿[10]。文献[10]中还比较了双电阻采样与单电阻采样的优劣，可供参考。最后还有个值得注意的问题，运放的选型与电路的设计也会影响电阻采样的效果，这方面的内容可参考文献[6, 8]中的说明。总结对于三相逆变器而言，进行电流检测最稳定方便且精度也较高的检测方法是使用集成霍尔传感器，不过其成本也较高。在大部分情况下，使用采样电阻进行低端检测是最为常用的方法。其中以两电阻检测最为普遍，如需进一步降低成本，可考虑使用单电阻检测的方案。参考文献[1] 设备设计者为何应考虑将霍尔效应传感器芯片用于电机控制[R].Allegro MicroSystems LLC.[2] Wang Y, Liu J, Zhao J, et al. Split core closed loop hall effect current sensors and applications: PCIM EUROPE International Exhibition and Conference for Power, Electronics, Nuremberg, 2012[C].[3] 百度百科. 电流互感器[EB/OL]. http://baike.baidu.com/view/427702.htm.[4] Current Shunt Monitors, SLYB194A[R].Texas Instruments Incorporated, 2014.[5] Sino Henri. 高端电流检测:差动放大器 VS 电流检测放大器[J]. Analog Dialogue, 2008.[6] Torres Daniel, Zambada Jorge. PMSM无传感器FOC的单分流三相电流重构算法, AN1299[R].Microchip Technology Inc, 2009.[7] 李飞飞. 基于PSoC4的矢量控制方案：电流采样[R].Cypress.[8] 马达控制三相变频器中相电流Shunt检测电路设计, ZHCA598[R].Texas Instruments Incorporated, 2014.[9] TMS320F28026F, TMS320F28027F InstaSPIN™-FOC Software Technical Reference Manual, SPRUHP4[R].Texas Instruments Incorporated, 2013.[10] 孙桂喜, 唐华标, 张建新, 等. 永磁同步电机矢量控制方案在变频空调风机中的运用[R].STMicroelectronics.]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Motor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C2000 DSP基本数据类型</title>
      <link href="/2015/12/27/C2000%20DSP%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2015/12/27/C2000%20DSP%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[一般情况下，在大部分平台上，一个字节(byte)是指8bit，char占用8bit的空间，int占用32bit的空间。然而，在TI C2000 DSP上，情况确不是这样的。在C2000系列DSP上，byte = 16 bits，char = short = int = 16 bits，long = 32 bit，long long = 64bit。上图截自”TMS320C28x Optimizing C/C++ Compiler User’s Guide“不过仔细看C语言标准，的确没有规定char是几位的，也只规定了long≥int≥short≥char。这也提醒我们，不要太依赖于所谓的经验，不要想当然……]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C2000 ePWM模块</title>
      <link href="/2015/12/24/C2000%20ePWM%E6%A8%A1%E5%9D%97/"/>
      <url>/2015/12/24/C2000%20ePWM%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[以TMS320F28030为例，其它型号可能有差异，不过大同小异。在TI C2000 DSP中，PWM模块是一个独立的模块，并没有算作通用定时器的一部分，这也充分体现了C2000系列用于控制系统的定位。整个ePWM模块可以视为由若干个独立的ePWM子模块组成，每个ePWM子模块对应2个互补输出的通道——EPWMxA及EPWMxB。这样的设计减少了各PWM通道间的耦合关系，使用起来更为方便灵活。在TI的参考手册中是这样说的：Cross coupling or sharing of resources has been avoided; instead, the ePWM is built up from smaller single channel modules with separate resources that can operate together as required to form a system. This modular approach results in an orthogonal architecture and provides a more transparent view of the peripheral structure, helping users to understand its operation quickly.各独立的ePWM模块可以单独工作，也可以通过时钟同步策略来连接为一个整体，除此之外，时钟同步还可用于同步ePWM模块与eCAP模块。下文所说的ePWM模块都是指每个独立的子模块。概述ePWM模块的简要结构框图如下：输出信号：** EPWMxA &amp;amp; EPWMxB ：**PWM信号输出。** EPWMxTZINT &amp;amp; EPWMxINT ：**中断信号输出，连接至PIE模块。** EPWMxSOCA &amp;amp; EPWMxSOCB ：**ADC SOC信号输出，用于控制ADC开始进行数据转换的时间。Each ePWM module has two ADC start of conversion signals . Any ePWM module can trigger a start of conversion . Which event triggers the start of conversion is configured in the Event-Trigger submodule of the ePWM.输入信号：** TZ1 ~ TZ6 ：**错误信号输入，ePWM模块内部可以选择性的处理这些错误信号，具体含义：These input signals alert the ePWM module of fault conditions external to the ePWM module. **Each module on a device can be configured to either use or ignore any of the trip-zone signals. The TZ1 to TZ3 trip-zone signals can be configured as asynchronous inputs through the GPIO peripheral. TZ4 is connected to an inverted EQEP1 error signal (EQEP1ERR) from the EQEP1 module (for those devices with an EQEP1 module). TZ5 is connected to the system clock fail logic, and TZ6 is connected to the EMUSTOP output from the CPU. **This allows you to configure a trip action when the clock fails or the CPU halts.** COMPxOUT ：**比较器模块的输出信号。时钟同步信号：** EPWMxSYNCI &amp;amp; EPWMxSYNCO ：**菊花链结构的时钟同步信号，EPWMxSYNCI是输入，EPWMxSYNCO是输出.各模块的连接关系见下图：下面简要总结下各模块的核心内容，具体参考TI的Reference manual.Time-Base主时基模块。一共有3种计数方式，示意图及频率计算方法如下：模式选择通过TBCTL[CTRMODE]位，预分频可通过TBCTL[HSPCLKDIV]位。产生CTR = PRD及CTR = Zero这两个信号。TBPDR寄存器有一个影子寄存器(Shadow Register)，通过TBCTL[PRDLD]位来控制是否使用此功能。The TBPRD shadow register is enabled when TBCTL[PRDLD] = 0. Reads from and writes to the TBPRD memory address go to the shadow register. The shadow register contents are transferred to the active register (TBPRD (Active) ← TBPRD (shadow)) when the time-base counter equals zero (TBCTR = 0x0000). By default the TBPRD shadow register is enabled.时钟同步的结构见下图：使能时钟同步的步骤如下：The proper procedure for enabling ePWM clocks is as follows:Enable ePWM module clocks in the PCLKCRx registerSet TBCLKSYNC= 0Configure ePWM modulesSet TBCLKSYNC=1注：TBCLKSYNC位位于PCLKCR0寄存器中，属于”System Control and Interrupts”的一部分。When TBCLKSYNC = 1, all ePWM time-base clocks are started with the rising edge of TBCLK aligned. For perfectly synchronized TBCLKs, the prescaler bits in the TBCTL register of each ePWM module must be set identically收到同步信号后：The value of the phase register is loaded into the counter register when an input synchronization pulse is detected (TBPHS → TBCTR).In up-down-count mode, the TBCTL[PSHDIR] bit configures the direction of the time-base counter immediately after a synchronization event. The new direction is independent of the direction prior to the synchronization event.多个ePWM模块之间可以存在一个精确的相位差，在一些特殊的电力电子拓扑结构中特别有用。例如在大功率的应用中，对于移相变压器、多绕组变压器等，其输入有多个整流单元，相位互差特定的角度，此时就可以使用TBPHS寄存器来调整它们之间载波的相位差；而且因为是相对于同一个时间基准来计数，其精度也较高。在这种使用情况下，一般将一相ePWM做为主模块，其时钟信号作为同步源，其余几相ePWM做为从模块，其时钟信号使用同步源与TBPHS的和或者差。Counter-Compare计数器比较模块。产生CTR = CMPA及CTR = CMPB这两个信号：同样，CMPA与CMPB寄存器也有其影子寄存器，分别通过CMPCTL[SHDWAMODE]与CMPCTL[SHDWBMODE]来进行控制。If the shadow register is enabled then the content of the shadow register is transferred to the active register on one of the following events as specified by the CMPCTL[LOADAMODE] and CMPCTL[LOADBMODE] register bits:CTR = PRD: Time-base counter equal to the period (TBCTR = TBPRD).CTR = Zero: Time-base counter equal to zero (TBCTR = 0x0000)Both CTR = PRD and CTR = ZeroAction-Qualifier输出波形产生及控制模块。模块原理框图：一共有4种可选操作：Set High : Set output EPWMxA or EPWMxB to a high level.Clear Low : Set output EPWMxA or EPWMxB to a low level.Toggle : If EPWMxA or EPWMxB is currently pulled high, then pull the output low. If EPWMxA or EPWMxB is currently pulled low, then pull the output high.Do Nothing : Keep outputs EPWMxA and EPWMxB at same level as currently set. Although the “Do Nothing” option prevents an event from causing an action on the EPWMxA and EPWMxB outputs, this event can still trigger interrupts and ADC start of conversion.在寄存器AQCTLA及AQCTLB中进行配置，各种常用配置的示例代码在参考手册中有详细说明。Dead-Band Generator互补PWM产生及死区控制模块。只使用Action Qualifier模块，通过灵活配置CMPA与CMPB寄存器，一样可以实现死区控制功能，然而这样做较为麻烦，更常规的做法是使用Dead Band Generator来生成互补PWM信号及控制死区时间。模块原理框图如下：常用的配置如表，其中Mode 2 &amp;amp; Mode 3为最为常用的互补输出模式。（表中均为S4 = 0， S5 = 0）从中可以看到，在使用Dead Band Generator来生成互补PWM信号时，只使用了Action Qualifier产生的一路PWM信号，即EPWMxA，另一路信号EPWMxB并没有使用，而是根据EPWMxA来产生的。最终生成的互补PWM信号波形如图所示：RED及FED时间由DBRED及DBFED寄存器决定，计算方法及一些常用值见参考手册中的说明。PWM-Chopper斩波模块，用于在PWM输出中加入一个高频载波信号。这个模块是可选的，其作用是用一个高频信号（最高为系统时钟的8分频）来调制PWM信号。经过调制后的输出波形效果如下：如此调制一般是用于高频开关电源中，当PWM的周期较长，用高频变压器作驱动器，就会达不到目的，并有可能烧坏器件。使用PWM-Chopper模块可以将PWM波经过“再调制”后的高频波作驱动就可以解决这个问题。Trip-Zone错误信号控制模块。TZSEL寄存器选择启用哪些错误信号(TZ1~TZ6)，TZCTL寄存器选择相应的操作，有4种可选操作：强制拉低强制拉高高阻输出保持原状态(Do nothing)错误输入一共有两种模式：One-Shot(OSHT)及Cycle-by-Cycle(CBC)模式，其区别在于：The one-shot trip condition remains latched until the user clears the condition via the TZCLR register.A cycle-by-cycle trip condition is automatically cleared when the time-base counter reaches zero.简而言之，就是One-Shot模式需要手动复位，而Cycle-by-Cycle模式会自动复位。同时，Trip-Zone模块也可以产生中断，通过TZEINT寄存器来配置。Event-Trigger中断及外部事件触发模块。原理框图如下：输入信号可通过ETPS[INTCNT]位配置为不产生中断、每次都产生中断、每2次产生中断、每3次产生中断。除了中断外，还可以产生ADC模块的SOC信号。Digital Compare数字比较模块原理框图如下：]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Simulink仿真模式</title>
      <link href="/2015/12/23/Simulink%E4%BB%BF%E7%9C%9F%E6%A8%A1%E5%BC%8F/"/>
      <url>/2015/12/23/Simulink%E4%BB%BF%E7%9C%9F%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[在Simulink中，一共有6种仿真模式可供选择，如图：Normal模式为一般正常的仿真模式Accelerator及Rapid Accelerator模式用于加快代码的执行速度SIL及PIL模式用于自动代码生成时进行测试仿真External模式用于连接外部系统实现基于客户端/服务器模式的实时系统仿真正常模式(Normal)不需要进行特殊设置，这是Simulink默认的仿真模式。下面简要介绍一下其他几种仿真模式。加速模式(Accelerator)Normal、Accelerator、Rapid Accelerator模式的比较如下：简而言之，就是Normal模式执行速度最慢，不过支持的功能最多；Rapid Accelerator模式执行速度最快，不过支持的功能最少，对于使用的模块也有限制(需要模块有C代码以可以编译为可执行文件)；Accelerator模块介于二者之间。这三种模式的具体功能比较可参阅帮助文档中”Choosing a Simulation Mode“小节，执行方式比较详见”How Acceleration Modes Work“小节。SIL与PIL模式这两种模式用于在使用Embedded Coder™、HDL Coder™或Simulink PLC Coder™从模型生成代码的过程中进行测试分析，属于Simulink Verification and Validation的一部分。关于各种”In-the-Loop”测试的含义，可参阅”有关基于模型的设计（MBD）一些概念和理解“这篇文章，这里把SIL与PIL的相关部分摘录如下：2）SIL，软件在环测试，软件在环测试，应该说是从模型在环测试引申过来的，区别只是把控制器的模型换成了由控制器模型生成的C代码编译成的S-function，SIL的目的是为了验证生成的代码和模型在功能上是否一致，或者说验证生成的代码和模型在功能上是否等效。验证等效性，是否一定需要被控对象模型？不必要，既然验证生成的代码和模型的一致性，那只需要给生成代码和用于代码生成的模型相同的输入，比较它们在相同的输入条件下，输出是否一致即可。3）PIL，PIL有两个目的，一是为了等效性验证，二是为了测量模型生成的代码在目标处理器上的运行时间。有关运行时间的测量，如果你选择的处理器足够强大，或者你非常把握目标代码的运行不会超限，那么PIL的意义就要打折扣了。外部模式(External)外部模式(External)是MATLAB Real Time Workshop(RTW)提供的一种仿真模式，可实现两个独立系统（宿主机与目标机）之间的通信。宿主机是指运行MATLAB和Simulink的计算机，而目标机是指运行RTW所生成的可执行程序的设备。在外部模式下，使用Simulink中的控制面板工具，可以通过网络连接控制模型的启动、停止、数据回传，调整模型运行参数等。External模式主要用于实现数据的实时采集与处理，此处的外部设备可以也是本机上另一个进程，也可以是另一台计算机，还可以配置为诸如Rasberry Pi等嵌入式硬件平台。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM8外设引脚重映射</title>
      <link href="/2015/12/21/STM8%E5%A4%96%E8%AE%BE%E5%BC%95%E8%84%9A%E9%87%8D%E6%98%A0%E5%B0%84/"/>
      <url>/2015/12/21/STM8%E5%A4%96%E8%AE%BE%E5%BC%95%E8%84%9A%E9%87%8D%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[在STM8中，外设对应引脚可能会有几种不同的选择，可根据实际情况来选择合适的引脚。下面总结下STM8S与STM8L系列中进行外设引脚重映射(Remap)的方法。STM8S在STM8S中，默认情况下一个外设功能只会对应一个引脚，只有少数外设引脚可以改变位置。进行引脚重映射通过修改”Option bytes”完成，具体修改内容可参考器件的数据手册。需要注意的是，修改”Option bytes”并不像读写其他一般寄存器那样直接，其修改方式在数据手册中有如下说明：Option bytes can be modified in ICP mode (via SWIM) by accessing the EEPROM address shown in the table below.Option bytes can also be modified “on the fly” by the application in IAP mode, except the ROP option that can only be modified in ICP mode (via SWIM).一般情况下可直接在IDE中设置”Option bytes”，如在IAR中：STM8L在STM8L中，同样可以通过修改”Option bytes”来完成一些引脚的重映射，不过除此之外，有些外设功能本身就对应到了多个引脚上，此时可以通过SYSCFG寄存器来选择需要使用的引脚。以STM8L051F3为例：此图中使用”[]”括起来的功能就是只能通过上文修改”Option bytes”的方法来进行重映射的功能，而其余功能的选择则可通过修改SYSCFG寄存器来完成，如Timer 2-channel 1可以选择PB0或PC5。SYSCFG寄存器的主要作用是进行引脚功能选择，其操作较为简单，直接根据参考手册中的说明设置所需的位即可。如果使用库函数的话，可通过调用SYSCFG_REMAPPinConfig()函数完成。如下面两句代码将STM8L051中TIM2_CH1与TIM2_CH2由默认的PB0、PB2重映射至PC5、PC6。]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM8系列单片机</title>
      <link href="/2015/12/21/STM8%E7%B3%BB%E5%88%97%E5%8D%95%E7%89%87%E6%9C%BA/"/>
      <url>/2015/12/21/STM8%E7%B3%BB%E5%88%97%E5%8D%95%E7%89%87%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[STM8系列单片机基于STM8专有8位内核，具有很高的性价比，其下一共有5个系列:STM8S、STM8L、STM8AF、STM8AL及STM8T，这篇文章中比较分析了这几个系列，下面简要总结一下。STM8S是STM8中的主流系列；STM8L侧重于低功耗；STM8AF与STM8AL则是STM8S及STM8L用于汽车应用的增强型，其使用温度更广，具有更高的可靠性；STM8T未在上图中出现，此系列在STM8L系列的基础上增加了ProxSense电荷转移电容采集技术，用于触控检测。各系列下又细分为诸多产品线：STM8S系列STM8L系列STM8AF系列STM8AL系列STM8T系列]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻抗测量方法</title>
      <link href="/2015/12/19/%E9%98%BB%E6%8A%97%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95/"/>
      <url>/2015/12/19/%E9%98%BB%E6%8A%97%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[阻抗测量在不少领域都有着广泛的应用，这几天做项目用到了LCR数字电桥来测量电机参数，正好来总结下阻抗测量的基本方法及技术。基本概念所谓的阻抗测量，就是通过仪器来得到待测元件的电阻(R)、电容(C)、电感(L)、品质因数(Q)、损耗因数(D)等信息，可以用一张图把这些关系简明的表示出来：测量技术阻抗测量有几种不同的技术和方法，是德科技在其文档“成功测量阻抗的8点提示”中简要介绍了各种方法及技术。简而言之，从原理上来看，阻抗测量有三种方法：自动平衡电桥技术IV和RF-IV技术传输/反射技术从仪器种类上来看，阻抗测量可以通过三大类仪器来完成：LCR表阻抗分析仪网络分析仪LCR表与阻抗分析仪采用RF-IV/IV或自动平衡电桥技术；网络分析仪则是基于传输/反射技术。LCR表和阻抗分析仪的主要区别之一是它们对测量结果的显示方式。LCR表用数字显示测量结果，而阻抗分析仪既可以用数字也可以用图形显示测量结果。使用自动平衡电桥技术的LCR表又称为LCR数字电桥，这也是最便宜和简单的阻抗测试仪器。网络分析仪主要用于通信领域，其价格也是最为昂贵的。关于网络分析仪，可参考NI的文档“网络分析基础”，下面主要讨论下LCR数字电桥的相关问题。LCR数字电桥LCR数字电桥的相关知识可以阅读IET Labs的”LCR Measurement Primer“，这份文档较为详细的介绍了LCR电桥各方面的知识，本文仅从使用的角度简要介绍下LCR数字电桥的基础知识。LCR数字电桥的基本原理框图如图：一言以蔽之，就是通过测量待测元件两端的电流与电压（同时记录相位信息），根据矢量形式的欧姆定律就可以计算得到各种所需参数。绝大部分LCR数字电桥均有四个被测端，其名字不同厂家的仪器有所区别，国内厂家的仪器一般称之为HD、LD、HS、LS。这四个端口的含义为：HD: 输出激励源正极LD：输出激励源负极HS: 检测信号输入正极LS: 检测信号输入负极大部分测量单个元件的时候，将HS与HS短接后接到元件正极上；LD与LS短接后接到元件负极上。如图所示：图中IH即上文HD，IL即LD，PH即HS，PL即LS。不过在某些情况下，需要使用其他的连接方式，比如是德科技在其文档“高效变压器/低频线圈测试”中就介绍了使用LCR数字电桥测量变压器互感的方法，如图所示：此图是基于其4263B LCR表的，不过对于其他型号的LCR数字电桥应该也可以使用。除此之外，还有所谓的三端连接法，如图所示：关于此电路的分析，见”LCR Measurement Primer“第24页。在测量前，一般需要将测试夹短接后执行清零操作，以去除测试夹本身的阻抗。阻抗模型最后，简要介绍一下串联模型与并联模型，如图所示：图中等效模型是以电容为例，不过对于电感同样存在串联模型与并联模型。]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用OpenMP进行多线程计算</title>
      <link href="/2015/12/11/%E4%BD%BF%E7%94%A8OpenMP%E8%BF%9B%E8%A1%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97/"/>
      <url>/2015/12/11/%E4%BD%BF%E7%94%A8OpenMP%E8%BF%9B%E8%A1%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[OpenMP是一套支持跨平台共享内存方式的多线程并发的编程API，关于其详细介绍，可浏览其官方主页与Wiki页面。多线程并行计算是一个值得深入研究的问题，不过很多时候，我们仅仅是需要实现一些很基础的多线程计算。例如程序中需要依次处理100张图片，它们之间又没有什么关联，这时如果使用多线程，可以极大的提升程序的执行效率。使用OpenMP就可以很方便的实现上述要求而不必了解多线程的底层技术。Microsoft VS编译器与GCC均支持OpenMP，需要通过编译选项来启用。GCC中添加-fopenmp编译选项VS中在项目属性中启用OpenMP支持，如下图所示：大多数情况下，需要进行多线程优化的代码段是一个for循环，此时，只要在for循环前面加上**#pragma omp parallel for**即可。示例代码段如下：以上代码段中的第一个for循环会自动使用多线程进行并行计算，而第二个for循环不受影响。简而言之，#pragma omp parallel for仅对之后的一个for循环起作用。for循环中有一些代码位于所谓的临界区段（Critical Section），这部分代码不能同时被两个线程访问，否则会发生错误。使用**#pragma omp critical**来指定临界区段代码，用法如下：使用&amp;#123;&amp;#125;将临界区段代码包围起来，然后在前面添加#pragma omp critical即可。只需要简单的添加这两句编译指令，OpenMP就会自动实现多线程运行了。当然，OpenMP还支持更多高级用法，此处给出的仅是最简单实用的用法。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrent </tag>
            
            <tag> OpenMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STC单片机不断电下载程序</title>
      <link href="/2015/12/10/STC%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8D%E6%96%AD%E7%94%B5%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/"/>
      <url>/2015/12/10/STC%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8D%E6%96%AD%E7%94%B5%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[在使用STC-ISP为STC单片机下载程序的过程中，需要手动对单片机进行复位，之后才能正确下载程序。这样不是很方便，我们可以采用一些方法来简化这一过程。基本思路：在程序中加入一段监控代码，监测UART接收到的数据，当接收到STC-ISP程序发送的下载开始的数据后，软件复位单片机从系统ISP监控程序区启动。首先要获取STC-ISP软件发送的数据，最简单的方法是通过虚拟串口软件配合串口助手即可看到所需的数据，结果如图所示：从中可以看到，STC-ISP会持续发送0x7F，直至单片机给出正确的响应，故程序中只需要接收到若干个连续的0x7F后进行软件复位即可。软件复位通过写IAP_CONTR寄存器实现，其定义如下：将第5、6两位置1即可实现软件复位且从系统ISP监控程序区启动的目的。下面给出具体实现代码：需要注意的是，STC-ISP软件中的最低波特率与最高波特率必须设置为相同的，且等于程序中配置好的波特率，不能使用自适应波特率。比如下图中就将波特率固定为115200bps。]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCS-51 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV 3.0安装</title>
      <link href="/2015/12/08/OpenCV%203.0%E5%AE%89%E8%A3%85/"/>
      <url>/2015/12/08/OpenCV%203.0%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[主要参考以下文章：【OpenCV入门教程之一】 安装OpenCV64位系统vs2013配置opencv3.0VS2013+openCV3.0无脑配置方法+解决警告问题【windows平台】目前OpenCV的最新版本为3.0.0，正式版发布于2015年6月4日。本文记录一下安装OpenCV 3.0及新建工程的步骤。相关环境：Windows 8.1 64bit；Visual Studio 2013。下载OpenCV SDK在官网上找到OpenCV for Windows下载下来即可，大概有300MB不到。这是一个自解压压缩包，下载完后直接双击运行即可。因为OpenCV项目文件打包的时候，根目录就是opencv，所以我们不需要额外的新建一个名为opencv的文件夹，然后再解压。解压后的文件有接近3G。配置环境变量在PATH路径中增加以下两项即可：其中的vc12对应VS2013，vc11对应VS2012。在之前版本的OpenCV中，还存在vc10文件夹对应VS2010，不过在OpenCV 3.0中，去掉了vc10文件夹。这里可以只保留需要用到的VS版本，删掉其余版本以节省空间。编写OpenCV的VS工程属性表VS中配置OpenCV的包含路径、库文件路径等通常是通过项目属性对话框完成的，这样操作较为繁琐，故这里采用工程属性表的方式来进行配置。工程属性表是一个后缀为.props的文本文件，其中记录了工程属性配置情况，新建工程后可以直接导入此文件即可。在OpenCV根目录下新建一个.props文件，比如OpenCV.props，文件内容如下：注意，其中具体路径要根据之前安装OpenCV的路径来确定。第6行用于配置包含目录；第7行与第8行分别是Win32和X64情况下的库目录；第12行与第16行分别是Debug与Release情况下的附加依赖项。OpenCV 3.0与之前的版本不同，库文件目录下同时有两个文件夹，/lib/与/staticlib/，并不需要同时添加这两个文件夹与其中的库文件，选择一个即可。如果选择/staticlib/的话与之前的版本一样，有一大堆的依赖项要添加；如果选择了/lib/的话，就只需要加入两个依赖项。故此处选择使用/lib/文件夹。创建新工程正常新建一个VC++空项目，然后打开属性管理器，如果没有属性管理器的话可以从视图-&amp;gt;其他窗口-&amp;gt;属性管理器中打开。打开后在工程名上点击右键，选择添加现有属性表，找到之前新建的项目属性表文件添加进来即可。新建一个main.cpp文件进行测试，使用如下测试代码：将pic.jpg图片放置于工程目录下编译运行程序，如果之前配置正确的话就可以显示出图片了。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM8 SWIM接口</title>
      <link href="/2015/12/06/STM8%20SWIM%E6%8E%A5%E5%8F%A3/"/>
      <url>/2015/12/06/STM8%20SWIM%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[STM8系列单片机通过SWIM接口进行程序下载与Debug，这是一个单线接口，仅有一条数据线，即SWIM。SWIM引脚为开漏(OD)结构，以此实现双向通信。关于SWIM协议的详细说明，可参考ST的文档”STM8 SWIM communication protocol and debug module“，此文档介绍了SWIM协议的通信过程与物理层时序等内容，如果需要自行设计制作SWIM下载器需要参考此文档。当然，如果仅是为了给STM8单片机下载程序，并不需要了解SWIM协议的具体实现方法，仅需要在板子上设计好下载接口，然后和ST-Link仿真器连接起来即可。ST-Link/V2中SWIM接口的定义如下：其中的VDD可以不接，从STM8L-Discovery开发板上提供的ST-Link上来看，VDD直接通过一个10k的电阻接地了：另外，从中可以看到，仿真器部分已经在SWIM上加上了上拉电阻，故目标板上并不需要加上拉电阻，直接和单片机SWIM口连接即可。]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BLDC六步换相法基本原理及驱动波形</title>
      <link href="/2015/12/03/BLDC%E5%85%AD%E6%AD%A5%E6%8D%A2%E7%9B%B8%E6%B3%95%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E9%A9%B1%E5%8A%A8%E6%B3%A2%E5%BD%A2/"/>
      <url>/2015/12/03/BLDC%E5%85%AD%E6%AD%A5%E6%8D%A2%E7%9B%B8%E6%B3%95%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E9%A9%B1%E5%8A%A8%E6%B3%A2%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[直流无刷电机（BLDC）最经典的驱动方法就是三相六步换相法，这几天调试时顺便用示波器捕捉了下6个MOS管的栅极驱动波形。基本驱动电路如图所示：所谓的六步换相法即是按如下的顺序通电：AB-&amp;gt;AC-&amp;gt;BC-&amp;gt;BA-&amp;gt;CA-&amp;gt;CB。当然，除此之外还可以使用其他的通电顺序，只需要保证磁场的变化方向能构成一个旋转磁场即可。一般情况下，还要使用PWM进行调速。最简单的方法是只对上桥臂MOS管（Q1、Q3、Q5）进行调制，下桥臂（Q2、Q4、Q6）使用GPIO控制。这样的优点是控制方式简单；缺点在于上桥臂截止时，只能通过下桥臂MOS管的体二极管进行续流，而体二极管压降较大，这会造成下桥臂MOS管发热更为严重。使用这种驱动方法的驱动波形如图所示：图中红色框内为一个周期，可以看到，只有上桥臂使用了PWM进行调制。更好的方法是使用互补的PWM信号进行控制，上下管交替导通。这种方式的驱动波形如图所示：图中红色框内为一个周期，可以看到，上下桥臂同时使用了PWM信号进行控制。互补PWM信号展开放大后的波形如图所示：上桥臂导通时下桥臂截止，上桥臂截止时下桥臂导通。]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C2000 CSM使用方法</title>
      <link href="/2015/11/30/C2000%20CSM%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2015/11/30/C2000%20CSM%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[在TI C2000系列DSP中，CSM模块用于对给芯片进行加密，以防止未经授权的代码逆向等行为，TI在其文档中对此模块的说明如下：The code security module (CSM) is a security feature incorporated in 28x devices. It prevents access/visibility to on-chip memory to unauthorized persons—that is, it prevents duplication/reverse engineering of proprietary code.The word secure means access to on-chip memory is protected. The word unsecure means access to onchip secure memory is not protected — that is, the contents of the memory could be read by any means (through a debugging tool such as Code Composer Studio™, for example).关于DSP中具体哪些部分受到CSM模块的保护，以及此模块的详细信息可参阅TI的相关文档，此处仅从使用的角度来讨论下如何对DSP芯片进行加密与解密。本文基于CCS 6.0。密码设定最简单的方法是直接使用controlSUITE中提供的DSP28***_CSMPasswords.asm文件，将此文件加入工程中，修改其中的密码即可。此文件的内容如下：对应的CMD文件中地址分配情况：设置密码时有一些关键点需要注意：将128-bit全部设为1意味着不加密，即所谓的”unsecure”。将128-bit全部设为0意味着永久加密，此时芯片不可被解密，即无法再进行编程，也无法读取其中的程序和数据。一般情况下，不要进行此设置。如果设置了128-bit中的低64-bit（即不为全1），会触发所谓的ECSL(Emulation Code Security Logic)功能，这时如需使用仿真器下载程序，需要进行些特殊设置，下文会对此进行详细讨论。加密后使用仿真器下载程序如果芯片没有被加密，自然可以直接使用仿真器通过JATG正常下载程序；但如果芯片设置了密码被加密了，就需要在仿真器设置中正确填入密码才能下载程序和Debug。具体来看，分为两种情况：没有设置低64位密码与设置了低64位密码。没有设置低64位密码此时ECSL功能没有被触发，只要在仿真器设置中正确填入密码即可正常下载程序。以CCS v6.0及XDS100V3仿真器为例，设置界面如图所示：图中设置的CSM密码为0xAAAABBBBCCCCDDDDFFFFFFFFFFFFFFFF。设置好后，就可以正常Debug了。设置了低64位密码此时情况要复杂一些，当设置了低64位密码时，DSP中的ECSL功能会被触发，关于此功能，TI文档中的说明如下：In addition to the CSM, the emulation code security logic (ECSL) has been implemented to prevent unauthorized users from stepping through secure code. Any code or data access to flash, user OTP, L0 memory while the emulator is connected will trip the ECSL and break the emulation connection.When initially debugging a device with the password locations in flash programmed (that is, secured), the emulator takes some time to take control of the CPU. During this time, the CPU will start running and may execute an instruction that performs an access to a protected ECSL area. If this happens, the ECSL will trip and cause the emulator connection to be cut.简而言之，当ECSL功能有效时，会强制切断仿真器与器件间的JTAG连接，导致连接失败。此时，就算是按之前的步骤正确设置了密码也是无法下载程序的。点击Debug按钮后会出现如下错误提示：C28xx: Error connecting to the target: (Error -1015 @ 0x0) Device is not responding to the request. Device may be locked, or the emulator connection may be unreliable. Unlock the device if possible (e.g. use wait in reset mode, and power-cycle the board). If error persists, confirm configuration and/or try more reliable JTAG settings (e.g. lower TCLK). (Emulation package 5.1.450.0) 此错误提示与密码错误时的提示是不一样的，密码错误时的提示如下：C28xx: Flash Programmer: Device is locked or not connected. Operation cancelled.C28xx: Error Writing Flash @ Address 0x003F74C6 of Length 0x00000016 (page 0)C28xx: GEL: File: D:\Forklift\MS8000V10\Project\Release\MS8000V10.out: Load failed.同时会有一个对话框提示：TI的文档中也给出了此问题的解决办法：The first is to use the Wait-In-Reset emulation mode, which will hold the device in reset until the emulator takes control. The emulator must support this mode for this option.The second option is to use the “Branch to check boot mode” boot option. This will sit in a loop and continuously poll the boot mode select pins. You can select this boot mode and then exit this mode once the emulator is connected by re-mapping the PC to another address or by changing the boot mode selection pin to the desired boot mode.简而言之，第一种方法是保持器件处于复位状态直至仿真器接管器件，这需要仿真器与器件的支持；第二种方法是通过BOOT引脚的配置，使得DSP进入一个所谓的”Branch to check boot mode”，然后再连接仿真器。我使用的XDS100v3仿真器并不支持第一种方法，在仿真器设置中”Halt the target on a connect”一项是不可选的，如图所示：此时只能采用第二种方法，然而第二种方法中的”Branch to check boot mode”具体指什么文档中并没有很明确的指出来。不过TI的Wiki Page上给出了正确的操作方法：Q: Why does Code Composer Studio give me an emulator error when I try to connect to my locked device?On devices with ECSL protection which do not support hardware wait-in-reset mode (such as the Piccolo devices), if the device is locked:When the device is powered up, the CPU will start running and may execute an instruction that performs an access to an ECSL protected area. If this happens, the ECSL will trip and cause the emulator connection to be cut. To resolve this:Disconnect your emulator.Set your boot pins for “WAIT” boot mode. Note: on 2833x/2823x this is documented as the “loop to check” boot mode.Reset your device.Reconnect your emulator.At this point you should be able to proceed and unlock your device.简而言之，对于2803x系列单片机来说，需要使DSP先复位进入Wait模式后再连接仿真器就可以顺利下载程序了。至于如何进入Wait模式，在器件参考手册中可以查到，以28031为例，上电时将GPIO34拉低即可（GPIO34默认情况下有内部上拉）：实际测试表明，这样设置后就可以通过仿真器正常下载程序并进行Debug了。]]></content>
      
      
      <categories>
          
          <category> 科研之路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C2000 DSP新建工程基本步骤</title>
      <link href="/2015/11/28/C2000%20DSP%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/"/>
      <url>/2015/11/28/C2000%20DSP%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[本文以TMS320F28031为例，介绍如何新建一个完整的CCS工程文件。其他型号的C2000系列微处理器的操作方法大同小异。准备工作需要安装好CCS及controlSUITE。下文使用的CCS版本为v6.0.0，controlSUITE版本为v3.3.3。新建工程打开CCS，菜单栏上找到Project-&amp;gt;New CCS Project...。在弹出的对话框中选好DSP的型号及仿真器的型号，填入工程名称及工程位置，其余选项保持默认值即可。点击Finish后在Project Explorer中可以看到新建的工程添加CMD文件新建好工程后自动加入了一个CMD文件，28031_RAM_lnk.cmd，此CMD文件用于配置DSP从RAM启动。一般情况下，程序调试过程中在RAM中进行测试，正式发布时肯定要从Flash中启动，故需要为这两种情况分别添加CMD文件。首先，将工程目录中已有的那个CMD文件删掉；之后在菜单栏上找到Project-&amp;gt;Properties进入工程属性设置界面。默认情况下，CCS已经为我们建立了两个Configuration，分别为Debug和Release，所以可以将Debug用于调试，程序下载至RAM中；Release用于发布，程序下载至Flash中。首先配置Debug，Configuration选择Debug，下方的Linker command file选择****_RAM_lnk.cmd，****是使用的DSP型号，如图所示：之后配置Release，Configuration选择Release，下方的Linker command file选择F****.cmd，****是使用的DSP型号，如图所示：配置完成后，选择Debug模式进行编译时F****.cmd文件会被排除掉；同理，选择Release模式进行编译时****_RAM_lnk.cmd文件会被排除掉。效果见下图：上面添加的CMD文件用于分配RAM、Flash等区域的存储空间，除此之外，还需要添加一个CMD文件用于为外设寄存器结构体分配正确的空间。这个CMD文件的名字为****_Headers_nonBIOS.cmd或****_Headers_BIOS.cmd。文件开头的注释对此文件的用途做了简要的说明：FILE: F2802x_Headers_nonBIOS.cmdTITLE: F2802x Peripheral registers linker command fileDESCRIPTION:This file is for use in Non-BIOS applications.Linker command file to place the peripheral structures used within the F2802x headerfiles into the correct memory mapped locations.This version of the file includes the PieVectorTable structure.For BIOS applications, please use the F2802x_Headers_BIOS.cmd file which does not include the PieVectorTable structure.从中可以看到****_Headers_nonBIOS.cmd与****_Headers_BIOS.cmd的区别在于是否包含PIE中断向量表，一般的，在有RTOS的情况下选用****_Headers_BIOS.cmd，其余情况下均选择****_Headers_nonBIOS.cmd。关于此文件的详细说明，可以参考TI的Application Report “Programming TMS320x28xx and 28xxx Peripherals in C/C++“。此文件可以从controlSUITE中找到，位于\controlSUITE\device_support\f****\v***\DSP****_headers\cmd路径下，其中v***代表固件库的版本，一般选用最新版。以本文使用的28031为例，具体路径就是\controlSUITE\device_support\f2803x\v130\DSP2803x_headers\cmd。需要注意的是，在添加文件的时候一般选择Copy files而不是Link to files，如图所示：添加寄存器头文件将\controlSUITE\device_support\f****\v***\DSP****_headers\中的source\与include\文件夹复制到工程目录下，将include\文件夹添加到包含路径中。注意不要选择绝对路径，而是使用Workspace...选择相对路径，如下图所示：刚刚添加的include\文件夹中包含的内容是对所有外设寄存器的结构体定义，这种方式TI称之为“Bit Field and Register-File Structure Approach”，与传统的“Traditional #define Approach”有所区别，使用起来会更为方便。关于这两种方式的具体说明与比较，TI在其应用报告”Programming TMS320x28xx and 28xxx Peripherals in C/C++“中有详细的论述。需要修改DSP****_Device.h文件以指定使用的DSP型号，以下例子中选择了DSP28_28031PN.source\文件夹下只有一个文件，就是DSP****_GlobalVariableDefs.c，这个文件中实例化了所有的外设结构体，并且通过通过#pragma DATA_SECTION()将其放置在地址映射中的正确位置，以此实现对外设寄存器的正确访问。TI文档中对此文件的说明如下：Declarations for the variables that are used to access the peripheral registers.Data section #pragma assignments that are used by the linker to place the variables in the proper locations in memory.添加标准外设库使用标准外设库可以更方便的控制外设而不需要具体了解寄存器的配置方法，这在进行初始化的过程中尤为有用，标准外设库的使用及controlSUITE中例程的说明文档位于\controlSUITE\device_support\f****\v***\doc\文件夹中。需要注意的是，并不是所有型号的C2000 DSP均提供了标准外设库，目前仅有2802x，2807x等几个系列提供了标准外设库文件。如需使用标准外设库文件，将库文件（即driverlib.lib）添加至工程中，并且包含\controlSUITE\device_support\f****\v***\DSP****_common\include\目录即可。添加TI提供的一些例程文件将\controlSUITE\device_support\f****\v***\DSP****_common\中的source\、include\与lib\文件夹复制到工程目录下，将include\文件夹添加到包含路径中。这些文件的具体作用参考\controlSUITE\device_support\f****\v***\doc\中的文档，可根据实际去除不需要的文件。在本项目中，最终的目录结构如图所示：设置程序入口点根据TI文档的说明，依次找到菜单栏的Project-&amp;gt;Properties-&amp;gt;C2000 Linker-&amp;gt;Symbol Management，在Program Entry Point -e中输入程序入口点即可。TI文档中对此设置的说明如下：Defines a global symbol that specifies the primary entry point for the output module. For the DSP2803x examples, this is the symbol “code_start”. This symbol is defined in the DSP2803x_common\source\DSP2803x_CodeStartBranch.asm file. When you load the code in Code Composer Studio, the debugger will set the PC to the address of this symbol. If you do not define a entry point using the -e option, then the linker will use _c_int00 by default.]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构——循环队列</title>
      <link href="/2015/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
      <url>/2015/11/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[可参考这篇文章，循环队列一般用静态数组实现，称之为队列的顺序存储类型。可使用如下结构体：循环队列入队及出队示意图见下图：循环队列实现的核心问题在于队满情况的判断。最普遍的做法是牺牲一个单元来区分队空和队满，入队时少用一个队列单元，即图中(d2)的情况。约定以“队头指针在队尾指针的下一位置“作为队满的标志，故在上述循环队列结构体定义中，Buffer的大小为Queue_Buffer_Size + 1。下面给出循环队列具体实现：初始化判断队列是否为空入队出队完整代码。]]></content>
      
      
      <categories>
          
          <category> 算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Struct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSI模型总结</title>
      <link href="/2015/11/23/OSI_Model/"/>
      <url>/2015/11/23/OSI_Model/</url>
      
        <content type="html"><![CDATA[OSI模型是最为常用的网络分层模型，其全称为“开放式系统互联通信参考模型”，Open System Interconnection Reference Model。 此模型由国际标准化组织(ISO)提出，是一个试图使各种计算机在世界范围内互连为网络的标准框架，对应标准为ISO/IEC 7498-1。此模型已成为计算机间和网络间进行通信的主要结构模型，目前使用的大多数网络通信协议的结构都是基于OSI模型的。 OSI模型中将网络通信的工作分为七层，这就是通常说的OSI七层模型，具体层次划分见下图及下表：层数据单元典型设备功能应用层数据计算机：应用程序直接和应用程序连接并提供常见的网络应用服务表示层数据计算机：编码方式将数据按照网络能理解的方案进行格式化会话层数据计算机：建立会话负责在网络中的两节点之间建立、维持和终止通信传输层数据段计算机：进程和端口提供端到端的交换数据的机制，检查分组编号与次序网络层数据包网络：路由器将网络地址转化为对应的物理地址，并且决定如何将数据从发送方传到接收方数据链路层数据帧网络：交换机、网桥控制物理层和网络层之间的通讯物理层比特网络：集线器、网线产生并检测电压，以便发送和接收携带数据的信号，提供为建立、维护和拆除物理链路所需要的机械的、电气的、功能的和规程的特性OSI七层模型的每一层都具有清晰的特征。基本来说，第七至第四层处理数据源和数据目的地之间的端到端通信，而第三至第一层处理网络设备间的通信。另外，OSI模型的七层也可以划分为两组：主机层（7、6、5、4层）和媒介层（3、2、1层）。主机层处理应用程序问题，并且通常只应用在软件上，最高层，即应用层是与终端用户最接近的；媒介层是处理数据传输的，物理层和数据链路层应用在硬件和软件上，最底层，即物理层是与物理网络媒介最接近的，并且负责在媒介上发送数据。 下面从最底层开始，具体说明各层的作用：物理层(Physical Layer)物理层位于OSI参考模型的最底层，它直接面向原始比特流的传输。为了实现原始比特流的物理传输，物理层必须解决好包括传输介质、信道类型、数据与信号之间的转换、信号传输中的衰减和噪声等在内的一系列问题。另外，物理层标准要给出关于物理接口的机械、电器功能和规程特性，以便于不同的制造厂家既能够根据公认的标准各自独立地制造设备，又能使各个厂家的产品互相兼容。简而言之，物理层规定了通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接。具体地讲，机械特性规定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等；电气特性规定了在物理连接上传输比特流时线路上信号电平的大小、阻抗匹配、传输速率、距离限制等；功能特性是指对各个信号先分配确切的信号含义，即定义了DTE和DCE之间各个线路的功能；规程特性定义了利用信号线进行bit流传输的一组 操作规程，是指在物理连接的建立、维护、交换信息是，DTE和DCE双放在各电路上的动作系列。在这一层，数据的单位称为比特（bit）。属于物理层定义的典型规范包括：EIA-RS-232、EIA-RS-422、V.35、RJ-45等。数据链路层(Data Link Layer)数据链路层涉及相邻节点时间的可靠数据传输，数据链路层通过加强物理层传输原始比特的功能，使之对网络层表现为一条无错线路。为了能够实现相邻节点之间无差错的数据传输，数据链路层在数据传输过程中提供了确认、差错控制和流量控制等机制。在数据链路层的设备有二层交换机和网桥，我们可以把数据链路层看做是承上启下的一层。数据链路层在不可靠的物理介质上提供了可靠的传输。在这一层，数据的单位称为帧（frame）。数据链路层典型协议包括：IEEE 802.11、PPP、L2TP、STP、ATM、Ethernet、GPRS、HSPA、PPPoE等。网络层(Network Layer)网络中的两台计算机进行通信时，中间可能要经过许多中间节点甚至不同的通信子网。网络层的任务就是在通信子网中选择一条合适的路径，使发送端传输层所传下来的数据能够通过所选择的路径到达目的端。网络层提供了路由及其相关的功能，可以将众多的数据链路结合成一个互连的网络，这是通过设备的逻辑寻址来实现的。有关路由的一切事情都在这第一层处理，地址解析和路由是网络层的重要目的，网络层还可以实现拥塞控制、网际互连等功能。在这一层，数据的单位称为数据包（packet）。网络层的典型协议包括：IP、IPsec、RIP、OSPF、BGP、IGMP等。传输层(Transport Layer)传输层是OSI参考模型中唯一负责端到端节点间数据传输和控制功能的一层。传输层也是具有承上启下功能的一层，它下面的三层主要面向网络通信，以确保信息被准确有效地传输，它上面的三层则面向用户主机，为用户提供各种服务，传输层通过弥补网络层服务质量的不足，为会话层提供端到端的可靠数据传输服务。传输层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的数据包和其它在传输过程中可能发生的危险。传输层为上层提供端到端的透明的、可靠的数据传输服务。所为透明的传输是指在通信过程中传输层对上层屏蔽了通信传输系统的具体细节。在这一层，数据的单也称作数据包（packets）。不过，在谈论TCP等具体的协议时又有特殊的叫法，TCP的数据单元称为段（segments），而UDP协议的数据单元称为报文（datagrams）。传输层的典型协议包括：TCP、UDP、SPX、PPTP、TLS/SSL、SCTP、DCCP等。会话层(Session Layer)会话层的主要功能是在两个节点之间建立、维护和释放面向用户的连接，并对会话进行管理和控制，保证会话数据可靠传输。会话层是建立在传输层之上，由于利用传输层提供的服务，使得两个会话实体之间不考虑他们之间相隔多远，使用了什么样的通信子网等网络通信细节，从而进行透明的、可靠的数据传输。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制，如服务器验证用户登录便是由会话层完成的。在会话层及以上的高层次中，数据传送的单位不再另外命名。会话层没有协议，应用层的HTTP、RPC、SDP、RTCP等协议有类似的功能。表示层(Presentation Layer)表示层的主要作用是为通信双方的应用层实体提供共同的表达手段，使双方能正确地理解所传送的信息。表示层为应用层提供了各种编码和数据转换功能。这些功能可以确保发自某个系统的应用层信息可以被另一个系统的应用层解读出来。这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法，即提供格式化的表示和转换数据服务。数据的压缩和解压缩、加密和解密等工作都由表示层负责。表示层没有协议，应用层的HTTP、FTP、Telnet等协议有类似的功能，传输层的TLS/SSL也有类似功能。应用层(Application Layer)应用层是OSI参考模型中最靠近用户的一层，负责为用户的应用程序提供网络服务。与OSI参考模型其它层不同的是，它不为任何其他OSI层提供服务，而只是为OSI模型以外的应用程序提供服务，具体来说就是为操作系统或网络应用程序提供访问网络服务的接口。应用层的协议最为丰富，典型协议包括：HTTP、POP3、SMTP、IMAP、DNS、DHCP、FTP、Telnet、SSH、NNTP、XMPP、SIP、RPC、RTCP、SDP、MMS等。关于HTTPS协议，有些文章将其算作应用层的一个协议，不过严格地讲，HTTPS并不是一个单独的协议，而是对工作在一加密连接（TLS或SSL）上的常规HTTP协议的称呼。最后，对OSI七层模型结构做一个概括性的总结：应用层：触及到应用程序的网络业务表示层：数据表达会话层：主机间通信传输层：端到端的可靠连接网络层：逻辑寻址和最佳路径数据链路层：访问介质物理层：数据二进制的传输知乎上有个通俗的例子可供参考：生动形象，切中要点的讲解osi七层模型和两主机传输过程。参考资料：网络工作中应该知道的OSI七层模型 - 阿布的博客OSI网络结构的七层模型 TCP/IP层次模型 - cutepig’s blogOSI七层模型笔记 - 简书OSI七层与TCP/IP五层网络架构详解 - 服务器运维与架构]]></content>
      
      
      <categories>
          
          <category> 软件之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Top </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安规电容总结</title>
      <link href="/2015/11/23/%E5%AE%89%E8%A7%84%E7%94%B5%E5%AE%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2015/11/23/%E5%AE%89%E8%A7%84%E7%94%B5%E5%AE%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[简介所谓安规电容，是指用于这样的场合，即电容器失效后，不会导致电击，不危及人身安全。具体来说，安规电容是一种与普通电容相比符合安全认证的电容，故称为安规电容。一般的电容失效后，会造成电击穿，通常表现为短路，这样就会引入大电流，对人或设备将造成危害；而安规电容失效后，则呈现开路状态，不会引入其它危险。除此之外，安规电容的放电特性与普通电容不同。普通电容在外部电源断开后电荷会保留很长时间，如果用手触摸就会被电到，而安规电容的放电时间相对较短。在实际使用时，一般还加上额外的放电电路进行放电。安规电容通常只用于抗干扰电路中的电源滤波上。出于安全及EMC考虑，一般在交流电源的入口处加上若干个安规电容，用于抑制EMI传导干扰。X电容与Y电容根据IEC 60384-14标准，安规电容包括X电容与Y电容两大类。X 电容是指跨接于 L-N 之间的电容器；Y 电容是指跨接于 L-G/N-G 之间的电容器。 其中，L=Line(火线), N=Neutral(零线), G=Ground(地线)示意图：火线与零线之间接个电容就像是“X”,故称X电容；而火线与地线之间接个电容像个“Y”，故称Y电容。通常Y电容成对使用，X电容可使用一个或多个。对于X电容与Y电容的技术规范在IEC 664标准中规定，中国国家标准GB/T 16935.1-1997与之等同。X电容跨接于火线与零线间，受电压峰值的影响，为避免短路，比较注重的参数是耐压等级，故按照允许的峰值脉冲电压过电压等级将其分为X1、X2、X3三种电容，具体定义如下：分类峰值脉冲电压过电压等级X1&amp;gt;2.5kV &amp;amp; ≤4.0kVX2&amp;gt;1.2kV &amp;amp; ≤2.5kVX3≤1.2kV其中，X2安规电容最为常用。Y电容跨接于火线与地线间，涉及到漏电安全的问题，因此它注重的参数就是绝缘等级，故按照绝缘等级将其分为Y1、Y2、Y3、Y4四种电容，具体定义如下：分类绝缘等级额定电压交流耐压脉冲电压Y1双重绝缘或加强绝缘≥250VAC4000VAC8.0kVY2基本绝缘或附加绝缘≥150VAC &amp;amp; &amp;lt;250VAC1500VAC5.0kVY3基本绝缘或附加绝缘≥150VAC &amp;amp; &amp;lt;250VAC1500VAC无Y4双重绝缘或加强绝缘&amp;lt;150VAC900VAC2.5kV其中，Y1与Y2安规电容最为常用，Y3与Y4安规电容因为其耐压过低，基本没有使用。型号及应用安规电容通常使用金属化薄膜为介质，常用的材料有聚酯膜CL及聚丙烯膜CBB两种。所谓金属化，是指电容引出线是从喷了金属的端面引出，从而使电流通路很短，所以也称为无感电容。CL电容与CBB电容的最大优点就是其绝缘性能特别好，优于其他材质的电容器，这正好符合安规电容的需求。除了CL电容与CBB电容外，Y电容有时也会使用陶瓷电容。X电容大部分均为CBB电容，X2与X1电容最为常用，X3电容基本不使用。其外形通常是这样的：一般X安规电容都使用图中这样的黄色环氧树脂外壳，体积较大，外壳上注明了其电容值、安规等级、各种安规认证等。图中这个电容就是一个0.47uF的X2安规电容。一般X1电容的额定电压为300VAC，X2电容的额定电压为275VAC。电容值从10nF4.7uF之间都有，大部分电路中使用12个0.47uF的X电容就可以了。Y电容通常使用Y2或Y1电容，Y3和Y4电容基本不使用。Y电容也有使用CBB电容的，其外形与X电容相同，比如下面这个Y2电容：不过，Y电容更常用的是陶瓷电容，这主要是因为陶瓷电容更为便宜，在成本上有很大的优势。其外壳通常是蓝色的，比如下面这个Y电容：陶瓷电容有时候并不严格区分Y1、Y2电容，外壳上会同时写上“Y1 400VAC / Y2 250VAC”的字样。Y电容的容量大小不能太大，一般情况下，工作在亚热带的机器，要求对地漏电电流不能超过0.7mA；工作在温带机器，要求对地漏电电流不能超过0.35mA。因此，Y电容的总容量一般都不超过4700pF。大部分电路中使用2个2200pF的Y电容就可以了。]]></content>
      
      
      <categories>
          
          <category> 硬件之理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HW Component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言生成随机数</title>
      <link href="/2015/11/16/C%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/2015/11/16/C%E8%AF%AD%E8%A8%80%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[在C语言中，使用rand()函数生成随机数，srand()函数初始化随机数种子。rand()函数原型为int rand(void)，在头文件stdlib.h中声明。此函数返回一个0~`RAND_MAX` 间的伪随机整数。RAND_MAX是头文件stdlib.h中定义的一个宏，其值在不同平台下有所区别。根据C语言标准，RAND_MAX最小为32767。在Microsoft VS提供的标准库文件中，RAND_MAX被定义为32767。srand()函数原型为void srand(unsigned int seed)，同样在头文件stdlib.h中声明。此函数将seed设置为伪随机数生成的初始种子。确定了初始种子后，每次调用rand()函数时，就会使用递推公式给出一个伪随机数。所以显而易见，若seed相同，之后得到的伪随机数序列也会完全相同。如果不显式调用srand()函数，在第一次调用rand()函数之前，会自动将seed设置为1。通常做法是使用当前时间来作为seed，即：其中，time()函数的原型为time_t time(time_t *timer)，在头文件time.h中声明。此处给出的函数原型是基于Microsoft VS提供的标准库文件的，在其它平台下可能会有所区别。关于此函数的参数与返回值，可参考MSDN中的说明：The time function returns the number of seconds elapsed since midnight (00:00:00), January 1, 1970, Coordinated Universal Time (UTC), according to the system clock. The return value is stored in the location given by timer. This parameter may be NULL, in which case the return value is not stored.time is a wrapper for _time64 and time_t is, by default, equivalent to __time64_t. If you need to force the compiler to interpret time_t as the old 32-bit time_t, you can define _USE_32BIT_TIME_T. This is not recommended because your application may fail after January 18, 2038; the use of this macro is not allowed on 64-bit platforms.简而言之，使用time(NULL)会返回从1970年1月1日0:0:0至今的秒数，每次运行程序时此值都不相同，故可以用此值作为seed。需要注意的是，time()的最小分辨率为1s，所以在1s内多次调用此函数的返回值是相同的。直接调用rand()函数仅能得到0~`RAND_MAX`间的整数，如需得到其它范围的整数或小数，则需要在此基础上再进行一些处理。生成任意范围的整数代码如下：这段代码是网上广为流传的代码，然而，从理论上仔细进行分析，这个方法并不能严格保证生成的伪随机数符合均匀分布。故此方法仅适合于粗略的生成一些随机数。生成0~1区间的小数代码如下：数学基础前面提到，rand()函数是使用某个递推公式来生成一个伪随机数序列的，事实上，这里使用的算法是线性同余法 （LCG，Linear Congruential Generator）。LCG的基本公式为：x(n+1) = (A * x(n) + C) % M所谓初始种子seed即为x(0)的值。不同编译器附带的标准库文件中A、C、M这三个参数的取值并不相同，具体可参考 Wikipedia 中的说明对于Microsoft VS来说，在rand.c文件中可以找到如下代码：可以看到，A = 214013, B = 2531011, m = 2^32。线性同余法的优势在计算速度快，内存消耗少。但是生成的随机数质量不高，因为其相邻的随机数并不独立，序列关联性较大。除了线性同余法外，还有多种生成伪随机数的方法，如生成均匀分布伪随机数使用的梅森旋转算法、Multiply-With-Carry算法，生成高斯分布伪随机数使用的中心极限定理法、Box-Muller算法等。具体可以参考 这篇文章 的说明。C++中生成随机数可以使用更好的方法，详见：C++生成随机数]]></content>
      
      
      <categories>
          
          <category> 编程之法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Number Theory </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Doxygen处理条件编译</title>
      <link href="/2015/11/13/Doxygen%E5%A4%84%E7%90%86%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/"/>
      <url>/2015/11/13/Doxygen%E5%A4%84%E7%90%86%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[在使用Doxygen生成文档的时候，发现有些内容没有生成。仔细研究程序源代码，发现这部分代码使用了条件编译进行控制，代码如下：而Doxygen是会对宏进行处理的，这样就会跳过这部分代码。解决方式：在Expert的Preprocessor选项中，找到PREDEFINED，添加需要预定义的宏即可。截图如下：]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Doxygen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Doxygen生成高质量代码参考文档</title>
      <link href="/2015/11/12/%E4%BD%BF%E7%94%A8Doxygen%E7%94%9F%E6%88%90%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/"/>
      <url>/2015/11/12/%E4%BD%BF%E7%94%A8Doxygen%E7%94%9F%E6%88%90%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[注释和文档是程序的重要组成部分，使用 Doxygen 可以自动将程序中特定格式的注释提取出来，生成一份很漂亮的参考文档。这样只要在编程的时候遵循特定的格式书写注释，程序编好后文档也就自动完成了，不需要专门花时间来写文档，这无疑减少了很多的工作量。Doxygen支持的语言有很多，常用的有C/C++、Java、Python等；可以生成的文档格式也很丰富，其中以HTML格式和Latex格式最为常用。关于Doxygen的安装和使用，可参考其官方 参考手册， 这个参考手册本身也是使用Doxygen生成的。网上也可找到很多基础教程，在此不再累述。本文主要介绍在使用C语言编程时该如何写注释，以便使用Doxygen自动生成高质量的文档。下面以STM32F0系列单片机的标准库（Standard Peripheral Library）中的ADC模块为例进行分析，这是ST公司为其F0系列单片机提供的驱动库文件，注释的书写十分标准，很适合进行学习模仿。定义功能模块STM32F0xx_StdPeriph_Driver是按照功能模块进行组织的，每个功能模块有其对应的头文件与源文件。功能模块列表如下：为了让Doxygen能正确提取模块定义，需添加模块定义注释。在文件中加入：使用@brief对本模块的主要功能进行说明，如需进行更详细的说明，可使用@details。定义宏定义子模块定义了功能模块后，一般还将宏定义单独定义为一个子模块，宏定义一般放在头文件中，加入以下注释：以上代码段中定义了一个名为ADC_Exported_Constants的模块，此模块包含了ADC模块中所有的宏定义。在ADC_Exported_Constants模块中，又有若干个子模块，如ADC_JitterOff，ADC_Resolution等。它们的关系可以参考下图：这样组织代码可以让大的量宏定义结构更为清晰，而且有利于在其它地方进行交叉引用。定义函数子模块与宏定义子模块类似，也可以将函数定义为一个子模块，并且按功能进行进一步分组归类。函数的定义与注释说明一般都全部放在源文件中，头文件中仅简单的进行函数声明。在源文件中加入以下注释：以上代码在实际代码的基础上进行了精简，仅保留了进行模块定义的基本结构。代码段中定义了一个名为ADC_Private_Functions的模块，此模块中包含了所有的函数定义，并且各函数按用途进行了分组，分为了若干个子模块，如Initialization and Configuration functions，Power saving functions等。关系示意图如下：结构体注释说明对于结构体，一般使用如下形式的注释：此代码段中对ADC_InitTypeDef这个结构体进行了较为详尽的注释，开头使用@brief说明此结构体的主要功能，之后对结构体中每个成员的意义进行了注释。使用/*!&amp;lt; Comment */这样的语法表示此注释对应的是注释前面的语句，这样可以使代码的排版更为美观。另外，注意到其中@ref标签的使用，这代表交叉引用。如@ref ADC_Resolution，实际会生成一个超链接指向之前定义的ADC_Resolution模块。这里的交叉引用可以为模块名、函数名、结构体等。以上代码段提取出的文档效果见下图：枚举的注释形式与结构体完全相同，可参照以上示例进行注释。函数注释说明函数的注释说明一般放在源文件中，头文件和源文件中最好不要重复添加注释，否则生成的文档会有重复。函数注释一般使用以下的形式：使用@brief简要说明函数的作用；使用@param说明输入参数，若输入参数是有限的几个值，可用@arg进行列举；使用@retval说明函数的返回值。另外，一些需要特别注意的地方可以使用@note，@warning进行说明。以上代码段提取出的文档效果见下图：文件头每个文件的开头部分一般都需要添加一个对此文件的说明，可使用如下格式：杂项使用@todo和@bug标签列出待办事项与Bug，Doxygen会自动汇总Todo与Bug列表。可使用@verbatim与@endverbatim包含一段文本，这段文本就会按原样输出。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Doxygen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客优化加载速度</title>
      <link href="/2015/11/01/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/"/>
      <url>/2015/11/01/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[前几天根据 小A同学 的方法在Github Pages上使用Hexo搭建了这个博客，然而之后发现访问速度实在是太慢了，而且有些时候还会直接无法打开。当然要想个办法来解决这个问题，于是又开始了折腾……写篇文章来记录下折腾的过程。Github &amp;amp; Gitcafe 同时部署目前Gitcafe已被Coding.net收购，其业务也并入Coding.net中，以下方法也适用于Coding.netGitcafe 可以视为中国版的Github，Github有Github Pages， Gitcafe就有Gitcafe Pages。二者的使用方法也如出一辙，具体可以参考 这篇文章。本来可以直接把博客全部迁移到Gitcafe上，不过在网上看到，可以同时在Github和Gitcafe上进行部署，并且让国内用户访问Gitcafe，国外用户访问Github。实现过程也不复杂，可以参考 这篇文章 的做法。主要就是在建立好Gitcafe Pages后，通过修改_config.yml文件的配置，让每次使用hexo d命令进行部署时，能同时部署至Github和Gitcafe上。相关代码如下：Github与Gitcafe使用的SSH RSA公钥必须相同。部署完成后，需要配置DNS多线路解析，以DNSPod为例，添加如下主机记录即可：Github与Gitcafe均使用了官方推荐的CNAME方式进行解析。优化Mathjax选择性加载加载Mathjax的过程很费时间，根据 Yilia 主题的默认写法，即使在网页中并没有生成公式时, 也会加载最基本 MathJax.js。为解决此问题，可根据 这篇文章 的做法，只有在用到公式的页面才加载 Mathjax。修改after-footer.ejs文件，将原来的替换为在需要使用公式的文章开头加上mathjax: true即可，比如：替换Mathjax镜像Mathjax的CDN服务器全部位于海外，故访问速度都很慢，可以参考 这篇文章 的做法，将其替换为一个中国镜像。找到mathjax.ejs文件，将替换为使用百度CDN加速静态资源库Fancyboxafter-footer.ejs中，将改为main.js中，将改为同时，可以直接删掉\yilia\source\fancybox\文件夹。Lazyloadmain.js中，将改为同时，可以直接删掉\yilia\source\js\jquery.lazyload.js文件。此文件并不是官方版本的Lazyload，主题作者Litten对它进行了一些更改，不过测试表明，使用官方的Lazyload来替代此文件没有什么问题。使用七牛加速静态资源文件Jquery将http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js下载下来，上传到七牛上，之后修改after-footer.ejs，将改为七牛提供的地址。7.url.cn的访问速度和稳定性均好于七牛，故没必要画蛇添足。**mobile.js &amp;amp; pc.js **将\yilia\source\js\mobile.js和将\yilia\source\js\pc.js上传至七牛，之后修改\yilia\source\js\main.js，将改为七牛提供的地址。main.js将\yilia\source\js\main.js上传至七牛，之后修改after-footer.ejs，将改为七牛提供的地址。字体文件将\yilia\source\css\fonts\目录中全部文件上传至七牛，之后修改以下这些文件：_variables.styl中，将改为七牛提供的地址。style.styl中，修改以下代码段]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用JLink为2440 NOR Flash下载程序</title>
      <link href="/2015/10/31/%E4%BD%BF%E7%94%A8JLink%E4%B8%BA2440%20NOR%20Flash%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/"/>
      <url>/2015/10/31/%E4%BD%BF%E7%94%A8JLink%E4%B8%BA2440%20NOR%20Flash%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[以Mini2440开发板为例，通过Jlink将程序下载至NOR Flash中运行。因为CPU可对NOR Flash直接寻址，程序可在NOR Flash中直接运行，故将裸机程序下载至NOR Flash中调试运行较为简单。使用J-Link Commander和J-Flash ARM均可实现程序下载，不过J-Flash ARM使用起来更为简单直观。下面总结一下使用J-Flash ARM下载程序的方法。 **需要先安装好J-Link驱动，连接好JTAG，并且给目标板上电。2440 OM[1:0]配置为从NOR Flash启动。 **新建工程(Optional)File -&amp;gt; New project检查连接情况(Optional)Target -&amp;gt; Connect如果连接正常的话，LOG窗口中会有类似下面这样的信息：其中Core ID: 0x0032409D (ARM9)就是检测到的CPU核心。设置工程(Optional)Options -&amp;gt; Project settings实际测试表明，不进行设置全部使用默认值（大部分选项的默认值均是Auto）可以成功下载程序，不过也有可能会发生一些 问题 。另外，默认情况下不使用目标RAM，下载速度会很慢。所以还是建议进行下设置。General一般不需要更改。Target Interface可保持默认值，也可修改下JTAG speed。CPU中，Core可以选择Auto，也可按实际情况选为ARM9。Use traget RAM (faster)建议选上，否则下载速度会很慢。RAM Address根据实际情况填写，对于S3C2440来说，可以使用内部4K的SRAM，其地址为0x40000000。在使用了目标RAM后，有时候下载会提示错误：PC of target system has unexpected value after programming,若出现此错误，可参考 这篇文章 的做法，将Use following init sequence:中Reset的Delay时间改为2ms。配置完成后的设置如图：Flash中，可不勾选Automatically detect flash memory，改为手动指定Flash型号。点击Select flash device后，选择正确的Falsh型号即可。Mini2440开发板上使用的NOR Flash为AM29LV160DB。如果没有实际使用的型号，可以选择一个兼容型号，然后去掉Check manufacturer flash Id和Check product flash Id即可。配置完成后的设置如图：Production保持默认。全部设置完成后，工程设置如图：可将设置文件保存为.jfalsh文件，下次直接打开即可。测试下载速度(Optional)Target -&amp;gt; Test -&amp;gt; Test speed可以通过测试下载速度来检查之前的配置是否正确，如果能正常下载测试数据，说明配置正确。如果测试通过的话，会自动弹出测试结果：选择程序文件File -&amp;gt; Open data file一般选择.bin格式的程序文件，不支持.axf文件，可通过fromelf.exe将.axf文件转为.bin文件。下载编程Target -&amp;gt; Program之后选择确定擦除和复写编程区域。如果下载成功的话，LOG窗口中会有类似下面这样的信息：]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JTAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用格式</title>
      <link href="/2015/10/30/Markdown%E5%B8%B8%E7%94%A8%E6%A0%BC%E5%BC%8F/"/>
      <url>/2015/10/30/Markdown%E5%B8%B8%E7%94%A8%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[根据以下文章整理得到：markdown简明语法献给写作者的 Markdown 新手指南Markdown语法说明（详解版）BAZINGA的博客不同Markdown解析器的行为可能会有所区别，支持的标签也不完全相同，本文根据Hexo所附带的解析器进行讨论。段落一个段落是由一个以上相连接的行句组成，而一个以上的空行则会切分出不同的段落（空行的定义是显示上看起来像是空行，便会被视为空行。比如，若某一行只包含空白和 tab，则该行也会被视为空行）。标题使用1到6个#，对应1至6级标题。分割线使用3个以上_表示。下面是一条分割线上面是一条分割线列表无序列表使用-，注意，-后有一个空格，不能省略。列表项1列表项2列表项3嵌套列表交替使用- +，并使用空格进行缩进。注：Hexo似乎只支持两级嵌套。嵌套列表1嵌套列表11嵌套列表12嵌套列表2有序列表使用1. 2. 3.，注意，之后要有一个空格。列表项1列表项2列表项3引用使用&amp;gt;表示。这是一条引用。超链接使用[显示文本](链接地址)这样的语法即可。浙江大学上海交通大学也可使用尖括号，会自动处理链接形式。http://gaomingfei.xyz&amp;#x67;&amp;#x31;&amp;#x39;&amp;#x39;&amp;#50;&amp;#x30;&amp;#x39;&amp;#x40;&amp;#x31;&amp;#x36;&amp;#51;&amp;#x2e;&amp;#99;&amp;#x6f;&amp;#109;图片使用![](图片链接地址)这样的语法即可。粗体和斜体使用2个*包含一段文本代表粗体，使用1个*包含一段文本代表斜体。这是正常文本， 这是粗体文本， 这是斜体文本。表格参见以下代码段，使用:来确定对齐方式。TablesAreCoolcol 3 isright-aligned$1600col 2 iscentered$12zebra stripesare neat$1代码行内代码使用`包含代码片段即可。代码段使用```包含代码片段即可，第一行的```后面可以指定使用的编程语言，一般建议手动指定，常用语言列表如下：Language NameAliasLanguage NameAliasARM assemblerarmasm, armAVR assembleravrasmAwkawk, mawk, nawk, gawkBashbash, sh, zshBasicbasicC#cs, csharpC, C++cpp, c, cc, c++CMakecmakeCSScssDOSdos, bat, cmdDelphi, Pacaldelphi, pascalDiffdiffDjangodjangoDTS (Device Tree)dtsExcelexcelFortranfortranGogoGradlegradleGroovygroovyHTML, XMLxml, html, xhtml, rssHTTPhttpJSONjsonJavajavaJavaScriptjavascript, jsLisplispLualuaMakefilemakefile, mk, makMarkdownmarkdown, mdMatlabmatlabPHPphpPerlperlProcessingprocessingPrologprologPythonpython, pyRrRubyrubySQLsqlSwiftswiftTcltclTeXtexVB.Netvbnet, vbVBScriptvbscript, vbsVHDLvhdlVerilogverilog, vVim Scriptvimx86 Assemblyx86asm完整的帮助见：CSS classes reference。如果不需要高亮，使用no-highlight公式需要Mathjax支持，详细说明可参考其文档。Hexo本身不直接支持Mathjax，不过本博客系统使用的Yilia主题添加了Mathjax支持，故不需要做其它配置即可直接使用。Mathjax公式常用语法可参考:Mathjax与LaTex公式简介使用$表示行内公式，使用$$表示整行公式，其中使用Latex格式来编辑公式，推荐一个比较好用的在线Latex公式可视化编辑器：CodeCogs。下面是一些公式的示例效果。著名的质能守恒方程为：$E=mc^2$。其中$E$代表能量，$m$代表质量，$c$代表光速同样很著名的麦克斯韦方程组为$$\nabla\cdot\vec{B}=0$$$$\nabla\cdot\vec{D}=\rho$$$$\nabla\times\vec{H}=\vec{J} + \frac{\partial \vec{D}}{\partial t}$$$$\nabla\times\vec{E}=- \frac{\partial \vec{B}}{\partial t}$$以上4个方程由两个散度方程和两个旋度方程组成，是麦克斯韦方程组的微分形式，可转化为对应的积分形式:$$\oint_{S} \vec{B}\cdot\mathrm{d}\vec{S}=0$$$$\oint_{S} \vec{B}\cdot\mathrm{d}\vec{S}=\int_{V}\rho \mathrm{d}V$$$$\oint_{l} \vec{H}\cdot \mathrm{d}\vec{l}=\int_{S}(\vec{J}+\frac{\partial \vec{D}}{\partial t})\cdot\mathrm{d}\vec{S}$$$$\oint_{l} \vec{E}\cdot \mathrm{d}\vec{l}=-\int_{S}\frac{\partial \vec{B}}{\partial t}\cdot\mathrm{d}\vec{S}$$需要注意的是，正如这篇文章所说，在书写MathJax公式的时候有时候会出现一些问题，主要是因为Markdown会将一些标记给编译掉，所以_、&amp;#123;&amp;#125;和\\等符号有时会出现问题，解决方式是在前面加上\进行转义。HTML标签文本中可直接用html标签，不需要额外标注这是 HTML 或是 Markdown，只要直接加标签就可以了。只有区块元素──比如 &amp;lt;div&amp;gt;、&amp;lt;table&amp;gt;、&amp;lt;pre&amp;gt;、&amp;lt;p&amp;gt; 等标签，必需在前后加上空白，以利与内容相区分。比如以下代码段，可以居中放置一张图片，其中url代表图片地址。Html标签另外一个比较有用的作用是可以方便的直接插入一些符号，避免被Markdown解释器错误的解释。]]></content>
      
      
      <categories>
          
          <category> 工具之术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

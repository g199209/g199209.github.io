<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>高明飞的博客</title>
  
  <subtitle>澹泊明志，宁静致远</subtitle>
  <link href="https://gaomf.cn/atom.xml" rel="self"/>
  
  <link href="https://gaomf.cn/"/>
  <updated>2021-06-12T03:16:52.312Z</updated>
  <id>https://gaomf.cn/</id>
  
  <author>
    <name>高明飞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何学习一个新东西</title>
    <link href="https://gaomf.cn/2021/06/12/How_to_Learn_a_New_Thing/"/>
    <id>https://gaomf.cn/2021/06/12/How_to_Learn_a_New_Thing/</id>
    <published>2021-06-12T03:07:03.000Z</published>
    <updated>2021-06-12T03:16:52.312Z</updated>
    
    <content type="html"><![CDATA[<p>我们从小到大都在学习各种新东西，学的东西多了自然会对“如何学新东西”这一问题本身有一些方法论层面的思考，本文就来分享总结下自己的一些经验。</p><p>对于学习各种<strong>人为创造</strong>的东西基本都可以按相同的方法进行，不过对于学习自然科学的概念方法会有所不同，本文就不去讨论了。</p><p>学习一个新东西基本可以分为三个阶段：初步理解，即会用；深入理解，即懂原理；融会贯通。</p><span id="more"></span><h2 id="初步理解"><a href="#初步理解" class="headerlink" title="初步理解"></a>初步理解</h2><p>这一阶段的目的是学会如何使用这个新东西，即学习如何用轮子的阶段，对于只需要应用的情况来说达到这一阶段就够了。此阶段的核心就是搞清楚三个问题：是什么（What），为什么（Why），怎么用（How），这十分类似于 3W 法则，因为这本来就是人类自然思维过程的抽象总结。</p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>最基本的第一步，搞清楚这是一个什么东西。这一步说简单也简单，说复杂也复杂。简单在于只要随便看看介绍就会对这是什么有个初步感觉了；复杂在于要想给一个东西下一个精确的定义来描述它是什么会是极为复杂的。</p><p>要理解一个东西是什么往往伴随着理解它不是什么同步进行。</p><p>在学习新东西时一开始只需要对它是什么有个基本认识就好了，后续随着学习过程的深入自然会对此问题有越来越深入精确的认识。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>搞清楚为什么要创造出这么一个东西？这个东西的作用是什么？它可以用来解决什么问题？</p><p>对于某些东西来说要搞清楚此问题并不简单，特别是一些源于数学的抽象概念和方法。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>学会如何用这个东西。一些基础小东西会相对较为单纯，其使用方法也自然很简单。然而很多时候一个东西会提供若干不同功能来满足不同需求与解决不同问题，各功能都会有自己不同的使用方法。且达到同样目的也可以选择不同优劣有异的功能组合。</p><p>一般而言一个东西的复杂度很大程度上取决于其提供功能的多样性。相对比较简单纯粹的东西就只有会用和不会用两种状态，而更多复杂的东西则存在连续的中间状态。</p><p>这一步通常会是一个逐步深化、逐步探索的过程，开始只会用其最基本的功能，随着使用的深入会发掘出越来越多的使用方法及功能来。</p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><p>即学习其内部实现原理，这一阶段也就是学习如何造轮子的阶段，由浅到深可以继续分为三步：</p><ol><li>理解这个东西是如何设计及实现出来的，它是如何工作的？</li><li>理解为什么这样做是正确及可行的？</li><li>理解为什么要这样设计，不这样做还可以怎么做？</li></ol><p>一般而言，一个相对较复杂的技术及概念都是基于一系列更基础的技术及概念组合而成的，要充分理解其实现原理就要先理解其用到的各种底层技术或概念。</p><p>实现原理与此东西的功能及使用方法是密切相关的，内部实现是为了支撑其外部功能，在不知道其功能与使用方法时是很难理解其实现原理的。</p><p>在这一点上是很容易走弯路的，就像大学的很多课程为什么会感觉无用和难学就是因为这些课程的设计不是从应用出发自顶向下而是从原理出发自底向上的。根据我个人的经验，自底向上的学习方式并不是完全不可行，然而学习过程会很痛苦和迷茫，往往也会事倍功半。从应用出发自顶向下的学习路线相对会自然很多，先会用，再去研究它是怎么工作的，这更加的符合人类认识事物的规律。</p><p>当然也不是说非要精通其使用方法后再去研究其实现原理，二者其实是一个相辅相成相互促进的关系，会用了再去研究其内部实现会自然很多；理解了其内部实现后会有助于更好的去应用。</p><h2 id="融会贯通"><a href="#融会贯通" class="headerlink" title="融会贯通"></a>融会贯通</h2><p>这一阶段主要是在一个更大的框架下来思考理解这个东西，以达到通汇贯通的目的。可以从两个维度来入手。</p><h3 id="同类比较"><a href="#同类比较" class="headerlink" title="同类比较"></a>同类比较</h3><p>一般来说解决一个问题的方法都不止一个，因此可以进一步深入思考下这些问题：</p><ul><li>为了实现同样的目的及作用，还有什么其他方法？</li><li>这些方法间有什么优劣？什么时候改选择什么方法？</li><li>造成它们各自优劣的原因是什么？实现原理又有何共同点及区别？</li></ul><h3 id="发展脉络"><a href="#发展脉络" class="headerlink" title="发展脉络"></a>发展脉络</h3><p>人类发展至今基本所有东西都是渐进式发展的，基本太多东西是全新发展出来的，因此可以从时间的维度上来进行下思考：</p><ul><li>为了达到同样的目的，历史上有过什么其他的方法？</li><li>它们是如何一步步演化到当前这个样子的？</li><li>未来又会向什么方向演化？</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们从小到大都在学习各种新东西，学的东西多了自然会对“如何学新东西”这一问题本身有一些方法论层面的思考，本文就来分享总结下自己的一些经验。&lt;/p&gt;
&lt;p&gt;对于学习各种&lt;strong&gt;人为创造&lt;/strong&gt;的东西基本都可以按相同的方法进行，不过对于学习自然科学的概念方法会有所不同，本文就不去讨论了。&lt;/p&gt;
&lt;p&gt;学习一个新东西基本可以分为三个阶段：初步理解，即会用；深入理解，即懂原理；融会贯通。&lt;/p&gt;</summary>
    
    
    
    <category term="人生之思" scheme="https://gaomf.cn/categories/%E4%BA%BA%E7%94%9F%E4%B9%8B%E6%80%9D/"/>
    
    
    <category term="Methodology" scheme="https://gaomf.cn/tags/Methodology/"/>
    
  </entry>
  
  <entry>
    <title>Chia 技术架构简述</title>
    <link href="https://gaomf.cn/2021/05/16/Chia_Architecture_Brief/"/>
    <id>https://gaomf.cn/2021/05/16/Chia_Architecture_Brief/</id>
    <published>2021-05-16T09:33:00.000Z</published>
    <updated>2021-06-11T13:45:29.550Z</updated>
    
    <content type="html"><![CDATA[<p>Chia（起亚） 是最近极为火热的数字货币项目，对应的货币叫做 Chia Coin，简称 XCH。其核心算法为 PoST（Proof of Space and Time），以替代比特币中的 PoW（Proof of Work）。</p><p>使用 PoSpace 空间证明而非 PoW 工作量证明是 Chia 项目宣称的最大优点。据他们的开发者宣称，PoW 耗费太多能源了，不环保，我们来搞点更环保的东西吧，不用 PoW 了，改用 PoSpace，即谁有的硬盘空间多谁的投票权就更大。因此他们还把通常称为白皮书（White Paper）的文档改名叫做绿皮书（Green Paper）。</p><p>然而仔细想想这哪里环保了，把一堆硬盘搞来塞满毫无意义的数据比比特币矿机还要更邪恶吧……Chia 的官网上还可笑的宣称硬盘更不容易被垄断，因此个人还有小玩家可以更好的入场，简直是更荒谬的说法，哪个个人会去囤积一堆存不了有用数据的硬盘？</p><p>IPFS 好歹还可以存一些实际有用的数据，看起来还真能促进下社会发展，至于 Chia 简直是除了圈钱和泡沫看不到任何其他意义。不过抛开实际意义，由于最近也研究了下 Chia 的文档和代码，就单纯的来和大家分享下 Chia 的技术实现吧。</p><span id="more"></span><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><p>Chia 的整体架构图如下：</p><p><img src="https://img.gaomf.cn/chia-network-architecture.png?x-oss-process=image/resize,h_600"></p><p>整个系统中主要有 3 种类型的参与者：</p><ul><li>Farmer，农民</li><li>TimeLord，时间领主</li><li>Full Node，全能节点（中文翻译不确定）</li></ul><h3 id="Farmer"><a href="#Farmer" class="headerlink" title="Farmer"></a>Farmer</h3><p>绝大部分参与者都是农民 Farmer，如何成为农民也很简单，直接去下载个打包好的客户端运行就好了。</p><p>至于为什么叫 Farmer 呢？当然是为了凸显 Chia 的<em>绿色环保</em>喽，我们不是在浪费能源的挖矿，我们是在<em>环保</em>的种田！</p><p>Farmer 的工作也很简单，基本就是两步：</p><ol><li>Plotting，播种</li><li>Farming，摸奖</li></ol><p>Farmer 生成的 Plots file（P 盘文件） 可能会分布在很多台机器上，因此需要在这些机器上都部署上用来支持摸奖的服务，这个服务就被称为 Harvester 收割机。Farmer 接收到来自 TimeLord 的 Challenge（质询） 后，会将此 Challenge 转发到所连接的所有 Harvester 上。</p><h4 id="Plotting"><a href="#Plotting" class="headerlink" title="Plotting"></a>Plotting</h4><p>Plotting 的目的是在磁盘上生成一大堆 Plots file，根据其实现代码，这一过程可分为 4 步：</p><ol><li> Phase 1, forward propagation. 计算出所需的 7 张表及 f 函数集合，这一步实际上就已经生成了 PoSpace 所需的所有数据了，只是生成的临时文件还太大，需要后续来压缩下。f 函数的计算过程中会用到 Plot ID，Plot ID 直接决定了 Plots file 的内容；</li><li> Phase 2, backprogagation. 主要目的在于消除表中的无意义项（Dead entries），以减少磁盘空间占用；</li><li> Phase 3, compresses. 进一步压缩生成的临时文件 1，生成临时文件 2，临时文件 2 其实就是最终的 Plots file 了；这一步做了重排序，会使得生成的表中各项的顺序发生变化，不是按 PoSpace 要求的某种顺序。</li><li> Phase 4, write checkpoint table. 写入检查点表，其意义在于加快查找表的过程。</li></ol><p>最后，若最终路径（<code>--final_dir</code>）与临时文件 2 的路径（<code>--tmp2_dir</code>）是一样的，简单的把临时文件 2 做个 Rename 重命名即可；否则做一次数据拷贝生成最终 Plots file。</p><p>此处之所以要 Copy 或 Rename 一下而不是直接把临时文件 2 作为最终文件的主要原因是为了分离临时文件及最终文件的存储位置。</p><p>根据 Chia 的设计，Plots file 越多越好，因此显然要把它们存放在廉价的大容量存储系统，如本地机械盘或云端的低价存储中。然而此类系统通常随机读写能力不佳，甚至是直接不支持随机写入。可在生成临时文件 2 时是需要随机写入的，且写入的 IOPS 对生成文件的速度有显著影响，因此在通常实践中，会把临时文件写到 SSD 上。</p><p>Plotting 的逻辑是由 <code>DiskPlotter</code> 这个类来实现的。</p><h4 id="Farming"><a href="#Farming" class="headerlink" title="Farming"></a>Farming</h4><p>Farming 的过程就是对一系列 Challenges 的证明响应，每一轮证明过程都是以一个 256 bit 的 Challenge 为输入，输出是一个 PoSpace 结构，其中包括 Plots file 的公钥，Pool 的公钥， Proof 结果等。其中最重要的就是 Proof 结果。</p><p>生成一个区块的过程中会产生 64 次 Challenges，这一过程在客户端 Farming 的界面中可以看到：</p><p><img src="https://img.gaomf.cn/20210510-170238%402x.png?x-oss-process=image/resize,h_600"></p><p>每一个这样的点被称为一个 Signage Point。</p><p>为减少 IO 次数及所需网络带宽，目前的实现中采用了一种类似于预筛选的方法，先用较少次数的读计算出一个 Quality 值，并根据特定算法评估此 Quality 对于当前 Signage Point 来说够不够好，如果够好的话再去获取完整 Proof 结果。获取 Proof &amp; Quality 的过程是由 Harvester 完成的，评估 Quality 质量则是 Farmer 的工作。</p><h4 id="Harvester"><a href="#Harvester" class="headerlink" title="Harvester"></a>Harvester</h4><p>Harvester 负责管理某台机器上的所有 Plots file，并接收来自 Farmer 的 Challenge，返回每个 Plots file 的 PoSpace 及 PoSpace Quality。</p><p>这部分代码是由 <code>DiskProver</code> 类实现的。</p><p>Challenge 的高 $k$ bit 表示 f7 要满足的一些性质，通过对 C1, C2, C3 表的一通查询最终可以确定 Table 7 中有几项满足要求，可能有若干项满足要求，也可能一项都没有，平均期望是存在 1 项满足要求。</p><p>这里有几项满足要求就意味着这个 Plots file 中存在多少个最终的 Proof 证明结果。</p><p>之后的查找过程示意如下：</p><p><img src="https://img.gaomf.cn/chia_plots_file_table.png"></p><p>不过要注意的是，从 Table 7 中的一项表项只能找到 Table 6 中对应的<strong>一项</strong>，这样依次找下去就可以得到 Table 1 中的 32 项，每项是由 2 个 $k$ bit 的整数构成的，因此最终结果就有 $k*64$ bit。对这 64 个数进行重新排序（排序规则是由 PoST 算法决定的），最终就可以生成一个长长的字符串，这就是 PoSpace 的证明结果。</p><p>至于 Quality 是怎么来的呢？Challenge 最低 5 bit 的含义是 Table 6 ～ Table 2 在生成 Quality 时应该选择左边的值还是右边的值，按此规则进行选取后 Table 7 中的一项就会对应得到 Table 1 中的一项，即 2 个整数。将 Challenge 与这两个整数简单的二进制连起来，并计算 SHA-256，得到的结果就是 Quality 值。</p><h3 id="Timelord"><a href="#Timelord" class="headerlink" title="Timelord"></a>Timelord</h3><p>Timelord 一般被翻译为时间领主，它负责向 Farmer 发起质询（Challenge）并计算 VDF，计算完成后打包成新的区块，实际上整个 Chia 链中的区块都是由 TimeLord 计算生成的。TimeLord 最终决定了哪个 Farmer 的某个 Plots file 赢得了当前区块，即摸中奖了可以获得 XCH 奖励。</p><p>那如何保证 TimeLord 是公平的而不是邪恶的始终选取自己的 plots file 呢？这就是由 Chia 的 PoST 算法决定的了。离 Challenge 越近（越优）的 PoSpace 会使得 TimeLord 计算 VDF 的速度越快。系统中不止有一个 TimeLord，而是有很多 TimeLord 在互相竞争，哪个 TimeLoad 先计算完成 VDF 成功打包区块，那整个链就会沿此区块继续延伸，其他在计算同一高度区块的 TimeLord 就会失败。</p><p>此过程与传统 Bitcoin 的运行模式基本一模一样，可以猜想，对于分支情况的处理也应该和比特币基本相同。然而一个显著区别是，Bitcoin 奖励的是矿工，即最终成功生成新区块的参与者，而在 Chia 中，TimeLord 是没有任何奖励的，完全是自愿劳动:) 被奖励的是 Farmer。</p><p>那无偿劳动为啥有人来干呢？根据某个 Chia 核心开发人员的说法是，当 TimeLord 好处多多，大家都会争着来干的，最显著的好处是，自己部署一个 TimeLord 与自己的 Harvester 离得近网络延迟小，避免自己由于网络延迟太大而成为炮灰。即由于网络延迟导致自己的 PoSpace 很久之后才被送到某个遥远的 TimeLord 上，导致根本没有机会被打包到区块中，即使自己的 PoSpace 比其他人更优。</p><p>TimeLord 是 CPU 密集型任务，目前的开源实现强制要求运行平台支持 AVX512-IFMA 指令集。如果某个 TimeLord 的运行速度能压倒性的快于其他 TimeLord，那它理论上是可以凭借算力而非磁盘空间来控制整个链的，因此按照 Chia 开发者的说法，要把运行得最快的 TimeLord 算法开源出来，而且使得 ASIC 的运算速度没法超过通用 CPU，这样才能避免邪恶 TimeLord 的出现。</p><h3 id="Full-Node"><a href="#Full-Node" class="headerlink" title="Full Node"></a>Full Node</h3><p>Full Node 的作用是广播中转各种消息，创建区块，保存和维护历史区块，与系统的其他参与者通信等。不同参与者之间的通信就是靠 Full Node 来完成的。</p><p>Full Node 间的一致性使用的是与比特币一样的 Gossip 协议。</p><h2 id="一些重要算法"><a href="#一些重要算法" class="headerlink" title="一些重要算法"></a>一些重要算法</h2><p>算法部分没有仔细研究，此处更多的是给出一些深入研究的链接。</p><h3 id="PoST-算法"><a href="#PoST-算法" class="headerlink" title="PoST 算法"></a>PoST 算法</h3><p>Chia 最重要的算法当然要数 PoST 算法了，PoST 算法是由两部分构成的，PoSpace + VDF。</p><p><a target="_blank" rel="noopener" href="https://www.chia.net/assets/Chia_Proof_of_Space_Construction_v1.1.pdf">PoSpace 的文档</a></p><p><a target="_blank" rel="noopener" href="https://eprint.iacr.org/2018/712.pdf">VDF 的文档</a></p><p>为什么只有 PoSpace 是不够的还需要 VDF 呢？因为整个区块链网络是个 P2P 网络，产生一个 Challenge 后需要去收集所有 Farmer 的 Proof，区块链设计的核心哲学就是没有邪恶的中心节点，那怎么确定哪个 Proof 是最优的呢？如果这个判断进行得很快，比如简单的比比差值，那所有的 TimeLoad 都可以马上宣称某个 Proof 为最优，此时区块如何增长就完全不可控了，所以 PoT 也是必不可少的。需要通过计算 VDF 的过程让全网能够就哪个 Proof 是最优的达成共识。</p><h3 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h3><p>一致性协议中主要介绍的是链的延伸过程，在 Chia 的绿皮书中对此有说明，不过目前有一份更新的 Google Doc:</p><p><a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1tmRIb7lgi4QfKkNaxuKOBHRmwbVlGL4f7EsBDr_5xZE/edit">Chia Consensus Algorithm</a></p><h3 id="签名算法"><a href="#签名算法" class="headerlink" title="签名算法"></a>签名算法</h3><p>所有区块链技术的最底层基石都是密码学，特别是各种数字签名技术。Chia 中签名用的算法是 BLS12-381。</p><p>BLS 算法是 2003 年由斯坦福大学的 Dan <strong>B</strong>oneh，Ben <strong>L</strong>ynn 以及 Hovav <strong>S</strong>hacham 提出的一种基于 ECC 的数字签名算法，和 ECDSA 的用处是一样的。该方案是一个基于双线性映射且具有唯一确定性的签名方案。BLS的主要思想是待签名的消息散列到一个椭圆曲线上的一个点，并利用双线性映射 e 函数的交换性质，在不泄露私钥的情况下，验证签名。BLS的算法在签名合并，多签，m/n 多签有丰富的应用。</p><p>而 BLS12-381 则一种具体的 BLS 签名算法，此算法由 Sean Bowe 于 2017 年提出，最早被用于一个叫 Zcash 的数字货币项目中，现在不少其他区块链项目也用了此算法。</p><p>在 Chia 的实现中需要用到不止一对密钥，比如钱包的密钥，Farmer 用的农民密钥等。这些密钥不是独立的，而是由一个主私钥通过私钥派生算法得到的，对于 BLS12-381 算法来说怎么生成这些密钥可以参考这个：</p><p><a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-2333">EIP-2333: BLS12-381 Key Generation</a></p><p>至于主私钥怎么来的呢，第一次启动 Chia 客户端时会创建一个由 24 个单词组成的助记词，这些助记词就是用来生成主私钥的。</p><p>Plotting 时会生成一个随机主私钥，通过它可以派生出一个本地私钥，这个本地私钥又可以导出一个本地公钥，最终，本地公钥与农民公钥（Farmer Public Key）融合，生成了绘图公钥（Plot Public Key），最后矿池公钥（Pool Public Key）和绘图公钥（Plot Public Key）会被组合到一起，并进行一次哈希，哈希的结果被称为绘图 ID（Plot ID）。</p><p>上述提及的绘图 ID，随机主私钥，农民公钥与矿池公钥均会被记录到 Plots file 的 Header 中。</p><p>生成区块时，需要用与 Plot file 匹配的矿池私钥（Pool Private Key）进行一次签名。</p><h2 id="开源项目代码结构"><a href="#开源项目代码结构" class="headerlink" title="开源项目代码结构"></a>开源项目代码结构</h2><p>Chia 的业务逻辑，网络，一致性算法等是用 Python 写的，即 <a target="_blank" rel="noopener" href="https://github.com/Chia-Network/chia-blockchain">chia-blockchain</a> 这个项目。这个项目也被视为 Chia 的主项目在 GitHub 上获得了最多的 Star。最终各平台上能运行的完整的程序也是在这个项目中发布 Release 版本的。</p><p>至于 GUI 部分是基于 Electron 开发的，对应项目为 <a target="_blank" rel="noopener" href="https://github.com/Chia-Network/chia-blockchain-gui">chia-blockchain-gui</a>。</p><p>核心的 PoST 算法则是 C++ 写的，分为两个项目：</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/Chia-Network/chiapos">chiapos</a>，PoSpace 相关代码，包括 Plots file 的生成及验证；</li><li><a target="_blank" rel="noopener" href="https://github.com/Chia-Network/chiavdf">chiavdf</a>，TimeLord 上运行的 VDF 算法。</li></ul><p>Chia 中使用的 BLS12-381 数字签名算法的实现为：<a target="_blank" rel="noopener" href="https://github.com/Chia-Network/bls-signatures">bls-signatures</a></p><p>此外 Chia 还开发了一个叫 Chialisp 的智能合约语言，相关项目有：</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/Chia-Network/clvm">clvm</a>，用 Python 写的 Chialisp 虚拟机；</li><li><a target="_blank" rel="noopener" href="https://github.com/Chia-Network/clvm_rs">clvm-rs</a>，用 Rust 写的 Chialisp 虚拟机；</li><li><a target="_blank" rel="noopener" href="https://github.com/Chia-Network/clvm_tools">clvm_tools</a>，一些支持工具。</li></ul><blockquote><p>参考资料：</p><p><a target="_blank" rel="noopener" href="https://dgideas.net/2021/hard-drive-crisis-the-principles-and-technical-details-behind-chia-mining-i/">硬盘危机——Chia 挖矿背后的原理与技术细节（一）</a></p><p><a target="_blank" rel="noopener" href="https://www.chia.net/assets/ChiaGreenPaper.pdf">Chia Green Paper</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366400067">Chia挖矿：深入浅出聊P盘（绘图 Plots）</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Chia（起亚） 是最近极为火热的数字货币项目，对应的货币叫做 Chia Coin，简称 XCH。其核心算法为 PoST（Proof of Space and Time），以替代比特币中的 PoW（Proof of Work）。&lt;/p&gt;
&lt;p&gt;使用 PoSpace 空间证明而非 PoW 工作量证明是 Chia 项目宣称的最大优点。据他们的开发者宣称，PoW 耗费太多能源了，不环保，我们来搞点更环保的东西吧，不用 PoW 了，改用 PoSpace，即谁有的硬盘空间多谁的投票权就更大。因此他们还把通常称为白皮书（White Paper）的文档改名叫做绿皮书（Green Paper）。&lt;/p&gt;
&lt;p&gt;然而仔细想想这哪里环保了，把一堆硬盘搞来塞满毫无意义的数据比比特币矿机还要更邪恶吧……Chia 的官网上还可笑的宣称硬盘更不容易被垄断，因此个人还有小玩家可以更好的入场，简直是更荒谬的说法，哪个个人会去囤积一堆存不了有用数据的硬盘？&lt;/p&gt;
&lt;p&gt;IPFS 好歹还可以存一些实际有用的数据，看起来还真能促进下社会发展，至于 Chia 简直是除了圈钱和泡沫看不到任何其他意义。不过抛开实际意义，由于最近也研究了下 Chia 的文档和代码，就单纯的来和大家分享下 Chia 的技术实现吧。&lt;/p&gt;</summary>
    
    
    
    <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
    <category term="Top" scheme="https://gaomf.cn/tags/Top/"/>
    
    <category term="Blockchain" scheme="https://gaomf.cn/tags/Blockchain/"/>
    
    <category term="P2P" scheme="https://gaomf.cn/tags/P2P/"/>
    
    <category term="Cryptography" scheme="https://gaomf.cn/tags/Cryptography/"/>
    
    <category term="Consensus" scheme="https://gaomf.cn/tags/Consensus/"/>
    
    <category term="Storage" scheme="https://gaomf.cn/tags/Storage/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中的 volatile，atomic 及 memory barrier</title>
    <link href="https://gaomf.cn/2020/09/11/Cpp_Volatile_Atomic_Memory_barrier/"/>
    <id>https://gaomf.cn/2020/09/11/Cpp_Volatile_Atomic_Memory_barrier/</id>
    <published>2020-09-11T08:46:28.000Z</published>
    <updated>2021-06-11T13:45:29.549Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 中的 <code>volatile</code> 关键字，<code>std::atomic</code> 变量及手动插入内存屏障指令（Memory Barrier）均是为了避免内存访问过程中出现一些不符合预期的行为。这三者的作用有些相似之处，不过显然它们并不相同，本文就将对这三者的应用场景做一总结。</p><span id="more"></span><p>这三者应用场景的区别可以用一张表来概括：</p><table><thead><tr><th></th><th><code>volatile</code></th><th>Memory Barrier</th><th><code>atomic</code></th></tr></thead><tbody><tr><td>抑制编译器重排</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>抑制编译器优化</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>抑制 CPU 乱序</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td>保证访问原子性</td><td>No</td><td>No</td><td>Yes</td></tr></tbody></table><p>下面来具体看一下每一条。</p><h3 id="抑制编译器重排"><a href="#抑制编译器重排" class="headerlink" title="抑制编译器重排"></a>抑制编译器重排</h3><p>所谓编译器重排，这里是指编译器在生成目标代码的过程中交换没有依赖关系的内存访问顺序的行为。</p><p>比如以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*p_a = a;</span><br><span class="line">b = *p_b;</span><br></pre></td></tr></table></figure><p>编译器<strong>不保证</strong>在最终生成的汇编代码中对 <code>p_a</code> 内存的写入在对 <code>p_b</code> 内存的读取之前。</p><p>如果这个顺序是有意义的，就需要用一些手段来保证编译器不会进行错误的优化。具体来说可以通过以下三种方式来实现：</p><ul><li>把对应的变量声明为 <code>volatile</code> 的，C++ 标准保证对 <code>volatile</code> 变量间的访问编译器不会进行重排，不过仅仅是  <code>volatile</code> 变量之间， <code>volatile</code> 变量和其他变量间还是有可能会重排的；</li><li>在需要的地方手动添加合适的 Memory Barrier 指令，Memory Barrier 指令的语义保证了编译器不会进行错误的重排操作；</li><li>把对应变量声明为 <code>atomic</code> 的， 与 <code>volatile</code> 类似，C++ 标准也保证 <code>atomic</code> 变量间的访问编译器不会进行重排。不过 C++ 中不存在所谓的 “atomic pointer” 这种东西，如果需要对某个确定的地址进行 atomic 操作，需要靠一些技巧性的手段来实现，比如在那个地址上进行 placement new 操作强制生成一个 <code>atomic</code> 等；</li></ul><h3 id="抑制编译器优化"><a href="#抑制编译器优化" class="headerlink" title="抑制编译器优化"></a>抑制编译器优化</h3><p>此处的编译器优化特指编译器不生成其认为无意义的内存访问代码的优化行为，比如如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">    a += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在较高优化级别下对变量 <code>a</code> 的内存访问基本都会被优化掉，<code>f()</code> 生成的汇编代码和一个空函数基本差不多。然而如果对 <code>a</code> 循环若干次的内存访问是有意义的，则需要做一些修改来抑制编译器的此优化行为。可以把对应变量声明为 <code>volatile</code> 或 <code>atomic</code> 的来实现此目的，C++ 标准保证对 <code>volatile</code> 或 <code>atomic</code> 内存的访问肯定会发生，不会被优化掉。</p><p>不过需要注意的是，这时候手动添加内存屏障指令是没有意义的，在上述代码的 <code>for</code> 循环中加入 <code>mfence</code> 指令后，仅仅是让循环没有被优化掉，然而每次循环中对变量 <code>a</code> 的赋值依然会被优化掉，结果就是连续执行了 1000 次 <code>mfence</code>。</p><h3 id="抑制-CPU-乱序"><a href="#抑制-CPU-乱序" class="headerlink" title="抑制 CPU 乱序"></a>抑制 CPU 乱序</h3><p>上面说到了编译器重排，那没有了编译器重排内存访问就会严格按照我们代码中的顺序执行了么？非也！现代 CPU 中的诸多特性均会影响这一行为。对于不同架构的 CPU 来说，其保证的内存存储模型是不一样的，比如 x86_64 就是所谓的 TSO（完全存储定序）模型，而很多 ARM 则是 RMO（宽松存储模型）。再加上多核间 Cache 一致性问题，多线程编程时会面临更多的挑战。</p><p>为了解决这些问题，从根本上来说只有通过插入所谓的 Memory Barrier 内存屏障指令来解决，这些指令会使得 CPU 保证特定的内存访问序及内存写入操作在多核间的可见性。然而由于不同处理器架构间的内存模型和具体 Memory Barrier 指令均不相同，需要在什么位置添加哪条指令并不具有通用性，因此 C++ 11 在此基础上做了一层抽象，引入了 <code>atomic</code> 类型及 Memory Order 的概念，有助于写出更通用的代码。从本质上看就是靠编译器来根据代码中指定的高层次 Memory Order 来自动选择是否需要插入特定处理器架构上低层次的内存屏障指令。</p><p>关于 Memory Order，内存模型，内存屏障等东西的原理和具体使用方法网上已经有很多写得不错的文章了，可以参考文末的几篇参考资料。</p><h3 id="保证访问原子性"><a href="#保证访问原子性" class="headerlink" title="保证访问原子性"></a>保证访问原子性</h3><p>所谓访问原子性就是 Read，Write 操作是否存在中间状态，具体如何实现原子性的访问与处理器指令集有很大关系，如果处理器本身就支持某些原子操作指令，如 Atomic Store， Atomic Load，Atomic Fetch Add，Atomic Compare And Swap（CAS）等，那只需要在代码生成时选择合适的指令即可，否则需要依赖锁来实现。C++ 中提供的可移植通用方法就是 <code>std::atomic</code>，<code>volatile</code> 及 Memory Barrier 均与此完全无关。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从上面的比较中可以看出，<code>volatile</code>，<code>atomic</code> 及 Memory Barrier 的适用范围还是比较好区分的。</p><ul><li>如果需要原子性的访问支持，只能选择 <code>atomic</code>；</li><li>如果仅仅只是需要保证内存访问不会被编译器优化掉，优先考虑 <code>volatile</code>；</li><li>如果需要保证 Memory Order，也优先考虑 <code>atomic</code>，只有当不需要保证原子性，而且很明确要在哪插入内存屏障时才考虑手动插入 Memory Barrier。</li></ul><blockquote><p>参考资料：</p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ishen/p/13200838.html">内存模型与c++中的memory order</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43526907">volatile与内存屏障总结</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41872203">X86/GCC memory fence的一些见解</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++ 中的 &lt;code&gt;volatile&lt;/code&gt; 关键字，&lt;code&gt;std::atomic&lt;/code&gt; 变量及手动插入内存屏障指令（Memory Barrier）均是为了避免内存访问过程中出现一些不符合预期的行为。这三者的作用有些相似之处，不过显然它们并不相同，本文就将对这三者的应用场景做一总结。&lt;/p&gt;</summary>
    
    
    
    <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
    <category term="ARM" scheme="https://gaomf.cn/tags/ARM/"/>
    
    <category term="Concurrent" scheme="https://gaomf.cn/tags/Concurrent/"/>
    
    <category term="C++" scheme="https://gaomf.cn/tags/C/"/>
    
    <category term="Compiler" scheme="https://gaomf.cn/tags/Compiler/"/>
    
    <category term="x86" scheme="https://gaomf.cn/tags/x86/"/>
    
  </entry>
  
  <entry>
    <title>动态库全局符号覆盖的大坑</title>
    <link href="https://gaomf.cn/2020/06/03/shared_library_global_symbol_override/"/>
    <id>https://gaomf.cn/2020/06/03/shared_library_global_symbol_override/</id>
    <published>2020-06-03T13:14:18.000Z</published>
    <updated>2021-06-11T13:45:29.578Z</updated>
    
    <content type="html"><![CDATA[<p>今天在调试时发现了一个奇怪的core：<code>double free or corruption (fasttop)</code>，从堆栈看是由于 <code>_dl_fini</code> 函数多次重复释放了某些 STL 容器导致的，此时就算在 <code>main</code> 函数中只保留个简单 <code>return 0</code> 也会出错，因此猜想肯定和某些全局变量有关。后面经过各种修改尝试，终于发现这是由于引用的 <code>.so</code> 动态库和主程序中定义了同名的全局 STL 容器导致的，此时的行为简直就是一个神坑，很有必要记录一下……</p><span id="more"></span><p>先说最终结论吧：</p><ul><li>多个动态库或者是动态库与主程序间可以有同名全局符号，包括全局变量和函数等，此时链接过程是不会出错的。</li><li>这些同名全局符号的地址是<strong>相同的</strong>！</li><li>链接过程中会从前往后依次查找符号，对于 <code>.so</code> 及 <code>.a</code> 来说，如果遇到相同的全局变量是不会报错的，此时 GCC 会默默的选择第一个，这种情况连 Warning 都不会有。这与多个 <code>.o</code> 是不同的，在多个 <code>.o</code> 中定义相同的全局变量无法正常链接。</li><li>以上行为的问题在于，绝大部分情况下各模块期望的行为都是调用自己的全局变量及函数，而不是调用其他模块的，因此大概率会造成运行时的各种异常。</li><li>尤有甚者，若全局变量并不是基本类型而是 <code>class</code>，那虽然此变量只有一个内存地址，然而<strong>其构造与析构函数会被调用多次</strong>，若其中有动态分配的内存，多次 <code>delete</code> 就会导致 <code>double free</code> 异常。</li><li>以上构造与析构行为是通过编译时向 <code>_init()</code> 及 <code>_fini()</code> 中添加 hook 函数实现的，构造顺序是链接顺序，析构顺序是其逆序。前文提到的 <code>_dl_fini()</code> 函数应该是 <code>_fini()</code> 的动态库版本。</li></ul><p>上面这些行为看上去已经很坑了吧，然而这并不是全部……以上行为仅适用于编译时直接指定需要链接库的情况，若是在程序运行过程中使用 <code>dlopen</code> 动态加载 <code>.so</code> 时行为不太一样；若通过 <code>LD_PRELOAD</code> 指定动态库那行为又不一样了……</p><p>使用 <code>dlopen</code> 加载时的行为可以简要归纳如下：</p><ul><li>主程序中的全局符号是<strong>永远都不会</strong>被加载进来的动态库给覆盖的，无论是变量还是函数。这与很多文章中说的不太一样，然而实际使用 GCC 9.3 测试的结果就是如此，估计是较新的 GCC 版本做了什么修改导致的。</li><li>多次调用 <code>dlopen</code> 加载多个动态库，若这些动态库间存在相同的全局符号，则它们之间是<strong>有可能</strong>相互覆盖的，这取决于 <code>dlopen</code> 的 <code>flag</code>。若使用 <code>RTLD_GLOBAL</code>，则后面加载进来的动态库会使用已有的全局符号；若使用 <code>RTLD_LOCAL</code>，则每个动态库间的符号是独立的。</li><li>上述行为中，对应全局变量的构造及析构每次都会进行，也就是后面加载进来的动态库会在之前内存的基础上再来构造一次，退出的时候也会析构多次。</li></ul><p>以上很多行为显然应该都不是预期行为的，那如何解决这些问题呢，大概有这些方法：</p><ul><li>创建 <code>.so</code> 时加上编译选项 <code>-Wl,-Bsymbolic</code>，这会强制采用本地的全局变量定义。</li><li>可以通过 <code>__attribute__ ((visibility(&quot;xxx&quot;)))</code> 来控制符号可见性，并通过编译选项 <code>-fvisibility=xxx</code> 来控制默认符号可见性。</li><li>将不需要导出的全局变量声明为 <code>static</code> 的。</li><li>最根本的做法，<strong>通过 namespace 等手段从根本上避免同名变量及函数的存在</strong>！</li></ul><hr><p>最后给出几个简单测试程序，可以对照着理解上面的各种行为。</p><p><code>my_calss.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   MyClass(<span class="keyword">int</span> a) : a_(a) &#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct! &quot;</span> &lt;&lt; a_ &lt;&lt; <span class="string">&quot; @ &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">     g_fun();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ~MyClass() &#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destruct! &quot;</span> &lt;&lt; a_ &lt;&lt; <span class="string">&quot; @ &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> a_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>my_lib1.cc</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;my_class.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">g_var</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>my_lib2.cc</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;my_class.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">g_var</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>app1.cc</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;my_class.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">g_var</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  g_fun();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>app2.cc</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;my_class.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">g_var</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dlopen(<span class="string">&quot;./libmylib1.so&quot;</span>, RTLD_NOW);</span><br><span class="line">  dlopen(<span class="string">&quot;./libmylib2.so&quot;</span>, RTLD_NOW);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  g_fun();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>app3.cc</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;my_class.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">g_var</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dlopen(<span class="string">&quot;./libmylib1.so&quot;</span>, RTLD_NOW | RTLD_GLOBAL);</span><br><span class="line">  dlopen(<span class="string">&quot;./libmylib2.so&quot;</span>, RTLD_NOW | RTLD_GLOBAL);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  g_fun();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Makefile</code>:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mylib1: my_class.h my_lib1.cc</span></span><br><span class="line">    g++ -fPIC -shared -o libmylib1.so my_lib1.cc</span><br><span class="line"></span><br><span class="line"><span class="section">mylib2: my_class.h my_lib2.cc</span></span><br><span class="line">    g++ -fPIC -shared -o libmylib2.so my_lib2.cc</span><br><span class="line"></span><br><span class="line"><span class="section">app1: app1.cc my_class.h mylib1 mylib2</span></span><br><span class="line">    g++ -L./ -lmylib1 -lmylib2 -o app1 app1.cc</span><br><span class="line"></span><br><span class="line"><span class="section">app2: app2.cc my_class.h</span></span><br><span class="line">    g++ -ldl -o app2 app2.cc</span><br><span class="line"></span><br><span class="line"><span class="section">app3: app3.cc my_class.h</span></span><br><span class="line">    g++ -ldl -o app3 app3.cc</span><br><span class="line"></span><br><span class="line"><span class="section">all: app1 app2 app3</span></span><br></pre></td></tr></table></figure><hr><p>测试程序运行结果为：</p><p><code>app1</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./app1</span></span><br><span class="line">Construct! 2 @ 0x404194</span><br><span class="line">app1.cc:6</span><br><span class="line">Construct! 1 @ 0x404194</span><br><span class="line">app1.cc:6</span><br><span class="line">Construct! 10 @ 0x404194</span><br><span class="line">app1.cc:6</span><br><span class="line">----------</span><br><span class="line">app1.cc:6</span><br><span class="line">----------</span><br><span class="line">Destruct! 10 @ 0x404194</span><br><span class="line">Destruct! 10 @ 0x404194</span><br><span class="line">Destruct! 10 @ 0x404194</span><br></pre></td></tr></table></figure><p><code>app2</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./app2</span></span><br><span class="line">Construct! 12 @ 0x404194</span><br><span class="line">app2.cc:9</span><br><span class="line">Construct! 1 @ 0x7fd81b9f106c</span><br><span class="line">my_lib1.cc:7</span><br><span class="line">Construct! 2 @ 0x7fd81b9ec06c</span><br><span class="line">my_lib2.cc:7</span><br><span class="line">----------</span><br><span class="line">app2.cc:9</span><br><span class="line">----------</span><br><span class="line">Destruct! 2 @ 0x7fd81b9ec06c</span><br><span class="line">Destruct! 1 @ 0x7fd81b9f106c</span><br><span class="line">Destruct! 12 @ 0x404194</span><br></pre></td></tr></table></figure><p><code>app3</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./app3</span></span><br><span class="line">Construct! 12 @ 0x404194</span><br><span class="line">app3.cc:9</span><br><span class="line">Construct! 1 @ 0x7efd3799d06c</span><br><span class="line">my_lib1.cc:7</span><br><span class="line">Construct! 2 @ 0x7efd3799d06c</span><br><span class="line">my_lib1.cc:7</span><br><span class="line">----------</span><br><span class="line">app3.cc:9</span><br><span class="line">----------</span><br><span class="line">Destruct! 2 @ 0x7efd3799d06c</span><br><span class="line">Destruct! 2 @ 0x7efd3799d06c</span><br><span class="line">Destruct! 12 @ 0x404194</span><br></pre></td></tr></table></figure><hr><p>本文只是一个简单的总结，关于此问题的更多深入讨论可以参考以下文章：</p><blockquote><p><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/aix/library/au-aix-symbol-visibility/index.html">控制共享库的符号可见性  第 1 部分 - 符号可见性简介</a><br><a target="_blank" rel="noopener" href="http://kouucocu.lofter.com/post/1cdb8c4b_50f6306">浅谈动态库符号的私有化与全局化</a><br><a target="_blank" rel="noopener" href="http://codemacro.com/2014/11/04/linux-dynamic-library/">linux动态库的种种要点</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36529418">Linux动态链接库so版本兼容</a><br><a target="_blank" rel="noopener" href="http://codemacro.com/2014/09/15/inside-static-library/">浅析静态库链接原理</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/383f9cd4c67e">全局符号</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/suncoolcat/p/3398170.html">Linux下全局符号覆盖问题</a><br><a target="_blank" rel="noopener" href="https://www.technovelty.org/c/what-exactly-does-bsymblic-do.html">What exactly does -Bsymblic do?</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天在调试时发现了一个奇怪的core：&lt;code&gt;double free or corruption (fasttop)&lt;/code&gt;，从堆栈看是由于 &lt;code&gt;_dl_fini&lt;/code&gt; 函数多次重复释放了某些 STL 容器导致的，此时就算在 &lt;code&gt;main&lt;/code&gt; 函数中只保留个简单 &lt;code&gt;return 0&lt;/code&gt; 也会出错，因此猜想肯定和某些全局变量有关。后面经过各种修改尝试，终于发现这是由于引用的 &lt;code&gt;.so&lt;/code&gt; 动态库和主程序中定义了同名的全局 STL 容器导致的，此时的行为简直就是一个神坑，很有必要记录一下……&lt;/p&gt;</summary>
    
    
    
    <category term="软件之道" scheme="https://gaomf.cn/categories/%E8%BD%AF%E4%BB%B6%E4%B9%8B%E9%81%93/"/>
    
    
    <category term="Top" scheme="https://gaomf.cn/tags/Top/"/>
    
    <category term="C++" scheme="https://gaomf.cn/tags/C/"/>
    
    <category term="Compiler" scheme="https://gaomf.cn/tags/Compiler/"/>
    
    <category term="Linux" scheme="https://gaomf.cn/tags/Linux/"/>
    
    <category term="Debug" scheme="https://gaomf.cn/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>如何从 coredump 文件中获取被优化掉的局部变量真实值</title>
    <link href="https://gaomf.cn/2019/12/24/coredump_optimized_value/"/>
    <id>https://gaomf.cn/2019/12/24/coredump_optimized_value/</id>
    <published>2019-12-24T12:56:28.000Z</published>
    <updated>2021-06-11T13:45:29.579Z</updated>
    
    <content type="html"><![CDATA[<p>在 GCC  <code>-O3</code> 优化级别下，很多局部变量是会被优化掉的，此时只能通过人工分析反汇编代码来获取所需信息，而这么做的前提是保存下来的寄存器中的值是准确的。绝大部分情况下 coredump 是由于 segment fault 或 assert 触发的，segment fault 情况下 Kernel 保存下来的 registers 信息是准确的，GDB 中直接用 <code>info registers</code> 就可以看到。然而若是由 assert 触发，由于 assert 会进行多层函数调用后最终执行 <code>raise()</code>，错误现场的寄存器信息是不准确的，这时候就需要一些其他手段来解决此问题。下面用一个具体例子来说明此问题。</p><span id="more"></span><p>测试程序代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> <span class="keyword">final</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b = a + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">final</span> = b;</span><br><span class="line">  <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    assert(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fun(rand()) == <span class="number">1</span>) &#123;</span><br><span class="line">      n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">100000</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此程序肯定会发生 assert failed，我们用 gdb 来看下调用栈：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Program terminated with signal SIGABRT, Aborted.</span><br><span class="line"><span class="meta">#</span><span class="bash">0  0x00007fac9f2f31f7 <span class="keyword">in</span> raise () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">gef&gt;</span><span class="bash"> bt</span></span><br><span class="line"><span class="meta">#</span><span class="bash">0  0x00007fac9f2f31f7 <span class="keyword">in</span> raise () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1  0x00007fac9f2f48e8 <span class="keyword">in</span> abort () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2  0x00007fac9f2ec266 <span class="keyword">in</span> __assert_fail_base () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">3  0x00007fac9f2ec312 <span class="keyword">in</span> __assert_fail () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">4  0x0000000000400d5e <span class="keyword">in</span> fun (a=&lt;optimized out&gt;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">5  main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;)</span></span><br></pre></td></tr></table></figure><p>切换到 <code>fun()</code> 的栈帧：</p><figure class="highlight sh"><figcaption><span>e</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; f 4</span><br><span class="line"><span class="comment">#4  0x0000000000400de0 in fun (a=&lt;optimized out&gt;)</span></span><br><span class="line">245    assert(<span class="literal">false</span>);</span><br><span class="line">gef&gt; p a</span><br><span class="line"><span class="variable">$1</span> = &lt;optimized out&gt;</span><br><span class="line">gef&gt; p b</span><br><span class="line"><span class="variable">$2</span> = &lt;optimized out&gt;</span><br></pre></td></tr></table></figure><p>可以看到 <code>a</code> 与 <code>b</code> 都被优化掉了，到底是哪个值触发了 assert 就不能直接确定了。当然并不是就彻底没办法知道了，来看下 <code>fun()</code> 函数的反汇编：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; disassemble</span><br><span class="line">Dump of assembler code for function main(<span class="keyword">int</span>, char**):</span><br><span class="line">   <span class="number">0x0000000000400d10</span> &lt;+<span class="number">0</span>&gt;:<span class="keyword">push</span>   <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000400d11</span> &lt;+<span class="number">1</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="number">0x186a1</span></span><br><span class="line">   <span class="number">0x0000000000400d16</span> &lt;+<span class="number">6</span>&gt;:<span class="keyword">nop</span>    <span class="built_in">WORD</span> <span class="built_in">PTR</span> <span class="built_in">cs</span>:[<span class="built_in">rax</span>+<span class="built_in">rax</span>*<span class="number">1</span>+<span class="number">0x0</span>]</span><br><span class="line">   <span class="number">0x0000000000400d20</span> &lt;+<span class="number">16</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400c70</span> &lt;rand@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000400d25</span> &lt;+<span class="number">21</span>&gt;:<span class="keyword">lea</span>    <span class="built_in">esi</span>,[<span class="built_in">rax</span>+<span class="number">0x64</span>]</span><br><span class="line">   <span class="number">0x0000000000400d28</span> &lt;+<span class="number">24</span>&gt;:<span class="keyword">test</span>   <span class="built_in">esi</span>,<span class="built_in">esi</span></span><br><span class="line">   <span class="number">0x0000000000400d2a</span> &lt;+<span class="number">26</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rip</span>+<span class="number">0x201570</span>],<span class="built_in">esi</span>        # <span class="number">0x6022a0</span> &lt;final&gt;</span><br><span class="line">   <span class="number">0x0000000000400d30</span> &lt;+<span class="number">32</span>&gt;:<span class="keyword">jg</span>     <span class="number">0x400d45</span> &lt;main(<span class="keyword">int</span>, char**)+<span class="number">53</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000400d32</span> &lt;+<span class="number">34</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edi</span>,<span class="number">0x602080</span></span><br><span class="line">   <span class="number">0x0000000000400d37</span> &lt;+<span class="number">39</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400cd0</span> &lt;_ZNSolsEi@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000400d3c</span> &lt;+<span class="number">44</span>&gt;:<span class="keyword">sub</span>    <span class="built_in">ebx</span>,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x0000000000400d3f</span> &lt;+<span class="number">47</span>&gt;:<span class="keyword">jne</span>    <span class="number">0x400d20</span> &lt;main(<span class="keyword">int</span>, char**)+<span class="number">16</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000400d41</span> &lt;+<span class="number">49</span>&gt;:<span class="keyword">xor</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="number">0x0000000000400d43</span> &lt;+<span class="number">51</span>&gt;:<span class="keyword">pop</span>    <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000400d44</span> &lt;+<span class="number">52</span>&gt;:<span class="keyword">ret</span></span><br><span class="line">   <span class="number">0x0000000000400d45</span> &lt;+<span class="number">53</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="number">0x400fc6</span></span><br><span class="line">   <span class="number">0x0000000000400d4a</span> &lt;+<span class="number">58</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0xf5</span></span><br><span class="line">   <span class="number">0x0000000000400d4f</span> &lt;+<span class="number">63</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">esi</span>,<span class="number">0x400f70</span></span><br><span class="line">   <span class="number">0x0000000000400d54</span> &lt;+<span class="number">68</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edi</span>,<span class="number">0x400fc0</span></span><br><span class="line">   <span class="number">0x0000000000400d59</span> &lt;+<span class="number">73</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400c80</span> &lt;__assert_fail@plt&gt;</span><br></pre></td></tr></table></figure><p>在 <code>-O3</code> 优化下 <code>fun()</code> 直接被内联到 <code>main()</code> 里面了，不过这不影响基本分析，重点关注 <code>&lt;+16&gt;</code> ~ <code>&lt;+32&gt;</code> 这几行，这就对应 <code>fun()</code> 的前几行逻辑，<code>if (b &gt; 0)</code> 是通过 <code>test</code> + <code>jg</code> 来实现的，<code>b</code> 的值此时就是 <code>%esi</code> 寄存器中的值。看下 gdb 分析出来的当前栈帧的寄存器值：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; info registers</span><br><span class="line"><span class="built_in">rax</span>            <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">rbx</span>            <span class="number">0x186a1</span>             <span class="number">0x186a1</span></span><br><span class="line"><span class="built_in">rcx</span>            <span class="number">0x7fac9f2f31f7</span>      <span class="number">0x7fac9f2f31f7</span></span><br><span class="line"><span class="built_in">rdx</span>            <span class="number">0x6</span>                 <span class="number">0x6</span></span><br><span class="line"><span class="built_in">rsi</span>            <span class="number">0x4cc5</span>              <span class="number">0x4cc5</span></span><br><span class="line"><span class="built_in">rdi</span>            <span class="number">0x4cc5</span>              <span class="number">0x4cc5</span></span><br><span class="line"><span class="built_in">rbp</span>            <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">rsp</span>            <span class="number">0x7fff091e0410</span>      <span class="number">0x7fff091e0410</span></span><br><span class="line"><span class="built_in">r8</span>             <span class="number">0x1</span>                 <span class="number">0x1</span></span><br><span class="line"><span class="built_in">r9</span>             <span class="number">0xfeff092d63646b68</span>  <span class="number">0xfeff092d63646b68</span></span><br><span class="line"><span class="built_in">r10</span>            <span class="number">0x8</span>                 <span class="number">0x8</span></span><br><span class="line"><span class="built_in">r11</span>            <span class="number">0x206</span>               <span class="number">0x206</span></span><br><span class="line"><span class="built_in">r12</span>            <span class="number">0x400daf</span>            <span class="number">0x400daf</span></span><br><span class="line"><span class="built_in">r13</span>            <span class="number">0x7fff091e04f0</span>      <span class="number">0x7fff091e04f0</span></span><br><span class="line"><span class="built_in">r14</span>            <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">r15</span>            <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">rip</span>            <span class="number">0x400d5e</span>            <span class="number">0x400d5e</span></span><br><span class="line">eflags         <span class="number">0x206</span>               [ PF IF ]</span><br><span class="line"><span class="built_in">cs</span>             <span class="number">0x33</span>                <span class="number">0x33</span></span><br><span class="line"><span class="built_in">ss</span>             <span class="number">0x2b</span>                <span class="number">0x2b</span></span><br><span class="line"><span class="built_in">ds</span>             <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">es</span>             <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">fs</span>             <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">gs</span>             <span class="number">0x0</span>                 <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>是不是其中 <code>%rsi</code> 的值就是我们需要的 <code>b</code> 了呢？非也！注意到 <code>&lt;+68&gt;</code> 行，在调用 <code>__assert_fail()</code> 前 <code>%esi</code> 又被重新赋值用于传递参数了，且由于 <code>%esi</code> 属于 caller save 的寄存器，在 <code>__assert_fail()</code> 内有可能会被再次改写。因此 <strong>使用 GDB 分析 coredump 文件不同栈帧的 register 信息时，只有为数不多的几个 callee save 寄存器的值是可靠的，其他的都是不可靠的。</strong> 那如何才能得到可靠的寄存器值呢？一般来说只有靠我们自己保存了，一个简单思路是只要在调用 <code>__assert_fail()</code> 前把所有寄存器的值保存到一个全局数组中就可以了。</p><p>在 <code>assert()</code> 前添加如下一段内联汇编代码即可实现此目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(<span class="string">&quot;movq $0, %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%rax, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%rbx, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%rcx, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%rdx, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%rsi, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%rdi, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%rbp, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%rsp, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%r8, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%r9, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%r10, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%r11, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%r12, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%r13, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%r14, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;movq %%r15, (%0, %%r15, 8);\n\t&quot;</span></span><br><span class="line">                     <span class="string">&quot;incq %%r15;\n\t&quot;</span></span><br><span class="line">                        :</span><br><span class="line">                        : <span class="string">&quot;r&quot;</span> (registers_data)</span><br><span class="line">                        : <span class="string">&quot;%r15&quot;</span>);</span><br></pre></td></tr></table></figure><p>再来看下此时的反汇编代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; disassemble</span><br><span class="line">Dump of assembler code for function main(<span class="keyword">int</span>, char**):</span><br><span class="line">   <span class="number">0x0000000000400d10</span> &lt;+<span class="number">0</span>&gt;:<span class="keyword">push</span>   <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d12</span> &lt;+<span class="number">2</span>&gt;:<span class="keyword">push</span>   <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000400d13</span> &lt;+<span class="number">3</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="number">0x186a1</span></span><br><span class="line">   <span class="number">0x0000000000400d18</span> &lt;+<span class="number">8</span>&gt;:<span class="keyword">sub</span>    <span class="built_in">rsp</span>,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x0000000000400d1c</span> &lt;+<span class="number">12</span>&gt;:<span class="keyword">nop</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="number">0x0</span>]</span><br><span class="line">   <span class="number">0x0000000000400d20</span> &lt;+<span class="number">16</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400c70</span> &lt;rand@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000400d25</span> &lt;+<span class="number">21</span>&gt;:<span class="keyword">lea</span>    <span class="built_in">esi</span>,[<span class="built_in">rax</span>+<span class="number">0x64</span>]</span><br><span class="line">   <span class="number">0x0000000000400d28</span> &lt;+<span class="number">24</span>&gt;:<span class="keyword">test</span>   <span class="built_in">esi</span>,<span class="built_in">esi</span></span><br><span class="line">   <span class="number">0x0000000000400d2a</span> &lt;+<span class="number">26</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rip</span>+<span class="number">0x201570</span>],<span class="built_in">esi</span>        # <span class="number">0x6022a0</span> &lt;final&gt;</span><br><span class="line">   <span class="number">0x0000000000400d30</span> &lt;+<span class="number">32</span>&gt;:<span class="keyword">jg</span>     <span class="number">0x400d4b</span> &lt;main(<span class="keyword">int</span>, char**)+<span class="number">59</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000400d32</span> &lt;+<span class="number">34</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edi</span>,<span class="number">0x602080</span></span><br><span class="line">   <span class="number">0x0000000000400d37</span> &lt;+<span class="number">39</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400cd0</span> &lt;_ZNSolsEi@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000400d3c</span> &lt;+<span class="number">44</span>&gt;:<span class="keyword">sub</span>    <span class="built_in">ebx</span>,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x0000000000400d3f</span> &lt;+<span class="number">47</span>&gt;:<span class="keyword">jne</span>    <span class="number">0x400d20</span> &lt;main(<span class="keyword">int</span>, char**)+<span class="number">16</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000400d41</span> &lt;+<span class="number">49</span>&gt;:<span class="keyword">add</span>    <span class="built_in">rsp</span>,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x0000000000400d45</span> &lt;+<span class="number">53</span>&gt;:<span class="keyword">xor</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="number">0x0000000000400d47</span> &lt;+<span class="number">55</span>&gt;:<span class="keyword">pop</span>    <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000400d48</span> &lt;+<span class="number">56</span>&gt;:<span class="keyword">pop</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d4a</span> &lt;+<span class="number">58</span>&gt;:<span class="keyword">ret</span></span><br><span class="line">   <span class="number">0x0000000000400d4b</span> &lt;+<span class="number">59</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x6021a0</span></span><br><span class="line">   <span class="number">0x0000000000400d50</span> &lt;+<span class="number">64</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">r15</span>,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000000000400d57</span> &lt;+<span class="number">71</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x0000000000400d5b</span> &lt;+<span class="number">75</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d5e</span> &lt;+<span class="number">78</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000400d62</span> &lt;+<span class="number">82</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d65</span> &lt;+<span class="number">85</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rcx</span></span><br><span class="line">   <span class="number">0x0000000000400d69</span> &lt;+<span class="number">89</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d6c</span> &lt;+<span class="number">92</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rdx</span></span><br><span class="line">   <span class="number">0x0000000000400d70</span> &lt;+<span class="number">96</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d73</span> &lt;+<span class="number">99</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rsi</span></span><br><span class="line">   <span class="number">0x0000000000400d77</span> &lt;+<span class="number">103</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d7a</span> &lt;+<span class="number">106</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rdi</span></span><br><span class="line">   <span class="number">0x0000000000400d7e</span> &lt;+<span class="number">110</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d81</span> &lt;+<span class="number">113</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rbp</span></span><br><span class="line">   <span class="number">0x0000000000400d85</span> &lt;+<span class="number">117</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d88</span> &lt;+<span class="number">120</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rsp</span></span><br><span class="line">   <span class="number">0x0000000000400d8c</span> &lt;+<span class="number">124</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d8f</span> &lt;+<span class="number">127</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r8</span></span><br><span class="line">   <span class="number">0x0000000000400d93</span> &lt;+<span class="number">131</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d96</span> &lt;+<span class="number">134</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r9</span></span><br><span class="line">   <span class="number">0x0000000000400d9a</span> &lt;+<span class="number">138</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d9d</span> &lt;+<span class="number">141</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r10</span></span><br><span class="line">   <span class="number">0x0000000000400da1</span> &lt;+<span class="number">145</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400da4</span> &lt;+<span class="number">148</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r11</span></span><br><span class="line">   <span class="number">0x0000000000400da8</span> &lt;+<span class="number">152</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400dab</span> &lt;+<span class="number">155</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r12</span></span><br><span class="line">   <span class="number">0x0000000000400daf</span> &lt;+<span class="number">159</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400db2</span> &lt;+<span class="number">162</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r13</span></span><br><span class="line">   <span class="number">0x0000000000400db6</span> &lt;+<span class="number">166</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400db9</span> &lt;+<span class="number">169</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r14</span></span><br><span class="line">   <span class="number">0x0000000000400dbd</span> &lt;+<span class="number">173</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400dc0</span> &lt;+<span class="number">176</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400dc4</span> &lt;+<span class="number">180</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400dc7</span> &lt;+<span class="number">183</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="number">0x4010c6</span></span><br><span class="line">   <span class="number">0x0000000000400dcc</span> &lt;+<span class="number">188</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0xf5</span></span><br><span class="line">   <span class="number">0x0000000000400dd1</span> &lt;+<span class="number">193</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">esi</span>,<span class="number">0x401070</span></span><br><span class="line">   <span class="number">0x0000000000400dd6</span> &lt;+<span class="number">198</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edi</span>,<span class="number">0x4010c0</span></span><br><span class="line">   <span class="number">0x0000000000400ddb</span> &lt;+<span class="number">203</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400c80</span> &lt;__assert_fail@plt&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;+59&gt;</code> ~ <code>&lt;+180&gt;</code> 行就是我们新加的逻辑，可以看到这段代码紧接在 <code>&lt;+32&gt;</code> 行之后，理论上分析的确是可以保存准确的寄存器信息。来看下实际效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gef&gt;</span><span class="bash"> p registers_data</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 = &#123;0x6021a0, 0x186a1, 0x7f872ad260d4, 0x7f872ad260c8, 0x6b8b45cb, 0x7f872ad266e0, 0x0, 0x7ffd6d53a660, 0x7f872ad260c8, 0x7f872ad26140, 0x7ffd6d53a370, 0x7f872a9a38b0, 0x400e2f, 0x7ffd6d53a750, 0x0, 0xf, 0x0 &lt;repeats 16 <span class="built_in">times</span>&gt;&#125;</span></span><br><span class="line"><span class="meta">gef&gt;</span><span class="bash"> p final</span></span><br><span class="line"><span class="meta">$</span><span class="bash">2 = 0x6b8b45cb</span></span><br></pre></td></tr></table></figure><p><code>registers_data[4]</code> 与 <code>final</code> 的值完全相同，而从源代码和反汇编 <code>&lt;+26&gt;</code> 行可以看到，<code>final</code> 中保存的就是 <code>b</code> 的真实值。</p><hr><blockquote><p>参考资料：<br><a target="_blank" rel="noopener" href="https://undo.io/resources/value-optimized-out-reverse-debugging-rescue/">Value optimized out. Reverse debugging to the rescue!</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 GCC  &lt;code&gt;-O3&lt;/code&gt; 优化级别下，很多局部变量是会被优化掉的，此时只能通过人工分析反汇编代码来获取所需信息，而这么做的前提是保存下来的寄存器中的值是准确的。绝大部分情况下 coredump 是由于 segment fault 或 assert 触发的，segment fault 情况下 Kernel 保存下来的 registers 信息是准确的，GDB 中直接用 &lt;code&gt;info registers&lt;/code&gt; 就可以看到。然而若是由 assert 触发，由于 assert 会进行多层函数调用后最终执行 &lt;code&gt;raise()&lt;/code&gt;，错误现场的寄存器信息是不准确的，这时候就需要一些其他手段来解决此问题。下面用一个具体例子来说明此问题。&lt;/p&gt;</summary>
    
    
    
    <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
    <category term="Top" scheme="https://gaomf.cn/tags/Top/"/>
    
    <category term="x86" scheme="https://gaomf.cn/tags/x86/"/>
    
    <category term="Linux" scheme="https://gaomf.cn/tags/Linux/"/>
    
    <category term="Debug" scheme="https://gaomf.cn/tags/Debug/"/>
    
    <category term="GDB" scheme="https://gaomf.cn/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>使用 perf 进行性能分析时如何获取准确的调用栈</title>
    <link href="https://gaomf.cn/2019/10/30/perf_stack_traceback/"/>
    <id>https://gaomf.cn/2019/10/30/perf_stack_traceback/</id>
    <published>2019-10-30T15:09:37.000Z</published>
    <updated>2021-06-11T13:45:29.576Z</updated>
    
    <content type="html"><![CDATA[<p><code>perf</code> 是 Linux 下重要的性能分析工具，<code>perf</code> 可以通过采样获取很多性能指标，其中最常用的是获取 CPU Cycles，即程序各部分代码运行所需的时间，进而确定性能瓶颈在哪。不过在实际使用过程中发现，简单的使用<code>perf record -g</code> 获取到的调用栈是有问题的，存在大量 <code>[Unknown]</code> 函数，从 <code>perf report</code> 的结果来看这些部分对应地址大部分都是非法地址，且生成的火焰图中存在很多明显与代码矛盾的调用关系。</p><span id="more"></span><p>最初怀疑是优化级别的问题，然而尝试使用 <code>Og</code> 或 <code>O0</code> 优化依然存在此问题，仔细阅读 <code>perf record</code> 的手册后发现，<code>perf</code> 同时支持 3 种栈回溯方式：<code>fp</code>, <code>dwarf</code>, <code>lbr</code>，可以通过 <code>--call-graph</code> 参数指定，而 <code>-g</code> 就相当于 <code>--call-graph fp</code>.</p><h3 id="栈回溯方式"><a href="#栈回溯方式" class="headerlink" title="栈回溯方式"></a>栈回溯方式</h3><p> <code>fp</code> 就是 Frame Pointer，即 x86 中的 <code>EBP</code> 寄存器，<code>fp</code> 指向当前栈帧栈底地址，此地址保存着上一栈帧的 <code>EBP</code> 值，具体可参考<a target="_blank" rel="noopener" href="https://www.cs.rutgers.edu/~pxk/419/notes/frames.html">此文章</a>的介绍，根据 <code>fp</code> 就可以逐级回溯调用栈。然而这一特性是会被优化掉的，而且这还是 GCC 的默认行为，在不手动指定 <code> -fno-omit-frame-pointer</code> 时默认都会进行此优化，此时 <code>EBP</code> 被当作一般的通用寄存器使用，以此为依据进行栈回溯显然是错误的。不过尝试指定 <code>-fno-omit-frame-pointer</code> 后依然没法获取到正确的调用栈，根据 GCC 手册的<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">说明</a>，指定了此选项后也并不保证所有函数调用都会使用 <code>fp</code>…… 看来只有放弃使用 <code>fp</code> 进行回溯了。</p><p><code>dwarf</code> 是一种调试文件格式，GCC 编译时附加的 <code>-g</code> 参数生成的就是 <code>dwarf</code> 格式的调试信息，其中包括了栈回溯所需的全部信息，使用 <code>libunwind</code> 即可展开这些信息。<code>dwarf</code> 的进一步介绍可参考 <a target="_blank" rel="noopener" href="http://cwndmiao.github.io/programming%20tools/2013/11/26/Dwarf/">“关于DWARF”</a>，值得一提的是，GDB 进行栈回溯时使用的正是 <code>dwarf</code> 调试信息。实际测试表明使用 <code>dwarf</code> 可以很好的获取到准确的调用栈。</p><p>最后 <code>perf</code> 还支持通过 <code>lbr</code> 获取调用栈，<code>lbr</code> 即 Last Branch Records，是较新的 Intel CPU 中提供的一组硬件寄存器，其作用是记录之前若干次分支跳转的地址，主要目的就是用来支持 <code>perf</code> 这类性能分析工具，其详细说明可参考 <a target="_blank" rel="noopener" href="https://lwn.net/Articles/680985/">“An introduction to last branch records”</a> &amp; <a target="_blank" rel="noopener" href="https://lwn.net/Articles/680996/">“Advanced usage of last branch records”</a>。此方法是性能与准确性最高的手段，然而它存在一个很大的局限性，由于硬件 Ring Buffer 寄存器的大小是有限的，<code>lbr</code> 能记录的栈深度也是有限的，具体值取决于特定 CPU 实现，一般就是 32 层，若超过此限制会得到错误的调用栈。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>实际测试下以上 3 种栈回溯方式得到的结果，测试程序是一个调用深度为 50 的简单程序，从 <code>f0()</code> 依次调用至 <code>f50()</code>。</p><p>**<code>--call-graph fp</code>**：</p><p><img src="https://img.gaomf.cn/perf_test_fp.svg"></p><p>**<code>--call-graph lbr</code>**：</p><p><img src="https://img.gaomf.cn/perf_test_lbr.svg"></p><p>**<code>--call-graph dwarf</code>**：</p><p><img src="https://img.gaomf.cn/perf_test_dwarf.svg"></p><p>可以看到，的确只有 <code>dwarf</code> 获取到了正确的调用栈。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><code>fp</code></td><td>None</td><td>1. 默认 <code>fp</code> 被优化掉了根本不可用。</td></tr><tr><td><code>lbr</code></td><td>1. 高效准确</td><td>1. 需要较新的 Intel CPU 才有此功能；2. 能记录的调用栈深度有限。</td></tr><tr><td><code>dwarf</code></td><td>1. 准确</td><td>1. 开销相对较大；2. 需要编译时附加了调试信息。</td></tr></tbody></table><hr><blockquote><p>参考资料：</p><p><a target="_blank" rel="noopener" href="http://www.brendangregg.com/perf.html">perf Examples</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;perf&lt;/code&gt; 是 Linux 下重要的性能分析工具，&lt;code&gt;perf&lt;/code&gt; 可以通过采样获取很多性能指标，其中最常用的是获取 CPU Cycles，即程序各部分代码运行所需的时间，进而确定性能瓶颈在哪。不过在实际使用过程中发现，简单的使用&lt;code&gt;perf record -g&lt;/code&gt; 获取到的调用栈是有问题的，存在大量 &lt;code&gt;[Unknown]&lt;/code&gt; 函数，从 &lt;code&gt;perf report&lt;/code&gt; 的结果来看这些部分对应地址大部分都是非法地址，且生成的火焰图中存在很多明显与代码矛盾的调用关系。&lt;/p&gt;</summary>
    
    
    
    <category term="工具之术" scheme="https://gaomf.cn/categories/%E5%B7%A5%E5%85%B7%E4%B9%8B%E6%9C%AF/"/>
    
    
    <category term="x86" scheme="https://gaomf.cn/tags/x86/"/>
    
    <category term="Linux" scheme="https://gaomf.cn/tags/Linux/"/>
    
    <category term="Debug" scheme="https://gaomf.cn/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>PVE上部署OpenWRT发生网络中断的解决方法</title>
    <link href="https://gaomf.cn/2019/07/28/PVE_OpenWRT_Network_Broken/"/>
    <id>https://gaomf.cn/2019/07/28/PVE_OpenWRT_Network_Broken/</id>
    <published>2019-07-28T03:27:09.000Z</published>
    <updated>2021-06-11T13:45:29.562Z</updated>
    
    <content type="html"><![CDATA[<p>在旧笔记本上使用Proxmox搭建了一个OpenWRT软路由，正常使用都很稳定，然而当PC使用百度网盘，迅雷等工具进行全速率下载时偶尔会出现网络中断问题，此时Proxmox宿主机的网络会全部断掉，即PVE自己的Web管理界面也无法登录。查看终端，此时会不断打印<code>Detected Hardware Unit Hang</code>的错误提示。</p><span id="more"></span><p>Google一下这个错误提示，还是有不少类似问题的：</p><blockquote><p><a target="_blank" rel="noopener" href="https://jhartman.pl/2018/08/06/proxmox-enp0s31f6-detected-hardware-unit-hang/">Proxmox: enp0s31f6: Detected Hardware Unit Hang</a></p><p><a target="_blank" rel="noopener" href="https://ovear.info/post/356">解决FreeNAS under KVM使用Virtio网卡导致宿主机网卡Hang的问题</a></p><p><a target="_blank" rel="noopener" href="https://serverfault.com/questions/616485/e1000e-reset-adapter-unexpectedly-detected-hardware-unit-hang">e1000e Reset adapter unexpectedly / Detected Hardware Unit Hang</a></p><p><a target="_blank" rel="noopener" href="https://superuser.com/questions/1270723/how-to-fix-eth0-detected-hardware-unit-hang-in-debian-9">How to fix “eth0: Detected Hardware Unit Hang” in Debian 9?</a></p><p><a target="_blank" rel="noopener" href="https://forum.proxmox.com/threads/proxmox-node-freezes.44618/">Proxmox Node freezes</a></p></blockquote><p>基本所有文章都提到此问题与<code>TCP checksum offload</code>特性有关，解决方案就是关掉<code>checksum offload</code>。具体方法是使用<code>ethtool</code>工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -K enp0s25 tx off rx off</span><br></pre></td></tr></table></figure><p>如果要重启后永久生效的话将此命令写入<code>/etc/network/if-up.d/ethtool2</code>文件中并为此文件加上<code>x</code>权限即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">ethtool -K enp0s25 tx off rx off</span><br></pre></td></tr></table></figure><hr><p>除此之外上述第2篇文章的情况和我遇到的很像，里面提到这与<code>Virtio</code>虚拟化有很大关系，而我使用的也正是<code>Vritio</code>，根据作者的说法，更应该在OpenWRT而不是Proxmox中关闭<code>checksum offload</code>。然而实际试了下却发现一个蛋疼的问题，OpenWRT中是无法把<code>tx checksum offload</code>给关掉的……</p><p>此外作者还提到，将网卡的虚拟化方式从<code>Virtio</code>改为<code>E1000</code>也可以解决此问题，不过会有CPU占用率上升的副作用。</p><hr><p>综合以上几种方法，我最后采用的解决办法是：禁用Proxmox宿主机上的<code>TCP checksum offload</code>，并将OpenWRT使用的网卡虚拟化方式改为<code>E1000</code>。实际测试下来没有再发生网卡hang的问题，满速率下载（250Mbps左右）时CPU占用率50%左右，比之前使用<code>Virtio</code>时CPU占用率要高10%左右，还是可以接受的。</p><hr><p>问题算是解决了，最后顺带去进一步学习了下相关的知识，首先是<code>TCP checksum offload</code>，此技术的作用是将计算TCP  checksum的工作由CPU软件实现改为由NIC设备（即网卡等）硬件实现，以此达到节约CPU资源的目的。</p><blockquote><p><a target="_blank" rel="noopener" href="https://www2.cs.duke.edu/ari/trapeze/freenix/node7.html">Checksum Offloading</a></p><p><a target="_blank" rel="noopener" href="https://www.ibm.com/support/knowledgecenter/en/ssw_aix_71/performance/tcp_checksum_offload.html">TCP checksum offload</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_20184565/article/details/82979778">UDP的checksum计算与硬件Offload</a></p></blockquote><p>另外就是<code>Virtio</code>与<code>E1000</code>，这是两种不同的网络虚拟化技术，<code>Virtio</code>是半虚拟化而<code>E1000</code>是全虚拟化。对于全虚拟化方案来说，虚拟机是完全感知不到自己是运行在一个虚拟环境中的；而半虚拟化则是虚拟机知道自己就是运行在一个虚拟环境中，此时IO驱动就可以做一些针对性的修改优化，以此降低虚拟化层进行转换带来的开销及性能损失。显而易见，半虚拟化技术的隔离度是没有全虚拟化好的，而且要是虚拟机驱动有问题会导致宿主机也出问题。这就是为什么在使用<code>Virtio</code>时，OpenWRT网络出现问题会导致整个Proxmox的网络都不能用了的原因。除了这两种虚拟化方式外，还有些更为先进的虚拟化技术，如<code>SR-IVO</code>等，有兴趣的话可以看看下面这篇文章的总结：</p><blockquote><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/xiaoli110/1558984">KVM虚拟化网络优化技术总结</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在旧笔记本上使用Proxmox搭建了一个OpenWRT软路由，正常使用都很稳定，然而当PC使用百度网盘，迅雷等工具进行全速率下载时偶尔会出现网络中断问题，此时Proxmox宿主机的网络会全部断掉，即PVE自己的Web管理界面也无法登录。查看终端，此时会不断打印&lt;code&gt;Detected Hardware Unit Hang&lt;/code&gt;的错误提示。&lt;/p&gt;</summary>
    
    
    
    <category term="工具之术" scheme="https://gaomf.cn/categories/%E5%B7%A5%E5%85%B7%E4%B9%8B%E6%9C%AF/"/>
    
    
    <category term="Network" scheme="https://gaomf.cn/tags/Network/"/>
    
    <category term="Virtualization" scheme="https://gaomf.cn/tags/Virtualization/"/>
    
  </entry>
  
  <entry>
    <title>用于嵌入式车载安全预警的交通标志检测若干关键技术研究与验证</title>
    <link href="https://gaomf.cn/2019/02/24/Thesis_of_Master/"/>
    <id>https://gaomf.cn/2019/02/24/Thesis_of_Master/</id>
    <published>2019-02-24T13:32:12.000Z</published>
    <updated>2021-06-11T13:45:29.584Z</updated>
    
    <content type="html"><![CDATA[<p>转眼间毕业已经要一年了，今天在整理电脑文件的时候翻出了当初写的硕士毕业论文，在知网上搜搜也<a target="_blank" rel="noopener" href="http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201802&filename=1018186759.nh">找得到了</a>。想想硕士期间做过的东西也太杂了，电机控制、Android 开发、嵌入式。。。最后确定了这个毕业论文的题目后只有1年不到的时间可以做了，这期间还要复习准备找工作，不过最后做出来的东西还算是自己基本满意的，这估计也是我在学术上的顶峰了……</p><span id="more"></span><p>为纪念下我离Academy最近的时刻，这里把我这篇论文的摘要及pdf版本的全文贴一下吧。</p><p>全文下载链接：<a target="_blank" rel="noopener" href="https://img.gaomf.cn/%E7%94%A8%E4%BA%8E%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%A6%E8%BD%BD%E5%AE%89%E5%85%A8%E9%A2%84%E8%AD%A6%E7%9A%84%E4%BA%A4%E9%80%9A%E6%A0%87%E5%BF%97%E6%A3%80%E6%B5%8B%E8%8B%A5%E5%B9%B2%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E4%B8%8E%E9%AA%8C%E8%AF%81_%E9%AB%98%E6%98%8E%E9%A3%9E.pdf">用于嵌入式车载安全预警的交通标志检测若干关键技术研究与验证</a></p><p>论文摘要：</p><p>车载安全预警系统可及时为驾驶员提供必要的行车安全预警信息以提高驾驶安全性,其包含若干子系统,如交通标志识别、超速预警等,而交通标志检测则是支撑诸多子系统的重要基础技术之一;本文就针对交通标志检测中基于颜色分割的定位算法及多线程任务调度策略这两项关键技术进行了研究,提出了适用于性能有限嵌入式系统的混合颜色分割策略及混合切换任务调度策略,并通过搭建嵌入式原型样机在实际道路环境中验证了方法的有效性。此外为更好的验证及评估交通标志检测算法的效果,本文建立了中国道路交通标志视频数据集,并将此数据集公开发布以供其他研究人员使用,这也是此领域目前唯一的中国公开数据集。目前主流成熟的交通标志检测定位方法基本均是基于颜色及几何形状局部特征的,本文在此框架下对用于车载安全预警的交通标志检测中最为重要的红色及黄色分割方法展开了深入研究,针对已有主流颜色分割方法的不足提出了混合颜色分割策略,此策略通过若干线性分类器的组合实现了对红色及黄色准确高效的分割,分割效果优于目前常用的各方法且其算法执行速度与最简单的RGB阈值法相似,可保证安全预警算法在性能有限的小型嵌入式车载设备上依然有较好的实时性;在颜色分割基础上本文采用经典的Hough变换实现了对红色圆形交通标志的检测定位并在数据集上评估了算法的效果。本文通过对交通标志检测识别问题进行建模分析提出可用采样间隔时间作为定量衡量此类系统实时性的指标,进而针对目前广泛使用的多核CPU提出了理论最优的理想多线程任务调度算法,此算法可显著降低采样间隔时间以提高系统实时性;不过理想任务调度算法实际无法实现,因此本文进一步提出了实际可实现的混合切换任务调度策略及动态更新参数估计策略;通过控制系统模型数值仿真及实际嵌入式原型样机上的测试验证均表明本文提出的方法可有效优化采样间隔时间分布以此提高系统实时性。本文同时开发了基于Qt的算法验证平台软件及基于Intel Joule模块的嵌入式原型样机,并在其上验证了上述各方法的有效性,最后在校园环境及城市道路上分别进行了静态及动态系统集成测试;测试结果表明本文提出的方法可在小型嵌入式设备上满足系统实时性要求,在天气光照条件较好时检出率也相对较高,不过算法鲁棒性依然需要加强。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;转眼间毕业已经要一年了，今天在整理电脑文件的时候翻出了当初写的硕士毕业论文，在知网上搜搜也&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD201802&amp;filename=1018186759.nh&quot;&gt;找得到了&lt;/a&gt;。想想硕士期间做过的东西也太杂了，电机控制、Android 开发、嵌入式。。。最后确定了这个毕业论文的题目后只有1年不到的时间可以做了，这期间还要复习准备找工作，不过最后做出来的东西还算是自己基本满意的，这估计也是我在学术上的顶峰了……&lt;/p&gt;</summary>
    
    
    
    <category term="科研之路" scheme="https://gaomf.cn/categories/%E7%A7%91%E7%A0%94%E4%B9%8B%E8%B7%AF/"/>
    
    
    <category term="Concurrent" scheme="https://gaomf.cn/tags/Concurrent/"/>
    
    <category term="OpenCV" scheme="https://gaomf.cn/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>深入分析Docker hello-world镜像</title>
    <link href="https://gaomf.cn/2019/02/15/Deep_Into_Dokcer_Helloworld/"/>
    <id>https://gaomf.cn/2019/02/15/Deep_Into_Dokcer_Helloworld/</id>
    <published>2019-02-15T14:46:25.000Z</published>
    <updated>2021-06-12T02:07:20.799Z</updated>
    
    <content type="html"><![CDATA[<p>学习Docker时一般刚开始接触的第一个docker image就是<code>hello-world</code>，这个image运行起来的效果也很简单直接，仅仅是在屏幕上输出一段Docker的使用说明就结束了。这个镜像虽然简单，然而仔细分析下还是涉及不少底层机制的。</p><span id="more"></span><p>我之所以会对这个镜像感兴趣，是发现它的大小仅仅只有1.84kB，这实在是太小了，写一个<code>printf(&quot;Hello Wolrd\n&quot;);</code>的程序编译出来大小就远超1.84kB了，所以很好奇这个镜像是如何构建出来的。</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Docker的镜像构建过程是由其镜像描述文件Dockerfile决定的，所以就先找到其Dockerfile来看看。<code>hello-world</code>用于<code>AMD64</code>架构的Dockerfile可以在<a target="_blank" rel="noopener" href="https://github.com/docker-library/hello-world/blob/b715c35271f1d18832480bde75fe17b93db26414/amd64/hello-world/Dockerfile">Github上</a>找到，只有简单的3行：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hello /</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/hello&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>第1行导入了一个名为<code>scratch</code>的东西，这并不是一个真正的image，可以把它视为是所有image的最底层虚拟镜像，类似于一个基本抽象类，Docker官方对其的说明<a target="_blank" rel="noopener" href="https://hub.docker.com/_/scratch">如下</a>：</p><blockquote><p>This image is most useful in the context of building base images (such as <a target="_blank" rel="noopener" href="https://registry.hub.docker.com/_/debian/"><code>debian</code></a> and <a target="_blank" rel="noopener" href="https://registry.hub.docker.com/_/busybox/"><code>busybox</code></a>) or super minimal images (that contain only a single binary and whatever it requires, such as <a target="_blank" rel="noopener" href="https://registry.hub.docker.com/_/hello-world/"><code>hello-world</code></a>).</p><p>As of Docker 1.5.0 (specifically, <a target="_blank" rel="noopener" href="https://github.com/docker/docker/pull/8827"><code>docker/docker#8827</code></a>), <code>FROM scratch</code> is a no-op in the <code>Dockerfile</code>, and will not create an extra layer in your image (so a previously 2-layer image will be a 1-layer image instead).</p><p>……</p><p>You can use Docker’s reserved, minimal image, <code>scratch</code>, as a starting point for building containers. Using the <code>scratch</code> “image” signals to the build process that you want the next command in the <code>Dockerfile</code> to be the first filesystem layer in your image.</p></blockquote><p>后面两行的含义也很直接，把一个名为hello的程序copy到根目录下，在运行image的时候运行此程序。下面就来看下这个如此小的hello world程序是如何实现的。</p><h2 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h2><p>hello.c文件的源码也在同一个<a target="_blank" rel="noopener" href="https://github.com/docker-library/hello-world/blob/master/hello.c">Github仓库中</a>，省略掉过长的字符串常量后很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> message[] =</span><br><span class="line">    <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">    <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _start() &#123;</span><br><span class="line">    syscall(SYS_write, <span class="number">1</span>, message, <span class="keyword">sizeof</span>(message) - <span class="number">1</span>);</span><br><span class="line">    syscall(SYS_exit, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个最简版本的Hello World和C语言教科书中第一个Hello World是有不小差别的。首先是程序入口点上，众所周知正常C/C++程序的入口点是<code>main()</code>，然而这里使用的是<code>_start()</code>。</p><p>我们的程序是运行在Linux系统上的，程序的加载与运行必然是由OS发起的，<strong>对于Linux来说，OS层面的程序入口点就是<code>_start()</code>而不是<code>main()</code> 函数</strong>，一个程序要能正常运行在<code>main()</code>之前是有一些准备工作要做的，比如建立程序运行环境（初始化.bss全局变量等）；在<code>main()</code>返回之后也有些收尾工作要处理，比如调用<code>exit()</code>通知系统等。这些工作正常情况下是由语言标准库来完成的，也就是所谓的Runtime运行环境，对于C语言来说就是<code>crt0.o</code>。大部分程序的<code>_start()</code>就位于其中，在建立好运行环境后<code>_start()</code>会调用<code>main()</code>跳转到用户定义的入口点处。当<code>main()</code>返回后程序又将回到<code>ctr0.o</code>中，最终调用<code>exit()</code>通知OS回收进程资源。</p><p>这里为了缩小程序体积和简单起见，没有使用标准的<code>ctr0.o</code> Runtime，事实上这一个简单的程序也不需要什么Runtime。程序最后直接通过<code>syscall</code>函数调用了<code>SYS_exit</code>系统调用结束了自身的运行。</p><p>将字符串输出到屏幕上也没有使用标准库中的<code>printf()</code>，同样是直接调用了<code>SYS_write</code>这个系统调用，其第一个参数显式的写为了1，其实就是<code>STDOUT_FILENO</code>，Linux系统在<code>unistd.h</code>中定义了<code>stdin</code>, <code>stdout</code>, <code>stderr</code>这几个标准文件描述符。</p><p>可以看到，这样一个程序是可以不依赖于任何其他的库在Linux上独立运行的，为了实现不链接C标准库的目的，需要使用一些特殊的编译选项。从编译这个<code>hello-world</code>程序使用的<a target="_blank" rel="noopener" href="https://github.com/docker-library/hello-world/blob/master/Makefile">Makefile</a>中可以找到使用的编译选项为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS := -static -Os -nostartfiles -fno-asynchronous-unwind-tables</span><br></pre></td></tr></table></figure><ul><li><code>-static</code>表示静态链接，虽然对这个程序来说无所谓动态链接还是静态链接……</li><li><code>-Os</code>表示为空间进行<code>-O2</code>级别的优化，专门用于减少目标文件大小；</li><li><code>-nostartfiles</code>是关键编译选项，此选项表示不使用标准C语言运行库（即<code>crt0.o</code>），也不链接C标准库；</li><li><code>-fno-asynchronous-unwind-tables</code>选项也是用于减少代码空间的，其大概含义是不产生C++异常处理机制中使用的<code>.eh_frame</code>段，关于什么是<code>unwind-tables</code>和<code>.eh_frame</code>是个比这篇文章复杂多了的问题，文末有几篇参考资料，之后有空可以深入学习下C++的底层机制……</li></ul><p>进行了以上诸多特殊优化处理后，终于可以得到一个只有1k多的可以正常运行于Linux上的Hello World程序了。</p><hr><blockquote><p>参考资料：</p><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/29694564/what-is-the-use-of-start-in-c">What is the use of _start() in C?</a></p><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/43050089/when-is-the-gcc-flag-nostartfiles-used">When is the gcc flag -nostartfiles used?</a></p><p><a target="_blank" rel="noopener" href="https://software.intel.com/en-us/blogs/2013/01/17/x86-gcc-code-size-optimizations">GCC x86 code size optimizations</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/catch/p/3619379.html">c++ 异常处理（2）</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习Docker时一般刚开始接触的第一个docker image就是&lt;code&gt;hello-world&lt;/code&gt;，这个image运行起来的效果也很简单直接，仅仅是在屏幕上输出一段Docker的使用说明就结束了。这个镜像虽然简单，然而仔细分析下还是涉及不少底层机制的。&lt;/p&gt;</summary>
    
    
    
    <category term="软件之道" scheme="https://gaomf.cn/categories/%E8%BD%AF%E4%BB%B6%E4%B9%8B%E9%81%93/"/>
    
    
    <category term="Compiler" scheme="https://gaomf.cn/tags/Compiler/"/>
    
    <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
    <category term="Runtime" scheme="https://gaomf.cn/tags/Runtime/"/>
    
    <category term="Linux" scheme="https://gaomf.cn/tags/Linux/"/>
    
    <category term="Docker" scheme="https://gaomf.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>sudo不需要输入密码的方法</title>
    <link href="https://gaomf.cn/2018/11/17/Sudo_No_Passwd/"/>
    <id>https://gaomf.cn/2018/11/17/Sudo_No_Passwd/</id>
    <published>2018-11-17T09:20:09.000Z</published>
    <updated>2021-06-11T13:45:29.574Z</updated>
    
    <content type="html"><![CDATA[<p>正常情况下，使用<code>sudo</code>命令是需要输入密码的，连续输入多条<code>sudo</code>只用输一次密码就行，不过若干分钟后又需要输入密码了。对于自己使用的本地桌面环境来说，其实是可以配置成<code>sudo</code>免输入密码的，这样可以减少一些麻烦。</p><span id="more"></span><p>以<code>Ubuntu 18.04</code>为例说明设置方法，其他发行版可能会有区别。<code>Ubuntu Desktop</code>默认已经将安装系统时配置的用户加入了<code>admin</code>用户组，且<code>admin</code>用户组中的用户都是有<code>sudo</code>权限的，因此无需修改<code>sudo</code>用户组。若需要将某用户添加到<code>sudo</code>用户组中，可参考文末链接。</p><p>输入<code>su -</code>命令切换到<code>root</code>下，修改<code>/etc/sudoers</code>文件，找到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Allow members of group sudo to execute any command</span></span><br><span class="line">%sudoALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Allow members of group sudo to execute any command</span></span><br><span class="line">%sudoALL=(ALL:ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure><p>即可。</p><p>这样就可以允许<code>sudo</code>用户组中的用户免密码执行<code>sudo</code>命令了。</p><hr><blockquote><p>参考资料：</p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5d02428f313d">免密码使用sudo和su</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;正常情况下，使用&lt;code&gt;sudo&lt;/code&gt;命令是需要输入密码的，连续输入多条&lt;code&gt;sudo&lt;/code&gt;只用输一次密码就行，不过若干分钟后又需要输入密码了。对于自己使用的本地桌面环境来说，其实是可以配置成&lt;code&gt;sudo&lt;/code&gt;免输入密码的，这样可以减少一些麻烦。&lt;/p&gt;</summary>
    
    
    
    <category term="工具之术" scheme="https://gaomf.cn/categories/%E5%B7%A5%E5%85%B7%E4%B9%8B%E6%9C%AF/"/>
    
    
    <category term="Linux" scheme="https://gaomf.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>为Hexo博客Yelee主题添加Gitment评论系统</title>
    <link href="https://gaomf.cn/2018/11/04/Hexo_Yelee_Gitment/"/>
    <id>https://gaomf.cn/2018/11/04/Hexo_Yelee_Gitment/</id>
    <published>2018-11-04T13:36:31.000Z</published>
    <updated>2021-06-12T02:50:49.370Z</updated>
    
    <content type="html"><![CDATA[<p>本来博客使用的是多说作为评论系统，前两年多说停止服务了换成了友言，用了没多久友言又要求备案不能用了……后面由于工作繁忙也就没管这个了。前段时间发现Gitment这个基于Github Issue的评论系统不错，这两天终于有空把它给加上了。</p><span id="more"></span><p>我使用的主题是基于<a target="_blank" rel="noopener" href="https://github.com/MOxFIVE/hexo-theme-yelee">Yelee</a>做了些修改得到的，Yelee又是基于<a target="_blank" rel="noopener" href="https://github.com/litten/hexo-theme-yilia">Yilia</a>的，添加Gitment的过程可以参考这篇文章：</p><blockquote><p><a target="_blank" rel="noopener" href="https://sogrey.github.io/article/Hexo-%E6%B7%BB%E5%8A%A0-Gitment-%E8%AF%84%E8%AE%BA/">Hexo 添加 Gitment 评论</a></p></blockquote><p>Yiila主题也添加了Gitment支持，其<a target="_blank" rel="noopener" href="https://github.com/litten/hexo-theme-yilia/commit/af58957e14a00b3da03e4026c56d34cdf7eda9b4">Commit</a>也是很有参考价值的。</p><p>与以上教程有区别的是，无需安装Gitment npm插件，添加修改的代码我也改了下，有兴趣的话可以看这个<a target="_blank" rel="noopener" href="https://github.com/g199209/BlogTheme/commit/bc591586bd737f0f24a08c54f36f6e10372050c6">Commit</a>。</p><p>其中Gitment的CSS &amp; JS文件改为了本地压缩后的版本，评论框的显示效果也调整了下。</p><p>终于评论系统又可以用啦，之后就该静心学学技术提高下自己的水平了……</p><blockquote><p>Update:</p><p>2021-06-12: Gitment 的 Github OAuth 是依赖于外部服务器的，目前公共的挂得差不多了，需要自己搭一个，参考下文：</p><p><a target="_blank" rel="noopener" href="https://sherry0429.github.io/2019/02/12/gitment%E4%BF%AE%E5%A4%8D/">gitment修复[object ProgressEvent]</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本来博客使用的是多说作为评论系统，前两年多说停止服务了换成了友言，用了没多久友言又要求备案不能用了……后面由于工作繁忙也就没管这个了。前段时间发现Gitment这个基于Github Issue的评论系统不错，这两天终于有空把它给加上了。&lt;/p&gt;</summary>
    
    
    
    <category term="工具之术" scheme="https://gaomf.cn/categories/%E5%B7%A5%E5%85%B7%E4%B9%8B%E6%9C%AF/"/>
    
    
    <category term="Blog" scheme="https://gaomf.cn/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>sizeof 获取 extern 数组长度</title>
    <link href="https://gaomf.cn/2018/06/30/sizeof_extern_array/"/>
    <id>https://gaomf.cn/2018/06/30/sizeof_extern_array/</id>
    <published>2018-06-30T08:52:12.000Z</published>
    <updated>2021-06-11T13:45:29.574Z</updated>
    
    <content type="html"><![CDATA[<p>sizeof是获取数组元素个数的常用运算符，然而前几天使用时发现，对于extern类型的数组，sizeof的使用上是有些需要考虑的问题的。</p><span id="more"></span><p>假设系统中有3个文件：</p><p><code>file1.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p><code>header1.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="built_in">array</span>[];</span><br></pre></td></tr></table></figure><p><code>main.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;header1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This is WRONG!</span></span><br><span class="line">    <span class="keyword">size_t</span> elements_in_array = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>main.c</code>中期望通过<code>sizeof</code>运算符获取<code>array</code>中元素个数，然而这么做是错误的，编译时无法通过，错误提示类似<code>incomplete type not allowed</code>这类。</p><p>造成这一问题的原因在于，**<code>sizeof</code>是在编译时计算的，而C/C++的编译是以文件为基本单位的**。在编译<code>main.c</code>文件时，编译器是不可能知道定义在<code>file1.c</code>文件中<code>array</code>数组具体信息的，只根据<code>header1.h</code>文件中的声明是无法确定<code>array</code>的具体大小的，因此，就算某些编译器编译时不报错，得到的结果也是不正确的。</p><p>分析清楚原因后来看下解决方案，基本解决方法有4种：</p><ol><li>避免使用匿名长度的数组声明，使用宏定义预先确定数组大小；</li><li>定义一个辅助变量用于保存数组大小信息，将其定义赋值放在定义<code>array</code>数组的同一个文件中；</li><li>使用特殊元素表示数组结束，就像字符串结尾的<code>&#39;\0&#39;</code>一样，这样就可以在运行阶段动态确定数组大小；</li><li>将数组的定义放到使用它的源文件中。</li></ol><p>这几种方法都有其缺点：</p><ol><li>使用<code>sizeof</code>就是不想固定数组长度，因为使用宏定义固定数组长度不够灵活，要是想添加数组元素也要同时修改宏定义，否则尽管编译不会报错，然而运行时新添加的元素其实是无效的，这会导致将来维护时一些潜在Bug发生的可能性增加；</li><li>需要一个额外的存储空间，且由于这是一个变量，每次使用数组长度时都需要访问内存，编译器也无法对数组长度作出任何假设，进而影响编译优化，理论上说这可能会导致运行时一些微小的效率损失；</li><li>需要修改上层逻辑，缺乏通用性；</li><li>大部分情况下，使用非<code>static</code>全局变量的原因就是多个源文件需要使用这个变量，这时显然无法做到这一点，多次重复定义链接时会出错的。</li></ol><p>实际使用中，需要根据具体问题具体分析采用哪种方法最恰当，一般而言不经常变化的数组就使用宏定义确定其大小，会经常变化的第2种方法最常用，此时还可以用一些宏定义简化编程，以上代码可修改为：</p><p><code>file1.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;header1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">ELEMENTS_IN_DEF(<span class="built_in">array</span>)</span><br></pre></td></tr></table></figure><p><code>header1.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ELEMENTS_IN(array)            __elements_in_##array</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ELEMENTS_IN_DEF(array)        size_t __elements_in_##array = sizeof(array) / sizeof(array[0]);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ELEMENTS_IN_DECLARE(array)    extern size_t __elements_in_##array;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="built_in">array</span>[];</span><br><span class="line">ELEMENTS_IN_DECLARE(<span class="built_in">array</span>)</span><br></pre></td></tr></table></figure><p><code>main.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;header1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> elements_in_array = ELEMENTS_IN(<span class="built_in">array</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考资料：</p><p><a target="_blank" rel="noopener" href="http://c-faq.com/decl/extarraysize.html">comp.lang.c FAQ list · Question 1.24</a></p><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/23230114/c-how-to-determine-sizeofarray-sizeofstruct-for-external-array">C: How to determine sizeof(array) / sizeof(struct) for external array?</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ranhui_xia/article/details/39502665">sizeof extern数组</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;sizeof是获取数组元素个数的常用运算符，然而前几天使用时发现，对于extern类型的数组，sizeof的使用上是有些需要考虑的问题的。&lt;/p&gt;</summary>
    
    
    
    <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
    <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>多歧路，今安在？</title>
    <link href="https://gaomf.cn/2018/06/03/The_Road/"/>
    <id>https://gaomf.cn/2018/06/03/The_Road/</id>
    <published>2018-06-03T08:59:01.000Z</published>
    <updated>2021-06-11T13:45:29.579Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写博客了，翻看自己的博客，上次更新已是半年多前了，这大半年来忙于找工作，毕业设计，毕业答辩、入职……入职前两个月也是各种忙碌，现在对手头的工作也熟悉一些了，于是乎在低头做事的空暇时也需要抬起头来看看路了。</p><span id="more"></span><p>自从找工作拿到几个Offer可以选择时就开始各种纠结与困惑了，大疆、阿里、Intel、华为、拼多多、乐鑫、网易……有幸能拿到这么些优秀公司的Offer，然而每一家公司都同时有吸引我和令我踌躇的地方，鱼和熊掌终不可兼得，选择也变得十分困难。虽然最终选择了大疆，然而这一选择并不是那么顺理成章，当时在犹豫，本以为选了之后就不会困惑了，现在才发觉，困惑的东西并不会随着时间推移而自然而然的变得清晰起来。</p><p>人生有很多选择，选择和努力哪个更重要呢？这个问题的标准答案在准备面试时都背得滚瓜烂熟了，选择与努力互为因果，选择是为了决定之后努力的方向，努力是为了将来能有更多选择。然而，记住了所谓的标准答案并无济于事，该困惑的时候还是一样困惑。</p><p>其实想想，所有困惑的根源都来自于两点：不知道自己真正想要的是什么；不知道未来会是怎样。</p><p>与其说是不知道自己想要什么，不如说是不知道自己愿意放弃什么，选择之所以困难，是因为选择与放弃总是如影相随的，选择了此就注定要放弃彼。人总是什么都想要的，但事实是我们注定要放弃大多数东西的，人生在不断的做出选择，同时也是在不断放弃。然而，我究竟愿意放弃什么呢？愿意选择什么呢？这并不是那么确定的啊……什么都不想放弃，也就注定什么都无法得到。</p><p>上面那点也许还能随着年岁与阅历的增长思考得越来越清楚，那对未来不可知的迷茫更是让人觉得无能为力。生命的精彩源于不可知，生命的痛苦也源于不可知。时代的洪流滚滚前进，顺之者昌逆之者亡，然而时代的车轮碾向何方又有谁知？</p><p>可供选的路总是越来越少的，我们都终有一日会无路可选，到那时，认命也罢，不认也罢，是非成败转头空，唯余夕阳照青山。在我们还有得可选的时候，还是多想想吧，就算是一条咸鱼也还是要挣扎下看看的。虽然路最终总是越走越窄的，还是要努力下让它窄得不要那么快吧，毕竟啊，谁又能说自己走的一定是那条自己想要同时又不会被时代湮没的道路呢？</p><p>瞎扯了这么多似乎还是多想清楚了那么一丝东西吧，脚踏实地亦要仰望星空，不要让天天加班和生活琐事的忙碌成为一种错觉蒙蔽了双眼。自己的未来何在，尽管想不清还是要去找的吧，在坚信自己找到之前，努力让未来的路宽广一些，努力让自己不要失去有选择的能力，虽然选择是困难和纠结的，然而没选择的走投无路是更大的悲哀。</p><p>然而，要维持像学校里那样站在四通八达的十字路口近乎是不可能完成的事，两条路经常是越来越远的，刚开始时尚有可能跳过去，越到后面越难跳过去了吧。所以啊，还是要尽快想清楚自己想去哪条路上才行啊，然而，谁知道哪时候能想清楚呢……不过在想清楚自己要跳去哪条路上之前，还是要多练练自己跳跃的能力，培养些通用的技能，让自己还是有路可跳有路可选吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;好久没写博客了，翻看自己的博客，上次更新已是半年多前了，这大半年来忙于找工作，毕业设计，毕业答辩、入职……入职前两个月也是各种忙碌，现在对手头的工作也熟悉一些了，于是乎在低头做事的空暇时也需要抬起头来看看路了。&lt;/p&gt;</summary>
    
    
    
    <category term="人生之思" scheme="https://gaomf.cn/categories/%E4%BA%BA%E7%94%9F%E4%B9%8B%E6%80%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>SSH反向穿透访问内网主机</title>
    <link href="https://gaomf.cn/2017/11/04/SSH_Forwarding/"/>
    <id>https://gaomf.cn/2017/11/04/SSH_Forwarding/</id>
    <published>2017-11-03T16:16:00.000Z</published>
    <updated>2021-06-11T13:45:29.564Z</updated>
    
    <content type="html"><![CDATA[<p>学校的网络位于无数重NAT内网中，而且还有各种VPN，所以想要从外网访问十分困难，之前试过各种方法都没成功。今天偶然看到了SSH反向穿透的方法，因为我访问内网服务器主要也是需要SSH连接功能，故此方法可以很好的满足我的需求。此处记录下配置方法。</p><span id="more"></span><p>SSH反向穿透需要有一台有公网IP的服务器作为桥梁，此处将位于多重NAT网络中需要访问的主机称为Target，而将有固定IP的中转服务器称为Server。SSH反向穿透的原理是，Target主动建立与Server间的SSH连接，利用SSH的端口转发功能，将访问Server某端口的数据包转发到Target SSH端口（22端口）上，以此实现间接登陆Target的目的。</p><p>假设Server上的转发端口为<code>6766</code>，使用如下命令在Target上建立与Server间的反向隧道：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 22 -fN -R 6766:localhost:22 userServer@Server</span><br></pre></td></tr></table></figure><p><code>-R</code>用于定义反向隧道，<code>-fN</code>用于在建立SSH连接后SSH进入后台运行。</p><p>之后需要在Server上打开<code>sshd</code>的<code>GatewayPorts</code>功能，这样才能实现只登录一次即可连接上Target。修改<code>/etc/ssh/sshd_config</code>文件，添加下面这行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GatewayPorts clientspecified</span><br></pre></td></tr></table></figure><p>重启<code>sshd</code>服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ssh restart</span><br></pre></td></tr></table></figure><p>此时就可以在任意一个终端上使用<code>ssh -p 6766 userTarget@Server</code>登录到Target上了，需要注意的是，此时使用的用户名、密码、秘钥都应该是Target而不是Server的，只有IP地址或者是域名是Server的。</p><p>最后一个问题是，如何保持这个SSH反向隧道的稳定存在，并且实现若Target意外重启后能自动再次建立此反向隧道。解决方法是使用<code>autossh</code>，并且把它作为一个服务自动启动。</p><p>先安装<code>autossh</code>，之后在<code>/etc/init.d</code>下建立一个名为<code>autossh</code>的文件：（以下操作以Ubuntu为例，其他发行版可能会有区别）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">/usr/bin/autossh -p 22 -M 6777 -fN -R *:6766:localhost:22 userServer@Server -i id_rsa</span><br></pre></td></tr></table></figure><p><code>-M</code>参数指定了一个监控端口，和端口转发无关，使用一个无用的端口即可；<code>-i</code>指定了一个密钥，此处用RSA密钥的方式登陆Server。</p><p>保存此文件，并添加执行权限：<code>chmod +x autossh</code>；注册服务：<code>update-rc.d autossh enable</code>；最后启动服务：<code>service autossh start</code>。</p><p>可使用<code>sysv-rc-conf</code>工具查看<code>autossh</code>服务的开机自启动情况。这样将其作为服务配置好后，就可以实现稳定的SSH反向穿透了，终于可以实现从任何地方自由访问内网主机的目的了~~</p><p>最后顺便提一下，SSH转发其实可以承载其他更多的网络服务，这个之后有空再来研究~</p><hr><blockquote><p>参考资料：<br><a target="_blank" rel="noopener" href="http://network.51cto.com/art/201505/477144.htm">如何通过SSH反向隧道，访问NAT后面的Linux服务器?</a><br><a target="_blank" rel="noopener" href="http://arondight.me/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/">使用SSH反向隧道进行内网穿透</a><br><a target="_blank" rel="noopener" href="https://marshal.ohtly.com/2017/01/26/Reverse-SSH-Tunneling-with-Autossh/">使用autossh实现反向SSH隧道</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/yuanchao99/article/details/9111269">ubuntu service的添加和删除</a><br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/37438630/how-to-use-systemctl-in-ubuntu-14-04">How to use systemctl in Ubuntu 14.04</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;学校的网络位于无数重NAT内网中，而且还有各种VPN，所以想要从外网访问十分困难，之前试过各种方法都没成功。今天偶然看到了SSH反向穿透的方法，因为我访问内网服务器主要也是需要SSH连接功能，故此方法可以很好的满足我的需求。此处记录下配置方法。&lt;/p&gt;</summary>
    
    
    
    <category term="工具之术" scheme="https://gaomf.cn/categories/%E5%B7%A5%E5%85%B7%E4%B9%8B%E6%9C%AF/"/>
    
    
    <category term="Linux" scheme="https://gaomf.cn/tags/Linux/"/>
    
    <category term="Network" scheme="https://gaomf.cn/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>C语言关键词restrict的应用</title>
    <link href="https://gaomf.cn/2017/10/25/C_restrict/"/>
    <id>https://gaomf.cn/2017/10/25/C_restrict/</id>
    <published>2017-10-25T08:22:00.000Z</published>
    <updated>2021-06-11T13:45:29.551Z</updated>
    
    <content type="html"><![CDATA[<p><code>restrict</code>是C99标准中新增的关键词，只能用于修饰指针（函数指针除外），其含义为：<strong>此指针是访问其指向对象的唯一初始方法</strong>。使用此关键词的意义在于：<strong>有助于编译器进行代码优化</strong>。</p><span id="more"></span><p><code>restrict</code>是一个类型限定词，在C99标准(ISO/IEC 9899:1999)的”6.7.3.1 Formal definition of restrict”中给出其定义，基本语法为<code>xxx * restrict var</code>，其中<code>xxx</code>是指针指向的变量类型。需要注意的是，只有指向所谓”object types”的指针才能用<code>restrict</code>修饰，而”object types”的定义应该是除了函数指针外所有类型的指针。另外，对于函数参数来说，由于数组和指针的等价性，函数参数为数组时也可以用<code>restrict</code>修饰，此时<code>restrict</code>放在<code>[]</code>中，如：<code>void fun(int par[restrict])</code>。</p><p>上面也说到，使用<code>restrict</code>的意义在于便于编译器优化，此处使用<code>restrict</code>最常用的一个例子进行说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> * a, <span class="keyword">int</span> * b)</span> </span>&#123;</span><br><span class="line">    *a = <span class="number">5</span>;</span><br><span class="line">    *b = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> *a + *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfoo</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">restrict</span> a, <span class="keyword">int</span> * <span class="keyword">restrict</span> b)</span> </span>&#123;</span><br><span class="line">    *a = <span class="number">5</span>;</span><br><span class="line">    *b = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> *a + *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!---workaround highlight bugs*---><p>对于<code>foo</code>函数，编译器是不能假设<code>a</code>和<code>b</code>指向的区域是不同的，它们有可能指向同一内存区域，故此时编译得到的汇编代码为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movl<span class="number">4</span>(%esp), %eax</span><br><span class="line">movl<span class="number">8</span>(%esp), %edx</span><br><span class="line">movl<span class="number">$5</span>, (%eax)</span><br><span class="line">movl<span class="number">$6</span>, (%edx)</span><br><span class="line">movl(%eax), %eax</span><br><span class="line">addl<span class="number">$6</span>, %eax</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>可以看到，在进行最后一步加法运算前，需要再读一遍<code>*a</code>的值，以保证结果的正确性，因为若<code>a==b</code>的话，此时<code>*a == 6</code>而不是<code>*a == 5</code>；此时这段程序返回的是12而不是11。</p><p>然而，我们如果能确保<code>a != b</code>，那以上代码是可以进一步优化的，<code>restrict</code>关键词就用于把这一信息提供给编译器，此时的<code>rfoo</code>函数编译结果如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movl<span class="number">4</span>(%esp), %eax</span><br><span class="line">movl<span class="number">$5</span>, (%eax)</span><br><span class="line">movl<span class="number">8</span>(%esp), %eax</span><br><span class="line">movl<span class="number">$6</span>, (%eax)</span><br><span class="line">movl<span class="number">$11</span>, %eax</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>这段代码中直接返回了编译器预先计算出来的结果11，与<code>foo</code>相比减少了一次加法运算，且不需要进行<code>movl    (%eax), %eax</code>这一步骤。（虽然由于Cache的存在，这一指令也不一定会进行内存访问）</p><blockquote><p>以上汇编代码使用GCC 4.9.3编译得到，编译参数为：<code>-O3 -S -std=gnu11</code>，结果和参考资料中给出的汇编代码稍有区别，不知为何参数传递使用的是栈而不是寄存器……</p></blockquote><p>从以上例子中可以看到，若一个指针是访问某内存区域的唯一方法，那可以为其加上<code>restrict</code>限定符，这有利于编译器进行代码优化生成效率更高的程序。</p><hr><blockquote><p>参考资料：<br><a target="_blank" rel="noopener" href="http://en.cppreference.com/w/c/language/restrict">restrict type qualifier</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/41653775?sort=created">如何理解C语言关键字restrict？</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovekatherine/article/details/1891806pub">C99中的restrict关键字</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;restrict&lt;/code&gt;是C99标准中新增的关键词，只能用于修饰指针（函数指针除外），其含义为：&lt;strong&gt;此指针是访问其指向对象的唯一初始方法&lt;/strong&gt;。使用此关键词的意义在于：&lt;strong&gt;有助于编译器进行代码优化&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
    <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel中的min和max宏</title>
    <link href="https://gaomf.cn/2017/10/08/Kernel_min_max_macro/"/>
    <id>https://gaomf.cn/2017/10/08/Kernel_min_max_macro/</id>
    <published>2017-10-08T08:38:00.000Z</published>
    <updated>2021-06-11T13:45:29.557Z</updated>
    
    <content type="html"><![CDATA[<p><code>min</code>和<code>max</code>是两个很常用的操作，一般都是用宏实现的，不过想要写出一个很完善的宏定义还是要考虑很多问题的，本文就来分析下Linux Kernel中的实现方法。文中仅考虑<code>min</code>，<code>max</code>的结构与其完全相同，只要修改下大于小于号即可。</p><span id="more"></span><p>宏定义中要将整体和变量都加上括号的意义此处就不多说了，据此我们可以写出一个最基本的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure><p>然而这种写法是有副作用的，考虑<code>min(a++, b)</code>这样的用法，其展开后的形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((a++) &lt; (b) ? (a++) : (b++))</span><br></pre></td></tr></table></figure><p>当<code>a&lt;b</code>时，<code>a++</code>会被执行两次，这显然不是我们所希望的，为了解决这一问题，我们可以使用下面这个稍显复杂的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) (&#123; \</span></span><br><span class="line">    typeof(a) __min1__ = (a);  \</span><br><span class="line">    typeof(b) __min2__ = (b);  \</span><br><span class="line">    (<span class="keyword">void</span>)(&amp;__min1__ == &amp;__min2__);  \</span><br><span class="line">    __min1__ &lt; __min2__ ? __min1__ : __min2__;&#125;)</span><br></pre></td></tr></table></figure><p>这里用到了GCC的一个扩展特性，形如<code>(&#123; ... &#125;)</code>这样的代码块会被视为一条语句，其计算结果是<code>&#123; ... &#125;</code>中最后一条语句的计算结果。故上述宏定义展开后的结果就是第5行返回的结果。注意，这个扩展特性不是所有编译器都有的，如果用VS编译上述代码，是无法通过编译的。<br>这个宏定义中，先根据<code>a</code>, <code>b</code>的类型生成了两个局部变量<code>__min1__</code>和<code>__min2__</code>，之后比较其大小，返回较小的一个，这样就保证了宏参数只会被执行一次，避免了上述副作用。另外，第4行代码其实是没有实际作用的，其意义在于，若<code>__min1__</code>和<code>__min2__</code>的类型不同，比较其地址时编译器会给出一个Warning，这样可以避免一些潜在的错误发生。</p><p>以上宏定义就是网上普遍流传的Linux Kernel中的实现方法，然而，我实际阅读了当前<code>4.12.7</code>版本的Kernel源代码，发现实际的实现方法要更复杂一些。在引入实际的实现方法前，我们先思考一下以上宏定义还存在什么漏洞。</p><p>考虑以下代码段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __min1__ = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> __min2__ = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> min_val = min(__min1__--, __min2__++);</span><br></pre></td></tr></table></figure><p>期望得到的结果应该是<code>__min1__ = 9</code>, <code>__min2__ = 21</code>, <code>min_val = 10</code>。然而实际情况是，<code>__min1__ = 10</code>, <code>__min2__ = 20</code>，<code>min_val</code>的值则是不确定的。造成这一结果的原因在于输入参数和宏定义内部使用的局部变量重名了，这样就会导致在宏定义的语句块内，外层同名变量的作用域被内层局部变量的作用域所屏蔽，展开后的代码就成了这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main_val = (&#123;typeof(__min1__--) __min1__ = (__min1__--); <span class="comment">/* 省略 */</span> &#125;)</span><br></pre></td></tr></table></figure><p>这就类似于<code>int a = a</code>这样的语句，执行完后<code>a</code>的值是不确定的，且因为展开后<code>__min1__</code>成了宏体内的局部变量，<code>__min1__--</code>的自减操作对于外层变量来说也是无效的。</p><p>知道问题的原因后解决方法就很清晰了，只要避免重名就可以了，其实上述宏定义中使用<code>__min1__</code>这样的名字也是为了避免重名，然而，靠起特殊的名字这种方法不是那么的优雅，故实际新版的Linux Kernel中使用了编译器产生的唯一名称来解决这一问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Indirect macros required for expanded argument pasting, eg. __LINE__. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___PASTE(a,b) a##b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PASTE(a,b) ___PASTE(a,b)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * min()/max()/clamp() macros that also do</span></span><br><span class="line"><span class="comment"> * strict type-checking.. See the</span></span><br><span class="line"><span class="comment"> * &quot;unnecessary&quot; pointer comparison.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __min(t1, t2, min1, min2, x, y) (&#123;\</span></span><br><span class="line">    t1 min1 = (x);\</span><br><span class="line">    t2 min2 = (y);\</span><br><span class="line">    (<span class="keyword">void</span>) (&amp;min1 == &amp;min2);\</span><br><span class="line">    min1 &lt; min2 ? min1 : min2; &#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(x, y)\</span></span><br><span class="line">    __min(typeof(x), typeof(y),\</span><br><span class="line">          __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),\</span><br><span class="line">          x, y)</span><br></pre></td></tr></table></figure><p>可以看到这是一个多重的宏嵌套结构，主要区别就在于<code>__UNIQUE_ID(min1_)</code>上，<code>__UNIQUE_ID</code>可以生成一个唯一的名字。唯一性是由编译器提供的<code>__COUNTER__</code>宏保证的，这也是GCC的一个扩展，<a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html">GCC文档中</a>对其的说明如下：</p><blockquote><p>This macro expands to sequential integral values starting from 0. In conjunction with the ## operator, this provides a convenient means to generate unique identifiers.</p></blockquote><p>简而言之，<code>__COUNTER__</code>会被展开为一个从0开始的整数，且每次调用后其值都会加一，这也就保证了其唯一性。</p><p>至于<code>__PASTE</code>宏这是用来实现两个token连接的，之所以要两重宏定义和宏的嵌套展开规则有关，可以参考我之前写的<a href="/2017/10/06/C_Macro/">总结文章</a>。调用<code>__UNIQUE_ID(min1_)</code>后产生的就是形如<code>__UNIQUE_ID_min1_0</code>这样的变量名，这就确保了此名称不会和传入变量的名称重复了。当然，我们还是可以通过刻意构造这样一个特殊名称来实现冲突的，只是程序是程序员自己写的，相信也没有程序员这么无聊……故我们只需要保证正常情况下不会发生冲突即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;min&lt;/code&gt;和&lt;code&gt;max&lt;/code&gt;是两个很常用的操作，一般都是用宏实现的，不过想要写出一个很完善的宏定义还是要考虑很多问题的，本文就来分析下Linux Kernel中的实现方法。文中仅考虑&lt;code&gt;min&lt;/code&gt;，&lt;code&gt;max&lt;/code&gt;的结构与其完全相同，只要修改下大于小于号即可。&lt;/p&gt;</summary>
    
    
    
    <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
    <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
    <category term="Kernel" scheme="https://gaomf.cn/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>C语言中typeof的使用</title>
    <link href="https://gaomf.cn/2017/10/07/C_typeof/"/>
    <id>https://gaomf.cn/2017/10/07/C_typeof/</id>
    <published>2017-10-07T12:48:00.000Z</published>
    <updated>2021-06-11T13:45:29.551Z</updated>
    
    <content type="html"><![CDATA[<p><code>typeof</code>不是C语言本身的关键词或运算符（<code>sizeof</code>是C标准定义的运算符），它是GCC的一个扩展，作用正如其字面意思，<strong>用某种已有东西（变量、函数等）的类型去定义新的变量类型</strong>。</p><span id="more"></span><p><code>typeof</code>通常用于宏定义中，一些示例用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typeof(var)</span><br><span class="line">typeof(a[<span class="number">0</span>])</span><br><span class="line">typeof(<span class="keyword">int</span> *)</span><br><span class="line">typeof(fun())</span><br></pre></td></tr></table></figure><p>可以看到，<code>typeof()</code>中可以是任何有类型的东西，变量就是其本身的类型，函数是它返回值的类型。<code>typeof</code>一般用于声明变量，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof(a) var;</span><br></pre></td></tr></table></figure><p>不过，这也不是绝对的，从语法上来说，所有可以出现基本类型关键词的地方都可以使用<code>typeof</code>，比如<code>sizeof(typeof(a))</code>这样的用法，虽然这里的<code>typeof</code>是多余的，不过它是符合语法的。</p><p>再来看一些高级用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">typeof(fun) * fptr;    <span class="comment">// int (*fptr)(int);</span></span><br><span class="line"></span><br><span class="line">typeof(<span class="keyword">int</span> *)a, b;     <span class="comment">// int * a, * b;</span></span><br><span class="line">typeof(<span class="keyword">int</span>) * a, b;    <span class="comment">// int * a, b;</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>typeof</code>还可以用来定义函数指针等，且<code>typeof(int *)a, b</code>是定义了两个指针变量。</p><p>最后指出一些需要注意的问题。<code>typeof()</code>是在编译时处理的，故<strong>其中的表达式在运行时是不会被执行的</strong>，比如<code>typeof(fun())</code>，<code>fun()</code>函数是不会被执行的，<code>typeof</code>只是在编译时分析得到了<code>fun()</code>的返回值而已。<code>typeof</code>还有一些局限性，其中的变量是不能包含存储类说明符的，如<code>static</code>、<code>extern</code>这类都是不行的。</p><hr><blockquote><p>参考资料：<br><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Typeof.html">6.6 Referring to a Type with typeof</a><br><a target="_blank" rel="noopener" href="http://cstriker1407.info/blog/the-gcc-study-notes-typeof/">GCC扩展关键字typeof学习笔记</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt;不是C语言本身的关键词或运算符（&lt;code&gt;sizeof&lt;/code&gt;是C标准定义的运算符），它是GCC的一个扩展，作用正如其字面意思，&lt;strong&gt;用某种已有东西（变量、函数等）的类型去定义新的变量类型&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
    <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>深入理解C语言中宏定义</title>
    <link href="https://gaomf.cn/2017/10/06/C_Macro/"/>
    <id>https://gaomf.cn/2017/10/06/C_Macro/</id>
    <published>2017-10-06T12:15:00.000Z</published>
    <updated>2021-06-11T13:45:29.583Z</updated>
    
    <content type="html"><![CDATA[<p>从本质上看，C语言中的宏定义实现的是一个文本替换的功能，似乎很简单的样子，然而这几天去看了下Linux Kernel源码中的各种宏定义，才发现一个宏定义竟然也可以有如此多的奇技淫巧……于是花了一天时间仔细研究了下宏的相关知识，此处整理总结下。</p><span id="more"></span><p>关于宏，网上有一组写得极好的文章，基本上看完这几篇文章就可以对宏有一个深入的理解了：</p><blockquote><p><a target="_blank" rel="noopener" href="http://feng.zone/2017/05/17/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-1/">宏定义黑魔法-从入门到奇技淫巧 (1) —— 基本概念</a><br><a target="_blank" rel="noopener" href="http://feng.zone/2017/05/18/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-2/">宏定义黑魔法-从入门到奇技淫巧 (2) —— object-like宏的展开</a><br><a target="_blank" rel="noopener" href="http://feng.zone/2017/05/20/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-3/">宏定义黑魔法-从入门到奇技淫巧 (3) —— function-like宏的展开</a><br><a target="_blank" rel="noopener" href="http://feng.zone/2017/05/21/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-4/">宏定义黑魔法-从入门到奇技淫巧 (4) —— 一些宏的高级用法</a><br><a target="_blank" rel="noopener" href="http://feng.zone/2017/05/21/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-5/">宏定义黑魔法-从入门到奇技淫巧 (5) —— 图灵完备</a><br><a target="_blank" rel="noopener" href="http://feng.zone/2017/05/28/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-6/">宏定义黑魔法-从入门到奇技淫巧 (6) —— 宏的一些坑</a></p></blockquote><p>作者的知乎上也有一份<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/feng-yu-yao/posts">相同的备份</a>。</p><p>相同的内容此处就不再重复了，此处列出一些要点。</p><ul><li>带参数的宏中可以使用两个特殊运算符，<code>#</code>(Stringification Operator)和<code>##</code>(Token Pasting Operator)，作用分别是把宏参数变为字符串字面量和连接两个token。且遇到这两个运算符时，宏参数不会展开。</li><li>宏的嵌套展开过程中，已展开过的宏不会重复展开。</li><li>宏展开后，会进一步检查是否构成了新的宏，若构成了会进一步展开。</li><li>宏定义中也可以使用<code>...</code>代表可变参数，用<code>__VA_ARGS__</code>获取可变参数列表。</li><li>宏参数会先展开，之后再进行替换，这也被称为”prescan”.</li><li>宏基本上是图灵完备的，所以可以只靠宏实现各种东西……</li></ul><p>宏的展开过程遵循以下流程图：</p><p><img src="https://img.gaomf.cn/Macro_Expand3.svg"></p><p>这个流程图是我根据自己的理解和实验画出来的，并不确定完全正确……图中的“已展开宏记录”就是文章中说的“蓝色列表”。</p><p>使用gcc编译时，可以通过附加<code>-E</code>参数，让gcc只进行预处理，这样就可以看到各种宏实际展开出来的结果是什么了，如<code>gcc -E -o test.i test.c</code>命令对<code>test.c</code>文件进行预处理，生成<code>test.i</code>文件。</p><p>关于宏的展开流程，有一些不太明确的地方，此处用例子说明下，结果都经过gcc预处理验证过。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M K(P)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K(a) a a ## a a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PP 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO(a) #a a</span></span><br><span class="line"></span><br><span class="line">FOO(M)--&gt;  FOO(K(P))</span><br><span class="line">        --&gt;  FOO(<span class="number">2</span> PP <span class="number">2</span>)</span><br><span class="line">        --&gt;  FOO(<span class="number">2</span> <span class="number">11</span> <span class="number">2</span>)</span><br><span class="line">        --&gt;  <span class="string">&quot;M&quot;</span> <span class="number">2</span> <span class="number">11</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>遇到<code>#</code>或<code>##</code>时，其相连的宏参数不会展开，然而这不意味着这个宏参数本身不会展开，其他部分用到这个宏参数的地方还是会展开的。</p><p>另外，<code>#</code>运算符后必须是一个宏参数，不能是其他东西，不过<code>##</code>两端则无这一要求，来看个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(a)  #a a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PP(a) #a a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAT(a) P ## P(P##a(a))</span></span><br><span class="line"></span><br><span class="line">CAT(P)--&gt;  PP(PP(P))</span><br><span class="line">        --&gt;  PP(<span class="string">&quot;P&quot;</span> P)</span><br><span class="line">        --&gt;  <span class="string">&quot;PP(P)&quot;</span> <span class="string">&quot;P&quot;</span> P</span><br><span class="line"></span><br><span class="line">CAT(A)--&gt;  PP(PA(A))</span><br><span class="line">        --&gt;  <span class="string">&quot;PA(A)&quot;</span> PA(A)</span><br></pre></td></tr></table></figure><p>可以看到，<code>##</code>两端可以是任意token，其作用就是把这两个token合成一个。另外，还可以看到，<code>##</code>是在最开始就进行处理的，所以<code>P(a)</code>这个宏是没有用到的。另外，由<code>##</code>操作符组合产生的新宏是会继续展开的，并不像某些文章说的那样会停止展开。</p><hr><p>关于多次扫描展开的问题，有些文章中说的是展开完成后会重新扫描一遍当前字符串，若有可以继续展开的则继续展开，然而实际测试下来并不是这样的。还是来看个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BRACKET ()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATE(a, b)  a ## b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO() 123</span></span><br><span class="line"></span><br><span class="line">CREATE(F, OO) BRACKET   --&gt;  FOO BRACKET</span><br><span class="line">                        --&gt;  FOO ()</span><br><span class="line"></span><br><span class="line">CREATE(F, OO) ()        --&gt;  FOO ()</span><br><span class="line">                        --&gt;  <span class="number">123</span></span><br><span class="line"></span><br><span class="line">FOO BRACKET             --&gt;  FOO ()</span><br></pre></td></tr></table></figure><p>可以看到，第1、3个例子中，展开到<code>FOO ()</code> 之后就没有继续展开下去了，这说明并没有重新扫描字符串这一步，<strong>已经处理过的部分不会再次处理的</strong>。而第2个例子则说明的确是会再展开合并出新的宏来的，故上面的流程图中使用了”向后扫描一个token，形成一个新的字符串”这样的说法。考虑到token是以空白为界划分的，<strong>后面组合出来的新宏只可能是function-like的宏</strong>，所以这样的展开方式是不存在歧义的，不会出现原来的宏被组合成其他宏的情况。</p><p>如果要继续展开上面未能展开的那两个宏，可以再封装一层：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BRACKET ()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATE(a, b)  a ## b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO() 123</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPAND(...) __VA_ARGS__</span></span><br><span class="line"></span><br><span class="line">EXPAND(CREATE(F, OO) BRACKET)--&gt;  EXPAND(FOO())</span><br><span class="line">                                --&gt;  EXPAND(<span class="number">123</span>)</span><br><span class="line">                                --&gt;  <span class="number">123</span></span><br></pre></td></tr></table></figure><p>这里利用的原理是：宏参数会先尽可能展开后再进行替换。</p><hr><p>将宏定义的各种奇技淫巧应用得巅峰造极、神鬼莫测之作就是<a target="_blank" rel="noopener" href="http://www.boost.org/doc/libs/1_65_1/libs/preprocessor/doc/index.html">The Boost Preprocessing library</a>，这是Boost库的一部分，不过和其他部分完全独立，这部分包含了各种数据结构和算法等，而且只有头文件，全部都是宏定义……简直可谓是丧心病狂……Github上有人将这部分独立的代码提取出来了，有兴趣的读者可以去进一步揣摩瞻仰：<a target="_blank" rel="noopener" href="https://github.com/imoldman/boost-preprocessor">boost-preprocessor</a></p><hr><blockquote><p>参考资料：<br><a target="_blank" rel="noopener" href="http://www.cppblog.com/kevinlynx/archive/2008/03/19/44828.html">代码自动生成-宏带来的奇技淫巧</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/jy_95/article/details/45260775">《C标准库》—之&lt;assert.h&gt;实现</a><br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/C_preprocessor">C preprocessor</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;从本质上看，C语言中的宏定义实现的是一个文本替换的功能，似乎很简单的样子，然而这几天去看了下Linux Kernel源码中的各种宏定义，才发现一个宏定义竟然也可以有如此多的奇技淫巧……于是花了一天时间仔细研究了下宏的相关知识，此处整理总结下。&lt;/p&gt;</summary>
    
    
    
    <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
    <category term="Top" scheme="https://gaomf.cn/tags/Top/"/>
    
    <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C语言中的字符串字面量连接</title>
    <link href="https://gaomf.cn/2017/10/05/string_literal_concatenate/"/>
    <id>https://gaomf.cn/2017/10/05/string_literal_concatenate/</id>
    <published>2017-10-05T07:27:00.000Z</published>
    <updated>2021-06-11T13:45:29.551Z</updated>
    
    <content type="html"><![CDATA[<p>字符串字面量(string literal)就是程序代码中出现的<code>&quot;</code>包围的字符串，比如<code>&quot;hello&quot;</code>, <code>&quot;I Love C Language!&quot;</code>这类的。在C语言中，有一个奇技淫巧：<strong>两个相邻的字符串字面量会自动被合并连接为一个</strong>。这里的相邻可以是直接连在一起，也可以是间隔着若干个空白字符。需要指出的是，这个特性是C语言标准所要求的，并不是某个编译器的扩展功能。</p><p>一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello&quot;</span> <span class="string">&quot; World&quot;</span><span class="string">&quot;!&quot;</span>    <span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上代码完全等同于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考资料：<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12120944/how-does-concatenation-of-two-string-literals-work">How does concatenation of two string literals work?</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;字符串字面量(string literal)就是程序代码中出现的&lt;code&gt;&amp;quot;&lt;/code&gt;包围的字符串，比如&lt;code&gt;&amp;quot;hello&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;I Love C Language!&amp;quot;&lt;/code&gt;这类</summary>
      
    
    
    
    <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
    <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>用代码判断栈的增长方向</title>
    <link href="https://gaomf.cn/2017/09/28/Detect_Stack_Direction/"/>
    <id>https://gaomf.cn/2017/09/28/Detect_Stack_Direction/</id>
    <published>2017-09-28T12:23:00.000Z</published>
    <updated>2021-06-11T13:45:29.584Z</updated>
    
    <content type="html"><![CDATA[<p>对于大部分CPU架构和编译器来说，程序的栈空间增长方向都是向下递减的，然而这也不是一定的。我们可以用一小段简单的C语言代码来判断下栈的增长方向。</p><span id="more"></span><p>栈基本都是用于保存局部变量和传递参数，故要判断栈的增长方向就要从这两个方面入手。<a target="_blank" rel="noopener" href="http://www.cnblogs.com/youxin/p/3313288.html">第一篇参考资料</a>中给出了各种思路及其可行性分析，很值得看看，此处直接给出结论：</p><ul><li>一个函数中的局部变量在栈中的顺序是不定的，或者说是由编译器决定的，故不能通过直接比较两个局部变量的地址来判断栈的增长方向；</li><li>函数参数压栈的顺序也是不确定的，虽然一般编译器都是从后向前压栈，然而从前向后也不是绝对不可能；</li><li>连续嵌套调用两个函数时，第一个函数的相关数据会先入栈，之后才是它调用的第二个函数，这一点应该是一个通用成立的结论。</li></ul><p>综上，要判断栈的增长方向，可以通过函数的嵌套调用来进行判断，更优雅一点的方案是使用递归，得到的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>Upward, Downward&#125; Stack_Dir_t;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack_Dir_t <span class="title">detect_stack_dir</span><span class="params">(<span class="keyword">char</span> * p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> local = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;local &gt; p ? Upward : Downward;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> detect_stack_dir(&amp;local);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (detect_stack_dir(<span class="literal">NULL</span>) == Upward)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack Growth Upward!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack Growth Downward!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在绝大多数平台上，我们得到的结果应该都是<code>Stack Growth Downward!</code>。</p><hr><blockquote><p>参考资料：<br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/youxin/p/3313288.html">判断栈和堆的生长方向</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/xkfz007/archive/2012/06/22/2558935.html">栈增长方向与大端/小端问题</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于大部分CPU架构和编译器来说，程序的栈空间增长方向都是向下递减的，然而这也不是一定的。我们可以用一小段简单的C语言代码来判断下栈的增长方向。&lt;/p&gt;</summary>
    
    
    
    <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
    <category term="Compiler" scheme="https://gaomf.cn/tags/Compiler/"/>
    
    <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
  </entry>
  
</feed>

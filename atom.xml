<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>高明飞的博客</title>
  
  <subtitle>澹泊明志，宁静致远</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gaomf.cn/"/>
  <updated>2020-06-03T14:26:07.370Z</updated>
  <id>https://gaomf.cn/</id>
  
  <author>
    <name>码农半亩地</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态库全局符号覆盖的大坑</title>
    <link href="https://gaomf.cn/2020/06/03/shared_library_global_symbol_override/"/>
    <id>https://gaomf.cn/2020/06/03/shared_library_global_symbol_override/</id>
    <published>2020-06-03T13:14:18.000Z</published>
    <updated>2020-06-03T14:26:07.370Z</updated>
    
    <content type="html"><![CDATA[<p>今天在调试时发现了一个奇怪的core：<code>double free or corruption (fasttop)</code>，从堆栈看是由于 <code>_dl_fini</code> 函数多次重复释放了某些 STL 容器导致的，此时就算在 <code>main</code> 函数中只保留个简单 <code>return 0</code> 也会出错，因此猜想肯定和某些全局变量有关。后面经过各种修改尝试，终于发现这是由于引用的 <code>.so</code> 动态库和主程序中定义了同名的全局 STL 容器导致的，此时的行为简直就是一个神坑，很有必要记录一下……</p><a id="more"></a><p>先说最终结论吧：</p><ul><li>多个动态库或者是动态库与主程序间可以有同名全局符号，包括全局变量和函数等，此时链接过程是不会出错的。</li><li>这些同名全局符号的地址是<strong>相同的</strong>！</li><li>链接过程中会从前往后依次查找符号，对于 <code>.so</code> 及 <code>.a</code> 来说，如果遇到相同的全局变量是不会报错的，此时 GCC 会默默的选择第一个，这种情况连 Warning 都不会有。这与多个 <code>.o</code> 是不同的，在多个 <code>.o</code> 中定义相同的全局变量无法正常链接。</li><li>以上行为的问题在于，绝大部分情况下各模块期望的行为都是调用自己的全局变量及函数，而不是调用其他模块的，因此大概率会造成运行时的各种异常。</li><li>尤有甚者，若全局变量并不是基本类型而是 <code>class</code>，那虽然此变量只有一个内存地址，然而<strong>其构造与析构函数会被调用多次</strong>，若其中有动态分配的内存，多次 <code>delete</code> 就会导致 <code>double free</code> 异常。</li><li>以上构造与析构行为是通过编译时向 <code>_init()</code> 及 <code>_fini()</code> 中添加 hook 函数实现的，构造顺序是链接顺序，析构顺序是其逆序。前文提到的 <code>_dl_fini()</code> 函数应该是 <code>_fini()</code> 的动态库版本。</li></ul><p>上面这些行为看上去已经很坑了吧，然而这并不是全部……以上行为仅适用于编译时直接指定需要链接库的情况，若是在程序运行过程中使用 <code>dlopen</code> 动态加载 <code>.so</code> 时行为不太一样；若通过 <code>LD_PRELOAD</code> 指定动态库那行为又不一样了……</p><p>使用 <code>dlopen</code> 加载时的行为可以简要归纳如下：</p><ul><li>主程序中的全局符号是<strong>永远都不会</strong>被加载进来的动态库给覆盖的，无论是变量还是函数。这与很多文章中说的不太一样，然而实际使用 GCC 9.3 测试的结果就是如此，估计是较新的 GCC 版本做了什么修改导致的。</li><li>多次调用 <code>dlopen</code> 加载多个动态库，若这些动态库间存在相同的全局符号，则它们之间是<strong>有可能</strong>相互覆盖的，这取决于 <code>dlopen</code> 的 <code>flag</code>。若使用 <code>RTLD_GLOBAL</code>，则后面加载进来的动态库会使用已有的全局符号；若使用 <code>RTLD_LOCAL</code>，则每个动态库间的符号是独立的。</li><li>上述行为中，对应全局变量的构造及析构每次都会进行，也就是后面加载进来的动态库会在之前内存的基础上再来构造一次，退出的时候也会析构多次。</li></ul><p>以上很多行为显然应该都不是预期行为的，那如何解决这些问题呢，大概有这些方法：</p><ul><li>创建 <code>.so</code> 时加上编译选项 <code>-Wl,-Bsymbolic</code>，这会强制采用本地的全局变量定义。</li><li>可以通过 <code>__attribute__ ((visibility(&quot;xxx&quot;)))</code> 来控制符号可见性，并通过编译选项 <code>-fvisibility=xxx</code> 来控制默认符号可见性。</li><li>将不需要导出的全局变量声明为 <code>static</code> 的。</li><li>最根本的做法，<strong>通过 namespace 等手段从根本上避免同名变量及函数的存在</strong>！</li></ul><hr><p>最后给出几个简单测试程序，可以对照着理解上面的各种行为。</p><p><code>my_calss.h</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   MyClass(<span class="keyword">int</span> a) : a_(a) &#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Construct! "</span> &lt;&lt; a_ &lt;&lt; <span class="string">" @ "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">     g_fun();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ~MyClass() &#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Destruct! "</span> &lt;&lt; a_ &lt;&lt; <span class="string">" @ "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> a_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>my_lib1.cc</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_class.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">g_var</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>my_lib2.cc</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_class.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">g_var</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>app1.cc</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_class.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">g_var</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  g_fun();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>app2.cc</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_class.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">g_var</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dlopen(<span class="string">"./libmylib1.so"</span>, RTLD_NOW);</span><br><span class="line">  dlopen(<span class="string">"./libmylib2.so"</span>, RTLD_NOW);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  g_fun();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>app3.cc</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_class.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">g_var</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __FILE__ &lt;&lt; <span class="string">":"</span> &lt;&lt; __LINE__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  dlopen(<span class="string">"./libmylib1.so"</span>, RTLD_NOW | RTLD_GLOBAL);</span><br><span class="line">  dlopen(<span class="string">"./libmylib2.so"</span>, RTLD_NOW | RTLD_GLOBAL);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  g_fun();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"----------"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Makefile</code>:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mylib1: my_class.h my_lib1.cc</span></span><br><span class="line">    g++ -fPIC -shared -o libmylib1.so my_lib1.cc</span><br><span class="line"></span><br><span class="line"><span class="section">mylib2: my_class.h my_lib2.cc</span></span><br><span class="line">    g++ -fPIC -shared -o libmylib2.so my_lib2.cc</span><br><span class="line"></span><br><span class="line"><span class="section">app1: app1.cc my_class.h mylib1 mylib2</span></span><br><span class="line">    g++ -L./ -lmylib1 -lmylib2 -o app1 app1.cc</span><br><span class="line"></span><br><span class="line"><span class="section">app2: app2.cc my_class.h</span></span><br><span class="line">    g++ -ldl -o app2 app2.cc</span><br><span class="line"></span><br><span class="line"><span class="section">app3: app3.cc my_class.h</span></span><br><span class="line">    g++ -ldl -o app3 app3.cc</span><br><span class="line"></span><br><span class="line"><span class="section">all: app1 app2 app3</span></span><br></pre></td></tr></table></figure><hr><p>测试程序运行结果为：</p><p><code>app1</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./app1</span></span><br><span class="line">Construct! 2 @ 0x404194</span><br><span class="line">app1.cc:6</span><br><span class="line">Construct! 1 @ 0x404194</span><br><span class="line">app1.cc:6</span><br><span class="line">Construct! 10 @ 0x404194</span><br><span class="line">app1.cc:6</span><br><span class="line">----------</span><br><span class="line">app1.cc:6</span><br><span class="line">----------</span><br><span class="line">Destruct! 10 @ 0x404194</span><br><span class="line">Destruct! 10 @ 0x404194</span><br><span class="line">Destruct! 10 @ 0x404194</span><br></pre></td></tr></table></figure><p><code>app2</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./app2</span></span><br><span class="line">Construct! 12 @ 0x404194</span><br><span class="line">app2.cc:9</span><br><span class="line">Construct! 1 @ 0x7fd81b9f106c</span><br><span class="line">my_lib1.cc:7</span><br><span class="line">Construct! 2 @ 0x7fd81b9ec06c</span><br><span class="line">my_lib2.cc:7</span><br><span class="line">----------</span><br><span class="line">app2.cc:9</span><br><span class="line">----------</span><br><span class="line">Destruct! 2 @ 0x7fd81b9ec06c</span><br><span class="line">Destruct! 1 @ 0x7fd81b9f106c</span><br><span class="line">Destruct! 12 @ 0x404194</span><br></pre></td></tr></table></figure><p><code>app3</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./app3</span></span><br><span class="line">Construct! 12 @ 0x404194</span><br><span class="line">app3.cc:9</span><br><span class="line">Construct! 1 @ 0x7efd3799d06c</span><br><span class="line">my_lib1.cc:7</span><br><span class="line">Construct! 2 @ 0x7efd3799d06c</span><br><span class="line">my_lib1.cc:7</span><br><span class="line">----------</span><br><span class="line">app3.cc:9</span><br><span class="line">----------</span><br><span class="line">Destruct! 2 @ 0x7efd3799d06c</span><br><span class="line">Destruct! 2 @ 0x7efd3799d06c</span><br><span class="line">Destruct! 12 @ 0x404194</span><br></pre></td></tr></table></figure><hr><p>本文只是一个简单的总结，关于此问题的更多深入讨论可以参考以下文章：</p><blockquote><p><a href="https://www.ibm.com/developerworks/cn/aix/library/au-aix-symbol-visibility/index.html" target="_blank" rel="noopener">控制共享库的符号可见性  第 1 部分 - 符号可见性简介</a><br><a href="http://kouucocu.lofter.com/post/1cdb8c4b_50f6306" target="_blank" rel="noopener">浅谈动态库符号的私有化与全局化</a><br><a href="http://codemacro.com/2014/11/04/linux-dynamic-library/" target="_blank" rel="noopener">linux动态库的种种要点</a><br><a href="https://zhuanlan.zhihu.com/p/36529418" target="_blank" rel="noopener">Linux动态链接库so版本兼容</a><br><a href="http://codemacro.com/2014/09/15/inside-static-library/" target="_blank" rel="noopener">浅析静态库链接原理</a><br><a href="https://www.jianshu.com/p/383f9cd4c67e" target="_blank" rel="noopener">全局符号</a><br><a href="https://www.cnblogs.com/suncoolcat/p/3398170.html" target="_blank" rel="noopener">Linux下全局符号覆盖问题</a><br><a href="https://www.technovelty.org/c/what-exactly-does-bsymblic-do.html" target="_blank" rel="noopener">What exactly does -Bsymblic do?</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在调试时发现了一个奇怪的core：&lt;code&gt;double free or corruption (fasttop)&lt;/code&gt;，从堆栈看是由于 &lt;code&gt;_dl_fini&lt;/code&gt; 函数多次重复释放了某些 STL 容器导致的，此时就算在 &lt;code&gt;main&lt;/code&gt; 函数中只保留个简单 &lt;code&gt;return 0&lt;/code&gt; 也会出错，因此猜想肯定和某些全局变量有关。后面经过各种修改尝试，终于发现这是由于引用的 &lt;code&gt;.so&lt;/code&gt; 动态库和主程序中定义了同名的全局 STL 容器导致的，此时的行为简直就是一个神坑，很有必要记录一下……&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件之道" scheme="https://gaomf.cn/categories/%E8%BD%AF%E4%BB%B6%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="Top" scheme="https://gaomf.cn/tags/Top/"/>
    
      <category term="C++" scheme="https://gaomf.cn/tags/C/"/>
    
      <category term="Linux" scheme="https://gaomf.cn/tags/Linux/"/>
    
      <category term="Compiler" scheme="https://gaomf.cn/tags/Compiler/"/>
    
      <category term="Debug" scheme="https://gaomf.cn/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>如何从 coredump 文件中获取被优化掉的局部变量真实值</title>
    <link href="https://gaomf.cn/2019/12/24/coredump_optimized_value/"/>
    <id>https://gaomf.cn/2019/12/24/coredump_optimized_value/</id>
    <published>2019-12-24T12:56:28.000Z</published>
    <updated>2019-12-24T14:05:29.015Z</updated>
    
    <content type="html"><![CDATA[<p>在 GCC  <code>-O3</code> 优化级别下，很多局部变量是会被优化掉的，此时只能通过人工分析反汇编代码来获取所需信息，而这么做的前提是保存下来的寄存器中的值是准确的。绝大部分情况下 coredump 是由于 segment fault 或 assert 触发的，segment fault 情况下 Kernel 保存下来的 registers 信息是准确的，GDB 中直接用 <code>info registers</code> 就可以看到。然而若是由 assert 触发，由于 assert 会进行多层函数调用后最终执行 <code>raise()</code>，错误现场的寄存器信息是不准确的，这时候就需要一些其他手段来解决此问题。下面用一个具体例子来说明此问题。</p><a id="more"></a><p>测试程序代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> final = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b = a + <span class="number">100</span>;</span><br><span class="line">  final = b;</span><br><span class="line">  <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    assert(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fun(rand()) == <span class="number">1</span>) &#123;</span><br><span class="line">      n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">100000</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此程序肯定会发生 assert failed，我们用 gdb 来看下调用栈：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Program terminated with signal SIGABRT, Aborted.</span><br><span class="line"><span class="meta">#</span><span class="bash">0  0x00007fac9f2f31f7 <span class="keyword">in</span> raise () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">gef&gt;</span><span class="bash"> bt</span></span><br><span class="line"><span class="meta">#</span><span class="bash">0  0x00007fac9f2f31f7 <span class="keyword">in</span> raise () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1  0x00007fac9f2f48e8 <span class="keyword">in</span> abort () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">2  0x00007fac9f2ec266 <span class="keyword">in</span> __assert_fail_base () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">3  0x00007fac9f2ec312 <span class="keyword">in</span> __assert_fail () from /lib64/libc.so.6</span></span><br><span class="line"><span class="meta">#</span><span class="bash">4  0x0000000000400d5e <span class="keyword">in</span> fun (a=&lt;optimized out&gt;)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">5  main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;)</span></span><br></pre></td></tr></table></figure><p>切换到 <code>fun()</code> 的栈帧：</p><figure class="highlight sh"><figcaption><span>e</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; f 4</span><br><span class="line"><span class="comment">#4  0x0000000000400de0 in fun (a=&lt;optimized out&gt;)</span></span><br><span class="line">245    assert(<span class="literal">false</span>);</span><br><span class="line">gef&gt; p a</span><br><span class="line"><span class="variable">$1</span> = &lt;optimized out&gt;</span><br><span class="line">gef&gt; p b</span><br><span class="line"><span class="variable">$2</span> = &lt;optimized out&gt;</span><br></pre></td></tr></table></figure><p>可以看到 <code>a</code> 与 <code>b</code> 都被优化掉了，到底是哪个值触发了 assert 就不能直接确定了。当然并不是就彻底没办法知道了，来看下 <code>fun()</code> 函数的反汇编：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; disassemble</span><br><span class="line">Dump of assembler code for function main(<span class="keyword">int</span>, char**):</span><br><span class="line">   <span class="number">0x0000000000400d10</span> &lt;+<span class="number">0</span>&gt;:<span class="keyword">push</span>   <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000400d11</span> &lt;+<span class="number">1</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="number">0x186a1</span></span><br><span class="line">   <span class="number">0x0000000000400d16</span> &lt;+<span class="number">6</span>&gt;:<span class="keyword">nop</span>    <span class="built_in">WORD</span> <span class="built_in">PTR</span> <span class="built_in">cs</span>:[<span class="built_in">rax</span>+<span class="built_in">rax</span>*<span class="number">1</span>+<span class="number">0x0</span>]</span><br><span class="line">   <span class="number">0x0000000000400d20</span> &lt;+<span class="number">16</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400c70</span> &lt;rand@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000400d25</span> &lt;+<span class="number">21</span>&gt;:<span class="keyword">lea</span>    <span class="built_in">esi</span>,[<span class="built_in">rax</span>+<span class="number">0x64</span>]</span><br><span class="line">   <span class="number">0x0000000000400d28</span> &lt;+<span class="number">24</span>&gt;:<span class="keyword">test</span>   <span class="built_in">esi</span>,<span class="built_in">esi</span></span><br><span class="line">   <span class="number">0x0000000000400d2a</span> &lt;+<span class="number">26</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rip</span>+<span class="number">0x201570</span>],<span class="built_in">esi</span>        # <span class="number">0x6022a0</span> &lt;final&gt;</span><br><span class="line">   <span class="number">0x0000000000400d30</span> &lt;+<span class="number">32</span>&gt;:<span class="keyword">jg</span>     <span class="number">0x400d45</span> &lt;main(<span class="keyword">int</span>, char**)+<span class="number">53</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000400d32</span> &lt;+<span class="number">34</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edi</span>,<span class="number">0x602080</span></span><br><span class="line">   <span class="number">0x0000000000400d37</span> &lt;+<span class="number">39</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400cd0</span> &lt;_ZNSolsEi@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000400d3c</span> &lt;+<span class="number">44</span>&gt;:<span class="keyword">sub</span>    <span class="built_in">ebx</span>,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x0000000000400d3f</span> &lt;+<span class="number">47</span>&gt;:<span class="keyword">jne</span>    <span class="number">0x400d20</span> &lt;main(<span class="keyword">int</span>, char**)+<span class="number">16</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000400d41</span> &lt;+<span class="number">49</span>&gt;:<span class="keyword">xor</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="number">0x0000000000400d43</span> &lt;+<span class="number">51</span>&gt;:<span class="keyword">pop</span>    <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000400d44</span> &lt;+<span class="number">52</span>&gt;:<span class="keyword">ret</span></span><br><span class="line">   <span class="number">0x0000000000400d45</span> &lt;+<span class="number">53</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="number">0x400fc6</span></span><br><span class="line">   <span class="number">0x0000000000400d4a</span> &lt;+<span class="number">58</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0xf5</span></span><br><span class="line">   <span class="number">0x0000000000400d4f</span> &lt;+<span class="number">63</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">esi</span>,<span class="number">0x400f70</span></span><br><span class="line">   <span class="number">0x0000000000400d54</span> &lt;+<span class="number">68</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edi</span>,<span class="number">0x400fc0</span></span><br><span class="line">   <span class="number">0x0000000000400d59</span> &lt;+<span class="number">73</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400c80</span> &lt;__assert_fail@plt&gt;</span><br></pre></td></tr></table></figure><p>在 <code>-O3</code> 优化下 <code>fun()</code> 直接被内联到 <code>main()</code> 里面了，不过这不影响基本分析，重点关注 <code>&lt;+16&gt;</code> ~ <code>&lt;+32&gt;</code> 这几行，这就对应 <code>fun()</code> 的前几行逻辑，<code>if (b &gt; 0)</code> 是通过 <code>test</code> + <code>jg</code> 来实现的，<code>b</code> 的值此时就是 <code>%esi</code> 寄存器中的值。看下 gdb 分析出来的当前栈帧的寄存器值：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; info registers</span><br><span class="line"><span class="built_in">rax</span>            <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">rbx</span>            <span class="number">0x186a1</span>             <span class="number">0x186a1</span></span><br><span class="line"><span class="built_in">rcx</span>            <span class="number">0x7fac9f2f31f7</span>      <span class="number">0x7fac9f2f31f7</span></span><br><span class="line"><span class="built_in">rdx</span>            <span class="number">0x6</span>                 <span class="number">0x6</span></span><br><span class="line"><span class="built_in">rsi</span>            <span class="number">0x4cc5</span>              <span class="number">0x4cc5</span></span><br><span class="line"><span class="built_in">rdi</span>            <span class="number">0x4cc5</span>              <span class="number">0x4cc5</span></span><br><span class="line"><span class="built_in">rbp</span>            <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">rsp</span>            <span class="number">0x7fff091e0410</span>      <span class="number">0x7fff091e0410</span></span><br><span class="line"><span class="built_in">r8</span>             <span class="number">0x1</span>                 <span class="number">0x1</span></span><br><span class="line"><span class="built_in">r9</span>             <span class="number">0xfeff092d63646b68</span>  <span class="number">0xfeff092d63646b68</span></span><br><span class="line"><span class="built_in">r10</span>            <span class="number">0x8</span>                 <span class="number">0x8</span></span><br><span class="line"><span class="built_in">r11</span>            <span class="number">0x206</span>               <span class="number">0x206</span></span><br><span class="line"><span class="built_in">r12</span>            <span class="number">0x400daf</span>            <span class="number">0x400daf</span></span><br><span class="line"><span class="built_in">r13</span>            <span class="number">0x7fff091e04f0</span>      <span class="number">0x7fff091e04f0</span></span><br><span class="line"><span class="built_in">r14</span>            <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">r15</span>            <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">rip</span>            <span class="number">0x400d5e</span>            <span class="number">0x400d5e</span></span><br><span class="line">eflags         <span class="number">0x206</span>               [ PF IF ]</span><br><span class="line"><span class="built_in">cs</span>             <span class="number">0x33</span>                <span class="number">0x33</span></span><br><span class="line"><span class="built_in">ss</span>             <span class="number">0x2b</span>                <span class="number">0x2b</span></span><br><span class="line"><span class="built_in">ds</span>             <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">es</span>             <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">fs</span>             <span class="number">0x0</span>                 <span class="number">0x0</span></span><br><span class="line"><span class="built_in">gs</span>             <span class="number">0x0</span>                 <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>是不是其中 <code>%rsi</code> 的值就是我们需要的 <code>b</code> 了呢？非也！注意到 <code>&lt;+68&gt;</code> 行，在调用 <code>__assert_fail()</code> 前 <code>%esi</code> 又被重新赋值用于传递参数了，且由于 <code>%esi</code> 属于 caller save 的寄存器，在 <code>__assert_fail()</code> 内有可能会被再次改写。因此 <strong>使用 GDB 分析 coredump 文件不同栈帧的 register 信息时，只有为数不多的几个 callee save 寄存器的值是可靠的，其他的都是不可靠的。</strong> 那如何才能得到可靠的寄存器值呢？一般来说只有靠我们自己保存了，一个简单思路是只要在调用 <code>__assert_fail()</code> 前把所有寄存器的值保存到一个全局数组中就可以了。</p><p>在 <code>assert()</code> 前添加如下一段内联汇编代码即可实现此目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(<span class="string">"movq $0, %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rax, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rbx, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rcx, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rdx, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rsi, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rdi, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rbp, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%rsp, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r8, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r9, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r10, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r11, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r12, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r13, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r14, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                     <span class="string">"movq %%r15, (%0, %%r15, 8);\n\t"</span></span><br><span class="line">                     <span class="string">"incq %%r15;\n\t"</span></span><br><span class="line">                        :</span><br><span class="line">                        : <span class="string">"r"</span> (registers_data)</span><br><span class="line">                        : <span class="string">"%r15"</span>);</span><br></pre></td></tr></table></figure><p>再来看下此时的反汇编代码：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">gef&gt; disassemble</span><br><span class="line">Dump of assembler code for function main(<span class="keyword">int</span>, char**):</span><br><span class="line">   <span class="number">0x0000000000400d10</span> &lt;+<span class="number">0</span>&gt;:<span class="keyword">push</span>   <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d12</span> &lt;+<span class="number">2</span>&gt;:<span class="keyword">push</span>   <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000400d13</span> &lt;+<span class="number">3</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">ebx</span>,<span class="number">0x186a1</span></span><br><span class="line">   <span class="number">0x0000000000400d18</span> &lt;+<span class="number">8</span>&gt;:<span class="keyword">sub</span>    <span class="built_in">rsp</span>,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x0000000000400d1c</span> &lt;+<span class="number">12</span>&gt;:<span class="keyword">nop</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="number">0x0</span>]</span><br><span class="line">   <span class="number">0x0000000000400d20</span> &lt;+<span class="number">16</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400c70</span> &lt;rand@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000400d25</span> &lt;+<span class="number">21</span>&gt;:<span class="keyword">lea</span>    <span class="built_in">esi</span>,[<span class="built_in">rax</span>+<span class="number">0x64</span>]</span><br><span class="line">   <span class="number">0x0000000000400d28</span> &lt;+<span class="number">24</span>&gt;:<span class="keyword">test</span>   <span class="built_in">esi</span>,<span class="built_in">esi</span></span><br><span class="line">   <span class="number">0x0000000000400d2a</span> &lt;+<span class="number">26</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rip</span>+<span class="number">0x201570</span>],<span class="built_in">esi</span>        # <span class="number">0x6022a0</span> &lt;final&gt;</span><br><span class="line">   <span class="number">0x0000000000400d30</span> &lt;+<span class="number">32</span>&gt;:<span class="keyword">jg</span>     <span class="number">0x400d4b</span> &lt;main(<span class="keyword">int</span>, char**)+<span class="number">59</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000400d32</span> &lt;+<span class="number">34</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edi</span>,<span class="number">0x602080</span></span><br><span class="line">   <span class="number">0x0000000000400d37</span> &lt;+<span class="number">39</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400cd0</span> &lt;_ZNSolsEi@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000400d3c</span> &lt;+<span class="number">44</span>&gt;:<span class="keyword">sub</span>    <span class="built_in">ebx</span>,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x0000000000400d3f</span> &lt;+<span class="number">47</span>&gt;:<span class="keyword">jne</span>    <span class="number">0x400d20</span> &lt;main(<span class="keyword">int</span>, char**)+<span class="number">16</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000400d41</span> &lt;+<span class="number">49</span>&gt;:<span class="keyword">add</span>    <span class="built_in">rsp</span>,<span class="number">0x8</span></span><br><span class="line">   <span class="number">0x0000000000400d45</span> &lt;+<span class="number">53</span>&gt;:<span class="keyword">xor</span>    <span class="built_in">eax</span>,<span class="built_in">eax</span></span><br><span class="line">   <span class="number">0x0000000000400d47</span> &lt;+<span class="number">55</span>&gt;:<span class="keyword">pop</span>    <span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000400d48</span> &lt;+<span class="number">56</span>&gt;:<span class="keyword">pop</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d4a</span> &lt;+<span class="number">58</span>&gt;:<span class="keyword">ret</span></span><br><span class="line">   <span class="number">0x0000000000400d4b</span> &lt;+<span class="number">59</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">eax</span>,<span class="number">0x6021a0</span></span><br><span class="line">   <span class="number">0x0000000000400d50</span> &lt;+<span class="number">64</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">r15</span>,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000000000400d57</span> &lt;+<span class="number">71</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x0000000000400d5b</span> &lt;+<span class="number">75</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d5e</span> &lt;+<span class="number">78</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rbx</span></span><br><span class="line">   <span class="number">0x0000000000400d62</span> &lt;+<span class="number">82</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d65</span> &lt;+<span class="number">85</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rcx</span></span><br><span class="line">   <span class="number">0x0000000000400d69</span> &lt;+<span class="number">89</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d6c</span> &lt;+<span class="number">92</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rdx</span></span><br><span class="line">   <span class="number">0x0000000000400d70</span> &lt;+<span class="number">96</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d73</span> &lt;+<span class="number">99</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rsi</span></span><br><span class="line">   <span class="number">0x0000000000400d77</span> &lt;+<span class="number">103</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d7a</span> &lt;+<span class="number">106</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rdi</span></span><br><span class="line">   <span class="number">0x0000000000400d7e</span> &lt;+<span class="number">110</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d81</span> &lt;+<span class="number">113</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rbp</span></span><br><span class="line">   <span class="number">0x0000000000400d85</span> &lt;+<span class="number">117</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d88</span> &lt;+<span class="number">120</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">rsp</span></span><br><span class="line">   <span class="number">0x0000000000400d8c</span> &lt;+<span class="number">124</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d8f</span> &lt;+<span class="number">127</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r8</span></span><br><span class="line">   <span class="number">0x0000000000400d93</span> &lt;+<span class="number">131</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d96</span> &lt;+<span class="number">134</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r9</span></span><br><span class="line">   <span class="number">0x0000000000400d9a</span> &lt;+<span class="number">138</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400d9d</span> &lt;+<span class="number">141</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r10</span></span><br><span class="line">   <span class="number">0x0000000000400da1</span> &lt;+<span class="number">145</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400da4</span> &lt;+<span class="number">148</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r11</span></span><br><span class="line">   <span class="number">0x0000000000400da8</span> &lt;+<span class="number">152</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400dab</span> &lt;+<span class="number">155</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r12</span></span><br><span class="line">   <span class="number">0x0000000000400daf</span> &lt;+<span class="number">159</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400db2</span> &lt;+<span class="number">162</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r13</span></span><br><span class="line">   <span class="number">0x0000000000400db6</span> &lt;+<span class="number">166</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400db9</span> &lt;+<span class="number">169</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r14</span></span><br><span class="line">   <span class="number">0x0000000000400dbd</span> &lt;+<span class="number">173</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400dc0</span> &lt;+<span class="number">176</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="built_in">r15</span>*<span class="number">8</span>],<span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400dc4</span> &lt;+<span class="number">180</span>&gt;:<span class="keyword">inc</span>    <span class="built_in">r15</span></span><br><span class="line">   <span class="number">0x0000000000400dc7</span> &lt;+<span class="number">183</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">ecx</span>,<span class="number">0x4010c6</span></span><br><span class="line">   <span class="number">0x0000000000400dcc</span> &lt;+<span class="number">188</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edx</span>,<span class="number">0xf5</span></span><br><span class="line">   <span class="number">0x0000000000400dd1</span> &lt;+<span class="number">193</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">esi</span>,<span class="number">0x401070</span></span><br><span class="line">   <span class="number">0x0000000000400dd6</span> &lt;+<span class="number">198</span>&gt;:<span class="keyword">mov</span>    <span class="built_in">edi</span>,<span class="number">0x4010c0</span></span><br><span class="line">   <span class="number">0x0000000000400ddb</span> &lt;+<span class="number">203</span>&gt;:<span class="keyword">call</span>   <span class="number">0x400c80</span> &lt;__assert_fail@plt&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;+59&gt;</code> ~ <code>&lt;+180&gt;</code> 行就是我们新加的逻辑，可以看到这段代码紧接在 <code>&lt;+32&gt;</code> 行之后，理论上分析的确是可以保存准确的寄存器信息。来看下实际效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gef&gt;</span><span class="bash"> p registers_data</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 = &#123;0x6021a0, 0x186a1, 0x7f872ad260d4, 0x7f872ad260c8, 0x6b8b45cb, 0x7f872ad266e0, 0x0, 0x7ffd6d53a660, 0x7f872ad260c8, 0x7f872ad26140, 0x7ffd6d53a370, 0x7f872a9a38b0, 0x400e2f, 0x7ffd6d53a750, 0x0, 0xf, 0x0 &lt;repeats 16 <span class="built_in">times</span>&gt;&#125;</span></span><br><span class="line"><span class="meta">gef&gt;</span><span class="bash"> p final</span></span><br><span class="line"><span class="meta">$</span><span class="bash">2 = 0x6b8b45cb</span></span><br></pre></td></tr></table></figure><p><code>registers_data[4]</code> 与 <code>final</code> 的值完全相同，而从源代码和反汇编 <code>&lt;+26&gt;</code> 行可以看到，<code>final</code> 中保存的就是 <code>b</code> 的真实值。</p><hr><blockquote><p>参考资料：<br><a href="https://undo.io/resources/value-optimized-out-reverse-debugging-rescue/" target="_blank" rel="noopener">Value optimized out. Reverse debugging to the rescue!</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 GCC  &lt;code&gt;-O3&lt;/code&gt; 优化级别下，很多局部变量是会被优化掉的，此时只能通过人工分析反汇编代码来获取所需信息，而这么做的前提是保存下来的寄存器中的值是准确的。绝大部分情况下 coredump 是由于 segment fault 或 assert 触发的，segment fault 情况下 Kernel 保存下来的 registers 信息是准确的，GDB 中直接用 &lt;code&gt;info registers&lt;/code&gt; 就可以看到。然而若是由 assert 触发，由于 assert 会进行多层函数调用后最终执行 &lt;code&gt;raise()&lt;/code&gt;，错误现场的寄存器信息是不准确的，这时候就需要一些其他手段来解决此问题。下面用一个具体例子来说明此问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
      <category term="Top" scheme="https://gaomf.cn/tags/Top/"/>
    
      <category term="Linux" scheme="https://gaomf.cn/tags/Linux/"/>
    
      <category term="Debug" scheme="https://gaomf.cn/tags/Debug/"/>
    
      <category term="x86" scheme="https://gaomf.cn/tags/x86/"/>
    
      <category term="GDB" scheme="https://gaomf.cn/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>使用 perf 进行性能分析时如何获取准确的调用栈</title>
    <link href="https://gaomf.cn/2019/10/30/perf_stack_traceback/"/>
    <id>https://gaomf.cn/2019/10/30/perf_stack_traceback/</id>
    <published>2019-10-30T15:09:37.000Z</published>
    <updated>2020-04-10T07:18:23.231Z</updated>
    
    <content type="html"><![CDATA[<p><code>perf</code> 是 Linux 下重要的性能分析工具，<code>perf</code> 可以通过采样获取很多性能指标，其中最常用的是获取 CPU Cycles，即程序各部分代码运行所需的时间，进而确定性能瓶颈在哪。不过在实际使用过程中发现，简单的使用<code>perf record -g</code> 获取到的调用栈是有问题的，存在大量 <code>[Unknown]</code> 函数，从 <code>perf report</code> 的结果来看这些部分对应地址大部分都是非法地址，且生成的火焰图中存在很多明显与代码矛盾的调用关系。</p><a id="more"></a><p>最初怀疑是优化级别的问题，然而尝试使用 <code>Og</code> 或 <code>O0</code> 优化依然存在此问题，仔细阅读 <code>perf record</code> 的手册后发现，<code>perf</code> 同时支持 3 种栈回溯方式：<code>fp</code>, <code>dwarf</code>, <code>lbr</code>，可以通过 <code>--call-graph</code> 参数指定，而 <code>-g</code> 就相当于 <code>--call-graph fp</code>.</p><h3 id="栈回溯方式"><a href="#栈回溯方式" class="headerlink" title="栈回溯方式"></a>栈回溯方式</h3><p> <code>fp</code> 就是 Frame Pointer，即 x86 中的 <code>EBP</code> 寄存器，<code>fp</code> 指向当前栈帧栈底地址，此地址保存着上一栈帧的 <code>EBP</code> 值，具体可参考<a href="https://www.cs.rutgers.edu/~pxk/419/notes/frames.html" target="_blank" rel="noopener">此文章</a>的介绍，根据 <code>fp</code> 就可以逐级回溯调用栈。然而这一特性是会被优化掉的，而且这还是 GCC 的默认行为，在不手动指定 <code>-fno-omit-frame-pointer</code> 时默认都会进行此优化，此时 <code>EBP</code> 被当作一般的通用寄存器使用，以此为依据进行栈回溯显然是错误的。不过尝试指定 <code>-fno-omit-frame-pointer</code> 后依然没法获取到正确的调用栈，根据 GCC 手册的<a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html" target="_blank" rel="noopener">说明</a>，指定了此选项后也并不保证所有函数调用都会使用 <code>fp</code>…… 看来只有放弃使用 <code>fp</code> 进行回溯了。</p><p><code>dwarf</code> 是一种调试文件格式，GCC 编译时附加的 <code>-g</code> 参数生成的就是 <code>dwarf</code> 格式的调试信息，其中包括了栈回溯所需的全部信息，使用 <code>libunwind</code> 即可展开这些信息。<code>dwarf</code> 的进一步介绍可参考 <a href="http://cwndmiao.github.io/programming%20tools/2013/11/26/Dwarf/" target="_blank" rel="noopener">“关于DWARF”</a>，值得一提的是，GDB 进行栈回溯时使用的正是 <code>dwarf</code> 调试信息。实际测试表明使用 <code>dwarf</code> 可以很好的获取到准确的调用栈。</p><p>最后 <code>perf</code> 还支持通过 <code>lbr</code> 获取调用栈，<code>lbr</code> 即 Last Branch Records，是较新的 Intel CPU 中提供的一组硬件寄存器，其作用是记录之前若干次分支跳转的地址，主要目的就是用来支持 <code>perf</code> 这类性能分析工具，其详细说明可参考 <a href="https://lwn.net/Articles/680985/" target="_blank" rel="noopener">“An introduction to last branch records”</a> &amp; <a href="https://lwn.net/Articles/680996/" target="_blank" rel="noopener">“Advanced usage of last branch records”</a>。此方法是性能与准确性最高的手段，然而它存在一个很大的局限性，由于硬件 Ring Buffer 寄存器的大小是有限的，<code>lbr</code> 能记录的栈深度也是有限的，具体值取决于特定 CPU 实现，一般就是 32 层，若超过此限制会得到错误的调用栈。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>实际测试下以上 3 种栈回溯方式得到的结果，测试程序是一个调用深度为 50 的简单程序，从 <code>f0()</code> 依次调用至 <code>f50()</code>。</p><p><strong><code>--call-graph fp</code></strong>：</p><p><img src="https://pic.gaomf.store/perf_test_fp.svg" alt=""></p><p><strong><code>--call-graph lbr</code></strong>：</p><p><img src="https://pic.gaomf.store/perf_test_lbr.svg" alt=""></p><p><strong><code>--call-graph dwarf</code></strong>：</p><p><img src="https://pic.gaomf.store/perf_test_dwarf.svg" alt=""></p><p>可以看到，的确只有 <code>dwarf</code> 获取到了正确的调用栈。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><code>fp</code></td><td>None</td><td>1. 默认 <code>fp</code> 被优化掉了根本不可用。</td></tr><tr><td><code>lbr</code></td><td>1. 高效准确</td><td>1. 需要较新的 Intel CPU 才有此功能；2. 能记录的调用栈深度有限。</td></tr><tr><td><code>dwarf</code></td><td>1. 准确</td><td>1. 开销相对较大；2. 需要编译时附加了调试信息。</td></tr></tbody></table><hr><blockquote><p>参考资料：</p><p><a href="http://www.brendangregg.com/perf.html" target="_blank" rel="noopener">perf Examples</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;perf&lt;/code&gt; 是 Linux 下重要的性能分析工具，&lt;code&gt;perf&lt;/code&gt; 可以通过采样获取很多性能指标，其中最常用的是获取 CPU Cycles，即程序各部分代码运行所需的时间，进而确定性能瓶颈在哪。不过在实际使用过程中发现，简单的使用&lt;code&gt;perf record -g&lt;/code&gt; 获取到的调用栈是有问题的，存在大量 &lt;code&gt;[Unknown]&lt;/code&gt; 函数，从 &lt;code&gt;perf report&lt;/code&gt; 的结果来看这些部分对应地址大部分都是非法地址，且生成的火焰图中存在很多明显与代码矛盾的调用关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具之术" scheme="https://gaomf.cn/categories/%E5%B7%A5%E5%85%B7%E4%B9%8B%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://gaomf.cn/tags/Linux/"/>
    
      <category term="Debug" scheme="https://gaomf.cn/tags/Debug/"/>
    
      <category term="x86" scheme="https://gaomf.cn/tags/x86/"/>
    
  </entry>
  
  <entry>
    <title>PVE上部署OpenWRT发生网络中断的解决方法</title>
    <link href="https://gaomf.cn/2019/07/28/PVE_OpenWRT_Network_Broken/"/>
    <id>https://gaomf.cn/2019/07/28/PVE_OpenWRT_Network_Broken/</id>
    <published>2019-07-28T03:27:09.000Z</published>
    <updated>2019-09-17T11:46:27.597Z</updated>
    
    <content type="html"><![CDATA[<p>在旧笔记本上使用Proxmox搭建了一个OpenWRT软路由，正常使用都很稳定，然而当PC使用百度网盘，迅雷等工具进行全速率下载时偶尔会出现网络中断问题，此时Proxmox宿主机的网络会全部断掉，即PVE自己的Web管理界面也无法登录。查看终端，此时会不断打印<code>Detected Hardware Unit Hang</code>的错误提示。</p><a id="more"></a><p>Google一下这个错误提示，还是有不少类似问题的：</p><blockquote><p><a href="https://jhartman.pl/2018/08/06/proxmox-enp0s31f6-detected-hardware-unit-hang/" target="_blank" rel="noopener">Proxmox: enp0s31f6: Detected Hardware Unit Hang</a></p><p><a href="https://ovear.info/post/356" target="_blank" rel="noopener">解决FreeNAS under KVM使用Virtio网卡导致宿主机网卡Hang的问题</a></p><p><a href="https://serverfault.com/questions/616485/e1000e-reset-adapter-unexpectedly-detected-hardware-unit-hang" target="_blank" rel="noopener">e1000e Reset adapter unexpectedly / Detected Hardware Unit Hang</a></p><p><a href="https://superuser.com/questions/1270723/how-to-fix-eth0-detected-hardware-unit-hang-in-debian-9" target="_blank" rel="noopener">How to fix “eth0: Detected Hardware Unit Hang” in Debian 9?</a></p><p><a href="https://forum.proxmox.com/threads/proxmox-node-freezes.44618/" target="_blank" rel="noopener">Proxmox Node freezes</a></p></blockquote><p>基本所有文章都提到此问题与<code>TCP checksum offload</code>特性有关，解决方案就是关掉<code>checksum offload</code>。具体方法是使用<code>ethtool</code>工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -K enp0s25 tx off rx off</span><br></pre></td></tr></table></figure><p>如果要重启后永久生效的话将此命令写入<code>/etc/network/if-up.d/ethtool2</code>文件中并为此文件加上<code>x</code>权限即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">ethtool -K enp0s25 tx off rx off</span><br></pre></td></tr></table></figure><hr><p>除此之外上述第2篇文章的情况和我遇到的很像，里面提到这与<code>Virtio</code>虚拟化有很大关系，而我使用的也正是<code>Vritio</code>，根据作者的说法，更应该在OpenWRT而不是Proxmox中关闭<code>checksum offload</code>。然而实际试了下却发现一个蛋疼的问题，OpenWRT中是无法把<code>tx checksum offload</code>给关掉的……</p><p>此外作者还提到，将网卡的虚拟化方式从<code>Virtio</code>改为<code>E1000</code>也可以解决此问题，不过会有CPU占用率上升的副作用。</p><hr><p>综合以上几种方法，我最后采用的解决办法是：禁用Proxmox宿主机上的<code>TCP checksum offload</code>，并将OpenWRT使用的网卡虚拟化方式改为<code>E1000</code>。实际测试下来没有再发生网卡hang的问题，满速率下载（250Mbps左右）时CPU占用率50%左右，比之前使用<code>Virtio</code>时CPU占用率要高10%左右，还是可以接受的。</p><hr><p>问题算是解决了，最后顺带去进一步学习了下相关的知识，首先是<code>TCP checksum offload</code>，此技术的作用是将计算TCP  checksum的工作由CPU软件实现改为由NIC设备（即网卡等）硬件实现，以此达到节约CPU资源的目的。</p><blockquote><p><a href="https://www2.cs.duke.edu/ari/trapeze/freenix/node7.html" target="_blank" rel="noopener">Checksum Offloading</a></p><p><a href="https://www.ibm.com/support/knowledgecenter/en/ssw_aix_71/performance/tcp_checksum_offload.html" target="_blank" rel="noopener">TCP checksum offload</a></p><p><a href="https://blog.csdn.net/sinat_20184565/article/details/82979778" target="_blank" rel="noopener">UDP的checksum计算与硬件Offload</a></p></blockquote><p>另外就是<code>Virtio</code>与<code>E1000</code>，这是两种不同的网络虚拟化技术，<code>Virtio</code>是半虚拟化而<code>E1000</code>是全虚拟化。对于全虚拟化方案来说，虚拟机是完全感知不到自己是运行在一个虚拟环境中的；而半虚拟化则是虚拟机知道自己就是运行在一个虚拟环境中，此时IO驱动就可以做一些针对性的修改优化，以此降低虚拟化层进行转换带来的开销及性能损失。显而易见，半虚拟化技术的隔离度是没有全虚拟化好的，而且要是虚拟机驱动有问题会导致宿主机也出问题。这就是为什么在使用<code>Virtio</code>时，OpenWRT网络出现问题会导致整个Proxmox的网络都不能用了的原因。除了这两种虚拟化方式外，还有些更为先进的虚拟化技术，如<code>SR-IVO</code>等，有兴趣的话可以看看下面这篇文章的总结：</p><blockquote><p><a href="https://blog.51cto.com/xiaoli110/1558984" target="_blank" rel="noopener">KVM虚拟化网络优化技术总结</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在旧笔记本上使用Proxmox搭建了一个OpenWRT软路由，正常使用都很稳定，然而当PC使用百度网盘，迅雷等工具进行全速率下载时偶尔会出现网络中断问题，此时Proxmox宿主机的网络会全部断掉，即PVE自己的Web管理界面也无法登录。查看终端，此时会不断打印&lt;code&gt;Detected Hardware Unit Hang&lt;/code&gt;的错误提示。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具之术" scheme="https://gaomf.cn/categories/%E5%B7%A5%E5%85%B7%E4%B9%8B%E6%9C%AF/"/>
    
    
      <category term="Network" scheme="https://gaomf.cn/tags/Network/"/>
    
      <category term="Virtualization" scheme="https://gaomf.cn/tags/Virtualization/"/>
    
  </entry>
  
  <entry>
    <title>用于嵌入式车载安全预警的交通标志检测若干关键技术研究与验证</title>
    <link href="https://gaomf.cn/2019/02/24/Thesis_of_Master/"/>
    <id>https://gaomf.cn/2019/02/24/Thesis_of_Master/</id>
    <published>2019-02-24T13:32:12.000Z</published>
    <updated>2020-04-10T07:18:23.239Z</updated>
    
    <content type="html"><![CDATA[<p>转眼间毕业已经要一年了，今天在整理电脑文件的时候翻出了当初写的硕士毕业论文，在知网上搜搜也<a href="http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201802&filename=1018186759.nh" target="_blank" rel="noopener">找得到了</a>。想想硕士期间做过的东西也太杂了，电机控制、Android 开发、嵌入式。。。最后确定了这个毕业论文的题目后只有1年不到的时间可以做了，这期间还要复习准备找工作，不过最后做出来的东西还算是自己基本满意的，这估计也是我在学术上的顶峰了……</p><a id="more"></a><p>为纪念下我离Academy最近的时刻，这里把我这篇论文的摘要及pdf版本的全文贴一下吧。</p><p>全文下载链接：<a href="https://pic.gaomf.store/%E7%94%A8%E4%BA%8E%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%A6%E8%BD%BD%E5%AE%89%E5%85%A8%E9%A2%84%E8%AD%A6%E7%9A%84%E4%BA%A4%E9%80%9A%E6%A0%87%E5%BF%97%E6%A3%80%E6%B5%8B%E8%8B%A5%E5%B9%B2%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E4%B8%8E%E9%AA%8C%E8%AF%81_%E9%AB%98%E6%98%8E%E9%A3%9E.pdf" target="_blank" rel="noopener">用于嵌入式车载安全预警的交通标志检测若干关键技术研究与验证</a></p><p>论文摘要：</p><p>车载安全预警系统可及时为驾驶员提供必要的行车安全预警信息以提高驾驶安全性,其包含若干子系统,如交通标志识别、超速预警等,而交通标志检测则是支撑诸多子系统的重要基础技术之一;本文就针对交通标志检测中基于颜色分割的定位算法及多线程任务调度策略这两项关键技术进行了研究,提出了适用于性能有限嵌入式系统的混合颜色分割策略及混合切换任务调度策略,并通过搭建嵌入式原型样机在实际道路环境中验证了方法的有效性。此外为更好的验证及评估交通标志检测算法的效果,本文建立了中国道路交通标志视频数据集,并将此数据集公开发布以供其他研究人员使用,这也是此领域目前唯一的中国公开数据集。目前主流成熟的交通标志检测定位方法基本均是基于颜色及几何形状局部特征的,本文在此框架下对用于车载安全预警的交通标志检测中最为重要的红色及黄色分割方法展开了深入研究,针对已有主流颜色分割方法的不足提出了混合颜色分割策略,此策略通过若干线性分类器的组合实现了对红色及黄色准确高效的分割,分割效果优于目前常用的各方法且其算法执行速度与最简单的RGB阈值法相似,可保证安全预警算法在性能有限的小型嵌入式车载设备上依然有较好的实时性;在颜色分割基础上本文采用经典的Hough变换实现了对红色圆形交通标志的检测定位并在数据集上评估了算法的效果。本文通过对交通标志检测识别问题进行建模分析提出可用采样间隔时间作为定量衡量此类系统实时性的指标,进而针对目前广泛使用的多核CPU提出了理论最优的理想多线程任务调度算法,此算法可显著降低采样间隔时间以提高系统实时性;不过理想任务调度算法实际无法实现,因此本文进一步提出了实际可实现的混合切换任务调度策略及动态更新参数估计策略;通过控制系统模型数值仿真及实际嵌入式原型样机上的测试验证均表明本文提出的方法可有效优化采样间隔时间分布以此提高系统实时性。本文同时开发了基于Qt的算法验证平台软件及基于Intel Joule模块的嵌入式原型样机,并在其上验证了上述各方法的有效性,最后在校园环境及城市道路上分别进行了静态及动态系统集成测试;测试结果表明本文提出的方法可在小型嵌入式设备上满足系统实时性要求,在天气光照条件较好时检出率也相对较高,不过算法鲁棒性依然需要加强。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转眼间毕业已经要一年了，今天在整理电脑文件的时候翻出了当初写的硕士毕业论文，在知网上搜搜也&lt;a href=&quot;http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&amp;dbname=CMFD201802&amp;filename=1018186759.nh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;找得到了&lt;/a&gt;。想想硕士期间做过的东西也太杂了，电机控制、Android 开发、嵌入式。。。最后确定了这个毕业论文的题目后只有1年不到的时间可以做了，这期间还要复习准备找工作，不过最后做出来的东西还算是自己基本满意的，这估计也是我在学术上的顶峰了……&lt;/p&gt;
    
    </summary>
    
    
      <category term="科研之路" scheme="https://gaomf.cn/categories/%E7%A7%91%E7%A0%94%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="Concurrent" scheme="https://gaomf.cn/tags/Concurrent/"/>
    
      <category term="OpenCV" scheme="https://gaomf.cn/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>深入分析Docker hello-world镜像</title>
    <link href="https://gaomf.cn/2019/02/15/Deep_Into_Dokcer_Helloworld/"/>
    <id>https://gaomf.cn/2019/02/15/Deep_Into_Dokcer_Helloworld/</id>
    <published>2019-02-15T14:46:25.000Z</published>
    <updated>2019-09-17T11:46:27.615Z</updated>
    
    <content type="html"><![CDATA[<p>学习Docker时一般刚开始接触的第一个docker image就是<code>hello-world</code>，这个image运行起来的效果也很简单直接，仅仅是在屏幕上输出一段Docker的使用说明就结束了。这个镜像虽然简单，然而仔细分析下还是涉及不少底层机制的。</p><a id="more"></a><p>我之所以会对这个镜像感兴趣，是发现它的大小仅仅只有1.84kB，这实在是太小了，写一个<code>printf(&quot;Hello Wolrd\n&quot;);</code>的程序编译出来大小就远超1.84kB了，所以很好奇这个镜像是如何构建出来的。</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Docker的镜像构建过程是由其镜像描述文件Dockerfile决定的，所以就先找到其Dockerfile来看看。<code>hello-world</code>用于<code>AMD64</code>架构的Dockerfile可以在<a href="https://github.com/docker-library/hello-world/blob/b715c35271f1d18832480bde75fe17b93db26414/amd64/hello-world/Dockerfile" target="_blank" rel="noopener">Github上</a>找到，只有简单的3行：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hello /</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/hello"</span>]</span></span><br></pre></td></tr></table></figure><p>第1行导入了一个名为<code>scratch</code>的东西，这并不是一个真正的image，可以把它视为是所有image的最底层虚拟镜像，类似于一个基本抽象类，Docker官方对其的说明<a href="https://hub.docker.com/_/scratch" target="_blank" rel="noopener">如下</a>：</p><blockquote><p>This image is most useful in the context of building base images (such as <a href="https://registry.hub.docker.com/_/debian/" target="_blank" rel="noopener"><code>debian</code></a> and <a href="https://registry.hub.docker.com/_/busybox/" target="_blank" rel="noopener"><code>busybox</code></a>) or super minimal images (that contain only a single binary and whatever it requires, such as <a href="https://registry.hub.docker.com/_/hello-world/" target="_blank" rel="noopener"><code>hello-world</code></a>).</p><p>As of Docker 1.5.0 (specifically, <a href="https://github.com/docker/docker/pull/8827" target="_blank" rel="noopener"><code>docker/docker#8827</code></a>), <code>FROM scratch</code> is a no-op in the <code>Dockerfile</code>, and will not create an extra layer in your image (so a previously 2-layer image will be a 1-layer image instead).</p><p>……</p><p>You can use Docker’s reserved, minimal image, <code>scratch</code>, as a starting point for building containers. Using the <code>scratch</code> “image” signals to the build process that you want the next command in the <code>Dockerfile</code> to be the first filesystem layer in your image.</p></blockquote><p>后面两行的含义也很直接，把一个名为hello的程序copy到根目录下，在运行image的时候运行此程序。下面就来看下这个如此小的hello world程序是如何实现的。</p><h2 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h2><p>hello.c文件的源码也在同一个<a href="https://github.com/docker-library/hello-world/blob/master/hello.c" target="_blank" rel="noopener">Github仓库中</a>，省略掉过长的字符串常量后很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> message[] =</span><br><span class="line">    <span class="string">"Hello World!"</span></span><br><span class="line">    <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _start() &#123;</span><br><span class="line">    syscall(SYS_write, <span class="number">1</span>, message, <span class="keyword">sizeof</span>(message) - <span class="number">1</span>);</span><br><span class="line">    syscall(SYS_exit, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个最简版本的Hello World和C语言教科书中第一个Hello World是有不小差别的。首先是程序入口点上，众所周知正常C/C++程序的入口点是<code>main()</code>，然而这里使用的是<code>_start()</code>。</p><p>我们的程序是运行在Linux系统上的，程序的加载与运行必然是由OS发起的，<strong>对于Linux来说，OS层面的程序入口点就是<code>_start()</code>而不是<code>main()</code></strong>，一个程序要能正常运行在<code>main()</code>之前是有一些准备工作要做的，比如建立程序运行环境（初始化.bss全局变量等）；在<code>main()</code>返回之后也有些收尾工作要处理，比如调用<code>exit()</code>通知系统等。这些工作正常情况下是由语言标准库来完成的，也就是所谓的Runtime运行环境，对于C语言来说就是<code>crt0.o</code>。大部分程序的<code>_start()</code>就位于其中，在建立好运行环境后<code>_start()</code>会调用<code>main()</code>跳转到用户定义的入口点处。当<code>main()</code>返回后程序又将回到<code>ctr0.o</code>中，最终调用<code>exit()</code>通知OS回收进程资源。</p><p>这里为了缩小程序体积和简单起见，没有使用标准的<code>ctr0.o</code> Runtime，事实上这一个简单的程序也不需要什么Runtime。程序最后直接通过<code>syscall</code>函数调用了<code>SYS_exit</code>系统调用结束了自身的运行。</p><p>将字符串输出到屏幕上也没有使用标准库中的<code>printf()</code>，同样是直接调用了<code>SYS_write</code>这个系统调用，其第一个参数显式的写为了1，其实就是<code>STDOUT_FILENO</code>，Linux系统在<code>unistd.h</code>中定义了<code>stdin</code>, <code>stdout</code>, <code>stderr</code>这几个标准文件描述符。</p><p>可以看到，这样一个程序是可以不依赖于任何其他的库在Linux上独立运行的，为了实现不链接C标准库的目的，需要使用一些特殊的编译选项。从编译这个<code>hello-world</code>程序使用的<a href="https://github.com/docker-library/hello-world/blob/master/Makefile" target="_blank" rel="noopener">Makefile</a>中可以找到使用的编译选项为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS := -static -Os -nostartfiles -fno-asynchronous-unwind-tables</span><br></pre></td></tr></table></figure><ul><li><code>-static</code>表示静态链接，虽然对这个程序来说无所谓动态链接还是静态链接……</li><li><code>-Os</code>表示为空间进行<code>-O2</code>级别的优化，专门用于减少目标文件大小；</li><li><code>-nostartfiles</code>是关键编译选项，此选项表示不使用标准C语言运行库（即<code>crt0.o</code>），也不链接C标准库；</li><li><code>-fno-asynchronous-unwind-tables</code>选项也是用于减少代码空间的，其大概含义是不产生C++异常处理机制中使用的<code>.eh_frame</code>段，关于什么是<code>unwind-tables</code>和<code>.eh_frame</code>是个比这篇文章复杂多了的问题，文末有几篇参考资料，之后有空可以深入学习下C++的底层机制……</li></ul><p>进行了以上诸多特殊优化处理后，终于可以得到一个只有1k多的可以正常运行于Linux上的Hello World程序了。</p><hr><blockquote><p>参考资料：</p><p><a href="https://stackoverflow.com/questions/29694564/what-is-the-use-of-start-in-c" target="_blank" rel="noopener">What is the use of _start() in C?</a></p><p><a href="https://stackoverflow.com/questions/43050089/when-is-the-gcc-flag-nostartfiles-used" target="_blank" rel="noopener">When is the gcc flag -nostartfiles used?</a></p><p><a href="https://software.intel.com/en-us/blogs/2013/01/17/x86-gcc-code-size-optimizations" target="_blank" rel="noopener">GCC x86 code size optimizations</a></p><p><a href="https://www.cnblogs.com/catch/p/3619379.html" target="_blank" rel="noopener">c++ 异常处理（2）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习Docker时一般刚开始接触的第一个docker image就是&lt;code&gt;hello-world&lt;/code&gt;，这个image运行起来的效果也很简单直接，仅仅是在屏幕上输出一段Docker的使用说明就结束了。这个镜像虽然简单，然而仔细分析下还是涉及不少底层机制的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件之道" scheme="https://gaomf.cn/categories/%E8%BD%AF%E4%BB%B6%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
      <category term="Runtime" scheme="https://gaomf.cn/tags/Runtime/"/>
    
      <category term="Linux" scheme="https://gaomf.cn/tags/Linux/"/>
    
      <category term="Compiler" scheme="https://gaomf.cn/tags/Compiler/"/>
    
      <category term="Docker" scheme="https://gaomf.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>sudo不需要输入密码的方法</title>
    <link href="https://gaomf.cn/2018/11/17/Sudo_No_Passwd/"/>
    <id>https://gaomf.cn/2018/11/17/Sudo_No_Passwd/</id>
    <published>2018-11-17T09:20:09.000Z</published>
    <updated>2019-09-17T11:46:27.607Z</updated>
    
    <content type="html"><![CDATA[<p>正常情况下，使用<code>sudo</code>命令是需要输入密码的，连续输入多条<code>sudo</code>只用输一次密码就行，不过若干分钟后又需要输入密码了。对于自己使用的本地桌面环境来说，其实是可以配置成<code>sudo</code>免输入密码的，这样可以减少一些麻烦。</p><a id="more"></a><p>以<code>Ubuntu 18.04</code>为例说明设置方法，其他发行版可能会有区别。<code>Ubuntu Desktop</code>默认已经将安装系统时配置的用户加入了<code>admin</code>用户组，且<code>admin</code>用户组中的用户都是有<code>sudo</code>权限的，因此无需修改<code>sudo</code>用户组。若需要将某用户添加到<code>sudo</code>用户组中，可参考文末链接。</p><p>输入<code>su -</code>命令切换到<code>root</code>下，修改<code>/etc/sudoers</code>文件，找到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Allow members of group sudo to execute any command</span></span><br><span class="line">%sudoALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Allow members of group sudo to execute any command</span></span><br><span class="line">%sudoALL=(ALL:ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure><p>即可。</p><p>这样就可以允许<code>sudo</code>用户组中的用户免密码执行<code>sudo</code>命令了。</p><hr><blockquote><p>参考资料：</p><p><a href="https://www.jianshu.com/p/5d02428f313d" target="_blank" rel="noopener">免密码使用sudo和su</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正常情况下，使用&lt;code&gt;sudo&lt;/code&gt;命令是需要输入密码的，连续输入多条&lt;code&gt;sudo&lt;/code&gt;只用输一次密码就行，不过若干分钟后又需要输入密码了。对于自己使用的本地桌面环境来说，其实是可以配置成&lt;code&gt;sudo&lt;/code&gt;免输入密码的，这样可以减少一些麻烦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具之术" scheme="https://gaomf.cn/categories/%E5%B7%A5%E5%85%B7%E4%B9%8B%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://gaomf.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>为Hexo博客Yelee主题添加Gitment评论系统</title>
    <link href="https://gaomf.cn/2018/11/04/Hexo_Yelee_Gitment/"/>
    <id>https://gaomf.cn/2018/11/04/Hexo_Yelee_Gitment/</id>
    <published>2018-11-04T13:36:31.000Z</published>
    <updated>2019-09-17T11:46:27.608Z</updated>
    
    <content type="html"><![CDATA[<p>本来博客使用的是多说作为评论系统，前两年多说停止服务了换成了友言，用了没多久友言又要求备案不能用了……后面由于工作繁忙也就没管这个了。前段时间发现Gitment这个基于Github Issue的评论系统不错，这两天终于有空把它给加上了。</p><a id="more"></a><p>我使用的主题是基于<a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">Yelee</a>做了些修改得到的，Yelee又是基于<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">Yilia</a>的，添加Gitment的过程可以参考这篇文章：</p><blockquote><p><a href="https://sogrey.github.io/article/Hexo-%E6%B7%BB%E5%8A%A0-Gitment-%E8%AF%84%E8%AE%BA/" target="_blank" rel="noopener">Hexo 添加 Gitment 评论</a></p></blockquote><p>Yiila主题也添加了Gitment支持，其<a href="https://github.com/litten/hexo-theme-yilia/commit/af58957e14a00b3da03e4026c56d34cdf7eda9b4" target="_blank" rel="noopener">Commit</a>也是很有参考价值的。</p><p>与以上教程有区别的是，无需安装Gitment npm插件，添加修改的代码我也改了下，有兴趣的话可以看这个<a href="https://github.com/g199209/BlogTheme/commit/bc591586bd737f0f24a08c54f36f6e10372050c6" target="_blank" rel="noopener">Commit</a>。</p><p>其中Gitment的CSS &amp; JS文件改为了本地压缩后的版本，评论框的显示效果也调整了下。</p><p>终于评论系统又可以用啦，之后就该静心学学技术提高下自己的水平了……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来博客使用的是多说作为评论系统，前两年多说停止服务了换成了友言，用了没多久友言又要求备案不能用了……后面由于工作繁忙也就没管这个了。前段时间发现Gitment这个基于Github Issue的评论系统不错，这两天终于有空把它给加上了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具之术" scheme="https://gaomf.cn/categories/%E5%B7%A5%E5%85%B7%E4%B9%8B%E6%9C%AF/"/>
    
    
      <category term="Blog" scheme="https://gaomf.cn/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>sizeof 获取 extern 数组长度</title>
    <link href="https://gaomf.cn/2018/06/30/sizeof_extern_array/"/>
    <id>https://gaomf.cn/2018/06/30/sizeof_extern_array/</id>
    <published>2018-06-30T08:52:12.000Z</published>
    <updated>2019-09-17T11:46:27.607Z</updated>
    
    <content type="html"><![CDATA[<p>sizeof是获取数组元素个数的常用运算符，然而前几天使用时发现，对于extern类型的数组，sizeof的使用上是有些需要考虑的问题的。</p><a id="more"></a><p>假设系统中有3个文件：</p><p><code>file1.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p><code>header1.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="built_in">array</span>[];</span><br></pre></td></tr></table></figure><p><code>main.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This is WRONG!</span></span><br><span class="line">    <span class="keyword">size_t</span> elements_in_array = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>main.c</code>中期望通过<code>sizeof</code>运算符获取<code>array</code>中元素个数，然而这么做是错误的，编译时无法通过，错误提示类似<code>incomplete type not allowed</code>这类。</p><p>造成这一问题的原因在于，<strong><code>sizeof</code>是在编译时计算的，而C/C++的编译是以文件为基本单位的</strong>。在编译<code>main.c</code>文件时，编译器是不可能知道定义在<code>file1.c</code>文件中<code>array</code>数组具体信息的，只根据<code>header1.h</code>文件中的声明是无法确定<code>array</code>的具体大小的，因此，就算某些编译器编译时不报错，得到的结果也是不正确的。</p><p>分析清楚原因后来看下解决方案，基本解决方法有4种：</p><ol><li>避免使用匿名长度的数组声明，使用宏定义预先确定数组大小；</li><li>定义一个辅助变量用于保存数组大小信息，将其定义赋值放在定义<code>array</code>数组的同一个文件中；</li><li>使用特殊元素表示数组结束，就像字符串结尾的<code>&#39;\0&#39;</code>一样，这样就可以在运行阶段动态确定数组大小；</li><li>将数组的定义放到使用它的源文件中。</li></ol><p>这几种方法都有其缺点：</p><ol><li>使用<code>sizeof</code>就是不想固定数组长度，因为使用宏定义固定数组长度不够灵活，要是想添加数组元素也要同时修改宏定义，否则尽管编译不会报错，然而运行时新添加的元素其实是无效的，这会导致将来维护时一些潜在Bug发生的可能性增加；</li><li>需要一个额外的存储空间，且由于这是一个变量，每次使用数组长度时都需要访问内存，编译器也无法对数组长度作出任何假设，进而影响编译优化，理论上说这可能会导致运行时一些微小的效率损失；</li><li>需要修改上层逻辑，缺乏通用性；</li><li>大部分情况下，使用非<code>static</code>全局变量的原因就是多个源文件需要使用这个变量，这时显然无法做到这一点，多次重复定义链接时会出错的。</li></ol><p>实际使用中，需要根据具体问题具体分析采用哪种方法最恰当，一般而言不经常变化的数组就使用宏定义确定其大小，会经常变化的第2种方法最常用，此时还可以用一些宏定义简化编程，以上代码可修改为：</p><p><code>file1.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">ELEMENTS_IN_DEF(<span class="built_in">array</span>)</span><br></pre></td></tr></table></figure><p><code>header1.h</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ELEMENTS_IN(array)            __elements_in_##array</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ELEMENTS_IN_DEF(array)        size_t __elements_in_##array = sizeof(array) / sizeof(array[0]);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  ELEMENTS_IN_DECLARE(array)    extern size_t __elements_in_##array;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="built_in">array</span>[];</span><br><span class="line">ELEMENTS_IN_DECLARE(<span class="built_in">array</span>)</span><br></pre></td></tr></table></figure><p><code>main.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> elements_in_array = ELEMENTS_IN(<span class="built_in">array</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考资料：</p><p><a href="http://c-faq.com/decl/extarraysize.html" target="_blank" rel="noopener">comp.lang.c FAQ list · Question 1.24</a></p><p><a href="https://stackoverflow.com/questions/23230114/c-how-to-determine-sizeofarray-sizeofstruct-for-external-array" target="_blank" rel="noopener">C: How to determine sizeof(array) / sizeof(struct) for external array?</a></p><p><a href="https://blog.csdn.net/ranhui_xia/article/details/39502665" target="_blank" rel="noopener">sizeof extern数组</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sizeof是获取数组元素个数的常用运算符，然而前几天使用时发现，对于extern类型的数组，sizeof的使用上是有些需要考虑的问题的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
      <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>多歧路，今安在？</title>
    <link href="https://gaomf.cn/2018/06/03/The_Road/"/>
    <id>https://gaomf.cn/2018/06/03/The_Road/</id>
    <published>2018-06-03T08:59:01.000Z</published>
    <updated>2019-09-17T11:46:27.611Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写博客了，翻看自己的博客，上次更新已是半年多前了，这大半年来忙于找工作，毕业设计，毕业答辩、入职……入职前两个月也是各种忙碌，现在对手头的工作也熟悉一些了，于是乎在低头做事的空暇时也需要抬起头来看看路了。</p><a id="more"></a><p>自从找工作拿到几个Offer可以选择时就开始各种纠结与困惑了，大疆、阿里、Intel、华为、拼多多、乐鑫、网易……有幸能拿到这么些优秀公司的Offer，然而每一家公司都同时有吸引我和令我踌躇的地方，鱼和熊掌终不可兼得，选择也变得十分困难。虽然最终选择了大疆，然而这一选择并不是那么顺理成章，当时在犹豫，本以为选了之后就不会困惑了，现在才发觉，困惑的东西并不会随着时间推移而自然而然的变得清晰起来。</p><p>人生有很多选择，选择和努力哪个更重要呢？这个问题的标准答案在准备面试时都背得滚瓜烂熟了，选择与努力互为因果，选择是为了决定之后努力的方向，努力是为了将来能有更多选择。然而，记住了所谓的标准答案并无济于事，该困惑的时候还是一样困惑。</p><p>其实想想，所有困惑的根源都来自于两点：不知道自己真正想要的是什么；不知道未来会是怎样。</p><p>与其说是不知道自己想要什么，不如说是不知道自己愿意放弃什么，选择之所以困难，是因为选择与放弃总是如影相随的，选择了此就注定要放弃彼。人总是什么都想要的，但事实是我们注定要放弃大多数东西的，人生在不断的做出选择，同时也是在不断放弃。然而，我究竟愿意放弃什么呢？愿意选择什么呢？这并不是那么确定的啊……什么都不想放弃，也就注定什么都无法得到。</p><p>上面那点也许还能随着年岁与阅历的增长思考得越来越清楚，那对未来不可知的迷茫更是让人觉得无能为力。生命的精彩源于不可知，生命的痛苦也源于不可知。时代的洪流滚滚前进，顺之者昌逆之者亡，然而时代的车轮碾向何方又有谁知？</p><p>可供选的路总是越来越少的，我们都终有一日会无路可选，到那时，认命也罢，不认也罢，是非成败转头空，唯余夕阳照青山。在我们还有得可选的时候，还是多想想吧，就算是一条咸鱼也还是要挣扎下看看的。虽然路最终总是越走越窄的，还是要努力下让它窄得不要那么快吧，毕竟啊，谁又能说自己走的一定是那条自己想要同时又不会被时代湮没的道路呢？</p><p>瞎扯了这么多似乎还是多想清楚了那么一丝东西吧，脚踏实地亦要仰望星空，不要让天天加班和生活琐事的忙碌成为一种错觉蒙蔽了双眼。自己的未来何在，尽管想不清还是要去找的吧，在坚信自己找到之前，努力让未来的路宽广一些，努力让自己不要失去有选择的能力，虽然选择是困难和纠结的，然而没选择的走投无路是更大的悲哀。</p><p>然而，要维持像学校里那样站在四通八达的十字路口近乎是不可能完成的事，两条路经常是越来越远的，刚开始时尚有可能跳过去，越到后面越难跳过去了吧。所以啊，还是要尽快想清楚自己想去哪条路上才行啊，然而，谁知道哪时候能想清楚呢……不过在想清楚自己要跳去哪条路上之前，还是要多练练自己跳跃的能力，培养些通用的技能，让自己还是有路可跳有路可选吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没写博客了，翻看自己的博客，上次更新已是半年多前了，这大半年来忙于找工作，毕业设计，毕业答辩、入职……入职前两个月也是各种忙碌，现在对手头的工作也熟悉一些了，于是乎在低头做事的空暇时也需要抬起头来看看路了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="人生之思" scheme="https://gaomf.cn/categories/%E4%BA%BA%E7%94%9F%E4%B9%8B%E6%80%9D/"/>
    
    
  </entry>
  
  <entry>
    <title>SSH反向穿透访问内网主机</title>
    <link href="https://gaomf.cn/2017/11/04/SSH_Forwarding/"/>
    <id>https://gaomf.cn/2017/11/04/SSH_Forwarding/</id>
    <published>2017-11-03T16:16:00.000Z</published>
    <updated>2019-09-17T11:46:27.599Z</updated>
    
    <content type="html"><![CDATA[<p>学校的网络位于无数重NAT内网中，而且还有各种VPN，所以想要从外网访问十分困难，之前试过各种方法都没成功。今天偶然看到了SSH反向穿透的方法，因为我访问内网服务器主要也是需要SSH连接功能，故此方法可以很好的满足我的需求。此处记录下配置方法。</p><a id="more"></a><p>SSH反向穿透需要有一台有公网IP的服务器作为桥梁，此处将位于多重NAT网络中需要访问的主机称为Target，而将有固定IP的中转服务器称为Server。SSH反向穿透的原理是，Target主动建立与Server间的SSH连接，利用SSH的端口转发功能，将访问Server某端口的数据包转发到Target SSH端口（22端口）上，以此实现间接登陆Target的目的。</p><p>假设Server上的转发端口为<code>6766</code>，使用如下命令在Target上建立与Server间的反向隧道：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 22 -fN -R 6766:localhost:22 userServer@Server</span><br></pre></td></tr></table></figure><p><code>-R</code>用于定义反向隧道，<code>-fN</code>用于在建立SSH连接后SSH进入后台运行。</p><p>之后需要在Server上打开<code>sshd</code>的<code>GatewayPorts</code>功能，这样才能实现只登录一次即可连接上Target。修改<code>/etc/ssh/sshd_config</code>文件，添加下面这行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GatewayPorts clientspecified</span><br></pre></td></tr></table></figure><p>重启<code>sshd</code>服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ssh restart</span><br></pre></td></tr></table></figure><p>此时就可以在任意一个终端上使用<code>ssh -p 6766 userTarget@Server</code>登录到Target上了，需要注意的是，此时使用的用户名、密码、秘钥都应该是Target而不是Server的，只有IP地址或者是域名是Server的。</p><p>最后一个问题是，如何保持这个SSH反向隧道的稳定存在，并且实现若Target意外重启后能自动再次建立此反向隧道。解决方法是使用<code>autossh</code>，并且把它作为一个服务自动启动。</p><p>先安装<code>autossh</code>，之后在<code>/etc/init.d</code>下建立一个名为<code>autossh</code>的文件：（以下操作以Ubuntu为例，其他发行版可能会有区别）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">/usr/bin/autossh -p 22 -M 6777 -fN -R *:6766:localhost:22 userServer@Server -i id_rsa</span><br></pre></td></tr></table></figure><p><code>-M</code>参数指定了一个监控端口，和端口转发无关，使用一个无用的端口即可；<code>-i</code>指定了一个密钥，此处用RSA密钥的方式登陆Server。</p><p>保存此文件，并添加执行权限：<code>chmod +x autossh</code>；注册服务：<code>update-rc.d autossh enable</code>；最后启动服务：<code>service autossh start</code>。</p><p>可使用<code>sysv-rc-conf</code>工具查看<code>autossh</code>服务的开机自启动情况。这样将其作为服务配置好后，就可以实现稳定的SSH反向穿透了，终于可以实现从任何地方自由访问内网主机的目的了~~</p><p>最后顺便提一下，SSH转发其实可以承载其他更多的网络服务，这个之后有空再来研究~</p><hr><blockquote><p>参考资料：<br><a href="http://network.51cto.com/art/201505/477144.htm" target="_blank" rel="noopener">如何通过SSH反向隧道，访问NAT后面的Linux服务器?</a><br><a href="http://arondight.me/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" target="_blank" rel="noopener">使用SSH反向隧道进行内网穿透</a><br><a href="https://marshal.ohtly.com/2017/01/26/Reverse-SSH-Tunneling-with-Autossh/" target="_blank" rel="noopener">使用autossh实现反向SSH隧道</a><br><a href="http://blog.csdn.net/yuanchao99/article/details/9111269" target="_blank" rel="noopener">ubuntu service的添加和删除</a><br><a href="https://stackoverflow.com/questions/37438630/how-to-use-systemctl-in-ubuntu-14-04" target="_blank" rel="noopener">How to use systemctl in Ubuntu 14.04</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学校的网络位于无数重NAT内网中，而且还有各种VPN，所以想要从外网访问十分困难，之前试过各种方法都没成功。今天偶然看到了SSH反向穿透的方法，因为我访问内网服务器主要也是需要SSH连接功能，故此方法可以很好的满足我的需求。此处记录下配置方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具之术" scheme="https://gaomf.cn/categories/%E5%B7%A5%E5%85%B7%E4%B9%8B%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://gaomf.cn/tags/Linux/"/>
    
      <category term="Network" scheme="https://gaomf.cn/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>C语言关键词restrict的应用</title>
    <link href="https://gaomf.cn/2017/10/25/C_restrict/"/>
    <id>https://gaomf.cn/2017/10/25/C_restrict/</id>
    <published>2017-10-25T08:22:00.000Z</published>
    <updated>2019-09-17T11:46:27.589Z</updated>
    
    <content type="html"><![CDATA[<p><code>restrict</code>是C99标准中新增的关键词，只能用于修饰指针（函数指针除外），其含义为：<strong>此指针是访问其指向对象的唯一初始方法</strong>。使用此关键词的意义在于：<strong>有助于编译器进行代码优化</strong>。</p><a id="more"></a><p><code>restrict</code>是一个类型限定词，在C99标准(ISO/IEC 9899:1999)的”6.7.3.1 Formal definition of restrict”中给出其定义，基本语法为<code>xxx * restrict var</code>，其中<code>xxx</code>是指针指向的变量类型。需要注意的是，只有指向所谓”object types”的指针才能用<code>restrict</code>修饰，而”object types”的定义应该是除了函数指针外所有类型的指针。另外，对于函数参数来说，由于数组和指针的等价性，函数参数为数组时也可以用<code>restrict</code>修饰，此时<code>restrict</code>放在<code>[]</code>中，如：<code>void fun(int par[restrict])</code>。</p><p>上面也说到，使用<code>restrict</code>的意义在于便于编译器优化，此处使用<code>restrict</code>最常用的一个例子进行说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> * a, <span class="keyword">int</span> * b)</span> </span>&#123;</span><br><span class="line">    *a = <span class="number">5</span>;</span><br><span class="line">    *b = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> *a + *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfoo</span><span class="params">(<span class="keyword">int</span> * <span class="keyword">restrict</span> a, <span class="keyword">int</span> * <span class="keyword">restrict</span> b)</span> </span>&#123;</span><br><span class="line">    *a = <span class="number">5</span>;</span><br><span class="line">    *b = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> *a + *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!---workaround highlight bugs*---><p>对于<code>foo</code>函数，编译器是不能假设<code>a</code>和<code>b</code>指向的区域是不同的，它们有可能指向同一内存区域，故此时编译得到的汇编代码为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movl<span class="number">4</span>(%esp), %eax</span><br><span class="line">movl<span class="number">8</span>(%esp), %edx</span><br><span class="line">movl<span class="number">$5</span>, (%eax)</span><br><span class="line">movl<span class="number">$6</span>, (%edx)</span><br><span class="line">movl(%eax), %eax</span><br><span class="line">addl<span class="number">$6</span>, %eax</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>可以看到，在进行最后一步加法运算前，需要再读一遍<code>*a</code>的值，以保证结果的正确性，因为若<code>a==b</code>的话，此时<code>*a == 6</code>而不是<code>*a == 5</code>；此时这段程序返回的是12而不是11。</p><p>然而，我们如果能确保<code>a != b</code>，那以上代码是可以进一步优化的，<code>restrict</code>关键词就用于把这一信息提供给编译器，此时的<code>rfoo</code>函数编译结果如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movl<span class="number">4</span>(%esp), %eax</span><br><span class="line">movl<span class="number">$5</span>, (%eax)</span><br><span class="line">movl<span class="number">8</span>(%esp), %eax</span><br><span class="line">movl<span class="number">$6</span>, (%eax)</span><br><span class="line">movl<span class="number">$11</span>, %eax</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>这段代码中直接返回了编译器预先计算出来的结果11，与<code>foo</code>相比减少了一次加法运算，且不需要进行<code>movl    (%eax), %eax</code>这一步骤。（虽然由于Cache的存在，这一指令也不一定会进行内存访问）</p><blockquote><p>以上汇编代码使用GCC 4.9.3编译得到，编译参数为：<code>-O3 -S -std=gnu11</code>，结果和参考资料中给出的汇编代码稍有区别，不知为何参数传递使用的是栈而不是寄存器……</p></blockquote><p>从以上例子中可以看到，若一个指针是访问某内存区域的唯一方法，那可以为其加上<code>restrict</code>限定符，这有利于编译器进行代码优化生成效率更高的程序。</p><hr><blockquote><p>参考资料：<br><a href="http://en.cppreference.com/w/c/language/restrict" target="_blank" rel="noopener">restrict type qualifier</a><br><a href="https://www.zhihu.com/question/41653775?sort=created" target="_blank" rel="noopener">如何理解C语言关键字restrict？</a><br><a href="http://blog.csdn.net/lovekatherine/article/details/1891806pub" target="_blank" rel="noopener">C99中的restrict关键字</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;restrict&lt;/code&gt;是C99标准中新增的关键词，只能用于修饰指针（函数指针除外），其含义为：&lt;strong&gt;此指针是访问其指向对象的唯一初始方法&lt;/strong&gt;。使用此关键词的意义在于：&lt;strong&gt;有助于编译器进行代码优化&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
      <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux kernel中的min和max宏</title>
    <link href="https://gaomf.cn/2017/10/08/Kernel_min_max_macro/"/>
    <id>https://gaomf.cn/2017/10/08/Kernel_min_max_macro/</id>
    <published>2017-10-08T08:38:00.000Z</published>
    <updated>2019-09-17T11:46:27.593Z</updated>
    
    <content type="html"><![CDATA[<p><code>min</code>和<code>max</code>是两个很常用的操作，一般都是用宏实现的，不过想要写出一个很完善的宏定义还是要考虑很多问题的，本文就来分析下Linux Kernel中的实现方法。文中仅考虑<code>min</code>，<code>max</code>的结构与其完全相同，只要修改下大于小于号即可。</p><a id="more"></a><p>宏定义中要将整体和变量都加上括号的意义此处就不多说了，据此我们可以写出一个最基本的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure><p>然而这种写法是有副作用的，考虑<code>min(a++, b)</code>这样的用法，其展开后的形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((a++) &lt; (b) ? (a++) : (b++))</span><br></pre></td></tr></table></figure><p>当<code>a&lt;b</code>时，<code>a++</code>会被执行两次，这显然不是我们所希望的，为了解决这一问题，我们可以使用下面这个稍显复杂的宏定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) (&#123; \</span></span><br><span class="line">    typeof(a) __min1__ = (a);  \</span><br><span class="line">    typeof(b) __min2__ = (b);  \</span><br><span class="line">    (<span class="keyword">void</span>)(&amp;__min1__ == &amp;__min2__);  \</span><br><span class="line">    __min1__ &lt; __min2__ ? __min1__ : __min2__;&#125;)</span><br></pre></td></tr></table></figure><p>这里用到了GCC的一个扩展特性，形如<code>({ ... })</code>这样的代码块会被视为一条语句，其计算结果是<code>{ ... }</code>中最后一条语句的计算结果。故上述宏定义展开后的结果就是第5行返回的结果。注意，这个扩展特性不是所有编译器都有的，如果用VS编译上述代码，是无法通过编译的。<br>这个宏定义中，先根据<code>a</code>, <code>b</code>的类型生成了两个局部变量<code>__min1__</code>和<code>__min2__</code>，之后比较其大小，返回较小的一个，这样就保证了宏参数只会被执行一次，避免了上述副作用。另外，第4行代码其实是没有实际作用的，其意义在于，若<code>__min1__</code>和<code>__min2__</code>的类型不同，比较其地址时编译器会给出一个Warning，这样可以避免一些潜在的错误发生。</p><p>以上宏定义就是网上普遍流传的Linux Kernel中的实现方法，然而，我实际阅读了当前<code>4.12.7</code>版本的Kernel源代码，发现实际的实现方法要更复杂一些。在引入实际的实现方法前，我们先思考一下以上宏定义还存在什么漏洞。</p><p>考虑以下代码段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __min1__ = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> __min2__ = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> min_val = min(__min1__--, __min2__++);</span><br></pre></td></tr></table></figure><p>期望得到的结果应该是<code>__min1__ = 9</code>, <code>__min2__ = 21</code>, <code>min_val = 10</code>。然而实际情况是，<code>__min1__ = 10</code>, <code>__min2__ = 20</code>，<code>min_val</code>的值则是不确定的。造成这一结果的原因在于输入参数和宏定义内部使用的局部变量重名了，这样就会导致在宏定义的语句块内，外层同名变量的作用域被内层局部变量的作用域所屏蔽，展开后的代码就成了这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main_val = (&#123;typeof(__min1__--) __min1__ = (__min1__--); <span class="comment">/* 省略 */</span> &#125;)</span><br></pre></td></tr></table></figure><p>这就类似于<code>int a = a</code>这样的语句，执行完后<code>a</code>的值是不确定的，且因为展开后<code>__min1__</code>成了宏体内的局部变量，<code>__min1__--</code>的自减操作对于外层变量来说也是无效的。</p><p>知道问题的原因后解决方法就很清晰了，只要避免重名就可以了，其实上述宏定义中使用<code>__min1__</code>这样的名字也是为了避免重名，然而，靠起特殊的名字这种方法不是那么的优雅，故实际新版的Linux Kernel中使用了编译器产生的唯一名称来解决这一问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Indirect macros required for expanded argument pasting, eg. __LINE__. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ___PASTE(a,b) a##b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PASTE(a,b) ___PASTE(a,b)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __UNIQUE_ID(prefix) __PASTE(__PASTE(__UNIQUE_ID_, prefix), __COUNTER__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * min()/max()/clamp() macros that also do</span></span><br><span class="line"><span class="comment"> * strict type-checking.. See the</span></span><br><span class="line"><span class="comment"> * "unnecessary" pointer comparison.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __min(t1, t2, min1, min2, x, y) (&#123;\</span></span><br><span class="line">    t1 min1 = (x);\</span><br><span class="line">    t2 min2 = (y);\</span><br><span class="line">    (<span class="keyword">void</span>) (&amp;min1 == &amp;min2);\</span><br><span class="line">    min1 &lt; min2 ? min1 : min2; &#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(x, y)\</span></span><br><span class="line">    __min(typeof(x), typeof(y),\</span><br><span class="line">          __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),\</span><br><span class="line">          x, y)</span><br></pre></td></tr></table></figure><p>可以看到这是一个多重的宏嵌套结构，主要区别就在于<code>__UNIQUE_ID(min1_)</code>上，<code>__UNIQUE_ID</code>可以生成一个唯一的名字。唯一性是由编译器提供的<code>__COUNTER__</code>宏保证的，这也是GCC的一个扩展，<a href="https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html" target="_blank" rel="noopener">GCC文档中</a>对其的说明如下：</p><blockquote><p>This macro expands to sequential integral values starting from 0. In conjunction with the ## operator, this provides a convenient means to generate unique identifiers.</p></blockquote><p>简而言之，<code>__COUNTER__</code>会被展开为一个从0开始的整数，且每次调用后其值都会加一，这也就保证了其唯一性。</p><p>至于<code>__PASTE</code>宏这是用来实现两个token连接的，之所以要两重宏定义和宏的嵌套展开规则有关，可以参考我之前写的<a href="/2017/10/06/C_Macro/">总结文章</a>。调用<code>__UNIQUE_ID(min1_)</code>后产生的就是形如<code>__UNIQUE_ID_min1_0</code>这样的变量名，这就确保了此名称不会和传入变量的名称重复了。当然，我们还是可以通过刻意构造这样一个特殊名称来实现冲突的，只是程序是程序员自己写的，相信也没有程序员这么无聊……故我们只需要保证正常情况下不会发生冲突即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;min&lt;/code&gt;和&lt;code&gt;max&lt;/code&gt;是两个很常用的操作，一般都是用宏实现的，不过想要写出一个很完善的宏定义还是要考虑很多问题的，本文就来分析下Linux Kernel中的实现方法。文中仅考虑&lt;code&gt;min&lt;/code&gt;，&lt;code&gt;max&lt;/code&gt;的结构与其完全相同，只要修改下大于小于号即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
      <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
      <category term="Kernel" scheme="https://gaomf.cn/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>C语言中typeof的使用</title>
    <link href="https://gaomf.cn/2017/10/07/C_typeof/"/>
    <id>https://gaomf.cn/2017/10/07/C_typeof/</id>
    <published>2017-10-07T12:48:00.000Z</published>
    <updated>2019-09-17T11:46:27.589Z</updated>
    
    <content type="html"><![CDATA[<p><code>typeof</code>不是C语言本身的关键词或运算符（<code>sizeof</code>是C标准定义的运算符），它是GCC的一个扩展，作用正如其字面意思，<strong>用某种已有东西（变量、函数等）的类型去定义新的变量类型</strong>。</p><a id="more"></a><p><code>typeof</code>通常用于宏定义中，一些示例用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typeof(var)</span><br><span class="line">typeof(a[<span class="number">0</span>])</span><br><span class="line">typeof(<span class="keyword">int</span> *)</span><br><span class="line">typeof(fun())</span><br></pre></td></tr></table></figure><p>可以看到，<code>typeof()</code>中可以是任何有类型的东西，变量就是其本身的类型，函数是它返回值的类型。<code>typeof</code>一般用于声明变量，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof(a) var;</span><br></pre></td></tr></table></figure><p>不过，这也不是绝对的，从语法上来说，所有可以出现基本类型关键词的地方都可以使用<code>typeof</code>，比如<code>sizeof(typeof(a))</code>这样的用法，虽然这里的<code>typeof</code>是多余的，不过它是符合语法的。</p><p>再来看一些高级用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">typeof(fun) * fptr;    <span class="comment">// int (*fptr)(int);</span></span><br><span class="line"></span><br><span class="line">typeof(<span class="keyword">int</span> *)a, b;     <span class="comment">// int * a, * b;</span></span><br><span class="line">typeof(<span class="keyword">int</span>) * a, b;    <span class="comment">// int * a, b;</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>typeof</code>还可以用来定义函数指针等，且<code>typeof(int *)a, b</code>是定义了两个指针变量。</p><p>最后指出一些需要注意的问题。<code>typeof()</code>是在编译时处理的，故<strong>其中的表达式在运行时是不会被执行的</strong>，比如<code>typeof(fun())</code>，<code>fun()</code>函数是不会被执行的，<code>typeof</code>只是在编译时分析得到了<code>fun()</code>的返回值而已。<code>typeof</code>还有一些局限性，其中的变量是不能包含存储类说明符的，如<code>static</code>、<code>extern</code>这类都是不行的。</p><hr><blockquote><p>参考资料：<br><a href="https://gcc.gnu.org/onlinedocs/gcc/Typeof.html" target="_blank" rel="noopener">6.6 Referring to a Type with typeof</a><br><a href="http://cstriker1407.info/blog/the-gcc-study-notes-typeof/" target="_blank" rel="noopener">GCC扩展关键字typeof学习笔记</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;typeof&lt;/code&gt;不是C语言本身的关键词或运算符（&lt;code&gt;sizeof&lt;/code&gt;是C标准定义的运算符），它是GCC的一个扩展，作用正如其字面意思，&lt;strong&gt;用某种已有东西（变量、函数等）的类型去定义新的变量类型&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
      <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>深入理解C语言中宏定义</title>
    <link href="https://gaomf.cn/2017/10/06/C_Macro/"/>
    <id>https://gaomf.cn/2017/10/06/C_Macro/</id>
    <published>2017-10-06T12:15:00.000Z</published>
    <updated>2020-04-10T07:18:23.239Z</updated>
    
    <content type="html"><![CDATA[<p>从本质上看，C语言中的宏定义实现的是一个文本替换的功能，似乎很简单的样子，然而这几天去看了下Linux Kernel源码中的各种宏定义，才发现一个宏定义竟然也可以有如此多的奇技淫巧……于是花了一天时间仔细研究了下宏的相关知识，此处整理总结下。</p><a id="more"></a><p>关于宏，网上有一组写得极好的文章，基本上看完这几篇文章就可以对宏有一个深入的理解了：</p><blockquote><p><a href="http://feng.zone/2017/05/17/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-1/" target="_blank" rel="noopener">宏定义黑魔法-从入门到奇技淫巧 (1) —— 基本概念</a><br><a href="http://feng.zone/2017/05/18/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-2/" target="_blank" rel="noopener">宏定义黑魔法-从入门到奇技淫巧 (2) —— object-like宏的展开</a><br><a href="http://feng.zone/2017/05/20/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-3/" target="_blank" rel="noopener">宏定义黑魔法-从入门到奇技淫巧 (3) —— function-like宏的展开</a><br><a href="http://feng.zone/2017/05/21/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-4/" target="_blank" rel="noopener">宏定义黑魔法-从入门到奇技淫巧 (4) —— 一些宏的高级用法</a><br><a href="http://feng.zone/2017/05/21/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-5/" target="_blank" rel="noopener">宏定义黑魔法-从入门到奇技淫巧 (5) —— 图灵完备</a><br><a href="http://feng.zone/2017/05/28/%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-6/" target="_blank" rel="noopener">宏定义黑魔法-从入门到奇技淫巧 (6) —— 宏的一些坑</a></p></blockquote><p>作者的知乎上也有一份<a href="https://www.zhihu.com/people/feng-yu-yao/posts" target="_blank" rel="noopener">相同的备份</a>。</p><p>相同的内容此处就不再重复了，此处列出一些要点。</p><ul><li>带参数的宏中可以使用两个特殊运算符，<code>#</code>(Stringification Operator)和<code>##</code>(Token Pasting Operator)，作用分别是把宏参数变为字符串字面量和连接两个token。且遇到这两个运算符时，宏参数不会展开。</li><li>宏的嵌套展开过程中，已展开过的宏不会重复展开。</li><li>宏展开后，会进一步检查是否构成了新的宏，若构成了会进一步展开。</li><li>宏定义中也可以使用<code>...</code>代表可变参数，用<code>__VA_ARGS__</code>获取可变参数列表。</li><li>宏参数会先展开，之后再进行替换，这也被称为”prescan”.</li><li>宏基本上是图灵完备的，所以可以只靠宏实现各种东西……</li></ul><p>宏的展开过程遵循以下流程图：</p><p><img src="https://pic.gaomf.store/Macro_Expand3.svg" alt=""></p><p>这个流程图是我根据自己的理解和实验画出来的，并不确定完全正确……图中的“已展开宏记录”就是文章中说的“蓝色列表”。</p><p>使用gcc编译时，可以通过附加<code>-E</code>参数，让gcc只进行预处理，这样就可以看到各种宏实际展开出来的结果是什么了，如<code>gcc -E -o test.i test.c</code>命令对<code>test.c</code>文件进行预处理，生成<code>test.i</code>文件。</p><p>关于宏的展开流程，有一些不太明确的地方，此处用例子说明下，结果都经过gcc预处理验证过。</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M K(P)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> K(a) a a ## a a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PP 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO(a) #a a</span></span><br><span class="line"></span><br><span class="line">FOO(M)--&gt;  FOO(K(P))</span><br><span class="line">        --&gt;  FOO(<span class="number">2</span> PP <span class="number">2</span>)</span><br><span class="line">        --&gt;  FOO(<span class="number">2</span> <span class="number">11</span> <span class="number">2</span>)</span><br><span class="line">        --&gt;  <span class="string">"M"</span> <span class="number">2</span> <span class="number">11</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>遇到<code>#</code>或<code>##</code>时，其相连的宏参数不会展开，然而这不意味着这个宏参数本身不会展开，其他部分用到这个宏参数的地方还是会展开的。</p><p>另外，<code>#</code>运算符后必须是一个宏参数，不能是其他东西，不过<code>##</code>两端则无这一要求，来看个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(a)  #a a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PP(a) #a a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAT(a) P ## P(P##a(a))</span></span><br><span class="line"></span><br><span class="line">CAT(P)--&gt;  PP(PP(P))</span><br><span class="line">        --&gt;  PP(<span class="string">"P"</span> P)</span><br><span class="line">        --&gt;  <span class="string">"PP(P)"</span> <span class="string">"P"</span> P</span><br><span class="line"></span><br><span class="line">CAT(A)--&gt;  PP(PA(A))</span><br><span class="line">        --&gt;  <span class="string">"PA(A)"</span> PA(A)</span><br></pre></td></tr></table></figure><p>可以看到，<code>##</code>两端可以是任意token，其作用就是把这两个token合成一个。另外，还可以看到，<code>##</code>是在最开始就进行处理的，所以<code>P(a)</code>这个宏是没有用到的。另外，由<code>##</code>操作符组合产生的新宏是会继续展开的，并不像某些文章说的那样会停止展开。</p><hr><p>关于多次扫描展开的问题，有些文章中说的是展开完成后会重新扫描一遍当前字符串，若有可以继续展开的则继续展开，然而实际测试下来并不是这样的。还是来看个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BRACKET ()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATE(a, b)  a ## b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO() 123</span></span><br><span class="line"></span><br><span class="line">CREATE(F, OO) BRACKET   --&gt;  FOO BRACKET</span><br><span class="line">                        --&gt;  FOO ()</span><br><span class="line"></span><br><span class="line">CREATE(F, OO) ()        --&gt;  FOO ()</span><br><span class="line">                        --&gt;  <span class="number">123</span></span><br><span class="line"></span><br><span class="line">FOO BRACKET             --&gt;  FOO ()</span><br></pre></td></tr></table></figure><p>可以看到，第1、3个例子中，展开到<code>FOO ()</code> 之后就没有继续展开下去了，这说明并没有重新扫描字符串这一步，<strong>已经处理过的部分不会再次处理的</strong>。而第2个例子则说明的确是会再展开合并出新的宏来的，故上面的流程图中使用了”向后扫描一个token，形成一个新的字符串”这样的说法。考虑到token是以空白为界划分的，<strong>后面组合出来的新宏只可能是function-like的宏</strong>，所以这样的展开方式是不存在歧义的，不会出现原来的宏被组合成其他宏的情况。</p><p>如果要继续展开上面未能展开的那两个宏，可以再封装一层：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BRACKET ()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATE(a, b)  a ## b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO() 123</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPAND(...) __VA_ARGS__</span></span><br><span class="line"></span><br><span class="line">EXPAND(CREATE(F, OO) BRACKET)--&gt;  EXPAND(FOO())</span><br><span class="line">                                --&gt;  EXPAND(<span class="number">123</span>)</span><br><span class="line">                                --&gt;  <span class="number">123</span></span><br></pre></td></tr></table></figure><p>这里利用的原理是：宏参数会先尽可能展开后再进行替换。</p><hr><p>将宏定义的各种奇技淫巧应用得巅峰造极、神鬼莫测之作就是<a href="http://www.boost.org/doc/libs/1_65_1/libs/preprocessor/doc/index.html" target="_blank" rel="noopener">The Boost Preprocessing library</a>，这是Boost库的一部分，不过和其他部分完全独立，这部分包含了各种数据结构和算法等，而且只有头文件，全部都是宏定义……简直可谓是丧心病狂……Github上有人将这部分独立的代码提取出来了，有兴趣的读者可以去进一步揣摩瞻仰：<a href="https://github.com/imoldman/boost-preprocessor" target="_blank" rel="noopener">boost-preprocessor</a></p><hr><blockquote><p>参考资料：<br><a href="http://www.cppblog.com/kevinlynx/archive/2008/03/19/44828.html" target="_blank" rel="noopener">代码自动生成-宏带来的奇技淫巧</a><br><a href="http://blog.csdn.net/jy_95/article/details/45260775" target="_blank" rel="noopener">《C标准库》—之&lt;assert.h&gt;实现</a><br><a href="https://en.wikipedia.org/wiki/C_preprocessor" target="_blank" rel="noopener">C preprocessor</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从本质上看，C语言中的宏定义实现的是一个文本替换的功能，似乎很简单的样子，然而这几天去看了下Linux Kernel源码中的各种宏定义，才发现一个宏定义竟然也可以有如此多的奇技淫巧……于是花了一天时间仔细研究了下宏的相关知识，此处整理总结下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
      <category term="Top" scheme="https://gaomf.cn/tags/Top/"/>
    
      <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C语言中的字符串字面量连接</title>
    <link href="https://gaomf.cn/2017/10/05/string_literal_concatenate/"/>
    <id>https://gaomf.cn/2017/10/05/string_literal_concatenate/</id>
    <published>2017-10-05T07:27:00.000Z</published>
    <updated>2019-09-17T11:46:27.589Z</updated>
    
    <content type="html"><![CDATA[<p>字符串字面量(string literal)就是程序代码中出现的<code>&quot;</code>包围的字符串，比如<code>&quot;hello&quot;</code>, <code>&quot;I Love C Language!&quot;</code>这类的。在C语言中，有一个奇技淫巧：<strong>两个相邻的字符串字面量会自动被合并连接为一个</strong>。这里的相邻可以是直接连在一起，也可以是间隔着若干个空白字符。需要指出的是，这个特性是C语言标准所要求的，并不是某个编译器的扩展功能。</p><p>一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello"</span> <span class="string">" World"</span><span class="string">"!"</span>    <span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure><p>以上代码完全等同于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考资料：<br><a href="https://stackoverflow.com/questions/12120944/how-does-concatenation-of-two-string-literals-work" target="_blank" rel="noopener">How does concatenation of two string literals work?</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字符串字面量(string literal)就是程序代码中出现的&lt;code&gt;&amp;quot;&lt;/code&gt;包围的字符串，比如&lt;code&gt;&amp;quot;hello&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;I Love C Language!&amp;quot;&lt;/code&gt;这类
      
    
    </summary>
    
    
      <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
      <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>用代码判断栈的增长方向</title>
    <link href="https://gaomf.cn/2017/09/28/Detect_Stack_Direction/"/>
    <id>https://gaomf.cn/2017/09/28/Detect_Stack_Direction/</id>
    <published>2017-09-28T12:23:00.000Z</published>
    <updated>2019-09-17T11:46:27.615Z</updated>
    
    <content type="html"><![CDATA[<p>对于大部分CPU架构和编译器来说，程序的栈空间增长方向都是向下递减的，然而这也不是一定的。我们可以用一小段简单的C语言代码来判断下栈的增长方向。</p><a id="more"></a><p>栈基本都是用于保存局部变量和传递参数，故要判断栈的增长方向就要从这两个方面入手。<a href="http://www.cnblogs.com/youxin/p/3313288.html" target="_blank" rel="noopener">第一篇参考资料</a>中给出了各种思路及其可行性分析，很值得看看，此处直接给出结论：</p><ul><li>一个函数中的局部变量在栈中的顺序是不定的，或者说是由编译器决定的，故不能通过直接比较两个局部变量的地址来判断栈的增长方向；</li><li>函数参数压栈的顺序也是不确定的，虽然一般编译器都是从后向前压栈，然而从前向后也不是绝对不可能；</li><li>连续嵌套调用两个函数时，第一个函数的相关数据会先入栈，之后才是它调用的第二个函数，这一点应该是一个通用成立的结论。</li></ul><p>综上，要判断栈的增长方向，可以通过函数的嵌套调用来进行判断，更优雅一点的方案是使用递归，得到的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;Upward, Downward&#125; Stack_Dir_t;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack_Dir_t <span class="title">detect_stack_dir</span><span class="params">(<span class="keyword">char</span> * p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> local = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;local &gt; p ? Upward : Downward;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> detect_stack_dir(&amp;local);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (detect_stack_dir(<span class="literal">NULL</span>) == Upward)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Stack Growth Upward!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Stack Growth Downward!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在绝大多数平台上，我们得到的结果应该都是<code>Stack Growth Downward!</code>。</p><hr><blockquote><p>参考资料：<br><a href="http://www.cnblogs.com/youxin/p/3313288.html" target="_blank" rel="noopener">判断栈和堆的生长方向</a><br><a href="http://www.cnblogs.com/xkfz007/archive/2012/06/22/2558935.html" target="_blank" rel="noopener">栈增长方向与大端/小端问题</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于大部分CPU架构和编译器来说，程序的栈空间增长方向都是向下递减的，然而这也不是一定的。我们可以用一小段简单的C语言代码来判断下栈的增长方向。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程之法" scheme="https://gaomf.cn/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%95/"/>
    
    
      <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
      <category term="Compiler" scheme="https://gaomf.cn/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>printf格式化字符串漏洞攻击</title>
    <link href="https://gaomf.cn/2017/09/20/printf_format_string_attack/"/>
    <id>https://gaomf.cn/2017/09/20/printf_format_string_attack/</id>
    <published>2017-09-20T13:58:00.000Z</published>
    <updated>2020-04-10T07:18:23.228Z</updated>
    
    <content type="html"><![CDATA[<p>前几天去Intel面试时，遇到了一个问题：<code>printf(&quot;%s&quot;, s)</code>与<code>printf(s)</code>有何区别？面试官还提示我从安全的角度回答这个问题，然而当时并没有想出答案来……:( 回来后仔细研究了下这个问题，才发现<code>pritnf(s)</code>这种写法是存在严重安全漏洞的，这被称为printf格式化字符串漏洞攻击。</p><a id="more"></a><p><code>printf</code>函数支持不定参数的原理在此不多说，可参考<code>stdarg.h</code>头文件的相关介绍。核心就是，函数使用栈传递参数，且根据cdecl函数调用约定，压栈顺序是从最后一个参数开始逆序进行的，而<code>printf</code>函数的第一个参数是确定的字符串，故可以从这个字符串中判断出栈中还有多少个数据，每个数据的类型是什么，进而依次取出各个数据。</p><p>正常情况下，格式化字符串中格式化字符<code>%</code>是和之后的参数一一对应的，然而我们可以考虑一种情况，若格式化字符<code>%</code>比参数多会怎么样呢，答案是，会取到栈中其他的数据。这就是<code>printf(s)</code>这种写法有问题的原因了，这里使用<code>s</code>而不是一个字符串字面常量，而<code>s</code>传入什么内容其实是不可控的，若传入字符中存在<code>%</code>，就会输出栈中其他一些内容。要是<code>s</code>还是可以由外部输入的，那就可以通过巧妙的构造<code>s</code>的形式来实现<strong>访问栈中本来没有权限访问的内容</strong>，这就是所谓的格式化字符串漏洞攻击。</p><p>下面来看一个实际的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> security;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;security);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序中由用户输入一个整数，存放在<code>security</code>这个变量中，之后再输入一个字符串<code>str</code>，并使用<code>printf(str)</code>这样的形式将其打印出来。针对这个例子，我们可以构造一个特定的输入字符串将<code>security</code>的内容给打印出来。</p><p>使用GCC 4.9.3编译以上程序，优化等级<code>-O2</code>，得到的程序用<code>objdump</code>反汇编一下，可以找出对应的汇编代码为：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00408350</span> &lt;_main&gt;:</span><br><span class="line">  <span class="number">408350</span>:<span class="number">55</span>                   <span class="keyword">push</span>   %ebp</span><br><span class="line">  <span class="number">408351</span>:<span class="number">89</span> e5                <span class="keyword">mov</span>    %esp,%ebp</span><br><span class="line">  <span class="number">408353</span>:<span class="number">53</span>                   <span class="keyword">push</span>   %ebx</span><br><span class="line">  <span class="number">408354</span>:<span class="number">83</span> e4 f0             <span class="keyword">and</span>    <span class="number">$0</span>xfffffff0,%esp</span><br><span class="line">  <span class="number">408357</span>:<span class="number">83</span> c4 <span class="number">80</span>             <span class="keyword">add</span>    <span class="number">$0</span>xffffff80,%esp</span><br><span class="line">  40835a:e8 <span class="number">31</span> <span class="number">95</span> ff ff       <span class="keyword">call</span>   <span class="number">401890</span> &lt;___main&gt;</span><br><span class="line">  40835f:<span class="number">8d</span> <span class="number">44</span> <span class="number">24</span> <span class="number">18</span>          <span class="keyword">lea</span>    <span class="number">0x18</span>(%esp),%eax</span><br><span class="line">  <span class="number">408363</span>:<span class="number">8d</span> 5c <span class="number">24</span> 1c          <span class="keyword">lea</span>    <span class="number">0x1c</span>(%esp),%ebx</span><br><span class="line">  <span class="number">408367</span>:c7 <span class="number">04</span> <span class="number">24</span> c0 a0 <span class="number">40</span> <span class="number">00</span> movl   <span class="number">$0</span>x40a0c0,(%esp)</span><br><span class="line">  40836e:<span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">04</span>          <span class="keyword">mov</span>    %eax,<span class="number">0x4</span>(%esp)</span><br><span class="line">  <span class="number">408372</span>:e8 f1 fb ff ff       <span class="keyword">call</span>   407f68 &lt;_scanf&gt;</span><br><span class="line">  <span class="number">408377</span>:<span class="number">89</span> 5c <span class="number">24</span> <span class="number">04</span>          <span class="keyword">mov</span>    %ebx,<span class="number">0x4</span>(%esp)</span><br><span class="line">  40837b:c7 <span class="number">04</span> <span class="number">24</span> c3 a0 <span class="number">40</span> <span class="number">00</span> movl   <span class="number">$0</span>x40a0c3,(%esp)</span><br><span class="line">  <span class="number">408382</span>:e8 e1 fb ff ff       <span class="keyword">call</span>   407f68 &lt;_scanf&gt;</span><br><span class="line">  <span class="number">408387</span>:<span class="number">89</span> 1c <span class="number">24</span>             <span class="keyword">mov</span>    %ebx,(%esp)</span><br><span class="line">  40838a:e8 e9 fb ff ff       <span class="keyword">call</span>   407f78 &lt;_printf&gt;</span><br><span class="line">  40838f:<span class="number">31</span> c0                <span class="keyword">xor</span>    %eax,%eax</span><br><span class="line">  <span class="number">408391</span>:8b <span class="number">5d</span> fc             <span class="keyword">mov</span>    -<span class="number">0x4</span>(%ebp),%ebx</span><br><span class="line">  <span class="number">408394</span>:c9                   <span class="keyword">leave</span>  </span><br><span class="line">  <span class="number">408395</span>:c3                   <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p><code>408350</code><del><code>40835a</code>部分为GCC自动生成的<code>main</code>函数入口处代码，此处不用管它；<code>40835f</code></del><code>408372</code>为第一个<code>scanf</code>函数，读入<code>security</code>；<code>408377</code><del><code>408382</code>为第二个<code>scanf</code>函数，读入<code>str</code>；<code>408387</code></del><code>40838a</code>调用<code>printf</code>输出<code>str</code>。根据反汇编结果，我们可以画出<code>408372</code>行时栈的结构：</p><p><img src="https://pic.gaomf.store/scanf_stack.svg" alt=""></p><p><code>scanf</code>函数反向压栈，故<code>%esp</code>指针指向的元素<code>$0x40a0c0</code>应该就是字符串字面量<code>&quot;%d&quot;</code>的首地址，而<code>%esp+0x04</code>就是栈中的下一个元素，这就是<code>security</code>变量的地址，从汇编代码中可以看到，这个地址是一个<code>%esp</code>的偏移量，<code>%esp+0x18</code>。由此，我们可以分析出<code>security</code>在栈中的位置，而之后<code>%esp</code>指针没有改变，故我们可以构造以下这个特殊的字符串：<code>%d%d%d%d%d_____security_is:%d</code>，这个字符串会连续取出栈中的前6个<code>int</code>，第6个<code>int</code>的地址就是<code>%esp+0x18</code>，这正是<code>security</code>变量的地址。</p><p>实际运行程序测试一下：</p><p><img src="https://pic.gaomf.store/20170920214800.png" alt=""></p><p>可以看到，我们成功读到了<code>security</code>的内容。</p><p>为了预防这个问题，我们需要确保在使用<code>printf</code>函数时第一个参数必须是一个字符串字面量。其实，以上写法编译器也会产生warning：format string is not a string literal (potentially insecure).</p><p>最后，其实配合一个比较少用的<code>printf</code>参数<code>%n</code>还可以利用此漏洞实现对栈中内容的修改，在此就不展开了，可参考第三篇参考资料。</p><hr><blockquote><p>参考资料：<br><a href="https://stackoverflow.com/questions/13692044/printfstring-vs-printfs-string" target="_blank" rel="noopener">printf(string) vs. printf(“%s”, string)</a><br><a href="https://stackoverflow.com/questions/39415536/what-is-the-underlying-difference-between-printfs-and-printfs-s" target="_blank" rel="noopener">What is the underlying difference between printf(s) and printf(“%s”, s)?</a><br><a href="https://paper.seebug.org/papers/Archive/drops2/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B.html" target="_blank" rel="noopener">格式化字符串漏洞简介</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天去Intel面试时，遇到了一个问题：&lt;code&gt;printf(&amp;quot;%s&amp;quot;, s)&lt;/code&gt;与&lt;code&gt;printf(s)&lt;/code&gt;有何区别？面试官还提示我从安全的角度回答这个问题，然而当时并没有想出答案来……:( 回来后仔细研究了下这个问题，才发现&lt;code&gt;pritnf(s)&lt;/code&gt;这种写法是存在严重安全漏洞的，这被称为printf格式化字符串漏洞攻击。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件之道" scheme="https://gaomf.cn/categories/%E8%BD%AF%E4%BB%B6%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="Top" scheme="https://gaomf.cn/tags/Top/"/>
    
      <category term="C" scheme="https://gaomf.cn/tags/C/"/>
    
      <category term="Security" scheme="https://gaomf.cn/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>Atom编辑器配置</title>
    <link href="https://gaomf.cn/2017/09/16/Atom_Configure/"/>
    <id>https://gaomf.cn/2017/09/16/Atom_Configure/</id>
    <published>2017-09-16T02:22:00.000Z</published>
    <updated>2020-04-10T07:18:23.200Z</updated>
    
    <content type="html"><![CDATA[<p>之前使用过各种文本编辑器，<a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a>、<a href="https://www.sublimetext.com" target="_blank" rel="noopener">Sublime Text</a>、<a href="http://www.vim.org/" target="_blank" rel="noopener">VIM</a>等，使用下来觉得各有千秋，都有些不太满意的地方。前段时间体验了下<a href="https://atom.io/" target="_blank" rel="noopener">Atom</a>，感觉很不错~作为一个所谓的”A hackable text editor for the 21st Century”，还是有很多可以折腾配置的东西，此处总结整理下。</p><a id="more"></a><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>Atom是Github社区推出的开源编辑器，即可以开箱即用无需配置，也可以充分的去定制折腾：</p><blockquote><p>Atom is a text editor that’s modern, approachable, yet hackable to the core—a tool you can customize to do anything but also use productively without ever touching a config file.</p></blockquote><p>Atom官方的使用手册见文末第一个参考资料链接。</p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>一般从其<a href="https://atom.io/" target="_blank" rel="noopener">主页</a>上下载编译好的二进制程序文件即可，Windows下一般使用<code>exe</code>安装包。安装过程完全不需要用户参与，也无法参与……安装包会将Atom自动安装到C盘的某个位置，且这是无法更改的。</p><h3 id="命令面板（Command-Palette）"><a href="#命令面板（Command-Palette）" class="headerlink" title="命令面板（Command Palette）"></a>命令面板（Command Palette）</h3><p>Windows下，使用<code>ctrl-shift-p</code>键即可打开命令面板，在这个命令面板中可以使用模糊搜索快速查找所需的命令，而无需像传统方式那样在层层菜单中寻找。如设置界面，可从菜单中的<code>File</code>-&gt;<code>Setting</code>打开，更快的方式是在命令面板中搜索<code>setting</code>，即可看到所需命令及其快捷键：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170827162506.png" alt=""></p><h3 id="主题与字体"><a href="#主题与字体" class="headerlink" title="主题与字体"></a>主题与字体</h3><p>在设置界面中，<code>Themes</code>一项用于设置界面及语法高亮主题，尝试下来<code>One</code>这个主题最好看，还提供了<code>One Light</code>及<code>One Dark</code>两套亮色及暗色主题。如果对自带的几个主题配色不满意的话，可以去官方的<a href="https://atom.io/themes" target="_blank" rel="noopener">几千个主题</a>中挑选自己喜欢的，或者干脆自己自定义一个~不过自带的这两个主题已经可以完全满足我的需求了，就不再去折腾了……</p><p>至于编辑器界面的字体与字号，可在<code>Editor</code>选项卡中配置，一般选择等宽字体，如我选择的<code>YaHei Consolas Hybrid</code>。</p><h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><p>Atom中，通过文件夹的方式来组织管理项目，界面左侧就是<code>Project</code>面板。若要查找项目中的文件，可使用<code>ctrl-p</code>快捷键；使用<code>ctrl-b</code>查找已打开的文件。</p><h3 id="编辑-amp-移动"><a href="#编辑-amp-移动" class="headerlink" title="编辑&amp;移动"></a>编辑&amp;移动</h3><p>Atom中本身就有一些光标移动的快捷键，不过更方便的是使用下文将要提到的Vim扩展插件，此处仅列举一些比Vim更好用的功能：</p><ul><li>跳转到某行：<code>ctrl-g</code>，之后输入行号</li><li>跳转到标签：<code>ctrl-r</code>，如要在工程内搜索，使用<code>ctrl-shift-r</code></li><li>将当前行（或选中的几行）上下移动：<code>ctrl-↑/↓</code>，此功能在调整代码时会很有用</li></ul><p>Atom中还有个很强大的多光标功能，按住<code>ctrl</code>键的同时用鼠标在多个位置点击或选取，即可启用多光标编辑模式。也可以选中一个词后，按<code>ctrl-d</code>键即可选择下一个相同的词。</p><p>另外，Atom中的括号等不仅会自动配对，而且选中某一个部分后输入单边括号，编辑器会自动用此括号把选中内容包围起来。</p><h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><p>使用<code>alt-ctrl-F2</code>键来添加或删除书签，使用<code>F2</code>键可以调到下一个书签，<code>ctrl-F2</code>打开书签列表。</p><h3 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h3><p>与大部分软件一样，<code>ctrl-f</code>打开搜索替换面板，<code>ctrl-shift-f</code>在整个工程中执行搜索替换。也可以使用正则表达式，在替换时若需反向引用，使用<code>$1</code>, <code>$2</code>…</p><h2 id="各种高级功能"><a href="#各种高级功能" class="headerlink" title="各种高级功能"></a>各种高级功能</h2><p>Atom内置了很多高级编辑功能，此处列出一些常用的，详见<a href="http://flight-manual.atom.io/" target="_blank" rel="noopener">Atom Flight Manual</a>中的帮助说明。</p><h3 id="Snippets"><a href="#Snippets" class="headerlink" title="Snippets"></a>Snippets</h3><p>常用代码片段，输入响应关键词后，会自动弹出提示，此时按<code>Tab</code>键即可自动输入。不同文件类型有不同的默认代码片段，各种package也会添加自己的snippets扩展，可在命令面板中输入<code>Snippets:Available</code>查看当前可用的snippets。如果要自定义snippets，可参考官方文档的说明：<a href="http://flight-manual.atom.io/using-atom/sections/snippets/#creating-your-own-snippets" target="_blank" rel="noopener">Creating Your Own Snippets</a></p><h3 id="Git集成"><a href="#Git集成" class="headerlink" title="Git集成"></a>Git集成</h3><p>Atom是Github发布的编辑器，自然内置了很好的Git支持，界面右下角即可看到当前状态，点击后即可打开Git面板。不过和大部分IDE中集成的Git一样，此处的Git只适合日常工作时commit新代码，若要查看之前的提交记录或进行一些更复杂的操作，还是使用专门的软件更好，比如<a href="https://www.gitkraken.com/" target="_blank" rel="noopener">GitKraken</a>。</p><p>值得一提的是，编辑器左侧使用不同颜色直接标出了此文件的修改情况，十分的直观~使用快捷键<code>alt-g-↑/↓</code>可以快速切换到下一个修改过的地方。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Atom本身是一个很轻量级的编辑器框架，它的各种功能都是由不同插件实现的，称为Packages，这也就是配置Atom中最好玩的部分了~插件的安装有几种不同的方法，最简单的方法是，在<code>Settings</code>-&gt;<code>Install</code>中直接搜索安装即可。此处记录下我安装的插件。</p><h3 id="配置备份"><a href="#配置备份" class="headerlink" title="配置备份"></a>配置备份</h3><p>Atom的所有配置文件其实都位于<code>.atom</code>文件夹下，理论上可通过自行备份这个文件夹来实现配置备份，不过此处我们有一个更优雅的解决方案：<code>Sync-setttings</code>插件。此插件基于Github gist进行备份，所以还需要进行一些额外的配置，详见下面两篇文章：</p><blockquote><p><a href="http://wiki.jikexueyuan.com/project/atom/sync-settings.html" target="_blank" rel="noopener">Sync-setttings(插件-备份神器)</a><br><a href="http://elickzhao.github.io/2016/10/Atom%20%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AEsync-setting/" target="_blank" rel="noopener">Atom 编辑器配置sync-setting</a></p></blockquote><h3 id="Vim扩展"><a href="#Vim扩展" class="headerlink" title="Vim扩展"></a>Vim扩展</h3><p>Vim最好用的地方应该是其移动方式，在Atom中也可以通过安装<code>vim-mode-plus</code>这个插件实现基础的Vim功能，这个插件是对官方Vim插件的升级加强，功能还是很完善的。这个插件还有一个<a href="https://github.com/t9md/atom-vim-mode-plus/wiki" target="_blank" rel="noopener">Wiki页面</a>，里面有各种帮助文档，其中<a href="https://github.com/t9md/atom-vim-mode-plus/wiki/AdvancedTopicTutorial" target="_blank" rel="noopener">Advanced Topic Tutorial</a>部分介绍了各种高级编辑技巧，很值得一读。</p><p><code>vim-mode-plus</code>插件默认绑定了很多快捷键，如果需要自定义的话，可以修改<code>keymap.cson</code>文件。比如我就根据自己的需求加入了以下一些配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&apos;atom-text-editor.vim-mode-plus&apos;:</span><br><span class="line">  # 保证通用的复制粘贴快捷键可用</span><br><span class="line">  &apos;ctrl-c&apos;: &apos;core:copy&apos;</span><br><span class="line">  &apos;ctrl-v&apos;: &apos;core:paste&apos;</span><br><span class="line"></span><br><span class="line">&apos;atom-text-editor.vim-mode-plus:not(.insert-mode)&apos;:</span><br><span class="line">  &apos;H&apos;: &apos;vim-mode-plus:move-to-first-character-of-line&apos;</span><br><span class="line">  &apos;L&apos;: &apos;vim-mode-plus:move-to-last-character-of-line&apos;</span><br><span class="line">  &apos;ctrl-/&apos;: &apos;vim-mode-plus:toggle-line-comments&apos;</span><br><span class="line">  &apos;space space&apos;: &apos;vim-mode-plus:toggle-fold&apos;</span><br></pre></td></tr></table></figure><p>Vim中还有个很好用的插件叫EasyMotion，可以实现快速移动定位，同样在Atom中，也可以通过安装<code>Jumpy</code>这个插件来实现这一目的。此插件默认绑定的快捷键是<code>shift-Enter</code>，可以将<code>vim-mode-plus</code>中的<code>f</code>键替换为这个插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;atom-text-editor:not(.mini).vim-mode-plus:not(.insert-mode):not(.jumpy-jump-mode)&apos;:</span><br><span class="line">  &apos;f&apos;: &apos;jumpy:toggle&apos;</span><br></pre></td></tr></table></figure><h3 id="Markdown扩展"><a href="#Markdown扩展" class="headerlink" title="Markdown扩展"></a>Markdown扩展</h3><p>Atom本身就支持Markdown语法高亮的，再配合一些插件就可以很完美的作为一个Markdown编辑器使用了：</p><ul><li><code>markdown-preview-enhanced</code> : Markdown预览增强版，提供了各种高级功能，详见其<a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/" target="_blank" rel="noopener">文档</a>。安装好后可以把Atom自带的<code>markdown-preview</code>给禁用掉</li><li><code>Markdown-Writer</code> : 各种辅助增强功能，功能介绍见其<a href="https://github.com/zhuochun/md-writer/wiki/Features" target="_blank" rel="noopener">文档</a></li></ul><p><code>Markdown-Writer</code>有一个很方便的功能就是自动生成草稿文件(draft)和发布(publish)完成的草稿文件，这需要先在其设置中配置一下，相应的<code>config.cson</code>文件如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"markdown-writer"</span>:</span><br><span class="line"><span class="symbol">  fileExtension:</span> <span class="string">".md"</span></span><br><span class="line"><span class="symbol">  frontMatter:</span> <span class="string">'''</span></span><br><span class="line"><span class="symbol">    title:</span> <span class="params">&lt;title&gt;</span></span><br><span class="line"><span class="symbol">    permalink:</span></span><br><span class="line"><span class="symbol">    toc:</span> false</span><br><span class="line"><span class="symbol">    mathjax:</span> false</span><br><span class="line"><span class="symbol">    fancybox:</span> false</span><br><span class="line"><span class="symbol">    tags:</span></span><br><span class="line"><span class="symbol">    categories:</span></span><br><span class="line"><span class="symbol">    date:</span> <span class="params">&lt;date&gt;</span></span><br><span class="line"></span><br><span class="line">    ---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="params">&lt;!--more--&gt;</span></span><br><span class="line"></span><br><span class="line">    ----------</span><br><span class="line"></span><br><span class="line">    &gt; 参考资料：</span><br><span class="line">    &gt; []()</span><br><span class="line">  <span class="string">'''</span></span><br><span class="line"><span class="symbol">  siteDraftsDir:</span> <span class="string">"draft"</span></span><br><span class="line"><span class="symbol">  siteEngine:</span> <span class="string">"hexo"</span></span><br><span class="line"><span class="symbol">  siteLocalDir:</span> <span class="string">"D:\\Github\\Hexo"</span></span><br><span class="line"><span class="symbol">  sitePostsDir:</span> <span class="string">"source\\_posts"</span></span><br><span class="line"><span class="symbol">  urlForCategories:</span> <span class="string">"http://gaomf.cn/categories.json"</span></span><br><span class="line"><span class="symbol">  urlForPosts:</span> <span class="string">"http://gaomf.cn/posts.json"</span></span><br><span class="line"><span class="symbol">  urlForTags:</span> <span class="string">"http://gaomf.cn/tags.json"</span></span><br></pre></td></tr></table></figure><p>最后三个选项是为了实现自动管理标签和分类用的，这需要另一个Hexo插件<a href="https://github.com/timnew/hexo-generator-atom-markdown-writer-meta" target="_blank" rel="noopener">hexo-generator-atom-markdown-writer-meta</a>配合，这个插件有些小Bug，在Hexo 3上无法正常使用，不过有人给出了解决方案，打上<a href="https://github.com/timnew/hexo-generator-atom-markdown-writer-meta/pull/5/files" target="_blank" rel="noopener">这个补丁</a>即可。</p><p>这样配置好后，再配合内置Terminal，就可以实现在Atom内完成博客写作的全过程了~</p><h3 id="minimap"><a href="#minimap" class="headerlink" title="minimap"></a>minimap</h3><p>Sublime Text中有一个很好用的文档缩略图功能，在滚动时屏幕右侧会显示此文档的缩略图。在Atom中也可以通过插件实现这一功能，这就是<code>minimap</code>插件，除了这个基础插件外，还有几个扩展插件用于增强其功能：</p><ul><li><code>minimap-autohider</code> : 在不滚动鼠标时自动隐藏minimap缩略图；</li><li><code>minimap-bookmarks</code> : 在缩略图中高亮显示书签；</li><li><code>minimap-find-and-replace</code> : 在缩略图中高亮显示搜索结果；</li><li><code>minimap-git-diff</code> : 在缩略图中高亮显示当前文档修改情况；</li><li><code>minimap-highlight-selected</code> : 在缩略图中高亮显示选中的单词；</li><li><code>minimap-split-diff</code> : 在缩略图中显示<code>split-diff</code>插件的比较结果；</li></ul><h3 id="Terminal集成"><a href="#Terminal集成" class="headerlink" title="Terminal集成"></a>Terminal集成</h3><p>Atom中的terminal插件有很多，使用下来最好用的是<code>platformio-ide-terminal</code>，在Windows下默认调用的是<code>powershell</code>。安装好此插件后，点击界面左下角的加号即可新建一个terminal，其显示风格也可以自定义，用起来极为方便。</p><h3 id="编程辅助"><a href="#编程辅助" class="headerlink" title="编程辅助"></a>编程辅助</h3><p>最常用的两个功能就是自动补全和代码检查，通过插件<code>autocomplete-plus</code>和<code>linter</code>实现，这两个插件都只是一个框架，针对不同语言有不同语言的扩展。针对C/C++，可安装<code>autocomplete-clang</code>和<code>linter-clang</code>，这两个插件都依赖于<code>clang</code>，所以要先装好<code>clang</code>。<code>clang</code>是LLVM的一部分，下载链接在<a href="http://releases.llvm.org/download.html" target="_blank" rel="noopener">这里</a>，在Windows下就是一个exe安装包，直接安装即可，不过需要注意的是，<strong>安装时一定要选择添加到环境变量，否则无法正常使用</strong>。安装好后，在命令行中输入<code>clang -v</code>，若有输出说明安装正确。</p><p>关于这两个插件的详细使用和配置可参考其文档。另外，<code>linter</code>的显示似乎还需要一个名为<code>Linter-UI-Default</code>的插件支持，也要一起安装上。</p><p>其他一些推荐插件还有：</p><ul><li><code>atom-ctags</code> : 为当前工程生成tag索引，以便实现跳转，默认跳转快捷键为<code>F12</code>，<code>shift-F12</code>返回；</li><li><code>symbols-tree-view</code> : 与<code>atom-ctags</code>配合使用，以列表的形式列出tag；</li></ul><p>最后一个待解决的问题就是调试器，要是能把GDB等集成到Atom里面就完美了，这个之后再来折腾……</p><blockquote><p>Update 2017-10-05:<br>对于Python来说，可以安装<code>autocomplete-python</code>和<code>linter-pylama</code>，Python的语法补全和错误检查比C语言用起来感觉更好~<br>关于调试器，可以使用<code>dbg-gdb</code>插件</p></blockquote><h3 id="其它插件"><a href="#其它插件" class="headerlink" title="其它插件"></a>其它插件</h3><ul><li><code>highlight-selected</code> : 高亮当前选中的单词</li><li><code>file-icons</code> : 添加一些文件类型的图标，更为美观</li><li><code>split-diff</code> : 可以对比两个文件的差异</li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>使用过程中也遇到了一些零散的问题，此处记录一下。</p><p>Q: 无法通过拖拽打开文件，即将文件拖入一个已经打开的Atom窗口界面时，显示红色的禁止标志。<br>A: 不要使用管理员身份运行Atom即可。</p><p>Q: 界面字体发虚。<br>A: <a href="/2017/08/30/Win10_Software_Font_Blur/">Win10下软件界面显示模糊问题解决办法</a><br>   <a href="/2017/09/06/Atom_Disable_GPU/">Atom禁用GPU启动的方法</a></p><p>Q: 安装Package时网络连接错误。<br>A: 这是由于GFW把相关网站墙掉了的缘故……开VPN或者是系统代理即可，使用代理的话，在<code>Settings</code>-&gt;<code>Core</code>中找到<code>Use Proxy Settings When Calling APM</code>，勾选上此选项即可。</p><hr><p>最后，使用了一段时间后觉得，Atom有各种好，不过它也有个最大的缺点，就是慢，真的好慢啊…………</p><hr><blockquote><p>参考资料：<br><a href="http://flight-manual.atom.io/" target="_blank" rel="noopener">Atom Flight Manual</a><br><a href="http://blog.csdn.net/u010494080/article/details/50372857" target="_blank" rel="noopener">Atom编辑器入门到精通(一) 安装及使用基础</a><br><a href="https://www.urlteam.org/2017/07/atom%E5%9C%A8vim%E6%A8%A1%E5%BC%8F%E4%B8%8B%E8%AE%BE%E7%BD%AE%E5%BF%AB%E6%8D%B7%E5%A4%8D%E5%88%B6%E6%8C%89%E9%94%AE/" target="_blank" rel="noopener">atom在vim模式下设置快捷复制按键</a><br><a href="https://draapho.github.io/2016/10/12/1610-WinSoft-atompack/" target="_blank" rel="noopener">Windows 软件系列-atom插件</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前使用过各种文本编辑器，&lt;a href=&quot;https://notepad-plus-plus.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Notepad++&lt;/a&gt;、&lt;a href=&quot;https://www.sublimetext.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sublime Text&lt;/a&gt;、&lt;a href=&quot;http://www.vim.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VIM&lt;/a&gt;等，使用下来觉得各有千秋，都有些不太满意的地方。前段时间体验了下&lt;a href=&quot;https://atom.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Atom&lt;/a&gt;，感觉很不错~作为一个所谓的”A hackable text editor for the 21st Century”，还是有很多可以折腾配置的东西，此处总结整理下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具之术" scheme="https://gaomf.cn/categories/%E5%B7%A5%E5%85%B7%E4%B9%8B%E6%9C%AF/"/>
    
    
      <category term="Editor" scheme="https://gaomf.cn/tags/Editor/"/>
    
  </entry>
  
  <entry>
    <title>Atom禁用GPU启动的方法</title>
    <link href="https://gaomf.cn/2017/09/06/Atom_Disable_GPU/"/>
    <id>https://gaomf.cn/2017/09/06/Atom_Disable_GPU/</id>
    <published>2017-09-06T14:51:00.000Z</published>
    <updated>2020-04-10T07:18:23.200Z</updated>
    
    <content type="html"><![CDATA[<p>正如在<a href="/2017/08/30/Win10_Software_Font_Blur/">之前的文章</a>中提到，Atom在Win10下若不禁用GPU加速的话，界面字体会模糊，启动时可以通过附加<code>--disable-gpu</code>选项来禁用GPU，然而在打开关联文件等时候，是无法直接设置命令行参数的，此时就需要做些配置来实现这一目的。</p><a id="more"></a><h3 id="修改快捷方式"><a href="#修改快捷方式" class="headerlink" title="修改快捷方式"></a>修改快捷方式</h3><p>若要直接打开一个程序，较常用的方法就是通过桌面或开始菜单中的快捷方式，此时可以在快捷方式属性中指定命令行参数即可，如图所示：</p><p><img src="https://pic.gaomf.store/TIM%E6%88%AA%E5%9B%BE20170906160347.png" alt=""></p><h3 id="修改右键菜单"><a href="#修改右键菜单" class="headerlink" title="修改右键菜单"></a>修改右键菜单</h3><p>默认情况下，Atom会自动新建一个<code>Open with Atom</code>的右键菜单项，这个功能还是很实用的，要实现此处打开的Atom也能附加命令行参数，需要通过修改注册表实现。在<code>regedit</code>中，找到<code>\HKEY_CLASSES_ROOT\*\shell\Atom</code>项，这就对应右键菜单中那个命令，其默认项为菜单项的名称，<code>Icon</code>项指向一个<code>exe</code>文件，对应缩略图图标，不要去修改它。继续展开其<code>command</code>子目录，其默认项就是调用的命令，在最后添加一个<code>--disable-gpu</code>即可，例如：<code>&quot;C:\Users\g1992\AppData\Local\atom\atom.exe&quot; &quot;%1&quot; --disable-gpu</code>。最先为Atom的目录，之后的<code>&quot;%1&quot;</code>应该就是系统传入的待打开的文件，最后为我们加上的附加参数。注意，<code>disable-gpu</code>必须加在<code>&quot;%1&quot;</code>之后，加在前面Atom无法正常打开文件。</p><h3 id="修改文件关联"><a href="#修改文件关联" class="headerlink" title="修改文件关联"></a>修改文件关联</h3><p>要修改文件关联调用的程序，也要通过修改注册表实现。系统的打开方式中列出的程序其实是由注册表中<code>\HKEY_CLASSES_ROOT\Applications\</code>目录决定的，每一个子项对应一个程序。找到<code>\HKEY_CLASSES_ROOT\Applications\atom.exe</code>项，这就对应打开方式中Atom项。<code>\HKEY_CLASSES_ROOT\Applications\atom.exe\shell\open</code>目录下的<code>FriendlyAppName</code>项就是打开方式中程序的名称，而其下的<code>command</code>目录的默认项就对应调用的命令行。同理在最后添加一个<code>--disable-gpu</code>即可。</p><hr><p>通过以上配置，基本可以实现无论通过哪种方式打开Atom均可以完全禁用GPU加速的效果了~</p><hr><blockquote><p>参考资料：<br><a href="http://www.360doc.com/content/13/0518/07/4299739_286250789.shtml" target="_blank" rel="noopener">修改注册表实现文件默认打开方式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正如在&lt;a href=&quot;/2017/08/30/Win10_Software_Font_Blur/&quot;&gt;之前的文章&lt;/a&gt;中提到，Atom在Win10下若不禁用GPU加速的话，界面字体会模糊，启动时可以通过附加&lt;code&gt;--disable-gpu&lt;/code&gt;选项来禁用GPU，然而在打开关联文件等时候，是无法直接设置命令行参数的，此时就需要做些配置来实现这一目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具之术" scheme="https://gaomf.cn/categories/%E5%B7%A5%E5%85%B7%E4%B9%8B%E6%9C%AF/"/>
    
    
      <category term="Editor" scheme="https://gaomf.cn/tags/Editor/"/>
    
  </entry>
  
</feed>
